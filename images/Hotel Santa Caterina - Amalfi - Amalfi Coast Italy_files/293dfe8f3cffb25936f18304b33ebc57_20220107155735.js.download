!function () { this.MooTools = { version: "1.4.5", build: "ab8ea8824dc3b24b6666867a2c4ed58ebb762cf0" }; var t, a = this.typeOf = function (t) { if (null == t) return "null"; if (null != t.$family) return t.$family(); if (t.nodeName) { if (1 == t.nodeType) return "element"; if (3 == t.nodeType) return /\S/.test(t.nodeValue) ? "textnode" : "whitespace" } else if ("number" == typeof t.length) { if (t.callee) return "arguments"; if ("item" in t) return "collection" } return typeof t }, e = this.instanceOf = function (t, e) { if (null == t) return !1; for (var i = t.$constructor || t.constructor; i;) { if (i === e) return !0; i = i.parent } return !!t.hasOwnProperty && t instanceof e }, i = this.Function, o = !0; for (t in { toString: 1 }) o = null; o = o && ["hasOwnProperty", "valueOf", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "constructor"], i.prototype.overloadSetter = function (s) { var r = this; return function (t, e) { if (null == t) return this; if (s || "string" != typeof t) { for (var i in t) r.call(this, i, t[i]); if (o) for (var n = o.length; n--;)i = o[n], t.hasOwnProperty(i) && r.call(this, i, t[i]) } else r.call(this, t, e); return this } }, i.prototype.overloadGetter = function (s) { var r = this; return function (t) { var e, i; if ("string" != typeof t ? e = t : 1 < arguments.length ? e = arguments : s && (e = [t]), e) { i = {}; for (var n = 0; n < e.length; n++)i[e[n]] = r.call(this, e[n]) } else i = r.call(this, t); return i } }, i.prototype.extend = function (t, e) { this[t] = e }.overloadSetter(), i.prototype.implement = function (t, e) { this.prototype[t] = e }.overloadSetter(); var h = Array.prototype.slice; i.from = function (t) { return "function" == a(t) ? t : function () { return t } }, Array.from = function (t) { return null == t ? [] : c.isEnumerable(t) && "string" != typeof t ? "array" == a(t) ? t : h.call(t) : [t] }, Number.from = function (t) { t = parseFloat(t); return isFinite(t) ? t : null }, String.from = function (t) { return t + "" }, i.implement({ hide: function () { return this.$hidden = !0, this }, protect: function () { return this.$protected = !0, this } }); var c = this.Type = function (t, e) { var i, n; return t && (i = t.toLowerCase(), n = function (t) { return a(t) == i }, c["is" + t] = n, null != e && (e.prototype.$family = function () { return i }.hide(), e.type = n)), null == e ? null : (e.extend(this), e.$constructor = c, e.prototype.$constructor = e) }, n = Object.prototype.toString; c.isEnumerable = function (t) { return null != t && "number" == typeof t.length && "[object Function]" != n.call(t) }; function l(t) { return t = a(t.prototype), s[t] || (s[t] = []) } var s = {}, u = function (t, e) { if (!e || !e.$hidden) { for (var i = l(this), n = 0; n < i.length; n++) { var s = i[n]; "type" == a(s) ? u.call(s, t, e) : s.call(this, t, e) } var r = this.prototype[t]; null != r && r.$protected || (this.prototype[t] = e), null == this[t] && "function" == a(e) && d.call(this, t, function (t) { return e.apply(t, h.call(arguments, 1)) }) } }, d = function (t, e) { var i; e && e.$hidden || (null != (i = this[t]) && i.$protected || (this[t] = e)) }; c.implement({ implement: u.overloadSetter(), extend: d.overloadSetter(), alias: function (t, e) { u.call(this, t, this.prototype[e]) }.overloadSetter(), mirror: function (t) { return l(this).push(t), this } }), new c("Type", c); var f = function (t, e, s) { var i = e != Object, r = e.prototype; i && (e = new c(t, e)); for (var o, n = 0, a = s.length; n < a; n++) { var h = s[n], l = e[h], u = r[h]; l && l.protect(), i && u && e.implement(h, u.protect()) } return i && (o = r.propertyIsEnumerable(s[0]), e.forEachMethod = function (t) { if (!o) for (var e = 0, i = s.length; e < i; e++)t.call(r, r[s[e]], s[e]); for (var n in r) t.call(r, r[n], n) }), f }; f("String", String, ["charAt", "charCodeAt", "concat", "indexOf", "lastIndexOf", "match", "quote", "replace", "search", "slice", "split", "substr", "substring", "trim", "toLowerCase", "toUpperCase"])("Array", Array, ["pop", "push", "reverse", "shift", "sort", "splice", "unshift", "concat", "join", "slice", "indexOf", "lastIndexOf", "filter", "forEach", "every", "map", "some", "reduce", "reduceRight"])("Number", Number, ["toExponential", "toFixed", "toLocaleString", "toPrecision"])("Function", i, ["apply", "call", "bind"])("RegExp", RegExp, ["exec", "test"])("Object", Object, ["create", "defineProperty", "defineProperties", "keys", "getPrototypeOf", "getOwnPropertyDescriptor", "getOwnPropertyNames", "preventExtensions", "isExtensible", "seal", "isSealed", "freeze", "isFrozen"])("Date", Date, ["now"]), Object.extend = d.overloadSetter(), Date.extend("now", function () { return +new Date }), new c("Boolean", Boolean), Number.prototype.$family = function () { return isFinite(this) ? "number" : "null" }.hide(), Number.extend("random", function (t, e) { return Math.floor(Math.random() * (e - t + 1) + t) }); var r = Object.prototype.hasOwnProperty; Object.extend("forEach", function (t, e, i) { for (var n in t) r.call(t, n) && e.call(i, t[n], n, t) }), Object.each = Object.forEach, Array.implement({ forEach: function (t, e) { for (var i = 0, n = this.length; i < n; i++)i in this && t.call(e, this[i], i, this) }, each: function (t, e) { return Array.forEach(this, t, e), this } }); function m(t) { switch (a(t)) { case "array": return t.clone(); case "object": return Object.clone(t); default: return t } } Array.implement("clone", function () { for (var t = this.length, e = new Array(t); t--;)e[t] = m(this[t]); return e }); function p(t, e, i) { switch (a(i)) { case "object": "object" == a(t[e]) ? Object.merge(t[e], i) : t[e] = Object.clone(i); break; case "array": t[e] = i.clone(); break; default: t[e] = i }return t } Object.extend({ merge: function (t, e, i) { if ("string" == a(e)) return p(t, e, i); for (var n = 1, s = arguments.length; n < s; n++) { var r, o = arguments[n]; for (r in o) p(t, r, o[r]) } return t }, clone: function (t) { var e, i = {}; for (e in t) i[e] = m(t[e]); return i }, append: function (t) { for (var e = 1, i = arguments.length; e < i; e++) { var n, s = arguments[e] || {}; for (n in s) t[n] = s[n] } return t } }), ["Object", "WhiteSpace", "TextNode", "Collection", "Arguments"].each(function (t) { new c(t) }); var g = Date.now(); String.extend("uniqueID", function () { return (g++).toString(36) }); var v = this.Hash = new c("Hash", function (t) { for (var e in "hash" == a(t) && (t = Object.clone(t.getClean())), t) this[e] = t[e]; return this }); v.implement({ forEach: function (t, e) { Object.forEach(this, t, e) }, getClean: function () { var t, e = {}; for (t in this) this.hasOwnProperty(t) && (e[t] = this[t]); return e }, getLength: function () { var t, e = 0; for (t in this) this.hasOwnProperty(t) && e++; return e } }), v.alias("each", "forEach"), Object.type = c.isObject; var y = this.Native = function (t) { return new c(t.name, t.initialize) }; y.type = c.type, y.implement = function (t, e) { for (var i = 0; i < t.length; i++)t[i].implement(e); return y }; var b = Array.type; Array.type = function (t) { return e(t, Array) || b(t) }, this.$A = function (t) { return Array.from(t).slice() }, this.$arguments = function (t) { return function () { return arguments[t] } }, this.$chk = function (t) { return !(!t && 0 !== t) }, this.$clear = function (t) { return clearTimeout(t), clearInterval(t), null }, this.$defined = function (t) { return null != t }, this.$each = function (t, e, i) { var n = a(t); ("arguments" == n || "collection" == n || "array" == n || "elements" == n ? Array : Object).each(t, e, i) }, this.$empty = function () { }, this.$extend = function (t, e) { return Object.append(t, e) }, this.$H = function (t) { return new v(t) }, this.$merge = function () { var t = Array.slice(arguments); return t.unshift({}), Object.merge.apply(null, t) }, this.$lambda = i.from, this.$mixin = Object.merge, this.$random = Number.random, this.$splat = Array.from, this.$time = Date.now, this.$type = function (t) { t = a(t); return "elements" == t ? "array" : "null" != t && t }, this.$unlink = function (t) { switch (a(t)) { case "object": return Object.clone(t); case "array": return Array.clone(t); case "hash": return new v(t); default: return t } } }(), Array.implement({ every: function (t, e) { for (var i = 0, n = this.length >>> 0; i < n; i++)if (i in this && !t.call(e, this[i], i, this)) return !1; return !0 }, filter: function (t, e) { for (var i, n = [], s = 0, r = this.length >>> 0; s < r; s++)s in this && (i = this[s], t.call(e, i, s, this) && n.push(i)); return n }, indexOf: function (t, e) { for (var i = this.length >>> 0, n = e < 0 ? Math.max(0, i + e) : e || 0; n < i; n++)if (this[n] === t) return n; return -1 }, map: function (t, e) { for (var i = this.length >>> 0, n = Array(i), s = 0; s < i; s++)s in this && (n[s] = t.call(e, this[s], s, this)); return n }, some: function (t, e) { for (var i = 0, n = this.length >>> 0; i < n; i++)if (i in this && t.call(e, this[i], i, this)) return !0; return !1 }, clean: function () { return this.filter(function (t) { return null != t }) }, invoke: function (e) { var i = Array.slice(arguments, 1); return this.map(function (t) { return t[e].apply(t, i) }) }, associate: function (t) { for (var e = {}, i = Math.min(this.length, t.length), n = 0; n < i; n++)e[t[n]] = this[n]; return e }, link: function (t) { for (var e = {}, i = 0, n = this.length; i < n; i++)for (var s in t) if (t[s](this[i])) { e[s] = this[i], delete t[s]; break } return e }, contains: function (t, e) { return -1 != this.indexOf(t, e) }, append: function (t) { return this.push.apply(this, t), this }, getLast: function () { return this.length ? this[this.length - 1] : null }, getRandom: function () { return this.length ? this[Number.random(0, this.length - 1)] : null }, include: function (t) { return this.contains(t) || this.push(t), this }, combine: function (t) { for (var e = 0, i = t.length; e < i; e++)this.include(t[e]); return this }, erase: function (t) { for (var e = this.length; e--;)this[e] === t && this.splice(e, 1); return this }, empty: function () { return this.length = 0, this }, flatten: function () { for (var t = [], e = 0, i = this.length; e < i; e++) { var n = typeOf(this[e]); "null" != n && (t = t.concat("array" == n || "collection" == n || "arguments" == n || instanceOf(this[e], Array) ? Array.flatten(this[e]) : this[e])) } return t }, pick: function () { for (var t = 0, e = this.length; t < e; t++)if (null != this[t]) return this[t]; return null }, hexToRgb: function (t) { if (3 != this.length) return null; var e = this.map(function (t) { return 1 == t.length && (t += t), t.toInt(16) }); return t ? e : "rgb(" + e + ")" }, rgbToHex: function (t) { if (this.length < 3) return null; if (4 == this.length && 0 == this[3] && !t) return "transparent"; for (var e = [], i = 0; i < 3; i++) { var n = (+this[i]).toString(16); e.push(1 == n.length ? "0" + n : n) } return t ? e : "#" + e.join("") } }), Array.alias("extend", "append"); var $pick = function () { return Array.from(arguments).pick() }; String.implement({ test: function (t, e) { return ("regexp" == typeOf(t) ? t : new RegExp("" + t, e)).test(this) }, contains: function (t, e) { return e ? -1 < (e + this + e).indexOf(e + t + e) : -1 < String(this).indexOf(t) }, trim: function () { return String(this).replace(/^\s+|\s+$/g, "") }, clean: function () { return String(this).replace(/\s+/g, " ").trim() }, camelCase: function () { return String(this).replace(/-\D/g, function (t) { return t.charAt(1).toUpperCase() }) }, hyphenate: function () { return String(this).replace(/[A-Z]/g, function (t) { return "-" + t.charAt(0).toLowerCase() }) }, capitalize: function () { return String(this).replace(/\b[a-z]/g, function (t) { return t.toUpperCase() }) }, escapeRegExp: function () { return String(this).replace(/([-.*+?^${}()|[\]\/\\])/g, "\\$1") }, toInt: function (t) { return parseInt(this, t || 10) }, toFloat: function () { return parseFloat(this) }, hexToRgb: function (t) { var e = String(this).match(/^#?(\w{1,2})(\w{1,2})(\w{1,2})$/); return e ? e.slice(1).hexToRgb(t) : null }, rgbToHex: function (t) { var e = String(this).match(/\d{1,3}/g); return e ? e.rgbToHex(t) : null }, substitute: function (i, t) { return String(this).replace(t || /\\?\{([^{}]+)\}/g, function (t, e) { return "\\" == t.charAt(0) ? t.slice(1) : null != i[e] ? i[e] : "" }) } }), Number.implement({ limit: function (t, e) { return Math.min(e, Math.max(t, this)) }, round: function (t) { return t = Math.pow(10, t || 0).toFixed(t < 0 ? -t : 0), Math.round(this * t) / t }, times: function (t, e) { for (var i = 0; i < this; i++)t.call(e, i, this) }, toFloat: function () { return parseFloat(this) }, toInt: function (t) { return parseInt(this, t || 10) } }), Number.alias("each", "times"), function () { var e = {};["abs", "acos", "asin", "atan", "atan2", "ceil", "cos", "exp", "floor", "log", "max", "min", "pow", "sin", "sqrt", "tan"].each(function (t) { Number[t] || (e[t] = function () { return Math[t].apply(null, [this].concat(Array.from(arguments))) }) }), Number.implement(e) }(), Function.extend({ attempt: function () { for (var t = 0, e = arguments.length; t < e; t++)try { return arguments[t]() } catch (t) { } return null } }), Function.implement({ attempt: function (t, e) { try { return this.apply(e, Array.from(t)) } catch (t) { } return null }, bind: function (i) { function n() { } var s = this, r = 1 < arguments.length ? Array.slice(arguments, 1) : null, o = function () { var t = i, e = arguments.length; this instanceof o && (n.prototype = s.prototype, t = new n); e = r || e ? s.apply(t, r && e ? r.concat(Array.slice(arguments)) : r || arguments) : s.call(t); return t == i ? e : t }; return o }, pass: function (t, e) { var i = this; return null != t && (t = Array.from(t)), function () { return i.apply(e, t || arguments) } }, delay: function (t, e, i) { return setTimeout(this.pass(null == i ? [] : i, e), t) }, periodical: function (t, e, i) { return setInterval(this.pass(null == i ? [] : i, e), t) } }), Function.implement({ create: function (i) { var n = this; return i = i || {}, function (t) { var e = null != (e = i.arguments) ? Array.from(e) : Array.slice(arguments, i.event ? 1 : 0); i.event && (e = [t || window.event].extend(e)); t = function () { return n.apply(i.bind || null, e) }; return i.delay ? setTimeout(t, i.delay) : i.periodical ? setInterval(t, i.periodical) : i.attempt ? Function.attempt(t) : t() } }, bindWithEvent: function (e, i) { var n = this; return null != i && (i = Array.from(i)), function (t) { return n.apply(e, null == i ? arguments : [t].concat(i)) } }, run: function (t, e) { return this.apply(e, Array.from(t)) } }), Object.create == Function.prototype.create && (Object.create = null); var $try = Function.attempt; !function () { var o = Object.prototype.hasOwnProperty; Object.extend({ subset: function (t, e) { for (var i = {}, n = 0, s = e.length; n < s; n++) { var r = e[n]; r in t && (i[r] = t[r]) } return i }, map: function (t, e, i) { var n, s = {}; for (n in t) o.call(t, n) && (s[n] = e.call(i, t[n], n, t)); return s }, filter: function (t, e, i) { var n, s = {}; for (n in t) { var r = t[n]; o.call(t, n) && e.call(i, r, n, t) && (s[n] = r) } return s }, every: function (t, e, i) { for (var n in t) if (o.call(t, n) && !e.call(i, t[n], n)) return !1; return !0 }, some: function (t, e, i) { for (var n in t) if (o.call(t, n) && e.call(i, t[n], n)) return !0; return !1 }, keys: function (t) { var e, i = []; for (e in t) o.call(t, e) && i.push(e); return i }, values: function (t) { var e, i = []; for (e in t) o.call(t, e) && i.push(t[e]); return i }, getLength: function (t) { return Object.keys(t).length }, keyOf: function (t, e) { for (var i in t) if (o.call(t, i) && t[i] === e) return i; return null }, contains: function (t, e) { return null != Object.keyOf(t, e) }, toQueryString: function (t, s) { var r = []; return Object.each(t, function (t, e) { var i; switch (s && (e = s + "[" + e + "]"), typeOf(t)) { case "object": i = Object.toQueryString(t, e); break; case "array": var n = {}; t.each(function (t, e) { n[e] = t }), i = Object.toQueryString(n, e); break; default: i = e + "=" + encodeURIComponent(t) }null != t && r.push(i) }), r.join("&") } }) }(), Hash.implement({ has: Object.prototype.hasOwnProperty, keyOf: function (t) { return Object.keyOf(this, t) }, hasValue: function (t) { return Object.contains(this, t) }, extend: function (t) { return Hash.each(t || {}, function (t, e) { Hash.set(this, e, t) }, this), this }, combine: function (t) { return Hash.each(t || {}, function (t, e) { Hash.include(this, e, t) }, this), this }, erase: function (t) { return this.hasOwnProperty(t) && delete this[t], this }, get: function (t) { return this.hasOwnProperty(t) ? this[t] : null }, set: function (t, e) { return this[t] && !this.hasOwnProperty(t) || (this[t] = e), this }, empty: function () { return Hash.each(this, function (t, e) { delete this[e] }, this), this }, include: function (t, e) { return null == this[t] && (this[t] = e), this }, map: function (t, e) { return new Hash(Object.map(this, t, e)) }, filter: function (t, e) { return new Hash(Object.filter(this, t, e)) }, every: function (t, e) { return Object.every(this, t, e) }, some: function (t, e) { return Object.some(this, t, e) }, getKeys: function () { return Object.keys(this) }, getValues: function () { return Object.values(this) }, toQueryString: function (t) { return Object.toQueryString(this, t) } }), Hash.extend = Object.append, Hash.alias({ indexOf: "keyOf", contains: "hasValue" }), function () { var i = this.document, n = i.window = this, t = navigator.userAgent.toLowerCase(), e = navigator.platform.toLowerCase(), s = t.match(/(opera|ie|firefox|chrome|version)[\s\/:]([\w\d\.]+)?.*?(safari|version[\s\/:]([\w\d\.]+)|$)/) || [null, "unknown", 0], r = "ie" == s[1] && i.documentMode, o = this.Browser = { extend: Function.prototype.extend, name: "version" == s[1] ? s[3] : s[1], version: r || parseFloat("opera" == s[1] && s[4] ? s[4] : s[2]), Platform: { name: t.match(/ip(?:ad|od|hone)/) ? "ios" : (t.match(/(?:webos|android)/) || e.match(/mac|win|linux/) || ["other"])[0] }, Features: { xpath: !!i.evaluate, air: !!n.runtime, query: !!i.querySelector, json: !!n.JSON }, Plugins: {} }; function a() { return new XMLHttpRequest } function h() { return new ActiveXObject("MSXML2.XMLHTTP") } function l() { return new ActiveXObject("Microsoft.XMLHTTP") } Object.hasOwnProperty.call(n, "ActiveXObject") && !n.ActiveXObject && (o.ie = !0), o[o.name] = !0, o[o.name + parseInt(o.version, 10)] = !0, o.Platform[o.Platform.name] = !0, o.Request = Function.attempt(function () { return a(), a }, function () { return h(), h }, function () { return l(), l }), o.Features.xhr = !!o.Request; var u, e = (Function.attempt(function () { return navigator.plugins["Shockwave Flash"].description }, function () { return new ActiveXObject("ShockwaveFlash.ShockwaveFlash").GetVariable("$version") }) || "0 r0").match(/\d+/g); if (o.Plugins.Flash = { version: Number(e[0] || "0." + e[1]) || 0, build: Number(e[2]) || 0 }, o.exec = function (t) { return t && (n.execScript ? n.execScript(t) : ((e = i.createElement("script")).setAttribute("type", "text/javascript"), e.text = t, i.head.appendChild(e), i.head.removeChild(e))), t; var e }, String.implement("stripScripts", function (t) { var i = "", e = this.replace(/<script[^>]*>([\s\S]*?)<\/script>/gi, function (t, e) { return i += e + "\n", "" }); return !0 === t ? o.exec(i) : "function" == typeOf(t) && t(i, e), e }), o.extend({ Document: this.Document, Window: this.Window, Element: this.Element, Event: this.Event }), this.Window = this.$constructor = new Type("Window", function () { }), this.$family = Function.from("window").hide(), Window.mirror(function (t, e) { n[t] = e }), this.Document = i.$constructor = new Type("Document", function () { }), i.$family = Function.from("document").hide(), Document.mirror(function (t, e) { i[t] = e }), i.html = i.documentElement, i.head || (i.head = i.getElementsByTagName("head")[0]), i.execCommand) try { i.execCommand("BackgroundImageCache", !1, !0) } catch (t) { } this.attachEvent && !this.addEventListener && (u = function () { this.detachEvent("onunload", u), i.head = i.html = i.window = null }, this.attachEvent("onunload", u)); var c = Array.from; try { c(i.html.childNodes) } catch (t) { Array.from = function (t) { if ("string" != typeof t && Type.isEnumerable(t) && "array" != typeOf(t)) { for (var e = t.length, i = new Array(e); e--;)i[e] = t[e]; return i } return c(t) }; var d = Array.prototype, f = d.slice;["pop", "push", "reverse", "shift", "sort", "splice", "unshift", "concat", "join", "slice"].each(function (t) { var e = d[t]; Array[t] = function (t) { return e.apply(Array.from(t), f.call(arguments, 1)) } }) } o.Platform.ios && (o.Platform.ipod = !0), o.Engine = {}; e = function (t, e) { o.Engine.name = t, o.Engine[t + e] = !0, o.Engine.version = e }; if (o.ie) switch (o.Engine.trident = !0, o.version) { case 6: e("trident", 4); break; case 7: e("trident", 5); break; case 8: e("trident", 6) }if (o.firefox && (o.Engine.gecko = !0, 3 <= o.version ? e("gecko", 19) : e("gecko", 18)), o.safari || o.chrome) switch (o.Engine.webkit = !0, o.version) { case 2: e("webkit", 419); break; case 3: e("webkit", 420); break; case 4: e("webkit", 525) }if (o.opera && (o.Engine.presto = !0, 9.6 <= o.version ? e("presto", 960) : 9.5 <= o.version ? e("presto", 950) : e("presto", 925)), "unknown" == o.name) switch ((t.match(/(?:webkit|khtml|gecko)/) || [])[0]) { case "webkit": case "khtml": o.Engine.webkit = !0; break; case "gecko": o.Engine.gecko = !0 }this.$exec = o.exec }(), function () { var o = {}, t = this.DOMEvent = new Type("DOMEvent", function (t, e) { if (e = e || window, (t = t || e.event).$extended) return t; this.event = t, this.$extended = !0, this.shift = t.shiftKey, this.control = t.ctrlKey, this.alt = t.altKey, this.meta = t.metaKey; for (var i = this.type = t.type, n = t.target || t.srcElement; n && 3 == n.nodeType;)n = n.parentNode; if (this.target = document.id(n), 0 == i.indexOf("key")) { var s = this.code = t.which || t.keyCode; this.key = o[s] || Object.keyOf(Event.Keys, s), "keydown" == i && (111 < s && s < 124 ? this.key = "f" + (s - 111) : 95 < s && s < 106 && (this.key = s - 96)), null == this.key && (this.key = String.fromCharCode(s).toLowerCase()) } else if ("click" == i || "dblclick" == i || "contextmenu" == i || "DOMMouseScroll" == i || 0 == i.indexOf("mouse")) { s = (s = e.document).compatMode && "CSS1Compat" != s.compatMode ? s.body : s.html; if (this.page = { x: null != t.pageX ? t.pageX : t.clientX + s.scrollLeft, y: null != t.pageY ? t.pageY : t.clientY + s.scrollTop }, this.client = { x: null != t.pageX ? t.pageX - e.pageXOffset : t.clientX, y: null != t.pageY ? t.pageY - e.pageYOffset : t.clientY }, "DOMMouseScroll" != i && "mousewheel" != i || (this.wheel = t.wheelDelta ? t.wheelDelta / 120 : -(t.detail || 0) / 3), this.rightClick = 3 == t.which || 2 == t.button, "mouseover" == i || "mouseout" == i) { for (var r = t.relatedTarget || t[("mouseover" == i ? "from" : "to") + "Element"]; r && 3 == r.nodeType;)r = r.parentNode; this.relatedTarget = document.id(r) } } else { 0 != i.indexOf("touch") && 0 != i.indexOf("gesture") || (this.rotation = t.rotation, this.scale = t.scale, this.targetTouches = t.targetTouches, this.changedTouches = t.changedTouches, (t = this.touches = t.touches) && t[0] && (t = t[0], this.page = { x: t.pageX, y: t.pageY }, this.client = { x: t.clientX, y: t.clientY })) } this.client || (this.client = {}), this.page || (this.page = {}) }); t.implement({ stop: function () { return this.preventDefault().stopPropagation() }, stopPropagation: function () { return this.event.stopPropagation ? this.event.stopPropagation() : this.event.cancelBubble = !0, this }, preventDefault: function () { return this.event.preventDefault ? this.event.preventDefault() : this.event.returnValue = !1, this } }), t.defineKey = function (t, e) { return o[t] = e, this }, t.defineKeys = t.defineKey.overloadSetter(!0), t.defineKeys({ 38: "up", 40: "down", 37: "left", 39: "right", 27: "esc", 32: "space", 8: "backspace", 9: "tab", 46: "delete", 13: "enter" }) }(); var Event = DOMEvent; Event.Keys = {}, Event.Keys = new Hash(Event.Keys), function () { function n(t, e, i) { if (s.Mutators.hasOwnProperty(t) && null == (e = s.Mutators[t].call(this, e))) return this; if ("function" == typeOf(e)) { if (e.$hidden) return this; this.prototype[t] = i ? e : function (t, n, s) { s.$origin && (s = s.$origin); var r = function () { if (s.$protected && null == this.$caller) throw new Error('The method "' + n + '" cannot be called.'); var t = this.caller, e = this.$caller; this.caller = e, this.$caller = r; var i = s.apply(this, arguments); return this.$caller = e, this.caller = t, i }.extend({ $owner: t, $origin: s, $name: n }); return r }(this, t, e) } else Object.merge(this.prototype, t, e); return this } var s = this.Class = new Type("Class", function (t) { instanceOf(t, Function) && (t = { initialize: t }); var e = function () { if (r(this), e.$prototyping) return this; this.$caller = null; var t = this.initialize ? this.initialize.apply(this, arguments) : this; return this.$caller = this.caller = null, t }.extend(this).implement(t); return e.$constructor = s, (e.prototype.$constructor = e).prototype.parent = i, e }), i = function () { if (!this.$caller) throw new Error('The method "parent" cannot be called.'); var t = this.$caller.$name, e = this.$caller.$owner.parent, e = e ? e.prototype[t] : null; if (!e) throw new Error('The method "' + t + '" has no parent.'); return e.apply(this, arguments) }, r = function (t) { for (var e in t) { var i = t[e]; switch (typeOf(i)) { case "object": function n() { } n.prototype = i, t[e] = r(new n); break; case "array": t[e] = i.clone() } } return t }; s.implement("implement", n.overloadSetter()), s.Mutators = { Extends: function (t) { this.parent = t, this.prototype = function (t) { t.$prototyping = !0; var e = new t; return delete t.$prototyping, e }(t) }, Implements: function (t) { Array.from(t).each(function (t) { var e, i = new t; for (e in i) n.call(this, e, i[e], !0) }, this) } } }(), function () { this.Chain = new Class({ $chain: [], chain: function () { return this.$chain.append(Array.flatten(arguments)), this }, callChain: function () { return !!this.$chain.length && this.$chain.shift().apply(this, arguments) }, clearChain: function () { return this.$chain.empty(), this } }); function s(t) { return t.replace(/^on([A-Z])/, function (t, e) { return e.toLowerCase() }) } this.Events = new Class({ $events: {}, addEvent: function (t, e, i) { return t = s(t), e == $empty || (this.$events[t] = (this.$events[t] || []).include(e), i && (e.internal = !0)), this }, addEvents: function (t) { for (var e in t) this.addEvent(e, t[e]); return this }, fireEvent: function (t, e, i) { t = s(t); t = this.$events[t]; return t && (e = Array.from(e), t.each(function (t) { i ? t.delay(i, this, e) : t.apply(this, e) }, this)), this }, removeEvent: function (t, e) { t = s(t); t = this.$events[t]; return !t || e.internal || -1 != (e = t.indexOf(e)) && delete t[e], this }, removeEvents: function (t) { if ("object" == typeOf(t)) { for (var e in t) this.removeEvent(e, t[e]); return this } for (e in t = t && s(t), this.$events) if (!t || t == e) for (var i = this.$events[e], n = i.length; n--;)n in i && this.removeEvent(e, i[n]); return this } }), this.Options = new Class({ setOptions: function () { var t = this.options = Object.merge.apply(null, [{}, this.options].append(arguments)); if (this.addEvent) for (var e in t) "function" == typeOf(t[e]) && /^on[A-Z]/.test(e) && (this.addEvent(e, t[e]), delete t[e]); return this } }) }(), function () { var y, b, w, S, i = {}, n = {}, x = /\\/g, s = function (t, e) { if (null == t) return null; if (!0 === t.Slick) return t; t = ("" + t).replace(/^\s+|\s+$/g, ""); e = (S = !!e) ? n : i; if (e[t]) return e[t]; for (y = { Slick: !0, expressions: [], raw: t, reverse: function () { return s(this.raw, !0) } }, b = -1; t != (t = t.replace(o, a));); return y.length = y.expressions.length, e[y.raw] = S ? r(y) : y }, E = function (t) { return "!" === t ? " " : " " === t ? "!" : /^!/.test(t) ? t.replace(/^!/, "") : "!" + t }, r = function (t) { for (var e = t.expressions, i = 0; i < e.length; i++) { for (var n = e[i], s = { parts: [], tag: "*", combinator: E(n[0].combinator) }, r = 0; r < n.length; r++) { var o = n[r]; o.reverseCombinator || (o.reverseCombinator = " "), o.combinator = o.reverseCombinator, delete o.reverseCombinator } n.reverse().push(s) } return t }, O = function (t) { return t.replace(/[-[\]{}()*+?.\\^$|,#\s]/g, function (t) { return "\\" + t }) }, o = new RegExp("^(?:\\s*(,)\\s*|\\s*(<combinator>+)\\s*|(\\s+)|(<unicode>+|\\*)|\\#(<unicode>+)|\\.(<unicode>+)|\\[\\s*(<unicode1>+)(?:\\s*([*^$!~|]?=)(?:\\s*(?:([\"']?)(.*?)\\9)))?\\s*\\](?!\\])|(:+)(<unicode>+)(?:\\((?:(?:([\"'])([^\\13]*)\\13)|((?:\\([^)]+\\)|[^()]*)+))\\))?)".replace(/<combinator>/, "[" + O(">+~`!@$%^&={}\\;</") + "]").replace(/<unicode>/g, "(?:[\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])").replace(/<unicode1>/g, "(?:[:\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])")); function a(t, e, i, n, s, r, o, a, h, l, u, c, d, f, m, p) { if ((e || -1 === b) && (y.expressions[++b] = [], w = -1, e)) return ""; (i || n || -1 === w) && (i = i || " ", n = y.expressions[b], S && n[w] && (n[w].reverseCombinator = E(i)), n[++w] = { combinator: i, tag: "*" }); var g, v, i = y.expressions[b][w]; if (s) i.tag = s.replace(x, ""); else if (r) i.id = r.replace(x, ""); else if (o) o = o.replace(x, ""), i.classList || (i.classList = []), i.classes || (i.classes = []), i.classList.push(o), i.classes.push({ value: o, regexp: new RegExp("(^|\\s)" + O(o) + "(\\s|$)") }); else if (d) p = (p = p || m) ? p.replace(x, "") : null, i.pseudos || (i.pseudos = []), i.pseudos.push({ key: d.replace(x, ""), value: p, type: 1 == c.length ? "class" : "element" }); else if (a) { switch (a = a.replace(x, ""), u = (u || "").replace(x, ""), h) { case "^=": v = new RegExp("^" + O(u)); break; case "$=": v = new RegExp(O(u) + "$"); break; case "~=": v = new RegExp("(^|\\s)" + O(u) + "(\\s|$)"); break; case "|=": v = new RegExp("^" + O(u) + "(-|$)"); break; case "=": g = function (t) { return u == t }; break; case "*=": g = function (t) { return t && -1 < t.indexOf(u) }; break; case "!=": g = function (t) { return u != t }; break; default: g = function (t) { return !!t } }"" == u && /^[*$^]=$/.test(h) && (g = function () { return !1 }), g = g || function (t) { return t && v.test(t) }, i.attributes || (i.attributes = []), i.attributes.push({ key: a, operator: h, value: u, test: g }) } return "" } var t = this.Slick || {}; t.parse = function (t) { return s(t) }, t.escapeRegExp = O, this.Slick || (this.Slick = t) }.apply("undefined" != typeof exports ? exports : this), function () { var n = {}, f = {}, e = Object.prototype.toString; n.isNativeCode = function (t) { return /\{\s*\[native code\]\s*\}/.test("" + t) }, n.isXML = function (t) { return !!t.xmlVersion || !!t.xml || "[object XMLDocument]" == e.call(t) || 9 == t.nodeType && "HTML" != t.documentElement.nodeName }, n.setDocument = function (i) { var t = i.nodeType; if (9 != t) if (t) i = i.ownerDocument; else { if (!i.navigator) return; i = i.document } if (this.document !== i) { var e, n, s, r, o, a = (this.document = i).documentElement, t = this.getUIDXML(a), h = f[t]; if (h) for (e in h) this[e] = h[e]; else { (h = f[t] = {}).root = a, h.isXMLDocument = this.isXML(i), h.brokenStarGEBTN = h.starSelectsClosedQSA = h.idGetsName = h.brokenMixedCaseQSA = h.brokenGEBCN = h.brokenCheckedQSA = h.brokenEmptyAttributeQSA = h.isHTMLDocument = h.nativeMatchesSelector = !1; var l, u = "slick_uniqueid", c = i.createElement("div"), t = i.body || i.getElementsByTagName("body")[0] || a; t.appendChild(c); try { c.innerHTML = '<a id="' + u + '"></a>', h.isHTMLDocument = !!i.getElementById(u) } catch (t) { } if (h.isHTMLDocument) { c.style.display = "none", c.appendChild(i.createComment("")), d = 1 < c.getElementsByTagName("*").length; try { c.innerHTML = "foo</foo>", n = (l = c.getElementsByTagName("*")) && !!l.length && "/" == l[0].nodeName.charAt(0) } catch (t) { } h.brokenStarGEBTN = d || n; try { c.innerHTML = '<a name="' + u + '"></a><b id="' + u + '"></b>', h.idGetsName = i.getElementById(u) === c.firstChild } catch (t) { } if (c.getElementsByClassName) { try { c.innerHTML = '<a class="f"></a><a class="b"></a>', c.getElementsByClassName("b").length, c.firstChild.className = "b", r = 2 != c.getElementsByClassName("b").length } catch (t) { } try { c.innerHTML = '<a class="a"></a><a class="f b a"></a>', s = 2 != c.getElementsByClassName("a").length } catch (t) { } h.brokenGEBCN = r || s } if (c.querySelectorAll) { try { c.innerHTML = "foo</foo>", l = c.querySelectorAll("*"), h.starSelectsClosedQSA = l && !!l.length && "/" == l[0].nodeName.charAt(0) } catch (t) { } try { c.innerHTML = '<a class="MiX"></a>', h.brokenMixedCaseQSA = !c.querySelectorAll(".MiX").length } catch (t) { } try { c.innerHTML = '<select><option selected="selected">a</option></select>', h.brokenCheckedQSA = 0 == c.querySelectorAll(":checked").length } catch (t) { } try { c.innerHTML = '<a class=""></a>', h.brokenEmptyAttributeQSA = 0 != c.querySelectorAll('[class*=""]').length } catch (t) { } } try { c.innerHTML = '<form action="s"><input id="action"/></form>', o = "s" != c.firstChild.getAttribute("action") } catch (t) { } if (h.nativeMatchesSelector = a.matchesSelector || a.mozMatchesSelector || a.webkitMatchesSelector, h.nativeMatchesSelector) try { h.nativeMatchesSelector.call(a, ":slick"), h.nativeMatchesSelector = null } catch (t) { } } try { a.slick_expando = 1, delete a.slick_expando, h.getUID = this.getUIDHTML } catch (t) { h.getUID = this.getUIDXML } t.removeChild(c), c = l = t = null, h.getAttribute = h.isHTMLDocument && o ? function (t, e) { var i = this.attributeGetters[e]; if (i) return i.call(t); e = t.getAttributeNode(e); return e ? e.nodeValue : null } : function (t, e) { var i = this.attributeGetters[e]; return i ? i.call(t) : t.getAttribute(e) }, h.hasAttribute = a && this.isNativeCode(a.hasAttribute) ? function (t, e) { return t.hasAttribute(e) } : function (t, e) { return !(!(t = t.getAttributeNode(e)) || !t.specified && !t.nodeValue) }; var d = a && this.isNativeCode(a.contains), t = i && this.isNativeCode(i.contains); for (e in h.contains = d && t ? function (t, e) { return t.contains(e) } : d && !t ? function (t, e) { return t === e || (t === i ? i.documentElement : t).contains(e) } : a && a.compareDocumentPosition ? function (t, e) { return t === e || !!(16 & t.compareDocumentPosition(e)) } : function (t, e) { if (e) do { if (e === t) return !0 } while (e = e.parentNode); return !1 }, h.documentSorter = a.compareDocumentPosition ? function (t, e) { return t.compareDocumentPosition && e.compareDocumentPosition ? 4 & t.compareDocumentPosition(e) ? -1 : t === e ? 0 : 1 : 0 } : "sourceIndex" in a ? function (t, e) { return t.sourceIndex && e.sourceIndex ? t.sourceIndex - e.sourceIndex : 0 } : i.createRange ? function (t, e) { if (!t.ownerDocument || !e.ownerDocument) return 0; var i = t.ownerDocument.createRange(), n = e.ownerDocument.createRange(); return i.setStart(t, 0), i.setEnd(t, 0), n.setStart(e, 0), n.setEnd(e, 0), i.compareBoundaryPoints(Range.START_TO_END, n) } : null, a = null, h) this[e] = h[e] } } }; var L = /^([#.]?)((?:[\w-]+|\*))$/, j = /\[.+[*$^]=(?:""|'')?\]/, I = {}; n.search = function (t, e, i, n) { var s = this.found = n ? null : i || []; if (!t) return s; if (t.navigator) t = t.document; else if (!t.nodeType) return s; var r, o, a, h, l, u, c, d, f, m, p, g = this.uniques = {}, v = !(!i || !i.length), y = 9 == t.nodeType; if (this.document !== (y ? t : t.ownerDocument) && this.setDocument(t), v) for (k = s.length; k--;)g[this.getUID(s[k])] = !0; if ("string" == typeof e) { var b = e.match(L); t: if (b) { var w, S = b[1], x = b[2]; if (S) { if ("#" == S) { if (!this.isHTMLDocument || !y) break t; if (!(w = t.getElementById(x))) return s; if (this.idGetsName && w.getAttributeNode("id").nodeValue != x) break t; if (n) return w || null; v && g[this.getUID(w)] || s.push(w) } else if ("." == S) { if (!this.isHTMLDocument || (!t.getElementsByClassName || this.brokenGEBCN) && t.querySelectorAll) break t; if (t.getElementsByClassName && !this.brokenGEBCN) { if (O = t.getElementsByClassName(x), n) return O[0] || null; for (k = 0; w = O[k++];)v && g[this.getUID(w)] || s.push(w) } else for (var E = new RegExp("(^|\\s)" + z.escapeRegExp(x) + "(\\s|$)"), O = t.getElementsByTagName("*"), k = 0; w = O[k++];)if (className = w.className, className && E.test(className)) { if (n) return w; v && g[this.getUID(w)] || s.push(w) } } } else { if ("*" == x && this.brokenStarGEBTN) break t; if (O = t.getElementsByTagName(x), n) return O[0] || null; for (k = 0; w = O[k++];)v && g[this.getUID(w)] || s.push(w) } return v && this.sort(s), n ? null : s } t: if (t.querySelectorAll && !(!this.isHTMLDocument || I[e] || this.brokenMixedCaseQSA || this.brokenCheckedQSA && -1 < e.indexOf(":checked") || this.brokenEmptyAttributeQSA && j.test(e) || !y && -1 < e.indexOf(",") || z.disableQSA)) { var C, M, A = e, T = t; y || (C = T.getAttribute("id"), M = "slickid__", T.setAttribute("id", M), A = "#" + M + " " + A, t = T.parentNode); try { if (n) return t.querySelector(A) || null; O = t.querySelectorAll(A) } catch (t) { I[e] = 1; break t } finally { y || (C ? T.setAttribute("id", C) : T.removeAttribute("id"), t = T) } if (this.starSelectsClosedQSA) for (k = 0; w = O[k++];)!("@" < w.nodeName) || v && g[this.getUID(w)] || s.push(w); else for (k = 0; w = O[k++];)v && g[this.getUID(w)] || s.push(w); return v && this.sort(s), s } if (!(r = this.Slick.parse(e)).length) return s } else { if (null == e) return s; if (!e.Slick) return this.contains(t.documentElement || t, e) && (s ? s.push(e) : s = e), s; r = e } this.posNTH = {}, this.posNTHLast = {}, this.posNTHType = {}, this.posNTHTypeLast = {}, this.push = !v && (n || 1 == r.length && 1 == r.expressions[0].length) ? this.pushArray : this.pushUID, null == s && (s = []); var D, P, F, N = r.expressions; t: for (k = 0; P = N[k]; k++)for (o = 0; F = P[o]; o++) { if (!this[l = "combinator:" + F.combinator]) continue t; if (u = this.isXMLDocument ? F.tag : F.tag.toUpperCase(), c = F.id, d = F.classList, f = F.classes, m = F.attributes, p = F.pseudos, F = o === P.length - 1, this.bitUniques = {}, F ? (this.uniques = g, this.found = s) : (this.uniques = {}, this.found = []), 0 === o) { if (this[l](t, u, c, f, m, p, d), n && F && s.length) break t } else if (n && F) { for (a = 0, h = D.length; a < h; a++)if (this[l](D[a], u, c, f, m, p, d), s.length) break t } else for (a = 0, h = D.length; a < h; a++)this[l](D[a], u, c, f, m, p, d); D = this.found } return (v || 1 < r.expressions.length) && this.sort(s), n ? s[0] || null : s }, n.uidx = 1, n.uidk = "slick-uniqueid", n.getUIDXML = function (t) { var e = t.getAttribute(this.uidk); return e || (e = this.uidx++, t.setAttribute(this.uidk, e)), e }, n.getUIDHTML = function (t) { return t.uniqueNumber || (t.uniqueNumber = this.uidx++) }, n.sort = function (t) { return this.documentSorter && t.sort(this.documentSorter), t }, n.cacheNTH = {}, n.matchNTH = /^([+-]?\d*)?([a-z]+)?([+-]\d+)?$/, n.parseNTHArgument = function (t) { if (!(s = t.match(this.matchNTH))) return !1; var e = s[2] || !1, i = s[1] || 1; "-" == i && (i = -1); var n = +s[3] || 0, s = "n" == e ? { a: i, b: n } : "odd" == e ? { a: 2, b: 1 } : "even" == e ? { a: 2, b: 0 } : { a: 0, b: i }; return this.cacheNTH[t] = s }, n.createNTHPseudo = function (a, h, l, u) { return function (t, e) { var i = this.getUID(t); if (!this[l][i]) { var n = t.parentNode; if (!n) return !1; var s = n[a], r = 1; if (u) for (var o = t.nodeName; s.nodeName == o && (this[l][this.getUID(s)] = r++), s = s[h];); else for (; 1 == s.nodeType && (this[l][this.getUID(s)] = r++), s = s[h];); } e = e || "n"; t = this.cacheNTH[e] || this.parseNTHArgument(e); if (!t) return !1; e = t.a, t = t.b, i = this[l][i]; if (0 == e) return t == i; if (0 < e) { if (i < t) return !1 } else if (t < i) return !1; return (i - t) % e == 0 } }, n.pushArray = function (t, e, i, n, s, r) { this.matchSelector(t, e, i, n, s, r) && this.found.push(t) }, n.pushUID = function (t, e, i, n, s, r) { var o = this.getUID(t); !this.uniques[o] && this.matchSelector(t, e, i, n, s, r) && (this.uniques[o] = !0, this.found.push(t)) }, n.matchNode = function (t, e) { if (this.isHTMLDocument && this.nativeMatchesSelector) try { return this.nativeMatchesSelector.call(t, e.replace(/\[([^=]+)=\s*([^'"\]]+?)\s*\]/g, '[$1="$2"]')) } catch (t) { } var i = this.Slick.parse(e); if (!i) return !0; for (var n = i.expressions, s = 0, r = 0; currentExpression = n[r]; r++)if (1 == currentExpression.length) { var o = currentExpression[0]; if (this.matchSelector(t, this.isXMLDocument ? o.tag : o.tag.toUpperCase(), o.id, o.classes, o.attributes, o.pseudos)) return !0; s++ } if (s == i.length) return !1; var a, h = this.search(this.document, i); for (r = 0; a = h[r++];)if (a === t) return !0; return !1 }, n.matchPseudo = function (t, e, i) { var n = "pseudo:" + e; if (this[n]) return this[n](t, i); e = this.getAttribute(t, e); return i ? i == e : !!e }, n.matchSelector = function (t, e, i, n, s, r) { if (e) { var o = this.isXMLDocument ? t.nodeName : t.nodeName.toUpperCase(); if ("*" == e) { if (o < "@") return !1 } else if (o != e) return !1 } if (i && t.getAttribute("id") != i) return !1; var a, h, l; if (n) for (a = n.length; a--;)if (!(l = this.getAttribute(t, "class")) || !n[a].regexp.test(l)) return !1; if (s) for (a = s.length; a--;)if ((h = s[a]).operator ? !h.test(this.getAttribute(t, h.key)) : !this.hasAttribute(t, h.key)) return !1; if (r) for (a = r.length; a--;)if (h = r[a], !this.matchPseudo(t, h.key, h.value)) return !1; return !0 }; var t, i = { " ": function (t, e, i, n, s, r, o) { var a, h, l; if (this.isHTMLDocument) { if (i) { if (!(h = this.document.getElementById(i)) && t.all || this.idGetsName && h && h.getAttributeNode("id").nodeValue != i) { if (!(l = t.all[i])) return; for (l[0] || (l = [l]), a = 0; h = l[a++];) { var u = h.getAttributeNode("id"); if (u && u.nodeValue == i) { this.push(h, e, null, n, s, r); break } } return } if (h) { if (this.document !== t && !this.contains(t, h)) return; return void this.push(h, e, null, n, s, r) } if (this.contains(this.root, t)) return } if (n && t.getElementsByClassName && !this.brokenGEBCN && (l = t.getElementsByClassName(o.join(" "))) && l.length) { for (a = 0; h = l[a++];)this.push(h, e, i, null, s, r); return } } if ((l = t.getElementsByTagName(e)) && l.length) for (this.brokenStarGEBTN || (e = null), a = 0; h = l[a++];)this.push(h, e, i, n, s, r) }, ">": function (t, e, i, n, s, r) { if (t = t.firstChild) for (; 1 == t.nodeType && this.push(t, e, i, n, s, r), t = t.nextSibling;); }, "+": function (t, e, i, n, s, r) { for (; t = t.nextSibling;)if (1 == t.nodeType) { this.push(t, e, i, n, s, r); break } }, "^": function (t, e, i, n, s, r) { (t = t.firstChild) && (1 == t.nodeType ? this.push(t, e, i, n, s, r) : this["combinator:+"](t, e, i, n, s, r)) }, "~": function (t, e, i, n, s, r) { for (; t = t.nextSibling;)if (1 == t.nodeType) { var o = this.getUID(t); if (this.bitUniques[o]) break; this.bitUniques[o] = !0, this.push(t, e, i, n, s, r) } }, "++": function (t, e, i, n, s, r) { this["combinator:+"](t, e, i, n, s, r), this["combinator:!+"](t, e, i, n, s, r) }, "~~": function (t, e, i, n, s, r) { this["combinator:~"](t, e, i, n, s, r), this["combinator:!~"](t, e, i, n, s, r) }, "!": function (t, e, i, n, s, r) { for (; t = t.parentNode;)t !== this.document && this.push(t, e, i, n, s, r) }, "!>": function (t, e, i, n, s, r) { (t = t.parentNode) !== this.document && this.push(t, e, i, n, s, r) }, "!+": function (t, e, i, n, s, r) { for (; t = t.previousSibling;)if (1 == t.nodeType) { this.push(t, e, i, n, s, r); break } }, "!^": function (t, e, i, n, s, r) { (t = t.lastChild) && (1 == t.nodeType ? this.push(t, e, i, n, s, r) : this["combinator:!+"](t, e, i, n, s, r)) }, "!~": function (t, e, i, n, s, r) { for (; t = t.previousSibling;)if (1 == t.nodeType) { var o = this.getUID(t); if (this.bitUniques[o]) break; this.bitUniques[o] = !0, this.push(t, e, i, n, s, r) } } }; for (t in i) n["combinator:" + t] = i[t]; var s, r = { empty: function (t) { var e = t.firstChild; return !(e && 1 == e.nodeType || (t.innerText || t.textContent || "").length) }, not: function (t, e) { return !this.matchNode(t, e) }, contains: function (t, e) { return -1 < (t.innerText || t.textContent || "").indexOf(e) }, "first-child": function (t) { for (; t = t.previousSibling;)if (1 == t.nodeType) return !1; return !0 }, "last-child": function (t) { for (; t = t.nextSibling;)if (1 == t.nodeType) return !1; return !0 }, "only-child": function (t) { for (var e = t; e = e.previousSibling;)if (1 == e.nodeType) return !1; for (var i = t; i = i.nextSibling;)if (1 == i.nodeType) return !1; return !0 }, "nth-child": n.createNTHPseudo("firstChild", "nextSibling", "posNTH"), "nth-last-child": n.createNTHPseudo("lastChild", "previousSibling", "posNTHLast"), "nth-of-type": n.createNTHPseudo("firstChild", "nextSibling", "posNTHType", !0), "nth-last-of-type": n.createNTHPseudo("lastChild", "previousSibling", "posNTHTypeLast", !0), index: function (t, e) { return this["pseudo:nth-child"](t, "" + (e + 1)) }, even: function (t) { return this["pseudo:nth-child"](t, "2n") }, odd: function (t) { return this["pseudo:nth-child"](t, "2n+1") }, "first-of-type": function (t) { for (var e = t.nodeName; t = t.previousSibling;)if (t.nodeName == e) return !1; return !0 }, "last-of-type": function (t) { for (var e = t.nodeName; t = t.nextSibling;)if (t.nodeName == e) return !1; return !0 }, "only-of-type": function (t) { for (var e = t, i = t.nodeName; e = e.previousSibling;)if (e.nodeName == i) return !1; for (var n = t; n = n.nextSibling;)if (n.nodeName == i) return !1; return !0 }, enabled: function (t) { return !t.disabled }, disabled: function (t) { return t.disabled }, checked: function (t) { return t.checked || t.selected }, focus: function (t) { return this.isHTMLDocument && this.document.activeElement === t && (t.href || t.type || this.hasAttribute(t, "tabindex")) }, root: function (t) { return t === this.root }, selected: function (t) { return t.selected } }; for (s in r) n["pseudo:" + s] = r[s]; var o = n.attributeGetters = { for: function () { return "htmlFor" in this ? this.htmlFor : this.getAttribute("for") }, href: function () { return "href" in this ? this.getAttribute("href", 2) : this.getAttribute("href") }, style: function () { return this.style ? this.style.cssText : this.getAttribute("style") }, tabindex: function () { var t = this.getAttributeNode("tabindex"); return t && t.specified ? t.nodeValue : null }, type: function () { return this.getAttribute("type") }, maxlength: function () { var t = this.getAttributeNode("maxLength"); return t && t.specified ? t.nodeValue : null } }; o.MAXLENGTH = o.maxLength = o.maxlength; var z = n.Slick = this.Slick || {}; z.version = "1.1.7", z.search = function (t, e, i) { return n.search(t, e, i) }, z.find = function (t, e) { return n.search(t, e, null, !0) }, z.contains = function (t, e) { return n.setDocument(t), n.contains(t, e) }, z.getAttribute = function (t, e) { return n.setDocument(t), n.getAttribute(t, e) }, z.hasAttribute = function (t, e) { return n.setDocument(t), n.hasAttribute(t, e) }, z.match = function (t, e) { return !(!t || !e) && (!e || e === t || (n.setDocument(t), n.matchNode(t, e))) }, z.defineAttributeGetter = function (t, e) { return n.attributeGetters[t] = e, this }, z.lookupAttributeGetter = function (t) { return n.attributeGetters[t] }, z.definePseudo = function (t, i) { return n["pseudo:" + t] = function (t, e) { return i.call(t, e) }, this }, z.lookupPseudo = function (t) { var e = n["pseudo:" + t]; return e ? function (t) { return e.call(this, t) } : null }, z.override = function (t, e) { return n.override(t, e), this }, z.isXML = n.isXML, z.uidOf = function (t) { return n.getUIDHTML(t) }, this.Slick || (this.Slick = z) }.apply("undefined" != typeof exports ? exports : this); var Element = function (t, e) { var i = Element.Constructors[t]; if (i) return i(e); if ("string" != typeof t) return document.id(t).set(e); if (e = e || {}, !/^[\w-]+$/.test(t)) { i = Slick.parse(t).expressions[0][0]; t = "*" == i.tag ? "div" : i.tag, i.id && null == e.id && (e.id = i.id); var n = i.attributes; if (n) for (var s, r = 0, o = n.length; r < o; r++)null == e[(s = n[r]).key] && (null != s.value && "=" == s.operator ? e[s.key] = s.value : s.value || s.operator || (e[s.key] = !0)); i.classList && null == e.class && (e.class = i.classList.join(" ")) } return document.newElement(t, e) }; Browser.Element && (Element.prototype = Browser.Element.prototype, Element.prototype._fireEvent = function (i) { return function (t, e) { return i.call(this, t, e) } }(Element.prototype.fireEvent)), new Type("Element", Element).mirror(function (o) { var t; Array.prototype[o] || ((t = {})[o] = function () { for (var t = [], e = arguments, i = !0, n = 0, s = this.length; n < s; n++)var r = this[n], r = t[n] = r[o].apply(r, e), i = i && "element" == typeOf(r); return i ? new Elements(t) : t }, Elements.implement(t)) }), Browser.Element || (Element.parent = Object, Element.Prototype = { $constructor: Element, $family: Function.from("element").hide() }, Element.mirror(function (t, e) { Element.Prototype[t] = e })), Element.Constructors = {}, Element.Constructors = new Hash; var IFrame = new Type("IFrame", function () { var t, e = Array.link(arguments, { properties: Type.isObject, iframe: function (t) { return null != t } }), i = e.properties || {}; e.iframe && (t = document.id(e.iframe)); var n = i.onload || function () { }; delete i.onload, i.id = i.name = [i.id, i.name, t ? t.id || t.name : "IFrame_" + String.uniqueID()].pick(), t = new Element(t || "iframe", i); e = function () { n.call(t.contentWindow) }; return window.frames[i.id] ? e() : t.addListener("load", e), t }), Elements = this.Elements = function (t) { if (t && t.length) for (var e, i = {}, n = 0; e = t[n++];) { var s = Slick.uidOf(e); i[s] || (i[s] = !0, this.push(e)) } }; Elements.prototype = { length: 0 }, Elements.parent = Array, new Type("Elements", Elements).implement({ filter: function (e, t) { return e ? new Elements(Array.filter(this, "string" == typeOf(e) ? function (t) { return t.match(e) } : e, t)) : this }.protect(), push: function () { for (var t = this.length, e = 0, i = arguments.length; e < i; e++) { var n = document.id(arguments[e]); n && (this[t++] = n) } return this.length = t }.protect(), unshift: function () { for (var t = [], e = 0, i = arguments.length; e < i; e++) { var n = document.id(arguments[e]); n && t.push(n) } return Array.prototype.unshift.apply(this, t) }.protect(), concat: function () { for (var t = new Elements(this), e = 0, i = arguments.length; e < i; e++) { var n = arguments[e]; Type.isEnumerable(n) ? t.append(n) : t.push(n) } return t }.protect(), append: function (t) { for (var e = 0, i = t.length; e < i; e++)this.push(t[e]); return this }.protect(), empty: function () { for (; this.length;)delete this[--this.length]; return this }.protect() }), Elements.alias("extend", "append"), function () { var i, n = Array.prototype.splice, t = { 0: 0, 1: 1, length: 2 }; n.call(t, 1, 1), 1 == t[1] && Elements.implement("splice", function () { for (var t = this.length, e = n.apply(this, arguments); t >= this.length;)delete this[t--]; return e }.protect()), Array.forEachMethod(function (t, e) { Elements.implement(e, t) }), Array.mirror(Elements); try { i = "x" == document.createElement("<input name=x>").name } catch (t) { } function s(t) { return ("" + t).replace(/&/g, "&amp;").replace(/"/g, "&quot;") } Document.implement({ newElement: function (t, e) { return e && null != e.checked && (e.defaultChecked = e.checked), i && e && (t = "<" + t, e.name && (t += ' name="' + s(e.name) + '"'), e.type && (t += ' type="' + s(e.type) + '"'), t += ">", delete e.name, delete e.type), this.id(this.createElement(t)).set(e) } }) }(), function () { var s; Slick.uidOf(window), Slick.uidOf(document), Document.implement({ newTextNode: function (t) { return this.createTextNode(t) }, getDocument: function () { return this }, getWindow: function () { return this.window }, id: ((s = { string: function (t, e, i) { return (t = Slick.find(i, "#" + t.replace(/(\W)/g, "\\$1"))) ? s.element(t, e) : null }, element: function (t, e) { var i; return Slick.uidOf(t), e || t.$family || /^(?:object|embed)$/i.test(t.tagName) || (i = t.fireEvent, t._fireEvent = function (t, e) { return i(t, e) }, Object.append(t, Element.Prototype)), t }, object: function (t, e, i) { return t.toElement ? s.element(t.toElement(i), e) : null } }).textnode = s.whitespace = s.window = s.document = function (t) { return t }, function (t, e, i) { if (t && t.$family && t.uniqueNumber) return t; var n = typeOf(t); return s[n] ? s[n](t, e, i || document) : null }) }), null == window.$ && Window.implement("$", function (t, e) { return document.id(t, e, this.document) }), Window.implement({ getDocument: function () { return this.document }, getWindow: function () { return this } }), [Document, Element].invoke("implement", { getElements: function (t) { return Slick.search(this, t, new Elements) }, getElement: function (t) { return document.id(Slick.find(this, t)) } }); var t = { contains: function (t) { return Slick.contains(this, t) } }; document.contains || Document.implement(t), document.createElement("div").contains || Element.implement(t), Element.implement("hasChild", function (t) { return this !== t && this.contains(t) }), function (n, i, s) { this.Selectors = {}; function r() { for (var t in e) e.hasOwnProperty(t) && (Slick.definePseudo(t, e[t]), delete e[t]) } var e = this.Selectors.Pseudo = new Hash; Slick.search = function (t, e, i) { return r(), n.call(this, t, e, i) }, Slick.find = function (t, e) { return r(), i.call(this, t, e) }, Slick.match = function (t, e) { return r(), s.call(this, t, e) } }(Slick.search, Slick.find, Slick.match); function i(t, e) { if (!t) return e; for (var i = (t = Object.clone(Slick.parse(t))).expressions, n = i.length; n--;)i[n][0].combinator = e; return t } Object.forEach({ getNext: "~", getPrevious: "!~", getParent: "!" }, function (e, t) { Element.implement(t, function (t) { return this.getElement(i(t, e)) }) }), Object.forEach({ getAllNext: "~", getAllPrevious: "!~", getSiblings: "~~", getChildren: ">", getParents: "!" }, function (e, t) { Element.implement(t, function (t) { return this.getElements(i(t, e)) }) }), Element.implement({ getFirst: function (t) { return document.id(Slick.search(this, i(t, ">"))[0]) }, getLast: function (t) { return document.id(Slick.search(this, i(t, ">")).getLast()) }, getWindow: function () { return this.ownerDocument.window }, getDocument: function () { return this.ownerDocument }, getElementById: function (t) { return document.id(Slick.find(this, "#" + ("" + t).replace(/(\W)/g, "\\$1"))) }, match: function (t) { return !t || Slick.match(this, t) } }), null == window.$$ && Window.implement("$$", function (t) { var e = new Elements; if (1 == arguments.length && "string" == typeof t) return Slick.search(this.document, t, e); for (var i = Array.flatten(arguments), n = 0, s = i.length; n < s; n++) { var r = i[n]; switch (typeOf(r)) { case "element": e.push(r); break; case "string": Slick.search(this.document, r, e) } } return e }), null == window.$$ && Window.implement("$$", function (t) { if (1 == arguments.length) { if ("string" == typeof t) return Slick.search(this.document, t, new Elements); if (Type.isEnumerable(t)) return new Elements(t) } return new Elements(arguments) }); var n = { before: function (t, e) { var i = e.parentNode; i && i.insertBefore(t, e) }, after: function (t, e) { var i = e.parentNode; i && i.insertBefore(t, e.nextSibling) }, bottom: function (t, e) { e.appendChild(t) }, top: function (t, e) { e.insertBefore(t, e.firstChild) } }; n.inside = n.bottom, Object.each(n, function (e, t) { var i = {}; i["inject" + (t = t.capitalize())] = function (t) { return e(this, document.id(t, !0)), this }, i["grab" + t] = function (t) { return e(document.id(t, !0), this), this }, Element.implement(i) }); var r = {}, o = {}, e = {}; Array.forEach(["type", "value", "defaultValue", "accessKey", "cellPadding", "cellSpacing", "colSpan", "frameBorder", "rowSpan", "tabIndex", "useMap"], function (t) { e[t.toLowerCase()] = t }), e.html = "innerHTML", e.text = null == document.createElement("div").textContent ? "innerText" : "textContent", Object.forEach(e, function (i, t) { o[t] = function (t, e) { t[i] = e }, r[t] = function (t) { return t[i] } }); var a = {}; Array.forEach(["compact", "nowrap", "ismap", "declare", "noshade", "checked", "disabled", "readOnly", "multiple", "selected", "noresize", "defer", "defaultChecked", "autofocus", "controls", "autoplay", "loop"], function (i) { var t = i.toLowerCase(); a[t] = i, o[t] = function (t, e) { t[i] = !!e }, r[t] = function (t) { return !!t[i] } }), Object.append(o, { class: function (t, e) { "className" in t ? t.className = e || "" : t.setAttribute("class", e) }, for: function (t, e) { "htmlFor" in t ? t.htmlFor = e : t.setAttribute("for", e) }, style: function (t, e) { t.style ? t.style.cssText = e : t.setAttribute("style", e) }, value: function (t, e) { t.value = null != e ? e : "" } }), r.class = function (t) { return "className" in t ? t.className || null : t.getAttribute("class") }; var h = document.createElement("button"); try { h.type = "button" } catch (t) { } "button" != h.type && (o.type = function (t, e) { t.setAttribute("type", e) }), h = null; var l = document.createElement("input"); l.value = "t", l.type = "submit", "t" != l.value && (o.type = function (t, e) { var i = t.value; t.type = e, t.value = i }), l = null; var u = ((w = document.createElement("div")).random = "attribute") == w.getAttribute("random"); Element.implement({ setProperty: function (t, e) { var i, n = o[t.toLowerCase()]; return n ? n(this, e) : (u && (i = this.retrieve("$attributeWhiteList", {})), null == e ? (this.removeAttribute(t), u && delete i[t]) : (this.setAttribute(t, "" + e), u && (i[t] = !0))), this }, setProperties: function (t) { for (var e in t) this.setProperty(e, t[e]); return this }, getProperty: function (t) { var e = r[t.toLowerCase()]; if (e) return e(this); if (u) { var e = this.getAttributeNode(t), i = this.retrieve("$attributeWhiteList", {}); if (!e) return null; if (e.expando && !i[t]) { e = this.outerHTML; if (e.substr(0, e.search(/\/?['"]?>(?![^<]*<['"])/)).indexOf(t) < 0) return null; i[t] = !0 } } i = Slick.getAttribute(this, t); return i || Slick.hasAttribute(this, t) ? i : null }, getProperties: function () { var t = Array.from(arguments); return t.map(this.getProperty, this).associate(t) }, removeProperty: function (t) { return this.setProperty(t, null) }, removeProperties: function () { return Array.each(arguments, this.removeProperty, this), this }, set: function (t, e) { var i = Element.Properties[t]; i && i.set ? i.set.call(this, e) : this.setProperty(t, e) }.overloadSetter(), get: function (t) { var e = Element.Properties[t]; return e && e.get ? e.get.apply(this) : this.getProperty(t) }.overloadGetter(), erase: function (t) { var e = Element.Properties[t]; return e && e.erase ? e.erase.apply(this) : this.removeProperty(t), this }, hasClass: function (t) { return this.className.clean().contains(t, " ") }, addClass: function (t) { return this.hasClass(t) || (this.className = (this.className + " " + t).clean()), this }, removeClass: function (t) { return this.className = this.className.replace(new RegExp("(^|\\s)" + t + "(?:\\s|$)"), "$1"), this }, toggleClass: function (t, e) { return null == e && (e = !this.hasClass(t)), e ? this.addClass(t) : this.removeClass(t) }, adopt: function () { var t, e = this, i = Array.flatten(arguments), n = i.length; 1 < n && (e = t = document.createDocumentFragment()); for (var s = 0; s < n; s++) { var r = document.id(i[s], !0); r && e.appendChild(r) } return t && this.appendChild(t), this }, appendText: function (t, e) { return this.grab(this.getDocument().newTextNode(t), e) }, grab: function (t, e) { return n[e || "bottom"](document.id(t, !0), this), this }, inject: function (t, e) { return n[e || "bottom"](this, document.id(t, !0)), this }, replaces: function (t) { return (t = document.id(t, !0)).parentNode.replaceChild(this, t), this }, wraps: function (t, e) { return t = document.id(t, !0), this.replaces(t).grab(t, e) }, getSelected: function () { return this.selectedIndex, new Elements(Array.from(this.options).filter(function (t) { return t.selected })) }, toQueryString: function () { var i = []; return this.getElements("input, select, textarea").each(function (e) { var t = e.type; e.name && !e.disabled && "submit" != t && "reset" != t && "file" != t && "image" != t && (t = "select" == e.get("tag") ? e.getSelected().map(function (t) { return document.id(t).get("value") }) : "radio" != t && "checkbox" != t || e.checked ? e.get("value") : null, Array.from(t).each(function (t) { void 0 !== t && i.push(encodeURIComponent(e.name) + "=" + encodeURIComponent(t)) })) }), i.join("&") } }); function c(t) { return m[t] || (m[t] = {}) } function d(t) { var e = t.uniqueNumber; return t.removeEvents && t.removeEvents(), t.clearAttributes && t.clearAttributes(), null != e && (delete f[e], delete m[e]), t } var f = {}, m = {}, p = { input: "checked", option: "selected", textarea: "value" }; Element.implement({ destroy: function () { var t = d(this).getElementsByTagName("*"); return Array.each(t, d), Element.dispose(this), null }, empty: function () { return Array.from(this.childNodes).each(Element.dispose), this }, dispose: function () { return this.parentNode ? this.parentNode.removeChild(this) : this }, clone: function (t, e) { t = !1 !== t; var i = this.cloneNode(t), n = [i], s = [this]; for (t && (n.append(Array.from(i.getElementsByTagName("*"))), s.append(Array.from(this.getElementsByTagName("*")))), f = n.length; f--;) { var r = n[f], o = s[f]; if (e || r.removeAttribute("id"), r.clearAttributes && (r.clearAttributes(), r.mergeAttributes(o), r.removeAttribute("uniqueNumber"), r.options)) for (var a = r.options, h = o.options, l = a.length; l--;)a[l].selected = h[l].selected; var u = p[o.tagName.toLowerCase()]; u && o[u] && (r[u] = o[u]) } if (Browser.ie) for (var c = i.getElementsByTagName("object"), d = this.getElementsByTagName("object"), f = c.length; f--;)c[f].outerHTML = d[f].outerHTML; return document.id(i) } }), [Element, Window, Document].invoke("implement", { addListener: function (t, e) { var i, n; return "unload" == t ? (i = e, n = this, e = function () { n.removeListener("unload", e), i() }) : f[Slick.uidOf(this)] = this, this.addEventListener ? this.addEventListener(t, e, !!arguments[2]) : this.attachEvent("on" + t, e), this }, removeListener: function (t, e) { return this.removeEventListener ? this.removeEventListener(t, e, !!arguments[2]) : this.detachEvent("on" + t, e), this }, retrieve: function (t, e) { var i = c(Slick.uidOf(this)), n = i[t]; return null != e && null == n && (n = i[t] = e), null != n ? n : null }, store: function (t, e) { return c(Slick.uidOf(this))[t] = e, this }, eliminate: function (t) { return delete c(Slick.uidOf(this))[t], this } }), window.attachEvent && !window.addEventListener && window.addListener("unload", function () { Object.each(f, d), window.CollectGarbage && CollectGarbage() }), Element.Properties = {}, Element.Properties = new Hash, Element.Properties.style = { set: function (t) { this.style.cssText = t }, get: function () { return this.style.cssText }, erase: function () { this.style.cssText = "" } }, Element.Properties.tag = { get: function () { return this.tagName.toLowerCase() } }, Element.Properties.html = { set: function (t) { null == t ? t = "" : "array" == typeOf(t) && (t = t.join("")), this.innerHTML = t }, erase: function () { this.innerHTML = "" } }; t = document.createElement("div"); t.innerHTML = "<nav></nav>"; var g = 1 == t.childNodes.length; if (!g) for (var v = "abbr article aside audio canvas datalist details figcaption figure footer header hgroup mark meter nav output progress section summary time video".split(" "), y = document.createDocumentFragment(), b = v.length; b--;)y.createElement(v[b]); t = null; var l = Function.attempt(function () { return document.createElement("table").innerHTML = "<tr><td></td></tr>", !0 }), w = "<td></td>"; (t = document.createElement("tr")).innerHTML = w; var S, x, w = t.innerHTML == w, t = null; l && w && g || (Element.Properties.html.set = (S = Element.Properties.html.set, (x = { table: [1, "<table>", "</table>"], select: [1, "<select>", "</select>"], tbody: [2, "<table><tbody>", "</tbody></table>"], tr: [3, "<table><tbody><tr>", "</tr></tbody></table>"] }).thead = x.tfoot = x.tbody, function (t) { var e = x[this.get("tag")]; if (e || g || (e = [0, "", ""]), !e) return S.call(this, t); var i = e[0], n = document.createElement("div"), s = n; for (g || y.appendChild(n), n.innerHTML = [e[1], t, e[2]].flatten().join(""); i--;)s = s.firstChild; this.empty().adopt(s.childNodes), g || y.removeChild(n), n = null })); w = document.createElement("form"); w.innerHTML = "<select><option>s</option></select>", "s" != w.firstChild.value && (Element.Properties.value = { set: function (t) { if ("select" != this.get("tag")) return this.setProperty("value", t); for (var e = this.getElements("option"), i = 0; i < e.length; i++) { var n = e[i], s = n.getAttributeNode("value"); if ((s && s.specified ? n.value : n.get("text")) == t) return n.selected = !0 } }, get: function () { var t = this, e = t.get("tag"); if ("select" != e && "option" != e) return this.getProperty("value"); if ("select" == e && !(t = t.getSelected()[0])) return ""; e = t.getAttributeNode("value"); return e && e.specified ? t.value : t.get("text") } }), w = null, document.createElement("div").getAttributeNode("id") && (Element.Properties.id = { set: function (t) { this.id = this.getAttributeNode("id").value = t }, get: function () { return this.id || null }, erase: function () { this.id = this.getAttributeNode("id").value = "" } }) }(), function () { var t = document.html; (e = document.createElement("div")).style.color = "red", e.style.color = null; var n = "red" == e.style.color, e = null; Element.Properties.styles = { set: function (t) { this.setStyles(t) } }; function i(t, e) { t.store("$opacity", e), t.style.visibility = 0 < e || null == e ? "visible" : "hidden" } var s = null != t.style.opacity, e = null != t.style.filter, r = /alpha\(opacity=([\d.]+)\)/i, o = s ? function (t, e) { t.style.opacity = e } : e ? function (t, e) { var i = t.style; t.currentStyle && t.currentStyle.hasLayout || (i.zoom = 1), e = null == e || 1 == e ? "" : "alpha(opacity=" + (100 * e).limit(0, 100).round() + ")"; t = i.filter || t.getComputedStyle("filter") || ""; i.filter = r.test(t) ? t.replace(r, e) : t + e, i.filter || i.removeAttribute("filter") } : i, a = s ? function (t) { t = t.style.opacity || t.getComputedStyle("opacity"); return "" == t ? 1 : t.toFloat() } : e ? function (t) { var e, t = t.style.filter || t.getComputedStyle("filter"); return t && (e = t.match(r)), null == e || null == t ? 1 : e[1] / 100 } : function (t) { var e = t.retrieve("$opacity"); return null == e && (e = "hidden" == t.style.visibility ? 0 : 1), e }, h = null == t.style.cssFloat ? "styleFloat" : "cssFloat"; Element.implement({ getComputedStyle: function (t) { if (this.currentStyle) return this.currentStyle[t.camelCase()]; var e = Element.getDocument(this).defaultView, e = e ? e.getComputedStyle(this, null) : null; return e ? e.getPropertyValue(t == h ? "float" : t.hyphenate()) : null }, setStyle: function (t, e) { return "opacity" == t ? (null != e && (e = parseFloat(e)), o(this, e)) : (t = ("float" == t ? h : t).camelCase(), "string" != typeOf(e) ? (i = (Element.Styles[t] || "@").split(" "), e = Array.from(e).map(function (t, e) { return i[e] ? "number" == typeOf(t) ? i[e].replace("@", Math.round(t)) : t : "" }).join(" ")) : e == String(Number(e)) && (e = Math.round(e)), ("" == (this.style[t] = e) || null == e) && n && this.style.removeAttribute && this.style.removeAttribute(t)), this; var i }, getStyle: function (t) { if ("opacity" == t) return a(this); t = ("float" == t ? h : t).camelCase(); var e, i = this.style[t]; if (!i || "zIndex" == t) { for (var n in i = [], Element.ShortStyles) if (t == n) { for (var s in Element.ShortStyles[n]) i.push(this.getStyle(s)); return i.join(" ") } i = this.getComputedStyle(t) } if (!i || (e = (i = String(i)).match(/rgba?\([\d\s,]+\)/)) && (i = i.replace(e[0], e[0].rgbToHex())), Browser.opera || Browser.ie) { if (/^(height|width)$/.test(t) && !/px$/.test(i)) { var r = 0; return ("width" == t ? ["left", "right"] : ["top", "bottom"]).each(function (t) { r += this.getStyle("border-" + t + "-width").toInt() + this.getStyle("padding-" + t).toInt() }, this), this["offset" + t.capitalize()] - r + "px" } if (Browser.ie && /^border(.+)Width|margin|padding/.test(t) && isNaN(parseFloat(i))) return "0px" } return i }, setStyles: function (t) { for (var e in t) this.setStyle(e, t[e]); return this }, getStyles: function () { var e = {}; return Array.flatten(arguments).each(function (t) { e[t] = this.getStyle(t) }, this), e } }), Element.Styles = { left: "@px", top: "@px", bottom: "@px", right: "@px", width: "@px", height: "@px", maxWidth: "@px", maxHeight: "@px", minWidth: "@px", minHeight: "@px", backgroundColor: "rgb(@, @, @)", backgroundPosition: "@px @px", color: "rgb(@, @, @)", fontSize: "@px", letterSpacing: "@px", lineHeight: "@px", clip: "rect(@px @px @px @px)", margin: "@px @px @px @px", padding: "@px @px @px @px", border: "@px @ rgb(@, @, @) @px @ rgb(@, @, @) @px @ rgb(@, @, @)", borderWidth: "@px @px @px @px", borderStyle: "@ @ @ @", borderColor: "rgb(@, @, @) rgb(@, @, @) rgb(@, @, @) rgb(@, @, @)", zIndex: "@", zoom: "@", fontWeight: "@", textIndent: "@px", opacity: "@" }, Element.implement({ setOpacity: function (t) { return o(this, t), this }, getOpacity: function () { return a(this) } }), Element.Properties.opacity = { set: function (t) { o(this, t), i(this, t) }, get: function () { return a(this) } }, Element.Styles = new Hash(Element.Styles), Element.ShortStyles = { margin: {}, padding: {}, border: {}, borderWidth: {}, borderStyle: {}, borderColor: {} }, ["Top", "Right", "Bottom", "Left"].each(function (i) { var n = Element.ShortStyles, s = Element.Styles;["margin", "padding"].each(function (t) { var e = t + i; n[t][e] = s[e] = "@px" }); var t = "border" + i; n.border[t] = s[t] = "@px @ rgb(@, @, @)"; var e = t + "Width", r = t + "Style", o = t + "Color"; n[t] = {}, n.borderWidth[e] = n[t][e] = s[e] = "@px", n.borderStyle[r] = n[t][r] = s[r] = "@", n.borderColor[o] = n[t][o] = s[o] = "rgb(@, @, @)" }) }(), function () { var t; Element.Properties.events = { set: function (t) { this.addEvents(t) } }, [Element, Window, Document].invoke("implement", { addEvent: function (e, i) { var t = this.retrieve("events", {}); if (t[e] || (t[e] = { keys: [], values: [] }), t[e].keys.contains(i)) return this; t[e].keys.push(i); var n = e, s = Element.Events[e], r = i, o = this; s && (s.onAdd && s.onAdd.call(this, i, e), s.condition && (r = function (t) { return !s.condition.call(this, t, e) || i.call(this, t) }), s.base && (n = Function.from(s.base).call(this, e))); var a = function () { return i.call(o) }, h = Element.NativeEvents[n]; return h && (2 == h && (a = function (t) { t = new DOMEvent(t, o.getWindow()), !1 === r.call(o, t) && t.stop() }), this.addListener(n, a, arguments[2])), t[e].values.push(a), this }, removeEvent: function (t, e) { var i = this.retrieve("events"); if (!i || !i[t]) return this; var n = i[t], s = n.keys.indexOf(e); if (-1 == s) return this; i = n.values[s]; delete n.keys[s], delete n.values[s]; s = Element.Events[t]; return s && (s.onRemove && s.onRemove.call(this, e, t), s.base && (t = Function.from(s.base).call(this, t))), Element.NativeEvents[t] ? this.removeListener(t, i, arguments[2]) : this }, addEvents: function (t) { for (var e in t) this.addEvent(e, t[e]); return this }, removeEvents: function (e) { if ("object" == typeOf(e)) { for (var t in e) this.removeEvent(t, e[t]); return this } var i = this.retrieve("events"); if (!i) return this; if (e) i[e] && (i[e].keys.each(function (t) { this.removeEvent(e, t) }, this), delete i[e]); else { for (t in i) this.removeEvents(t); this.eliminate("events") } return this }, fireEvent: function (t, e, i) { var n = this.retrieve("events"); return n && n[t] && (e = Array.from(e), n[t].keys.each(function (t) { i ? t.delay(i, this, e) : t.apply(this, e) }, this)), this }, cloneEvents: function (t, e) { var i = (t = document.id(t)).retrieve("events"); if (!i) return this; if (e) i[e] && i[e].keys.each(function (t) { this.addEvent(e, t) }, this); else for (var n in i) this.cloneEvents(t, n); return this } }), Element.NativeEvents = { click: 2, dblclick: 2, mouseup: 2, mousedown: 2, contextmenu: 2, mousewheel: 2, DOMMouseScroll: 2, mouseover: 2, mouseout: 2, mousemove: 2, selectstart: 2, selectend: 2, keydown: 2, keypress: 2, keyup: 2, orientationchange: 2, touchstart: 2, touchmove: 2, touchend: 2, touchcancel: 2, gesturestart: 2, gesturechange: 2, gestureend: 2, focus: 2, blur: 2, change: 2, reset: 2, select: 2, submit: 2, paste: 2, input: 2, load: 2, unload: 1, beforeunload: 2, resize: 1, move: 1, DOMContentLoaded: 1, readystatechange: 1, error: 1, abort: 1, scroll: 1 }, Element.Events = { mousewheel: { base: Browser.firefox ? "DOMMouseScroll" : "mousewheel" } }, "onmouseenter" in document.documentElement ? Element.NativeEvents.mouseenter = Element.NativeEvents.mouseleave = 2 : (t = function (t) { t = t.relatedTarget; return null == t || !!t && (t != this && "xul" != t.prefix && "document" != typeOf(this) && !this.contains(t)) }, Element.Events.mouseenter = { base: "mouseover", condition: t }, Element.Events.mouseleave = { base: "mouseout", condition: t }), window.addEventListener || (Element.NativeEvents.propertychange = 2, Element.Events.change = { base: function () { var t = this.type; return "input" != this.get("tag") || "radio" != t && "checkbox" != t ? "change" : "propertychange" }, condition: function (t) { return "radio" != this.type || "checked" == t.event.propertyName && this.checked } }), Element.Events = new Hash(Element.Events) }(), function () { var t = !!window.addEventListener; Element.NativeEvents.focusin = Element.NativeEvents.focusout = 2; function p(t, e, i, n, s) { for (; s && s != t;) { if (e(s, n)) return i.call(s, n, s); s = document.id(s.parentNode) } } function e(u) { return { base: "focusin", remove: function (t, e) { var i = t.retrieve(c + u + "listeners", {})[e]; if (i && i.forms) for (var n = i.forms.length; n--;)i.forms[n].removeEvent(u, i.fns[n]) }, listen: function (e, i, n, t, s, r) { var o, a, h, l = "form" == s.get("tag") ? s : t.target.getParent("form"); l && (h = (a = (o = e.retrieve(c + u + "listeners", {}))[r] || { forms: [], fns: [] }).fns, -1 == (t = a.forms).indexOf(l) && (t.push(l), t = function (t) { p(e, i, n, t, s) }, l.addEvent(u, t), h.push(t), o[r] = a, e.store(c + u + "listeners", o))) } } } var g = { mouseenter: { base: "mouseover" }, mouseleave: { base: "mouseout" }, focus: { base: "focus" + (t ? "" : "in"), capture: !0 }, blur: { base: t ? "blur" : "focusout", capture: !0 } }, c = "$delegation:", i = function (o) { return { base: "focusin", listen: function (e, i, n, t, s) { var r = { blur: function () { this.removeEvents(r) } }; r[o] = function (t) { p(e, i, n, t, s) }, t.target.addEvents(r) } } }; t || Object.append(g, { submit: e("submit"), reset: e("reset"), change: i("change"), select: i("select") }); var i = Element.prototype, v = i.addEvent, d = i.removeEvent, i = function (r, o) { return function (t, e, i) { if (-1 == t.indexOf(":relay")) return r.call(this, t, e, i); var n = Slick.parse(t).expressions[0][0]; if ("relay" != n.pseudos[0].key) return r.call(this, t, e, i); var s = n.tag; return n.pseudos.slice(1).each(function (t) { s += ":" + t.key + (t.value ? "(" + t.value + ")" : "") }), r.call(this, t, e), o.call(this, s, n.pseudos[0].value, e) } }, f = { addEvent: function (i, n, s) { var t = this.retrieve("$delegates", {}), e = t[i]; if (e) for (var r in e) if (e[r].fn == s && e[r].match == n) return this; var o = i, a = n, h = s, l = g[i] || {}; i = l.base || o, n = function (t) { return Slick.match(t, a) }; var u, c, d = Element.Events[o]; d && d.condition && (u = n, c = d.condition, n = function (t, e) { return u(t, e) && c.call(t, e, i) }); var f = this, m = String.uniqueID(), d = l.listen ? function (t, e) { !e && t && t.target && (e = t.target), e && l.listen(f, n, s, t, e, m) } : function (t, e) { !e && t && t.target && (e = t.target), e && p(f, n, s, t, e) }; return (e = e || {})[m] = { match: a, fn: h, delegator: d }, t[o] = e, v.call(this, i, d, l.capture) }, removeEvent: function (t, e, i, n) { var s, r, o = this.retrieve("$delegates", {}), a = o[t]; if (!a) return this; if (n) { var h = t, l = a[n].delegator, u = g[t] || {}; return t = u.base || h, u.remove && u.remove(this, n), delete a[n], o[h] = a, d.call(this, t, l) } if (i) { for (s in a) if ((r = a[s]).match == e && r.fn == i) return f.removeEvent.call(this, t, e, i, s) } else for (s in a) (r = a[s]).match == e && f.removeEvent.call(this, t, e, r.fn, s); return this } };[Element, Window, Document].invoke("implement", { addEvent: i(v, f.addEvent), removeEvent: i(d, f.removeEvent) }) }(), function () { var t = document.createElement("div"), e = document.createElement("div"); t.style.height = "0", t.appendChild(e); function i(t) { return "static" != h(t, "position") || d(t) } function n(t) { return i(t) || /^(?:table|td|th)$/i.test(t.tagName) } var s = e.offsetParent === t, t = null; Element.implement({ scrollTo: function (t, e) { return d(this) ? this.getWindow().scrollTo(t, e) : (this.scrollLeft = t, this.scrollTop = e), this }, getSize: function () { return d(this) ? this.getWindow().getSize() : { x: this.offsetWidth, y: this.offsetHeight } }, getScrollSize: function () { return d(this) ? this.getWindow().getScrollSize() : { x: this.scrollWidth, y: this.scrollHeight } }, getScroll: function () { return d(this) ? this.getWindow().getScroll() : { x: this.scrollLeft, y: this.scrollTop } }, getScrolls: function () { for (var t = this.parentNode, e = { x: 0, y: 0 }; t && !d(t);)e.x += t.scrollLeft, e.y += t.scrollTop, t = t.parentNode; return e }, getOffsetParent: s ? function () { var t = this; if (d(t) || "fixed" == h(t, "position")) return null; for (var e = "static" == h(t, "position") ? n : i; t = t.parentNode;)if (e(t)) return t; return null } : function () { if (d(this) || "fixed" == h(this, "position")) return null; try { return this.offsetParent } catch (t) { } return null }, getOffsets: function () { if (this.getBoundingClientRect && !Browser.Platform.ios) { var t = this.getBoundingClientRect(), e = document.id(this.getDocument().documentElement), i = e.getScroll(), n = this.getScrolls(), s = "fixed" == h(this, "position"); return { x: t.left.toInt() + n.x + (s ? 0 : i.x) - e.clientLeft, y: t.top.toInt() + n.y + (s ? 0 : i.y) - e.clientTop } } var r, o = this, a = { x: 0, y: 0 }; if (d(this)) return a; for (; o && !d(o);) { a.x += o.offsetLeft, a.y += o.offsetTop, Browser.firefox ? (l(o) || (a.x += c(o), a.y += u(o)), (r = o.parentNode) && "visible" != h(r, "overflow") && (a.x += c(r), a.y += u(r))) : o != this && Browser.safari && (a.x += c(o), a.y += u(o)), o = o.offsetParent } return Browser.firefox && !l(this) && (a.x -= c(this), a.y -= u(this)), a }, getPosition: function (t) { var e = this.getOffsets(), i = this.getScrolls(), e = { x: e.x - i.x, y: e.y - i.y }; if (t = t && document.id(t)) { i = t.getPosition(); return { x: e.x - i.x - c(t), y: e.y - i.y - u(t) } } return e }, getCoordinates: function (t) { if (d(this)) return this.getWindow().getCoordinates(); var e = this.getPosition(t), t = this.getSize(), t = { left: e.x, top: e.y, width: t.x, height: t.y }; return t.right = t.left + t.width, t.bottom = t.top + t.height, t }, computePosition: function (t) { return { left: t.x - r(this, "margin-left"), top: t.y - r(this, "margin-top") } }, setPosition: function (t) { return this.setStyles(this.computePosition(t)) } }), [Document, Window].invoke("implement", { getSize: function () { var t = o(this); return { x: t.clientWidth, y: t.clientHeight } }, getScroll: function () { var t = this.getWindow(), e = o(this); return { x: t.pageXOffset || e.scrollLeft, y: t.pageYOffset || e.scrollTop } }, getScrollSize: function () { var t = o(this), e = this.getSize(), i = this.getDocument().body; return { x: Math.max(t.scrollWidth, i.scrollWidth, e.x), y: Math.max(t.scrollHeight, i.scrollHeight, e.y) } }, getPosition: function () { return { x: 0, y: 0 } }, getCoordinates: function () { var t = this.getSize(); return { top: 0, left: 0, bottom: t.y, right: t.x, height: t.y, width: t.x } } }); var h = Element.getComputedStyle; function r(t, e) { return h(t, e).toInt() || 0 } function l(t) { return "border-box" == h(t, "-moz-box-sizing") } function u(t) { return r(t, "border-top-width") } function c(t) { return r(t, "border-left-width") } function d(t) { return /^(?:body|html)$/i.test(t.tagName) } function o(t) { t = t.getDocument(); return t.compatMode && "CSS1Compat" != t.compatMode ? t.body : t.html } }(), Element.alias({ position: "setPosition" }), [Window, Document, Element].invoke("implement", { getHeight: function () { return this.getSize().y }, getWidth: function () { return this.getSize().x }, getScrollTop: function () { return this.getScroll().y }, getScrollLeft: function () { return this.getScroll().x }, getScrollHeight: function () { return this.getScrollSize().y }, getScrollWidth: function () { return this.getScrollSize().x }, getTop: function () { return this.getPosition().y }, getLeft: function () { return this.getPosition().x } }), function () { var n = this.Fx = new Class({ Implements: [Chain, Events, Options], options: { fps: 60, unit: !1, duration: 500, frames: null, frameSkip: !0, link: "ignore" }, initialize: function (t) { this.subject = this.subject || this, this.setOptions(t) }, getTransition: function () { return function (t) { return -(Math.cos(Math.PI * t) - 1) / 2 } }, step: function (t) { var e; this.options.frameSkip ? (e = (null != this.time ? t - this.time : 0) / this.frameInterval, this.time = t, this.frame += e) : this.frame++, this.frame < this.frames ? (e = this.transition(this.frame / this.frames), this.set(this.compute(this.from, this.to, e))) : (this.frame = this.frames, this.set(this.compute(this.from, this.to, 1)), this.stop()) }, set: function (t) { return t }, compute: function (t, e, i) { return n.compute(t, e, i) }, check: function () { if (!this.isRunning()) return !0; switch (this.options.link) { case "cancel": return this.cancel(), !0; case "chain": return this.chain(this.caller.pass(arguments, this)), !1 }return !1 }, start: function (t, e) { if (!this.check(t, e)) return this; this.from = t, this.to = e, this.frame = this.options.frameSkip ? 0 : -1, this.time = null, this.transition = this.getTransition(); var i = this.options.frames, t = this.options.fps, e = this.options.duration; return this.duration = n.Durations[e] || e.toInt(), this.frameInterval = 1e3 / t, this.frames = i || Math.round(this.duration / this.frameInterval), this.fireEvent("start", this.subject), r.call(this, t), this }, stop: function () { return this.isRunning() && (this.time = null, t.call(this, this.options.fps), this.frames == this.frame ? (this.fireEvent("complete", this.subject), this.callChain() || this.fireEvent("chainComplete", this.subject)) : this.fireEvent("stop", this.subject)), this }, cancel: function () { return this.isRunning() && (this.time = null, t.call(this, this.options.fps), this.frame = this.frames, this.fireEvent("cancel", this.subject).clearChain()), this }, pause: function () { return this.isRunning() && (this.time = null, t.call(this, this.options.fps)), this }, resume: function () { return this.frame < this.frames && !this.isRunning() && r.call(this, this.options.fps), this }, isRunning: function () { var t = i[this.options.fps]; return t && t.contains(this) } }); n.compute = function (t, e, i) { return (e - t) * i + t }, n.Durations = { short: 250, normal: 500, long: 1e3 }; var i = {}, s = {}, r = function (t) { var e = i[t] || (i[t] = []); e.push(this), s[t] || (s[t] = function () { for (var t = Date.now(), e = this.length; e--;) { var i = this[e]; i && i.step(t) } }.periodical(Math.round(1e3 / t), e)) }, t = function (t) { var e = i[t]; e && (e.erase(this), !e.length && s[t] && (delete i[t], s[t] = clearInterval(s[t]))) } }(), Fx.CSS = new Class({ Extends: Fx, prepare: function (t, e, i) { var n, s, r = (i = Array.from(i))[0], o = i[1]; return null == o && (o = r, r = t.getStyle(e), (n = this.options.unit) && r.slice(-n.length) != n && 0 != parseFloat(r) && (t.setStyle(e, o + n), s = t.getComputedStyle(e), /px$/.test(s) || null == (s = t.style[("pixel-" + e).camelCase()]) && (i = t.style.left, t.style.left = o + n, s = t.style.pixelLeft, t.style.left = i), r = (o || 1) / (parseFloat(s) || 1) * (parseFloat(r) || 0), t.setStyle(e, r + n))), { from: this.parse(r), to: this.parse(o) } }, parse: function (t) { return (t = "string" == typeof (t = Function.from(t)()) ? t.split(" ") : Array.from(t)).map(function (n) { n = String(n); var s = !1; return Object.each(Fx.CSS.Parsers, function (t, e) { var i; s || (!(i = t.parse(n)) && 0 !== i || (s = { value: i, parser: t })) }), s = s || { value: n, parser: Fx.CSS.Parsers.String } }) }, compute: function (e, i, n) { var s = []; return Math.min(e.length, i.length).times(function (t) { s.push({ value: e[t].parser.compute(e[t].value, i[t].value, n), parser: e[t].parser }) }), s.$family = Function.from("fx:css:value"), s }, serve: function (t, e) { "fx:css:value" != typeOf(t) && (t = this.parse(t)); var i = []; return t.each(function (t) { i = i.concat(t.parser.serve(t.value, e)) }), i }, render: function (t, e, i, n) { t.setStyle(e, this.serve(i, n)) }, search: function (t) { if (Fx.CSS.Cache[t]) return Fx.CSS.Cache[t]; var n = {}, s = new RegExp("^" + t.escapeRegExp() + "$"); return Array.each(document.styleSheets, function (t, e) { var i = t.href; i && i.contains("://") && !i.contains(document.domain) || (t = t.rules || t.cssRules, Array.each(t, function (i, t) { var e; !i.style || (e = i.selectorText ? i.selectorText.replace(/^\w+/, function (t) { return t.toLowerCase() }) : null) && s.test(e) && Object.each(Element.Styles, function (t, e) { i.style[e] && !Element.ShortStyles[e] && (t = String(i.style[e]), n[e] = /^rgb/.test(t) ? t.rgbToHex() : t) }) })) }), Fx.CSS.Cache[t] = n } }), Fx.CSS.Cache = {}, Fx.CSS.Parsers = { Color: { parse: function (t) { return t.match(/^#[0-9a-f]{3,6}$/i) ? t.hexToRgb(!0) : !!(t = t.match(/(\d+),\s*(\d+),\s*(\d+)/)) && [t[1], t[2], t[3]] }, compute: function (i, n, s) { return i.map(function (t, e) { return Math.round(Fx.compute(i[e], n[e], s)) }) }, serve: function (t) { return t.map(Number) } }, Number: { parse: parseFloat, compute: Fx.compute, serve: function (t, e) { return e ? t + e : t } }, String: { parse: Function.from(!1), compute: function (t, e) { return e }, serve: function (t) { return t } } }, Fx.CSS.Parsers = new Hash(Fx.CSS.Parsers), Fx.Tween = new Class({ Extends: Fx.CSS, initialize: function (t, e) { this.element = this.subject = document.id(t), this.parent(e) }, set: function (t, e) { return 1 == arguments.length && (e = t, t = this.property || this.options.property), this.render(this.element, t, e, this.options.unit), this }, start: function (t, e, i) { if (!this.check(t, e, i)) return this; i = Array.flatten(arguments); this.property = this.options.property || i.shift(); i = this.prepare(this.element, this.property, i); return this.parent(i.from, i.to) } }), Element.Properties.tween = { set: function (t) { return this.get("tween").cancel().setOptions(t), this }, get: function () { var t = this.retrieve("tween"); return t || (t = new Fx.Tween(this, { link: "cancel" }), this.store("tween", t)), t } }, Element.implement({ tween: function (t, e, i) { return this.get("tween").start(t, e, i), this }, fade: function (t) { var e = this.get("tween"), i = ["opacity"].append(arguments); switch (null == i[1] && (i[1] = "toggle"), i[1]) { case "in": s = "start", i[1] = 1; break; case "out": s = "start", i[1] = 0; break; case "show": s = "set", i[1] = 1; break; case "hide": s = "set", i[1] = 0; break; case "toggle": var n = this.retrieve("fade:flag", 1 == this.getStyle("opacity")), s = "start"; i[1] = n ? 0 : 1, this.store("fade:flag", !n), n = !0; break; default: s = "start" }n || this.eliminate("fade:flag"), e[s].apply(e, i); i = i[i.length - 1]; return "set" == s || 0 != i ? this.setStyle("visibility", 0 == i ? "hidden" : "visible") : e.chain(function () { this.element.setStyle("visibility", "hidden"), this.callChain() }), this }, highlight: function (t, e) { e = e || ("transparent" == (e = this.retrieve("highlight:original", this.getStyle("background-color"))) ? "#fff" : e); var i = this.get("tween"); return i.start("background-color", t || "#ffff88", e).chain(function () { this.setStyle("background-color", this.retrieve("highlight:original")), i.callChain() }.bind(this)), this } }), Fx.Morph = new Class({ Extends: Fx.CSS, initialize: function (t, e) { this.element = this.subject = document.id(t), this.parent(e) }, set: function (t) { for (var e in "string" == typeof t && (t = this.search(t)), t) this.render(this.element, e, t[e], this.options.unit); return this }, compute: function (t, e, i) { var n, s = {}; for (n in t) s[n] = this.parent(t[n], e[n], i); return s }, start: function (t) { if (!this.check(t)) return this; "string" == typeof t && (t = this.search(t)); var e, i = {}, n = {}; for (e in t) { var s = this.prepare(this.element, e, t[e]); i[e] = s.from, n[e] = s.to } return this.parent(i, n) } }), Element.Properties.morph = { set: function (t) { return this.get("morph").cancel().setOptions(t), this }, get: function () { var t = this.retrieve("morph"); return t || (t = new Fx.Morph(this, { link: "cancel" }), this.store("morph", t)), t } }, Element.implement({ morph: function (t) { return this.get("morph").start(t), this } }), Fx.implement({ getTransition: function () { var t, e = this.options.transition || Fx.Transitions.Sine.easeInOut; return "string" == typeof e && (t = e.split(":"), e = (e = Fx.Transitions)[t[0]] || e[t[0].capitalize()], t[1] && (e = e["ease" + t[1].capitalize() + (t[2] ? t[2].capitalize() : "")])), e } }), Fx.Transition = function (e, i) { i = Array.from(i); function t(t) { return e(t, i) } return Object.append(t, { easeIn: t, easeOut: function (t) { return 1 - e(1 - t, i) }, easeInOut: function (t) { return (t <= .5 ? e(2 * t, i) : 2 - e(2 * (1 - t), i)) / 2 } }) }, Fx.Transitions = { linear: function (t) { return t } }, Fx.Transitions = new Hash(Fx.Transitions), Fx.Transitions.extend = function (t) { for (var e in t) Fx.Transitions[e] = new Fx.Transition(t[e]) }, Fx.Transitions.extend({ Pow: function (t, e) { return Math.pow(t, e && e[0] || 6) }, Expo: function (t) { return Math.pow(2, 8 * (t - 1)) }, Circ: function (t) { return 1 - Math.sin(Math.acos(t)) }, Sine: function (t) { return 1 - Math.cos(t * Math.PI / 2) }, Back: function (t, e) { return e = e && e[0] || 1.618, Math.pow(t, 2) * ((e + 1) * t - e) }, Bounce: function (t) { for (var e, i = 0, n = 1; ; i += n, n /= 2)if ((7 - 4 * i) / 11 <= t) { e = n * n - Math.pow((11 - 6 * i - 11 * t) / 4, 2); break } return e }, Elastic: function (t, e) { return Math.pow(2, 10 * --t) * Math.cos(20 * t * Math.PI * (e && e[0] || 1) / 3) } }), ["Quad", "Cubic", "Quart", "Quint"].each(function (t, e) { Fx.Transitions[t] = new Fx.Transition(function (t) { return Math.pow(t, e + 2) }) }), function () { function i() { } var o = "onprogress" in new Browser.Request, e = this.Request = new Class({ Implements: [Chain, Events, Options], options: { url: "", data: "", headers: { "X-Requested-With": "XMLHttpRequest", Accept: "text/javascript, text/html, application/xml, text/xml, */*" }, async: !0, format: !1, method: "post", link: "ignore", isSuccess: null, emulation: !0, urlEncoded: !0, encoding: "utf-8", evalScripts: !1, evalResponse: !1, timeout: 0, noCache: !1 }, initialize: function (t) { this.xhr = new Browser.Request, this.setOptions(t), this.headers = this.options.headers }, onStateChange: function () { var e = this.xhr; 4 == e.readyState && this.running && (this.running = !1, this.status = 0, Function.attempt(function () { var t = e.status; this.status = 1223 == t ? 204 : t }.bind(this)), e.onreadystatechange = i, o && (e.onprogress = e.onloadstart = i), clearTimeout(this.timer), this.response = { text: this.xhr.responseText || "", xml: this.xhr.responseXML }, this.options.isSuccess.call(this, this.status) ? this.success(this.response.text, this.response.xml) : this.failure()) }, isSuccess: function () { var t = this.status; return 200 <= t && t < 300 }, isRunning: function () { return !!this.running }, processScripts: function (t) { return this.options.evalResponse || /(ecma|java)script/.test(this.getHeader("Content-type")) ? Browser.exec(t) : t.stripScripts(this.options.evalScripts) }, success: function (t, e) { this.onSuccess(this.processScripts(t), e) }, onSuccess: function () { this.fireEvent("complete", arguments).fireEvent("success", arguments).callChain() }, failure: function () { this.onFailure() }, onFailure: function () { this.fireEvent("complete").fireEvent("failure", this.xhr) }, loadstart: function (t) { this.fireEvent("loadstart", [t, this.xhr]) }, progress: function (t) { this.fireEvent("progress", [t, this.xhr]) }, timeout: function () { this.fireEvent("timeout", this.xhr) }, setHeader: function (t, e) { return this.headers[t] = e, this }, getHeader: function (t) { return Function.attempt(function () { return this.xhr.getResponseHeader(t) }.bind(this)) }, check: function () { if (!this.running) return !0; switch (this.options.link) { case "cancel": return this.cancel(), !0; case "chain": return this.chain(this.caller.pass(arguments, this)), !1 }return !1 }, send: function (t) { if (!this.check(t)) return this; this.options.isSuccess = this.options.isSuccess || this.isSuccess, this.running = !0; var e = typeOf(t); "string" != e && "element" != e || (t = { data: t }); var i, n = this.options, e = (t = Object.append({ data: n.data, url: n.url, method: n.method }, t)).data, n = String(t.url), t = t.method.toLowerCase(); switch (typeOf(e)) { case "element": e = document.id(e).toQueryString(); break; case "object": case "hash": e = Object.toQueryString(e) }this.options.format && (i = "format=" + this.options.format, e = e ? i + "&" + e : i), this.options.emulation && !["get", "post"].contains(t) && (i = "_method=" + t, e = e ? i + "&" + e : i, t = "post"), this.options.urlEncoded && ["post", "put"].contains(t) && (s = this.options.encoding ? "; charset=" + this.options.encoding : "", this.headers["Content-type"] = "application/x-www-form-urlencoded" + s); var s = (n = n || document.location.pathname).lastIndexOf("/"); -1 < s && -1 < (s = n.indexOf("#")) && (n = n.substr(0, s)), this.options.noCache && (n += (n.contains("?") ? "&" : "?") + String.uniqueID()), e && "get" == t && (n += (n.contains("?") ? "&" : "?") + e, e = null); var r = this.xhr; return o && (r.onloadstart = this.loadstart.bind(this), r.onprogress = this.progress.bind(this)), r.open(t.toUpperCase(), n, this.options.async, this.options.user, this.options.password), this.options.user && "withCredentials" in r && (r.withCredentials = !0), r.onreadystatechange = this.onStateChange.bind(this), Object.each(this.headers, function (e, i) { try { r.setRequestHeader(i, e) } catch (t) { this.fireEvent("exception", [i, e]) } }, this), this.fireEvent("request"), r.send(e), this.options.async ? this.options.timeout && (this.timer = this.timeout.delay(this.options.timeout, this)) : this.onStateChange(), this }, cancel: function () { if (!this.running) return this; this.running = !1; var t = this.xhr; return t.abort(), clearTimeout(this.timer), t.onreadystatechange = i, o && (t.onprogress = t.onloadstart = i), this.xhr = new Browser.Request, this.fireEvent("cancel"), this } }), t = {};["get", "post", "put", "delete", "GET", "POST", "PUT", "DELETE"].each(function (i) { t[i] = function (t) { var e = { method: i }; return null != t && (e.data = t), this.send(e) } }), e.implement(t), Element.Properties.send = { set: function (t) { return this.get("send").cancel().setOptions(t), this }, get: function () { var t = this.retrieve("send"); return t || (t = new e({ data: this, link: "cancel", method: this.get("method") || "post", url: this.get("action") }), this.store("send", t)), t } }, Element.implement({ send: function (t) { var e = this.get("send"); return e.send({ data: this, url: t || e.options.url }), this } }) }(), Request.HTML = new Class({ Extends: Request, options: { update: !1, append: !1, evalScripts: !0, filter: !1, headers: { Accept: "text/html, application/xml, text/xml, */*" } }, success: function (t) { var e = this.options, i = this.response; i.html = t.stripScripts(function (t) { i.javascript = t }); t = i.html.match(/<body[^>]*>([\s\S]*?)<\/body>/i); t && (i.html = t[1]); var n, t = new Element("div").set("html", i.html); i.tree = t.childNodes, i.elements = t.getElements(e.filter || "*"), e.filter && (i.tree = i.elements), e.update ? (n = document.id(e.update).empty(), e.filter ? n.adopt(i.elements) : n.set("html", i.html)) : e.append && (n = document.id(e.append), e.filter ? i.elements.reverse().inject(n) : n.adopt(t.getChildren())), e.evalScripts && Browser.exec(i.javascript), this.onSuccess(i.tree, i.elements, i.html, i.javascript) } }), Element.Properties.load = { set: function (t) { return this.get("load").cancel().setOptions(t), this }, get: function () { var t = this.retrieve("load"); return t || (t = new Request.HTML({ data: this, link: "cancel", update: this, method: "get" }), this.store("load", t)), t } }, Element.implement({ load: function () { return this.get("load").send(Array.link(arguments, { data: Type.isObject, url: Type.isString })), this } }), "undefined" == typeof JSON && (this.JSON = {}), JSON = new Hash({ stringify: JSON.stringify, parse: JSON.parse }), function () { var special = { "\b": "\\b", "\t": "\\t", "\n": "\\n", "\f": "\\f", "\r": "\\r", '"': '\\"', "\\": "\\\\" }, escape = function (t) { return special[t] || "\\u" + ("0000" + t.charCodeAt(0).toString(16)).slice(-4) }; JSON.validate = function (t) { return t = t.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, "@").replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, "]").replace(/(?:^|:|,)(?:\s*\[)+/g, ""), /^[\],:{}\s]*$/.test(t) }, JSON.encode = JSON.stringify ? function (t) { return JSON.stringify(t) } : function (t) { switch (t && t.toJSON && (t = t.toJSON()), typeOf(t)) { case "string": return '"' + t.replace(/[\x00-\x1f\\"]/g, escape) + '"'; case "array": return "[" + t.map(JSON.encode).clean() + "]"; case "object": case "hash": var i = []; return Object.each(t, function (t, e) { t = JSON.encode(t); t && i.push(JSON.encode(e) + ":" + t) }), "{" + i + "}"; case "number": case "boolean": return "" + t; case "null": return "null" }return null }, JSON.decode = function (string, secure) { if (!string || "string" != typeOf(string)) return null; if (secure || JSON.secure) { if (JSON.parse) return JSON.parse(string); if (!JSON.validate(string)) throw new Error("JSON could not decode the input; security is enabled and the value is not secure.") } return eval("(" + string + ")") } }(), Request.JSON = new Class({ Extends: Request, options: { secure: !0 }, initialize: function (t) { this.parent(t), Object.append(this.headers, { Accept: "application/json", "X-Request": "JSON" }) }, success: function (e) { var t; try { t = this.response.json = JSON.decode(e, this.options.secure) } catch (t) { return void this.fireEvent("error", [e, t]) } null == t ? this.onFailure() : this.onSuccess(t, e) } }); var Cookie = new Class({ Implements: Options, options: { path: "/", domain: !1, duration: !1, secure: !1, document: document, encode: !0 }, initialize: function (t, e) { this.key = t, this.setOptions(e) }, write: function (t) { var e; return this.options.encode && (t = encodeURIComponent(t)), this.options.domain && (t += "; domain=" + this.options.domain), this.options.path && (t += "; path=" + this.options.path), this.options.duration && ((e = new Date).setTime(e.getTime() + 24 * this.options.duration * 60 * 60 * 1e3), t += "; expires=" + e.toGMTString()), this.options.secure && (t += "; secure"), this.options.document.cookie = this.key + "=" + t, this }, read: function () { var t = this.options.document.cookie.match("(?:^|;)\\s*" + this.key.escapeRegExp() + "=([^;]*)"); return t ? decodeURIComponent(t[1]) : null }, dispose: function () { return new Cookie(this.key, Object.merge({}, this.options, { duration: -1 })).write(""), this } }); Cookie.write = function (t, e, i) { return new Cookie(t, i).write(e) }, Cookie.read = function (t) { return new Cookie(t).read() }, Cookie.dispose = function (t, e) { return new Cookie(t, e).dispose() }, function (e, i) { var n, s, t, r, o = [], a = i.createElement("div"), h = function () { clearTimeout(r), n || (Browser.loaded = n = !0, i.removeListener("DOMContentLoaded", h).removeListener("readystatechange", l), i.fireEvent("domready"), e.fireEvent("domready")) }, l = function () { for (var t = o.length; t--;)if (o[t]()) return h(), !0; return !1 }, u = function () { clearTimeout(r), l() || (r = setTimeout(u, 10)) }; i.addListener("DOMContentLoaded", h); function c() { try { return a.doScroll(), !0 } catch (t) { } return !1 } a.doScroll && !c() && (o.push(c), t = !0), i.readyState && o.push(function () { var t = i.readyState; return "loaded" == t || "complete" == t }), "onreadystatechange" in i ? i.addListener("readystatechange", l) : t = !0, t && u(), Element.Events.domready = { onAdd: function (t) { n && t.call(this) } }, Element.Events.load = { base: "load", onAdd: function (t) { s && this == e && t.call(this) }, condition: function () { return this == e && (h(), delete Element.Events.load), !0 } }, e.addEvent("load", function () { s = !0 }) }(window, document), function () { var Swiff = this.Swiff = new Class({ Implements: Options, options: { id: null, height: 1, width: 1, container: null, properties: {}, params: { quality: "high", allowScriptAccess: "always", wMode: "window", swLiveConnect: !0 }, callBacks: {}, vars: {} }, toElement: function () { return this.object }, initialize: function (t, e) { this.instance = "Swiff_" + String.uniqueID(), this.setOptions(e), e = this.options; var i = this.id = e.id || this.instance, n = document.id(e.container); Swiff.CallBacks[this.instance] = {}; var s, r = e.params, o = e.vars, a = e.callBacks, h = Object.append({ height: e.height, width: e.width }, e.properties), l = this; for (s in a) Swiff.CallBacks[this.instance][s] = function (t) { return function () { return t.apply(l.object, arguments) } }(a[s]), o[s] = "Swiff.CallBacks." + this.instance + "." + s; r.flashVars = Object.toQueryString(o), Browser.ie ? (h.classid = "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000", r.movie = t) : h.type = "application/x-shockwave-flash", h.data = t; var u, c, d = '<object id="' + i + '"'; for (u in h) d += " " + u + '="' + h[u] + '"'; for (c in d += ">", r) r[c] && (d += '<param name="' + c + '" value="' + r[c] + '" />'); d += "</object>", this.object = (n ? n.empty() : new Element("div")).set("html", d).firstChild }, replaces: function (t) { return (t = document.id(t, !0)).parentNode.replaceChild(this.toElement(), t), this }, inject: function (t) { return document.id(t, !0).appendChild(this.toElement()), this }, remote: function () { return Swiff.remote.apply(Swiff, [this.toElement()].append(arguments)) } }); Swiff.CallBacks = {}, Swiff.remote = function (obj, fn) { var rs = obj.CallFunction('<invoke name="' + fn + '" returntype="javascript">' + __flash__argumentsToXML(arguments, 2) + "</invoke>"); return eval(rs) } }(), MooTools.More = { version: "1.4.0.1", build: "a4244edf2aa97ac8a196fc96082dd35af1abab87" }, function () { Events.Pseudos = function (a, l, r) { function u(i) { return { store: i.store ? function (t, e) { i.store(n + t, e) } : function (t, e) { (i._monitorEvents || (i._monitorEvents = {}))[t] = e }, retrieve: i.retrieve ? function (t, e) { return i.retrieve(n + t, e) } : function (t, e) { return i._monitorEvents && i._monitorEvents[t] || e } } } function c(t) { if (-1 == t.indexOf(":") || !a) return null; for (var e = Slick.parse(t).expressions[0][0], i = e.pseudos, n = i.length, s = []; n--;) { var r = i[n].key, o = a[r]; null != o && s.push({ event: e.tag, value: i[n].value, pseudo: r, original: t, listener: o }) } return s.length ? s : null } var n = "_monitorEvents:"; return { addEvent: function (t, e, i) { var n = c(t); if (!n) return l.call(this, t, e, i); var s = u(this), r = s.retrieve(t, []), o = n[0].event, i = Array.slice(arguments, 2), a = e, h = this; return n.each(function (t) { var e = t.listener, i = a; 0 == e ? o += ":" + t.pseudo + "(" + t.value + ")" : a = function () { e.call(h, t, i, arguments, a) } }), r.include({ type: o, event: e, monitor: a }), s.store(t, r), t != o && l.apply(this, [t, e].concat(i)), l.apply(this, [o, a].concat(i)) }, removeEvent: function (t, i) { if (!c(t)) return r.call(this, t, i); var e = u(this), n = e.retrieve(t); if (!n) return this; var s = Array.slice(arguments, 2); return r.apply(this, [t, i].concat(s)), n.each(function (t, e) { i && t.event != i || r.apply(this, [t.type, t.monitor].concat(s)), delete n[e] }, this), e.store(t, n), this } } }; var i = { once: function (t, e, i, n) { e.apply(this, i), this.removeEvent(t.event, n).removeEvent(t.original, e) }, throttle: function (t, e, i) { e._throttled || (e.apply(this, i), e._throttled = setTimeout(function () { e._throttled = !1 }, t.value || 250)) }, pause: function (t, e, i) { clearTimeout(e._pause), e._pause = e.delay(t.value || 250, this, i) } }; Events.definePseudo = function (t, e) { return i[t] = e, this }, Events.lookupPseudo = function (t) { return i[t] }; var t = Events.prototype; Events.implement(Events.Pseudos(i, t.addEvent, t.removeEvent)), ["Request", "Fx"].each(function (t) { this[t] && this[t].implement(Events.prototype) }) }(), Class.refactor = function (e, t) { return Object.each(t, function (i, t) { var n = (n = e.prototype[t]) && n.$origin || n || function () { }; e.implement(t, "function" == typeof i ? function () { var t = this.previous; this.previous = n; var e = i.apply(this, arguments); return this.previous = t, e } : i) }), e }, Class.Mutators.Binds = function (t) { return this.prototype.initialize || this.implement("initialize", function () { }), Array.from(t).concat(this.prototype.Binds || []) }, Class.Mutators.initialize = function (t) { return function () { return Array.from(this.Binds).each(function (t) { var e = this[t]; e && (this[t] = e.bind(this)) }, this), t.apply(this, arguments) } }, Class.Occlude = new Class({ occlude: function (t, e) { var i = (e = document.id(e || this.element)).retrieve(t || this.property); return i && !this.occluded ? this.occluded = i : (this.occluded = !1, e.store(t || this.property, this), this.occluded) } }), function () { var t = { wait: function (t) { return this.chain(function () { return this.callChain.delay(null == t ? 500 : t, this), this }.bind(this)) } }; Chain.implement(t), this.Fx && Fx.implement(t), this.Element && Element.implement && this.Fx && Element.implement({ chains: function (t) { return Array.from(t || ["tween", "morph", "reveal"]).each(function (t) { (t = this.get(t)) && t.setOptions({ link: "chain" }) }, this), this }, pauseFx: function (t, e) { return this.chains(e).get(e || "tween").wait(t), this } }) }(), Array.implement({ min: function () { return Math.min.apply(null, this) }, max: function () { return Math.max.apply(null, this) }, average: function () { return this.length ? this.sum() / this.length : 0 }, sum: function () { var t = 0, e = this.length; if (e) for (; e--;)t += this[e]; return t }, unique: function () { return [].combine(this) }, shuffle: function () { for (var t = this.length; t && --t;) { var e = this[t], i = Math.floor(Math.random() * (t + 1)); this[t] = this[i], this[i] = e } return this }, reduce: function (t, e) { for (var i = 0, n = this.length; i < n; i++)i in this && (e = void 0 === e ? this[i] : t.call(null, e, this[i], i, this)); return e }, reduceRight: function (t, e) { for (var i = this.length; i--;)i in this && (e = void 0 === e ? this[i] : t.call(null, e, this[i], i, this)); return e } }), function () { function n(t) { return null != t } var s = Object.prototype.hasOwnProperty; Object.extend({ getFromPath: function (t, e) { "string" == typeof e && (e = e.split(".")); for (var i = 0, n = e.length; i < n; i++) { if (!s.call(t, e[i])) return null; t = t[e[i]] } return t }, cleanValues: function (t, e) { for (var i in e = e || n, t) e(t[i]) || delete t[i]; return t }, erase: function (t, e) { return s.call(t, e) && delete t[e], t }, run: function (t) { var e, i = Array.slice(arguments, 1); for (e in t) t[e].apply && t[e].apply(t, i); return t } }) }(), function () { function n(t) { return instanceOf(t, o.Set) ? t : l[t] } var r = null, l = {}, o = this.Locale = { define: function (t, e, i, n) { var s; return instanceOf(t, o.Set) ? (s = t.name) && (l[s] = t) : (l[s = t] || (l[s] = new o.Set(s)), t = l[s]), e && t.define(e, i, n), "cascade" == e ? o.inherit(s, i) : (r = r || t, t) }, use: function (t) { return (t = n(t)) && (r = t, this.fireEvent("change", t), this.fireEvent("langChange", t.name)), this }, getCurrent: function () { return r }, get: function (t, e) { return r ? r.get(t, e) : "" }, inherit: function (t, e, i) { return (t = n(t)) && t.inherit(e, i), this }, list: function () { return Object.keys(l) } }; Object.append(o, new Events), o.Set = new Class({ sets: {}, inherits: { locales: [], sets: {} }, initialize: function (t) { this.name = t || "" }, define: function (t, e, i) { var n = (n = this.sets[t]) || {}; return e && ("object" == typeOf(e) ? n = Object.merge(n, e) : n[e] = i), this.sets[t] = n, this }, get: function (t, e, i) { var n = Object.getFromPath(this.sets, t); if (null != n) { var s = typeOf(n); return "function" == s ? n = n.apply(null, Array.from(e)) : "object" == s && (n = Object.clone(n)), n } var s = t.indexOf("."), s = s < 0 ? t : t.substr(0, s), r = (this.inherits.sets[s] || []).combine(this.inherits.locales).include("en-US"); i = i || []; for (var o = 0, a = r.length; o < a; o++)if (!i.contains(r[o])) { i.include(r[o]); var h = l[r[o]]; if (h && null != (n = h.get(t, e, i))) return n } return "" }, inherit: function (t, e) { t = Array.from(t), e && !this.inherits.sets[e] && (this.inherits.sets[e] = []); for (var i = t.length; i--;)(e ? this.inherits.sets[e] : this.inherits.locales).unshift(t[i]); return this } }); var t = MooTools.lang = {}; Object.append(t, o, { setLanguage: o.use, getCurrentLanguage: function () { var t = o.getCurrent(); return t ? t.name : null }, set: function () { return o.define.apply(this, arguments), this }, get: function (t, e, i) { return e && (t += "." + e), o.get(t, i) } }) }(), Locale.define("en-US", "Date", { months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], months_abbr: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], days_abbr: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], dateOrder: ["month", "date", "year"], shortDate: "%m/%d/%Y", shortTime: "%I:%M%p", AM: "AM", PM: "PM", firstDayOfWeek: 0, ordinal: function (t) { return 3 < t && t < 21 ? "th" : ["th", "st", "nd", "rd", "th"][Math.min(t % 10, 4)] }, lessThanMinuteAgo: "less than a minute ago", minuteAgo: "about a minute ago", minutesAgo: "{delta} minutes ago", hourAgo: "about an hour ago", hoursAgo: "about {delta} hours ago", dayAgo: "1 day ago", daysAgo: "{delta} days ago", weekAgo: "1 week ago", weeksAgo: "{delta} weeks ago", monthAgo: "1 month ago", monthsAgo: "{delta} months ago", yearAgo: "1 year ago", yearsAgo: "{delta} years ago", lessThanMinuteUntil: "less than a minute from now", minuteUntil: "about a minute from now", minutesUntil: "{delta} minutes from now", hourUntil: "about an hour from now", hoursUntil: "about {delta} hours from now", dayUntil: "1 day from now", daysUntil: "{delta} days from now", weekUntil: "1 week from now", weeksUntil: "{delta} weeks from now", monthUntil: "1 month from now", monthsUntil: "{delta} months from now", yearUntil: "1 year from now", yearsUntil: "{delta} years from now" }), function () { var o = this.Date, i = o.Methods = { ms: "Milliseconds", year: "FullYear", min: "Minutes", mo: "Month", sec: "Seconds", hr: "Hours" };["Date", "Day", "FullYear", "Hours", "Milliseconds", "Minutes", "Month", "Seconds", "Time", "TimezoneOffset", "Week", "Timezone", "GMTOffset", "DayOfYear", "LastMonth", "LastDayOfMonth", "UTCDate", "UTCDay", "UTCFullYear", "AMPM", "Ordinal", "UTCHours", "UTCMilliseconds", "UTCMinutes", "UTCMonth", "UTCSeconds", "UTCMilliseconds"].each(function (t) { o.Methods[t.toLowerCase()] = t }); var n = function (t, e, i) { return 1 != e && t < Math.pow(10, e - 1) ? (i || "0") + n(t, e - 1, i) : t }; o.implement({ set: function (t, e) { t = t.toLowerCase(); t = i[t] && "set" + i[t]; return t && this[t] && this[t](e), this }.overloadSetter(), get: function (t) { t = t.toLowerCase(); t = i[t] && "get" + i[t]; return t && this[t] ? this[t]() : null }.overloadGetter(), clone: function () { return new o(this.get("time")) }, increment: function (t, e) { switch (e = null != e ? e : 1, t = t || "day") { case "year": return this.increment("month", 12 * e); case "month": var i = this.get("date"); return this.set("date", 1).set("mo", this.get("mo") + e), this.set("date", i.min(this.get("lastdayofmonth"))); case "week": return this.increment("day", 7 * e); case "day": return this.set("date", this.get("date") + e) }if (!o.units[t]) throw new Error(t + " is not a supported interval"); return this.set("time", this.get("time") + e * o.units[t]()) }, decrement: function (t, e) { return this.increment(t, -1 * (null != e ? e : 1)) }, isLeapYear: function () { return o.isLeapYear(this.get("year")) }, clearTime: function () { return this.set({ hr: 0, min: 0, sec: 0, ms: 0 }) }, diff: function (t, e) { return "string" == typeOf(t) && (t = o.parse(t)), ((t - this) / o.units[e || "day"](3, 3)).round() }, getLastDayOfMonth: function () { return o.daysInMonth(this.get("mo"), this.get("year")) }, getDayOfYear: function () { return (o.UTC(this.get("year"), this.get("mo"), this.get("date") + 1) - o.UTC(this.get("year"), 0, 1)) / o.units.day() }, setDay: function (t, e) { null == e && "" === (e = o.getMsg("firstDayOfWeek")) && (e = 1), t = (7 + o.parseDay(t, !0) - e) % 7; e = (7 + this.get("day") - e) % 7; return this.increment("day", t - e) }, getWeek: function (t) { null == t && "" === (t = o.getMsg("firstDayOfWeek")) && (t = 1); var e = this, i = (7 + e.get("day") - t) % 7, n = 0; if (1 == t) { var s = e.get("month"), r = e.get("date") - i; if (11 == s && 28 < r) return 1; 0 == s && r < -2 && (e = new o(e).decrement("day", i), i = 0), 4 < (r = new o(e.get("year"), 0, 1).get("day") || 7) && (n = -7) } else r = new o(e.get("year"), 0, 1).get("day"); return n += e.get("dayofyear"), n += 6 - i, (n += (7 + r - t) % 7) / 7 }, getOrdinal: function (t) { return o.getMsg("ordinal", t || this.get("date")) }, getTimezone: function () { return this.toString().replace(/^.*? ([A-Z]{3}).[0-9]{4}.*$/, "$1").replace(/^.*?\(([A-Z])[a-z]+ ([A-Z])[a-z]+ ([A-Z])[a-z]+\)$/, "$1$2$3") }, getGMTOffset: function () { var t = this.get("timezoneOffset"); return (0 < t ? "-" : "+") + n((t.abs() / 60).floor(), 2) + n(t % 60, 2) }, setAMPM: function (t) { t = t.toUpperCase(); var e = this.get("hr"); return 11 < e && "AM" == t ? this.decrement("hour", 12) : e < 12 && "PM" == t ? this.increment("hour", 12) : this }, getAMPM: function () { return this.get("hr") < 12 ? "AM" : "PM" }, parse: function (t) { return this.set("time", o.parse(t)), this }, isValid: function (t) { return t = t || this, "date" == typeOf(t) && !isNaN(t.valueOf()) }, format: function (t) { if (!this.isValid()) return "invalid date"; if ("string" == typeof (t = t || "%x %X") && (t = a[t.toLowerCase()] || t), "function" == typeof t) return t(this); var i = this; return t.replace(/%([a-z%])/gi, function (t, e) { switch (e) { case "a": return o.getMsg("days_abbr")[i.get("day")]; case "A": return o.getMsg("days")[i.get("day")]; case "b": return o.getMsg("months_abbr")[i.get("month")]; case "B": return o.getMsg("months")[i.get("month")]; case "c": return i.format("%a %b %d %H:%M:%S %Y"); case "d": return n(i.get("date"), 2); case "e": return n(i.get("date"), 2, " "); case "H": return n(i.get("hr"), 2); case "I": return n(i.get("hr") % 12 || 12, 2); case "j": return n(i.get("dayofyear"), 3); case "k": return n(i.get("hr"), 2, " "); case "l": return n(i.get("hr") % 12 || 12, 2, " "); case "L": return n(i.get("ms"), 3); case "m": return n(i.get("mo") + 1, 2); case "M": return n(i.get("min"), 2); case "o": return i.get("ordinal"); case "p": return o.getMsg(i.get("ampm")); case "s": return Math.round(i / 1e3); case "S": return n(i.get("seconds"), 2); case "T": return i.format("%H:%M:%S"); case "U": return n(i.get("week"), 2); case "w": return i.get("day"); case "x": return i.format(o.getMsg("shortDate")); case "X": return i.format(o.getMsg("shortTime")); case "y": return i.get("year").toString().substr(2); case "Y": return i.get("year"); case "z": return i.get("GMTOffset"); case "Z": return i.get("Timezone") }return e }) }, toISOString: function () { return this.format("iso8601") } }).alias({ toJSON: "toISOString", compare: "diff", strftime: "format" }); function s(t, e, i) { var n = -1, s = o.getMsg(t + "s"); switch (typeOf(e)) { case "object": n = s[e.get(t)]; break; case "number": if (!(n = s[e])) throw new Error("Invalid " + t + " index: " + e); break; case "string": e = s.filter(function (t) { return this.test(t) }, new RegExp("^" + e, "i")); if (!e.length) throw new Error("Invalid " + t + " string"); if (1 < e.length) throw new Error("Ambiguous " + t); n = e[0] }return i ? s.indexOf(n) : n } var e = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], r = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], a = { db: "%Y-%m-%d %H:%M:%S", compact: "%Y%m%dT%H%M%S", short: "%d %b %H:%M", long: "%B %d, %Y %H:%M", rfc822: function (t) { return e[t.get("day")] + t.format(", %d ") + r[t.get("month")] + t.format(" %Y %H:%M:%S %Z") }, rfc2822: function (t) { return e[t.get("day")] + t.format(", %d ") + r[t.get("month")] + t.format(" %Y %H:%M:%S %z") }, iso8601: function (t) { return t.getUTCFullYear() + "-" + n(t.getUTCMonth() + 1, 2) + "-" + n(t.getUTCDate(), 2) + "T" + n(t.getUTCHours(), 2) + ":" + n(t.getUTCMinutes(), 2) + ":" + n(t.getUTCSeconds(), 2) + "." + n(t.getUTCMilliseconds(), 3) + "Z" } }, h = [], l = o.parse, u = 1900, c = 70; o.extend({ getMsg: function (t, e) { return Locale.get("Date." + t, e) }, units: { ms: Function.from(1), second: Function.from(1e3), minute: Function.from(6e4), hour: Function.from(36e5), day: Function.from(864e5), week: Function.from(6084e5), month: function (t, e) { var i = new o; return 864e5 * o.daysInMonth(null != t ? t : i.get("mo"), null != e ? e : i.get("year")) }, year: function (t) { return t = t || (new o).get("year"), o.isLeapYear(t) ? 316224e5 : 31536e6 } }, daysInMonth: function (t, e) { return [31, o.isLeapYear(e) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][t] }, isLeapYear: function (t) { return t % 4 == 0 && t % 100 != 0 || t % 400 == 0 }, parse: function (i) { var n, t = typeOf(i); return "number" == t ? new o(i) : "string" != t ? i : (i = i.clean()).length ? (h.some(function (t) { var e = t.re.exec(i); return !!e && (n = t.handler(e)) }), n && n.isValid() || (n = new o(l(i))) && n.isValid() || (n = new o(i.toInt())), n) : null }, parseDay: function (t, e) { return s("day", t, e) }, parseMonth: function (t, e) { return s("month", t, e) }, parseUTC: function (t) { t = new o(t), t = o.UTC(t.get("year"), t.get("mo"), t.get("date"), t.get("hr"), t.get("min"), t.get("sec"), t.get("ms")); return new o(t) }, orderIndex: function (t) { return o.getMsg("dateOrder").indexOf(t) + 1 }, defineFormat: function (t, e) { return a[t] = e, this }, parsePatterns: h, defineParser: function (t) { return h.push(t.re && t.handler ? t : p(t)), this }, defineParsers: function () { return Array.flatten(arguments).each(o.defineParser), this }, define2DigitYearStart: function (t) { return u = t - (c = t % 100), this } }).extend({ defineFormats: o.defineFormat.overloadSetter() }); function d(t) { return new RegExp("(?:" + o.getMsg(t).map(function (t) { return t.substr(0, 3) }).join("|") + ")[a-z]*") } var f, m = { d: /[0-2]?[0-9]|3[01]/, H: /[01]?[0-9]|2[0-3]/, I: /0?[1-9]|1[0-2]/, M: /[0-5]?\d/, s: /\d+/, o: /[a-z]*/, p: /[ap]\.?m\.?/, y: /\d{2}|\d{4}/, Y: /\d{4}/, z: /Z|[+-]\d{2}(?::?\d{2})?/ }; m.m = m.I, m.S = m.M; var p = function (t) { if (!f) return { format: t }; var s = [], e = (t.source || t).replace(/%([a-z])/gi, function (t, e) { return function (t) { switch (t) { case "T": return "%H:%M:%S"; case "x": return (1 == o.orderIndex("month") ? "%m[-./]%d" : "%d[-./]%m") + "([-./]%y)?"; case "X": return "%H([.:]%M)?([.:]%S([.:]%s)?)? ?%p? ?%z?" }return null }(e) || t }).replace(/\((?!\?)/g, "(?:").replace(/ (?!\?|\*)/g, ",? ").replace(/%([a-z%])/gi, function (t, e) { var i = m[e]; return i ? (s.push(e), "(" + i.source + ")") : e }).replace(/\[a-z\]/gi, "[a-z\\u00c0-\\uffff;&]"); return { format: t, re: new RegExp("^" + e + "$", "i"), handler: function (t) { t = t.slice(1).associate(s); var e, i = (new o).clearTime(), n = t.y || t.Y; for (e in null != n && g.call(i, "y", n), "d" in t && g.call(i, "d", 1), ("m" in t || t.b || t.B) && g.call(i, "m", 1), t) g.call(i, e, t[e]); return i } } }, g = function (t, e) { if (!e) return this; switch (t) { case "a": case "A": return this.set("day", o.parseDay(e, !0)); case "b": case "B": return this.set("mo", o.parseMonth(e, !0)); case "d": return this.set("date", e); case "H": case "I": return this.set("hr", e); case "m": return this.set("mo", e - 1); case "M": return this.set("min", e); case "p": return this.set("ampm", e.replace(/\./g, "")); case "S": return this.set("sec", e); case "s": return this.set("ms", 1e3 * ("0." + e)); case "w": return this.set("day", e); case "Y": return this.set("year", e); case "y": return (e = +e) < 100 && (e += u + (e < c ? 100 : 0)), this.set("year", e); case "z": "Z" == e && (e = "+00"); e = ((e = e.match(/([+-])(\d{2}):?(\d{2})?/))[1] + "1") * (60 * e[2] + (+e[3] || 0)) + this.getTimezoneOffset(); return this.set("time", this - 6e4 * e) }return this }; o.defineParsers("%Y([-./]%m([-./]%d((T| )%X)?)?)?", "%Y%m%d(T%H(%M%S?)?)?", "%x( %X)?", "%d%o( %b( %Y)?)?( %X)?", "%b( %d%o)?( %Y)?( %X)?", "%Y %b( %d%o( %X)?)?", "%o %b %d %X %z %Y", "%T", "%H:%M( ?%p)?"), Locale.addEvent("change", function (t) { Locale.get("Date") && (f = t, m.a = m.A = d("days"), m.b = m.B = d("months"), h.each(function (t, e) { t.format && (h[e] = p(t.format)) })) }).fireEvent("change", Locale.getCurrent()) }(), Date.implement({ timeDiffInWords: function (t) { return Date.distanceOfTimeInWords(this, t || new Date) }, timeDiff: function (t, e) { null == t && (t = new Date); for (var i, n, s = ((t - this) / 1e3).floor().abs(), r = [], o = [60, 60, 24, 365, 0], a = ["s", "m", "h", "d", "y"], h = 0; h < o.length && (!h || s); h++)i = s, (n = o[h]) && (i = s % n, s = (s / n).floor()), r.unshift(i + (a[h] || "")); return r.join(e || ":") } }).extend({ distanceOfTimeInWords: function (t, e) { return Date.getTimePhrase(((e - t) / 1e3).toInt()) }, getTimePhrase: function (t) { var e = t < 0 ? "Until" : "Ago"; t < 0 && (t *= -1); var i, n = { minute: 60, hour: 60, day: 24, week: 7, month: 52 / 12, year: 12, eon: 1 / 0 }, s = "lessThanMinute"; for (i in n) { var r = n[i]; if (t < 1.5 * r) { .75 * r < t && (s = i); break } t /= r, s = i + "s" } return t = t.round(), Date.getMsg(s + e, t).substitute({ delta: t }) } }).defineParsers({ re: /^(?:tod|tom|yes)/i, handler: function (t) { var e = (new Date).clearTime(); switch (t[0]) { case "tom": return e.increment(); case "yes": return e.decrement(); default: return e } } }, { re: /^(next|last) ([a-z]+)$/i, handler: function (t) { var e = (new Date).clearTime(), i = e.getDay(), n = Date.parseDay(t[2], !0), s = n - i; return n <= i && (s += 7), "last" == t[1] && (s -= 7), e.set("date", e.getDate() + s) } }).alias("timeAgoInWords", "timeDiffInWords"), Locale.define("en-US", "Number", { decimal: ".", group: ",", currency: { prefix: "$ " } }), Number.implement({ format: function (e) { var t = this; e = e ? Object.clone(e) : {}; function i(t) { return null != e[t] ? e[t] : Locale.get("Number." + t) } var n, s = t < 0, r = i("decimal"), o = i("precision"), a = i("group"), h = i("decimals"); s && (null == (n = i("negative") || {}).prefix && null == n.suffix && (n.prefix = "-"), ["prefix", "suffix"].each(function (t) { n[t] && (e[t] = i(t) + n[t]) }), t = -t); var l, u = i("prefix"), s = i("suffix"); if ("" !== h && 0 <= h && h <= 20 && (t = t.toFixed(h)), 1 <= o && o <= 21 && (t = (+t).toPrecision(o)), t += "", !1 === i("scientific") && -1 < t.indexOf("e")) { var o = t.split("e"), c = +o[1], t = o[0].replace(".", ""); if (c < 0) { for (c = -c - 1, -1 < (l = o[0].indexOf(".")) && (c -= l - 1); c--;)t = "0" + t; t = "0." + t } else for (-1 < (l = o[0].lastIndexOf(".")) && (c -= o[0].length - l - 1); c--;)t += "0" } if ("." != r && (t = t.replace(".", r)), a) { l = -1 < (l = t.lastIndexOf(r)) ? l : t.length; for (var d = t.substring(l), f = l; f--;)(l - f - 1) % 3 == 0 && f != l - 1 && (d = a + d), d = t.charAt(f) + d; t = d } return u && (t = u + t), s && (t += s), t }, formatCurrency: function (t) { var e = Locale.get("Number.currency") || {}; return null == e.scientific && (e.scientific = !1), e.decimals = null != t ? t : null == e.decimals ? 2 : e.decimals, this.format(e) }, formatPercentage: function (t) { var e = Locale.get("Number.percentage") || {}; return null == e.suffix && (e.suffix = "%"), e.decimals = null != t ? t : null == e.decimals ? 2 : e.decimals, this.format(e) } }), function () { function t(t, e) { var i, n = t; for (i in e) n = n.replace(e[i], i); return n } function i(t, e) { return t = t || "", new RegExp(e ? "<" + t + "(?!\\w)[^>]*>([\\s\\S]*?)</" + t + "(?!\\w)>" : "</?" + t + "([^>]+)?>", "gi") } var e = { a: /[àáâãäåăą]/g, A: /[ÀÁÂÃÄÅĂĄ]/g, c: /[ćčç]/g, C: /[ĆČÇ]/g, d: /[ďđ]/g, D: /[ĎÐ]/g, e: /[èéêëěę]/g, E: /[ÈÉÊËĚĘ]/g, g: /[ğ]/g, G: /[Ğ]/g, i: /[ìíîï]/g, I: /[ÌÍÎÏ]/g, l: /[ĺľł]/g, L: /[ĹĽŁ]/g, n: /[ñňń]/g, N: /[ÑŇŃ]/g, o: /[òóôõöøő]/g, O: /[ÒÓÔÕÖØ]/g, r: /[řŕ]/g, R: /[ŘŔ]/g, s: /[ššş]/g, S: /[ŠŞŚ]/g, t: /[ťţ]/g, T: /[ŤŢ]/g, ue: /[ü]/g, UE: /[Ü]/g, u: /[ùúûůµ]/g, U: /[ÙÚÛŮ]/g, y: /[ÿý]/g, Y: /[ŸÝ]/g, z: /[žźż]/g, Z: /[ŽŹŻ]/g, th: /[þ]/g, TH: /[Þ]/g, dh: /[ð]/g, DH: /[Ð]/g, ss: /[ß]/g, oe: /[œ]/g, OE: /[Œ]/g, ae: /[æ]/g, AE: /[Æ]/g }, n = { " ": /[\xa0\u2002\u2003\u2009]/g, "*": /[\xb7]/g, "'": /[\u2018\u2019]/g, '"': /[\u201c\u201d]/g, "...": /[\u2026]/g, "-": /[\u2013]/g, "&raquo;": /[\uFFFD]/g }; String.implement({ standardize: function () { return t(this, e) }, repeat: function (t) { return new Array(t + 1).join(this) }, pad: function (t, e, i) { if (this.length >= t) return this; t = (null == e ? " " : "" + e).repeat(t - this.length).substr(0, t - this.length); return i && "right" != i ? "left" == i ? t + this : t.substr(0, (t.length / 2).floor()) + this + t.substr(0, (t.length / 2).ceil()) : this + t }, getTags: function (t, e) { return this.match(i(t, e)) || [] }, stripTags: function (t, e) { return this.replace(i(t, e), "") }, tidy: function () { return t(this, n) }, truncate: function (t, e, i) { var n = this; return null == e && 1 == arguments.length && (e = "…"), n.length > t && (n = n.substring(0, t), !i || -1 != (i = n.lastIndexOf(i)) && (n = n.substr(0, i)), e && (n += e)), n } }) }(), String.implement({ parseQueryString: function (o, i) { null == o && (o = !0), null == i && (i = !0); var t = this.split(/[&;]/), a = {}; return t.length && t.each(function (t) { var e = t.indexOf("=") + 1, n = e ? t.substr(e) : "", s = e ? t.substr(0, e - 1).match(/([^\]\[]+|(\B)(?=\]))/g) : [t], r = a; s && (i && (n = decodeURIComponent(n)), s.each(function (t, e) { o && (t = decodeURIComponent(t)); var i = r[t]; e < s.length - 1 ? r = r[t] = i || {} : "array" == typeOf(i) ? i.push(n) : r[t] = null != i ? [i, n] : n })) }), a }, cleanQueryString: function (n) { return this.split("&").filter(function (t) { var e = t.indexOf("="), i = e < 0 ? "" : t.substr(0, e), e = t.substr(e + 1); return n ? n.call(null, i, e) : e || 0 === e }).join("&") } }), function () { function t() { return this.get("value") } var s = this.URI = new Class({ Implements: Options, options: {}, regex: /^(?:(\w+):)?(?:\/\/(?:(?:([^:@\/]*):?([^:@\/]*))?@)?([^:\/?#]*)(?::(\d*))?)?(\.\.?$|(?:[^?#\/]*\/)*)([^?#]*)(?:\?([^#]*))?(?:#(.*))?/, parts: ["scheme", "user", "password", "host", "port", "directory", "file", "query", "fragment"], schemes: { http: 80, https: 443, ftp: 21, rtsp: 554, mms: 1755, file: 0 }, initialize: function (t, e) { this.setOptions(e); e = this.options.base || s.base; (t = t || e) && t.parsed ? this.parsed = Object.clone(t.parsed) : this.set("value", t.href || t.toString(), !!e && new s(e)) }, parse: function (t, e) { t = t.match(this.regex); return !!t && (t.shift(), this.merge(t.associate(this.parts), e)) }, merge: function (e, i) { return !!(e && e.scheme || i && i.scheme) && (i && this.parts.every(function (t) { return !e[t] && (e[t] = i[t] || "", !0) }), e.port = e.port || this.schemes[e.scheme.toLowerCase()], e.directory = e.directory ? this.parseDirectory(e.directory, i ? i.directory : "") : "/", e) }, parseDirectory: function (t, e) { if (!(t = ("/" == t.substr(0, 1) ? "" : e || "/") + t).test(s.regs.directoryDot)) return t; var i = []; return t.replace(s.regs.endSlash, "").split("/").each(function (t) { ".." == t && 0 < i.length ? i.pop() : "." != t && i.push(t) }), i.join("/") + "/" }, combine: function (t) { return t.value || t.scheme + "://" + (t.user ? t.user + (t.password ? ":" + t.password : "") + "@" : "") + (t.host || "") + (t.port && t.port != this.schemes[t.scheme] ? ":" + t.port : "") + (t.directory || "/") + (t.file || "") + (t.query ? "?" + t.query : "") + (t.fragment ? "#" + t.fragment : "") }, set: function (t, e, i) { var n; return "value" == t ? (n = (n = e.match(s.regs.scheme)) && n[1]) && null == this.schemes[n.toLowerCase()] ? this.parsed = { scheme: n, value: e } : this.parsed = this.parse(e, (i || this).parsed) || (n ? { scheme: n, value: e } : { value: e }) : "data" == t ? this.setData(e) : this.parsed[t] = e, this }, get: function (t, e) { switch (t) { case "value": return this.combine(this.parsed, !!e && e.parsed); case "data": return this.getData() }return this.parsed[t] || "" }, go: function () { document.location.href = this.toString() }, toURI: function () { return this }, getData: function (t, e) { e = this.get(e || "query"); if (!e && 0 !== e) return t ? null : {}; e = e.parseQueryString(); return t ? e[t] : e }, setData: function (t, e, i) { var n; return "string" == typeof t ? ((n = this.getData())[arguments[0]] = e, t = n) : e && (t = Object.merge(this.getData(), t)), this.set(i || "query", Object.toQueryString(t)) }, clearData: function (t) { return this.set(t || "query", "") }, toString: t, valueOf: t }); s.regs = { endSlash: /\/$/, scheme: /^(\w+):/, directoryDot: /\.\/|\.$/ }, s.base = new s(Array.from(document.getElements("base[href]", !0)).getLast(), { base: document.location }), String.implement({ toURI: function (t) { return new s(this, t) } }) }(), URI = Class.refactor(URI, { combine: function (t, e) { if (!e || t.scheme != e.scheme || t.host != e.host || t.port != e.port) return this.previous.apply(this, arguments); var i = t.file + (t.query ? "?" + t.query : "") + (t.fragment ? "#" + t.fragment : ""); if (!e.directory) return (t.directory || (t.file ? "" : "./")) + i; for (var n = e.directory.split("/"), s = t.directory.split("/"), r = "", o = 0, a = 0; a < n.length && a < s.length && n[a] == s[a]; a++); for (o = 0; o < n.length - a - 1; o++)r += "../"; for (o = a; o < s.length - 1; o++)r += s[o] + "/"; return (r || (t.file ? "" : "./")) + i }, toAbsolute: function (t) { return (t = new URI(t)) && t.set("directory", "").set("file", ""), this.toRelative(t) }, toRelative: function (t) { return this.get("value", new URI(t)) } }), function () { var i; this.Hash || (i = this.Hash = new Type("Hash", function (t) { for (var e in "hash" == typeOf(t) && (t = Object.clone(t.getClean())), t) this[e] = t[e]; return this }), this.$H = function (t) { return new i(t) }, i.implement({ forEach: function (t, e) { Object.forEach(this, t, e) }, getClean: function () { var t, e = {}; for (t in this) this.hasOwnProperty(t) && (e[t] = this[t]); return e }, getLength: function () { var t, e = 0; for (t in this) this.hasOwnProperty(t) && e++; return e } }), i.alias("each", "forEach"), i.implement({ has: Object.prototype.hasOwnProperty, keyOf: function (t) { return Object.keyOf(this, t) }, hasValue: function (t) { return Object.contains(this, t) }, extend: function (t) { return i.each(t || {}, function (t, e) { i.set(this, e, t) }, this), this }, combine: function (t) { return i.each(t || {}, function (t, e) { i.include(this, e, t) }, this), this }, erase: function (t) { return this.hasOwnProperty(t) && delete this[t], this }, get: function (t) { return this.hasOwnProperty(t) ? this[t] : null }, set: function (t, e) { return this[t] && !this.hasOwnProperty(t) || (this[t] = e), this }, empty: function () { return i.each(this, function (t, e) { delete this[e] }, this), this }, include: function (t, e) { return null == this[t] && (this[t] = e), this }, map: function (t, e) { return new i(Object.map(this, t, e)) }, filter: function (t, e) { return new i(Object.filter(this, t, e)) }, every: function (t, e) { return Object.every(this, t, e) }, some: function (t, e) { return Object.some(this, t, e) }, getKeys: function () { return Object.keys(this) }, getValues: function () { return Object.values(this) }, toQueryString: function (t) { return Object.toQueryString(this, t) } }), i.alias({ indexOf: "keyOf", contains: "hasValue" })) }(), Hash.implement({ getFromPath: function (t) { return Object.getFromPath(this, t) }, cleanValues: function (t) { return new Hash(Object.cleanValues(this, t)) }, run: function () { Object.run(arguments) } }), Element.implement({ tidy: function () { this.set("value", this.get("value").tidy()) }, getTextInRange: function (t, e) { return this.get("value").substring(t, e) }, getSelectedText: function () { return this.setSelectionRange ? this.getTextInRange(this.getSelectionStart(), this.getSelectionEnd()) : document.selection.createRange().text }, getSelectedRange: function () { if (null != this.selectionStart) return { start: this.selectionStart, end: this.selectionEnd }; var t = { start: 0, end: 0 }, e = this.getDocument().selection.createRange(); if (!e || e.parentElement() != this) return t; var i, n, s = e.duplicate(); return "text" == this.type || "password" == this.type ? (t.start = 0 - s.moveStart("character", -1e5), t.end = t.start + e.text.length) : (n = (i = this.get("value")).length, s.moveToElementText(this), s.setEndPoint("StartToEnd", e), s.text.length && (n -= i.match(/[\n\r]*$/)[0].length), t.end = n - s.text.length, s.setEndPoint("StartToStart", e), t.start = n - s.text.length), t }, getSelectionStart: function () { return this.getSelectedRange().start }, getSelectionEnd: function () { return this.getSelectedRange().end }, setCaretPosition: function (t) { return "end" == t && (t = this.get("value").length), this.selectRange(t, t), this }, getCaretPosition: function () { return this.getSelectedRange().start }, selectRange: function (t, e) { var i; return this.setSelectionRange ? (this.focus(), this.setSelectionRange(t, e)) : (e = (i = this.get("value")).substr(t, e - t).replace(/\r/g, "").length, t = i.substr(0, t).replace(/\r/g, "").length, (i = this.createTextRange()).collapse(!0), i.moveEnd("character", t + e), i.moveStart("character", t), i.select()), this }, insertAtCursor: function (t, e) { var i = this.getSelectedRange(), n = this.get("value"); return this.set("value", n.substring(0, i.start) + t + n.substring(i.end, n.length)), !1 !== e ? this.selectRange(i.start, i.start + t.length) : this.setCaretPosition(i.start + t.length), this }, insertAroundCursor: function (t, e) { t = Object.append({ before: "", defaultMiddle: "", after: "" }, t); var i = this.getSelectedText() || t.defaultMiddle, n = this.getSelectedRange(), s = this.get("value"); return n.start == n.end ? (this.set("value", s.substring(0, n.start) + t.before + i + t.after + s.substring(n.end, s.length)), this.selectRange(n.start + t.before.length, n.end + t.before.length + i.length)) : (i = s.substring(n.start, n.end), this.set("value", s.substring(0, n.start) + t.before + i + t.after + s.substring(n.end, s.length)), t = n.start + t.before.length, !1 !== e ? this.selectRange(t, t + i.length) : this.setCaretPosition(t + s.length)), this } }), Elements.from = function (t, e) { !e && null != e || (t = t.stripScripts()); var i, e = t.match(/^\s*<(t[dhr]|tbody|tfoot|thead)/i); return e && (i = new Element("table"), e = e[1].toLowerCase(), ["td", "th", "tr"].contains(e) && (i = new Element("tbody").inject(i), "tr" != e && (i = new Element("tr").inject(i)))), (i || new Element("div")).set("html", t).getChildren() }, function () { for (var i = { relay: !1 }, t = ["once", "throttle", "pause"], e = t.length; e--;)i[t[e]] = Events.lookupPseudo(t[e]); DOMEvent.definePseudo = function (t, e) { return i[t] = e, this }; var n = Element.prototype;[Element, Window, Document].invoke("implement", Events.Pseudos(i, n.addEvent, n.removeEvent)) }(), function () { var o = "$moo:keys-pressed", a = "$moo:keys-keyup"; DOMEvent.definePseudo("keys", function (t, e, i) { var n = i[0], s = [], r = this.retrieve(o, []); s.append(t.value.replace("++", function () { return s.push("+"), "" }).split("+")), r.include(n.key), s.every(function (t) { return r.contains(t) }) && e.apply(this, i), this.store(o, r), this.retrieve(a) || (i = function (t) { (function () { r = this.retrieve(o, []).erase(t.key), this.store(o, r) }).delay(0, this) }, this.store(a, i).addEvent("keyup", i)) }), DOMEvent.defineKeys({ 16: "shift", 17: "control", 18: "alt", 20: "capslock", 33: "pageup", 34: "pagedown", 35: "end", 36: "home", 144: "numlock", 145: "scrolllock", 186: ";", 187: "=", 188: ",", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\", 221: "]", 222: "'", 107: "+" }).defineKey(Browser.firefox ? 109 : 189, "-") }(), function () { function s(t) { return !(t && !t.offsetHeight && !t.offsetWidth) } Element.implement({ measure: function (t) { if (s(this)) return t.call(this); for (var e = this.getParent(), i = []; !s(e) && e != document.body;)i.push(e.expose()), e = e.getParent(); var n = this.expose(), t = t.call(this); return n(), i.each(function (t) { t() }), t }, expose: function () { if ("none" != this.getStyle("display")) return function () { }; var t = this.style.cssText; return this.setStyles({ display: "block", position: "absolute", visibility: "hidden" }), function () { this.style.cssText = t }.bind(this) }, getDimensions: function (t) { t = Object.merge({ computeSize: !1 }, t); function e(t, e) { return e.computeSize ? t.getComputedSize(e) : t.getSize() } var i = { x: 0, y: 0 }, n = this.getParent("body"); if (n && "none" == this.getStyle("display")) i = this.measure(function () { return e(this, t) }); else if (n) try { i = e(this, t) } catch (t) { } return Object.append(i, i.x || 0 === i.x ? { width: i.x, height: i.y } : { x: i.width, y: i.height }) }, getComputedSize: function (t) { t && t.plains && (t.planes = t.plains), t = Object.merge({ styles: ["padding", "border"], planes: { height: ["top", "bottom"], width: ["left", "right"] }, mode: "both" }, t); var n, i, e, s, r = {}, o = { width: 0, height: 0 }; return "vertical" == t.mode ? (delete o.width, delete t.planes.width) : "horizontal" == t.mode && (delete o.height, delete t.planes.height), i = t.styles, e = t.planes, s = [], Object.each(e, function (t) { Object.each(t, function (e) { i.each(function (t) { s.push(t + "-" + e + ("border" == t ? "-width" : "")) }) }) }), s.each(function (t) { r[t] = this.getStyle(t).toInt() }, this), Object.each(t.planes, function (t, e) { var s = e.capitalize(), i = this.getStyle(e); "auto" != i || n || (n = this.getDimensions()), i = r[e] = "auto" == i ? n[e] : i.toInt(), o["total" + s] = i, t.each(function (t) { var i, e, n, e = (i = t, e = r, n = 0, Object.each(e, function (t, e) { e.test(i) && (n += t.toInt()) }), n); o["computed" + t.capitalize()] = e, o["total" + s] += e }) }, this), Object.append(o, r) } }) }(), function () { var a = !1, h = !1; Element.implement({ pin: function (t, e) { if (h || (i = new Element("div").setStyles({ position: "fixed", top: 0, right: 0 }).inject(document.body), a = 0 === i.offsetTop, i.dispose(), h = !0), "none" == this.getStyle("display")) return this; var i = window.getScroll(); if (!1 !== t) { var n, s, r = this.getPosition(a ? document.body : this.getOffsetParent()); this.retrieve("pin:_pinned") || (t = { top: r.y - i.y, left: r.x - i.x }, a && !e ? this.setStyle("position", "fixed").setStyles(t) : (o = this.getOffsetParent(), n = this.getPosition(o), s = this.getStyles("left", "top"), (o && "auto" == s.left || "auto" == s.top) && this.setPosition(n), "static" == this.getStyle("position") && this.setStyle("position", "absolute"), n = { x: s.left.toInt() - i.x, y: s.top.toInt() - i.y }, s = function () { var t; this.retrieve("pin:_pinned") && (t = window.getScroll(), this.setStyles({ left: n.x + t.x, top: n.y + t.y })) }.bind(this), this.store("pin:_scrollFixer", s), window.addEvent("scroll", s)), this.store("pin:_pinned", !0)) } else { if (!this.retrieve("pin:_pinned")) return this; var o = "static" != (o = this.getParent()).getComputedStyle("position") ? o : o.getOffsetParent(); r = this.getPosition(o), this.store("pin:_pinned", !1), (s = this.retrieve("pin:_scrollFixer")) ? (this.store("pin:_scrollFixer", null), window.removeEvent("scroll", s)) : this.setStyles({ position: "absolute", top: r.y + i.y, left: r.x + i.x }), this.removeClass("isPinned") } return this }, unpin: function () { return this.pin(!1) }, togglePin: function () { return this.pin(!this.retrieve("pin:_pinned")) } }), Element.alias("togglepin", "togglePin") }(), function (i) { var s = Element.Position = { options: { relativeTo: document.body, position: { x: "center", y: "center" }, offset: { x: 0, y: 0 } }, getOptions: function (t, e) { return e = Object.merge({}, s.options, e), s.setPositionOption(e), s.setEdgeOption(e), s.setOffsetOption(t, e), s.setDimensionsOption(t, e), e }, setPositionOption: function (t) { t.position = s.getCoordinateFromValue(t.position) }, setEdgeOption: function (t) { var e = s.getCoordinateFromValue(t.edge); t.edge = e || ("center" == t.position.x && "center" == t.position.y ? { x: "center", y: "center" } : { x: "left", y: "top" }) }, setOffsetOption: function (t, e) { var i, n = t.measure(function () { return document.id(this.getOffsetParent()) }), s = n.getScroll(); n && n != t.getDocument().body && (i = n.measure(function () { var t, e = this.getPosition(); return "fixed" == this.getStyle("position") && (t = window.getScroll(), e.x += t.x, e.y += t.y), e }), e.offset = { parentPositioned: n != document.id(e.relativeTo), x: e.offset.x - i.x + s.x, y: e.offset.y - i.y + s.y }) }, setDimensionsOption: function (t, e) { e.dimensions = t.getDimensions({ computeSize: !0, styles: ["padding", "border", "margin"] }) }, getPosition: function (t, e) { var i = {}; e = s.getOptions(t, e); var n = document.id(e.relativeTo) || document.body; s.setPositionCoordinates(e, i, n), e.edge && s.toEdge(i, e); t = e.offset; return i.left = (0 <= i.x || t.parentPositioned || e.allowNegative ? i.x : 0).toInt(), i.top = (0 <= i.y || t.parentPositioned || e.allowNegative ? i.y : 0).toInt(), s.toMinMax(i, e), !e.relFixedPosition && "fixed" != n.getStyle("position") || s.toRelFixedPosition(n, i), e.ignoreScroll && s.toIgnoreScroll(n, i), e.ignoreMargins && s.toIgnoreMargins(i, e), i.left = Math.ceil(i.left), i.top = Math.ceil(i.top), delete i.x, delete i.y, i }, setPositionCoordinates: function (t, e, i) { var n = t.offset.y, s = t.offset.x, r = i == document.body ? window.getScroll() : i.getPosition(), o = r.y, a = r.x, r = window.getSize(); switch (t.position.x) { case "left": e.x = a + s; break; case "right": e.x = a + s + i.offsetWidth; break; default: e.x = a + (i == document.body ? r.x : i.offsetWidth) / 2 + s }switch (t.position.y) { case "top": e.y = o + n; break; case "bottom": e.y = o + n + i.offsetHeight; break; default: e.y = o + (i == document.body ? r.y : i.offsetHeight) / 2 + n } }, toMinMax: function (i, n) { var s, r = { left: "x", top: "y" };["minimum", "maximum"].each(function (e) { ["left", "top"].each(function (t) { null != (s = n[e] ? n[e][r[t]] : null) && ("minimum" == e ? i[t] < s : i[t] > s) && (i[t] = s) }) }) }, toRelFixedPosition: function (t, e) { var i = window.getScroll(); e.top += i.y, e.left += i.x }, toIgnoreScroll: function (t, e) { t = t.getScroll(); e.top -= t.y, e.left -= t.x }, toIgnoreMargins: function (t, e) { t.left += "right" == e.edge.x ? e.dimensions["margin-right"] : "center" != e.edge.x ? -e.dimensions["margin-left"] : -e.dimensions["margin-left"] + (e.dimensions["margin-right"] + e.dimensions["margin-left"]) / 2, t.top += "bottom" == e.edge.y ? e.dimensions["margin-bottom"] : "center" != e.edge.y ? -e.dimensions["margin-top"] : -e.dimensions["margin-top"] + (e.dimensions["margin-bottom"] + e.dimensions["margin-top"]) / 2 }, toEdge: function (t, e) { var i = {}, n = e.dimensions, e = e.edge; switch (e.x) { case "left": i.x = 0; break; case "right": i.x = -n.x - n.computedRight - n.computedLeft; break; default: i.x = -Math.round(n.totalWidth / 2) }switch (e.y) { case "top": i.y = 0; break; case "bottom": i.y = -n.y - n.computedTop - n.computedBottom; break; default: i.y = -Math.round(n.totalHeight / 2) }t.x += i.x, t.y += i.y }, getCoordinateFromValue: function (t) { return "string" != typeOf(t) ? t : { x: (t = t.toLowerCase()).test("left") ? "left" : t.test("right") ? "right" : "center", y: t.test(/upper|top/) ? "top" : t.test("bottom") ? "bottom" : "center" } } }; Element.implement({ position: function (t) { if (t && (null != t.x || null != t.y)) return i ? i.apply(this, arguments) : this; var e = this.setStyle("position", "absolute").calculatePosition(t); return t && t.returnPos ? e : this.setStyles(e) }, calculatePosition: function (t) { return s.getPosition(this, t) } }) }(Element.prototype.position), Element.implement({ isDisplayed: function () { return "none" != this.getStyle("display") }, isVisible: function () { var t = this.offsetWidth, e = this.offsetHeight; return (0 != t || 0 != e) && (0 < t && 0 < e || "none" != this.style.display) }, toggle: function () { return this[this.isDisplayed() ? "hide" : "show"]() }, hide: function () { var t; try { t = this.getStyle("display") } catch (t) { } return "none" == t ? this : this.store("element:_originalDisplay", t || "").setStyle("display", "none") }, show: function (t) { return !t && this.isDisplayed() ? this : (t = t || this.retrieve("element:_originalDisplay") || "block", this.setStyle("display", "none" == t ? "block" : t)) }, swapClass: function (t, e) { return this.removeClass(t).addClass(e) } }), Document.implement({ clearSelection: function () { if (window.getSelection) { var t = window.getSelection(); t && t.removeAllRanges && t.removeAllRanges() } else if (document.selection && document.selection.empty) try { document.selection.empty() } catch (t) { } } }); var IframeShim = new Class({ Implements: [Options, Events, Class.Occlude], options: { className: "iframeShim", src: 'javascript:false;document.write("");', display: !1, zIndex: null, margin: 0, offset: { x: 0, y: 0 }, browsers: Browser.ie6 || Browser.firefox && Browser.version < 3 && Browser.Platform.mac }, property: "IframeShim", initialize: function (t, e) { return this.element = document.id(t), this.occlude() ? this.occluded : (this.setOptions(e), this.makeShim(), this) }, makeShim: function () { var t, e; this.options.browsers ? ((e = this.element.getStyle("zIndex").toInt()) || (e = 1, "static" != (t = this.element.getStyle("position")) && t || this.element.setStyle("position", "relative"), this.element.setStyle("zIndex", e)), (e = (null != this.options.zIndex || 0 === this.options.zIndex) && e > this.options.zIndex ? this.options.zIndex : e - 1) < 0 && (e = 1), this.shim = new Element("iframe", { src: this.options.src, scrolling: "no", frameborder: 0, styles: { zIndex: e, position: "absolute", border: "none", filter: "progid:DXImageTransform.Microsoft.Alpha(style=0,opacity=0)" }, class: this.options.className }).store("IframeShim", this), e = function () { this.shim.inject(this.element, "after"), this[this.options.display ? "show" : "hide"](), this.fireEvent("inject") }.bind(this), IframeShim.ready ? e() : window.addEvent("load", e)) : this.position = this.hide = this.show = this.dispose = Function.from(this) }, position: function () { if (!IframeShim.ready || !this.shim) return this; var t = this.element.measure(function () { return this.getSize() }); return null != this.options.margin && (t.x = t.x - 2 * this.options.margin, t.y = t.y - 2 * this.options.margin, this.options.offset.x += this.options.margin, this.options.offset.y += this.options.margin), this.shim.set({ width: t.x, height: t.y }).position({ relativeTo: this.element, offset: this.options.offset }), this }, hide: function () { return this.shim && this.shim.setStyle("display", "none"), this }, show: function () { return this.shim && this.shim.setStyle("display", "block"), this.position() }, dispose: function () { return this.shim && this.shim.dispose(), this }, destroy: function () { return this.shim && this.shim.destroy(), this } }); window.addEvent("load", function () { IframeShim.ready = !0 }); var Mask = new Class({ Implements: [Options, Events], Binds: ["position"], options: { style: {}, class: "mask", maskMargins: !1, useIframeShim: !0, iframeShimOptions: {} }, initialize: function (t, e) { this.target = document.id(t) || document.id(document.body), this.target.store("mask", this), this.setOptions(e), this.render(), this.inject() }, render: function () { this.element = new Element("div", { class: this.options.class, id: this.options.id || "mask-" + String.uniqueID(), styles: Object.merge({}, this.options.style, { display: "none" }), events: { click: function (t) { this.fireEvent("click", t), this.options.hideOnClick && this.hide() }.bind(this) } }), this.hidden = !0 }, toElement: function () { return this.element }, inject: function (t, e) { e = e || this.options.inject && this.options.inject.where || this.target == document.body ? "inside" : "after", t = t || this.options.inject && this.options.inject.target || this.target, this.element.inject(t, e), this.options.useIframeShim && (this.shim = new IframeShim(this.element, this.options.iframeShimOptions), this.addEvents({ show: this.shim.show.bind(this.shim), hide: this.shim.hide.bind(this.shim), destroy: this.shim.destroy.bind(this.shim) })) }, position: function () { return this.resize(this.options.width, this.options.height), this.element.position({ relativeTo: this.target, position: "topLeft", ignoreMargins: !this.options.maskMargins, ignoreScroll: this.target == document.body }), this }, resize: function (t, e) { var i = { styles: ["padding", "border"] }; this.options.maskMargins && i.styles.push("margin"); var n = this.target.getComputedSize(i); return this.target == document.body && (this.element.setStyles({ width: 0, height: 0 }), i = window.getScrollSize(), n.totalHeight < i.y && (n.totalHeight = i.y), n.totalWidth < i.x && (n.totalWidth = i.x)), this.element.setStyles({ width: Array.pick([t, n.totalWidth, n.x]), height: Array.pick([e, n.totalHeight, n.y]) }), this }, show: function () { return this.hidden && (window.addEvent("resize", this.position), this.position(), this.showMask.apply(this, arguments)), this }, showMask: function () { this.element.setStyle("display", "block"), this.hidden = !1, this.fireEvent("show") }, hide: function () { return this.hidden ? this : (window.removeEvent("resize", this.position), this.hideMask.apply(this, arguments), this.options.destroyOnHide ? this.destroy() : this) }, hideMask: function () { this.element.setStyle("display", "none"), this.hidden = !0, this.fireEvent("hide") }, toggle: function () { this[this.hidden ? "show" : "hide"]() }, destroy: function () { this.hide(), this.element.destroy(), this.fireEvent("destroy"), this.target.eliminate("mask") } }); Element.Properties.mask = { set: function (t) { var e = this.retrieve("mask"); return e && e.destroy(), this.eliminate("mask").store("mask:options", t) }, get: function () { var t = this.retrieve("mask"); return t || (t = new Mask(this, this.retrieve("mask:options")), this.store("mask", t)), t } }, Element.implement({ mask: function (t) { return t && this.set("mask", t), this.get("mask").show(), this }, unmask: function () { return this.get("mask").hide(), this } }); var Spinner = new Class({ Extends: Mask, Implements: Chain, options: { class: "spinner", containerPosition: {}, content: { class: "spinner-content" }, messageContainer: { class: "spinner-msg" }, img: { class: "spinner-img" }, fxOptions: { link: "chain" } }, initialize: function (t, e) { this.target = document.id(t) || document.id(document.body), this.target.store("spinner", this), this.setOptions(e), this.render(), this.inject(); e = function () { this.active = !1 }.bind(this); this.addEvents({ hide: e, show: e }) }, render: function () { this.parent(), this.element.set("id", this.options.id || "spinner-" + String.uniqueID()), this.content = document.id(this.options.content) || new Element("div", this.options.content), this.content.inject(this.element), this.options.message && (this.msg = document.id(this.options.message) || new Element("p", this.options.messageContainer).appendText(this.options.message), this.msg.inject(this.content)), this.options.img && (this.img = document.id(this.options.img) || new Element("div", this.options.img), this.img.inject(this.content)), this.element.set("tween", this.options.fxOptions) }, show: function (t) { return this.active ? this.chain(this.show.bind(this)) : this.hidden ? (this.active = !0, this.parent(t)) : (this.callChain.delay(20, this), this) }, showMask: function (t) { var e = function () { this.content.position(Object.merge({ relativeTo: this.element }, this.options.containerPosition)) }.bind(this); t ? (this.parent(), e()) : (this.options.style.opacity || (this.options.style.opacity = this.element.getStyle("opacity").toFloat()), this.element.setStyles({ display: "block", opacity: 0 }).tween("opacity", this.options.style.opacity), e(), this.hidden = !1, this.fireEvent("show"), this.callChain()) }, hide: function (t) { return this.active ? this.chain(this.hide.bind(this)) : this.hidden ? (this.callChain.delay(20, this), this) : (this.active = !0, this.parent(t)) }, hideMask: function (t) { if (t) return this.parent(); this.element.tween("opacity", 0).get("tween").chain(function () { this.element.setStyle("display", "none"), this.hidden = !0, this.fireEvent("hide"), this.callChain() }.bind(this)) }, destroy: function () { this.content.destroy(), this.parent(), this.target.eliminate("spinner") } }); Request = Class.refactor(Request, { options: { useSpinner: !1, spinnerOptions: {}, spinnerTarget: !1 }, initialize: function (t) { this._send = this.send, this.send = function (t) { var e = this.getSpinner(); return e ? e.chain(this._send.pass(t, this)).show() : this._send(t), this }, this.previous(t) }, getSpinner: function () { var t, e; return this.spinner || (t = document.id(this.options.spinnerTarget) || document.id(this.options.update), this.options.useSpinner && t && (t.set("spinner", this.options.spinnerOptions), e = this.spinner = t.get("spinner"), ["complete", "exception", "cancel"].each(function (t) { this.addEvent(t, e.hide.bind(e)) }, this))), this.spinner } }), Element.Properties.spinner = { set: function (t) { var e = this.retrieve("spinner"); return e && e.destroy(), this.eliminate("spinner").store("spinner:options", t) }, get: function () { var t = this.retrieve("spinner"); return t || (t = new Spinner(this, this.retrieve("spinner:options")), this.store("spinner", t)), t } }, Element.implement({ spin: function (t) { return t && this.set("spinner", t), this.get("spinner").show(), this }, unspin: function () { return this.get("spinner").hide(), this } }), window.Form || (window.Form = {}), Form.Request = new Class({ Binds: ["onSubmit", "onFormValidate"], Implements: [Options, Events, Class.Occlude], options: { requestOptions: { evalScripts: !0, useSpinner: !0, emulation: !1, link: "ignore" }, sendButtonClicked: !0, extraData: {}, resetForm: !0 }, property: "form.request", initialize: function (t, e, i) { if (this.element = document.id(t), this.occlude()) return this.occluded; this.setOptions(i).setTarget(e).attach() }, setTarget: function (t) { return this.target = document.id(t), this.request ? this.request.setOptions({ update: this.target }) : this.makeRequest(), this }, toElement: function () { return this.element }, makeRequest: function () { var r = this; return this.request = new Request.HTML(Object.merge({ update: this.target, emulation: !1, spinnerTarget: this.element, method: this.element.get("method") || "post" }, this.options.requestOptions)).addEvents({ success: function (e, i, n, s) { ["complete", "success"].each(function (t) { r.fireEvent(t, [r.target, e, i, n, s]) }) }, failure: function () { r.fireEvent("complete", arguments).fireEvent("failure", arguments) }, exception: function () { r.fireEvent("failure", arguments) } }), this.attachReset() }, attachReset: function () { return this.options.resetForm && this.request.addEvent("success", function () { Function.attempt(function () { this.element.reset() }.bind(this)), window.OverText && OverText.update() }.bind(this)), this }, attach: function (t) { var e = 0 != t ? "addEvent" : "removeEvent"; this.element[e]("click:relay(button, input[type=submit])", this.saveClickedButton.bind(this)); t = this.element.retrieve("validator"); return t ? t[e]("onFormValidate", this.onFormValidate) : this.element[e]("submit", this.onSubmit), this }, detach: function () { return this.attach(!1) }, enable: function () { return this.attach() }, disable: function () { return this.detach() }, onFormValidate: function (t, e, i) { var n; i && (n = this.element.retrieve("validator"), (t || n && !n.options.stopOnFailure) && (i.stop(), this.send())) }, onSubmit: function (t) { var e = this.element.retrieve("validator"); if (e) return this.element.removeEvent("submit", this.onSubmit), e.addEvent("onFormValidate", this.onFormValidate), void this.element.validate(); t && t.stop(), this.send() }, saveClickedButton: function (t, e) { var i = e.get("name"); i && this.options.sendButtonClicked && (this.options.extraData[i] = e.get("value") || !0, this.clickedCleaner = function () { delete this.options.extraData[i], this.clickedCleaner = function () { } }.bind(this)) }, clickedCleaner: function () { }, send: function () { var t = this.element.toQueryString().trim(), e = Object.toQueryString(this.options.extraData); return t ? t += "&" + e : t = e, this.fireEvent("send", [this.element, t.parseQueryString()]), this.request.send({ data: t, url: this.options.requestOptions.url || this.element.get("action") }), this.clickedCleaner(), this } }), Element.implement("formUpdate", function (t, e) { var i = this.retrieve("form.request"); return i ? (t && i.setTarget(t), e && i.setOptions(e).makeRequest()) : i = new Form.Request(this, t, e), i.send(), this }), function () { function n(t) { var e, i = t.options.hideInputs; return window.OverText && (e = [null], OverText.each(function (t) { e.include("." + t.options.labelClass) }), e && (i += e.join(", "))), i ? t.element.getElements(i) : null } Fx.Reveal = new Class({ Extends: Fx.Morph, options: { link: "cancel", styles: ["padding", "border", "margin"], transitionOpacity: !Browser.ie6, mode: "vertical", display: function () { return "tr" != this.element.get("tag") ? "block" : "table-row" }, opacity: 1, hideInputs: Browser.ie ? "select, input, textarea, object, embed" : null }, dissolve: function () { var t, i, e; return this.hiding || this.showing ? "chain" == this.options.link ? this.chain(this.dissolve.bind(this)) : "cancel" != this.options.link || this.hiding || (this.cancel(), this.dissolve()) : "none" != this.element.getStyle("display") ? (this.hiding = !0, this.showing = !1, this.hidden = !0, this.cssText = this.element.style.cssText, t = this.element.getComputedSize({ styles: this.options.styles, mode: this.options.mode }), this.options.transitionOpacity && (t.opacity = this.options.opacity), i = {}, Object.each(t, function (t, e) { i[e] = [t, 0] }), this.element.setStyles({ display: Function.from(this.options.display).call(this), overflow: "hidden" }), (e = n(this)) && e.setStyle("visibility", "hidden"), this.$chain.unshift(function () { this.hidden && (this.hiding = !1, this.element.style.cssText = this.cssText, this.element.setStyle("display", "none"), e && e.setStyle("visibility", "visible")), this.fireEvent("hide", this.element), this.callChain() }.bind(this)), this.start(i)) : (this.callChain.delay(10, this), this.fireEvent("complete", this.element), this.fireEvent("hide", this.element)), this }, reveal: function () { var t, i, e; return this.showing || this.hiding ? "chain" == this.options.link ? this.chain(this.reveal.bind(this)) : "cancel" != this.options.link || this.showing || (this.cancel(), this.reveal()) : "none" == this.element.getStyle("display") ? (this.hiding = !1, this.showing = !0, this.hidden = !1, this.cssText = this.element.style.cssText, this.element.measure(function () { t = this.element.getComputedSize({ styles: this.options.styles, mode: this.options.mode }) }.bind(this)), null != this.options.heightOverride && (t.height = this.options.heightOverride.toInt()), null != this.options.widthOverride && (t.width = this.options.widthOverride.toInt()), this.options.transitionOpacity && (this.element.setStyle("opacity", 0), t.opacity = this.options.opacity), i = { height: 0, display: Function.from(this.options.display).call(this) }, Object.each(t, function (t, e) { i[e] = 0 }), i.overflow = "hidden", this.element.setStyles(i), (e = n(this)) && e.setStyle("visibility", "hidden"), this.$chain.unshift(function () { this.element.style.cssText = this.cssText, this.element.setStyle("display", Function.from(this.options.display).call(this)), this.hidden || (this.showing = !1), e && e.setStyle("visibility", "visible"), this.callChain(), this.fireEvent("show", this.element) }.bind(this)), this.start(t)) : (this.callChain(), this.fireEvent("complete", this.element), this.fireEvent("show", this.element)), this }, toggle: function () { return "none" == this.element.getStyle("display") ? this.reveal() : this.dissolve(), this }, cancel: function () { return this.parent.apply(this, arguments), null != this.cssText && (this.element.style.cssText = this.cssText), this.hiding = !1, this.showing = !1, this } }), Element.Properties.reveal = { set: function (t) { return this.get("reveal").cancel().setOptions(t), this }, get: function () { var t = this.retrieve("reveal"); return t || (t = new Fx.Reveal(this), this.store("reveal", t)), t } }, Element.Properties.dissolve = Element.Properties.reveal, Element.implement({ reveal: function (t) { return this.get("reveal").setOptions(t).reveal(), this }, dissolve: function (t) { return this.get("reveal").setOptions(t).dissolve(), this }, nix: function (t) { var e = Array.link(arguments, { destroy: Type.isBoolean, options: Type.isObject }); return this.get("reveal").setOptions(t).dissolve().chain(function () { this[e.destroy ? "destroy" : "dispose"]() }.bind(this)), this }, wink: function () { var t = Array.link(arguments, { duration: Type.isNumber, options: Type.isObject }), e = this.get("reveal").setOptions(t.options); e.reveal().chain(function () { (function () { e.dissolve() }).delay(t.duration || 2e3) }) } }) }(), Form.Request.Append = new Class({ Extends: Form.Request, options: { useReveal: !0, revealOptions: {}, inject: "bottom" }, makeRequest: function () { this.request = new Request.HTML(Object.merge({ url: this.element.get("action"), method: this.element.get("method") || "post", spinnerTarget: this.element }, this.options.requestOptions, { evalScripts: !1 })).addEvents({ success: function (t, e, i, n) { var s = Elements.from(i), r = 1 == s.length ? s[0] : new Element("div", { styles: { display: "none" } }).adopt(s); r.inject(this.target, this.options.inject), this.options.requestOptions.evalScripts && Browser.exec(n), this.fireEvent("beforeEffect", r); s = function () { this.fireEvent("success", [r, this.target, t, e, i, n]) }.bind(this); this.options.useReveal ? (r.set("reveal", this.options.revealOptions).get("reveal").chain(s), r.reveal()) : s() }.bind(this), failure: function (t) { this.fireEvent("failure", t) }.bind(this) }), this.attachReset() } }), Locale.define("en-US", "FormValidator", { required: "This field is required.", length: "Please enter {length} characters (you entered {elLength} characters)", minLength: "Please enter at least {minLength} characters (you entered {length} characters).", maxLength: "Please enter no more than {maxLength} characters (you entered {length} characters).", integer: "Please enter an integer in this field. Numbers with decimals (e.g. 1.25) are not permitted.", numeric: 'Please enter only numeric values in this field (i.e. "1" or "1.1" or "-1" or "-1.1").', digits: "Please use numbers and punctuation only in this field (for example, a phone number with dashes or dots is permitted).", alpha: "Please use only letters (a-z) within this field. No spaces or other characters are allowed.", alphanum: "Please use only letters (a-z) or numbers (0-9) in this field. No spaces or other characters are allowed.", dateSuchAs: "Please enter a valid date such as {date}", dateInFormatMDY: 'Please enter a valid date such as MM/DD/YYYY (i.e. "12/31/1999")', email: 'Please enter a valid email address. For example "fred@domain.com".', url: "Please enter a valid URL such as http://www.example.com.", currencyDollar: "Please enter a valid $ amount. For example $100.00 .", oneRequired: "Please enter something for at least one of these inputs.", errorPrefix: "Error: ", warningPrefix: "Warning: ", noSpace: "There can be no spaces in this input.", reqChkByNode: "No items are selected.", requiredChk: "This field is required.", reqChkByName: "Please select a {label}.", match: "This field needs to match the {matchName} field", startDate: "the start date", endDate: "the end date", currendDate: "the current date", afterDate: "The date should be the same or after {label}.", beforeDate: "The date should be the same or before {label}.", startMonth: "Please select a start month", sameMonth: "These two dates must be in the same month - you must change one or the other.", creditcard: "The credit card number entered is invalid. Please check the number and try again. {length} digits entered." }), window.Form || (window.Form = {}); var InputValidator = this.InputValidator = new Class({ Implements: [Options], options: { errorMsg: "Validation failed.", test: Function.from(!0) }, initialize: function (t, e) { this.setOptions(e), this.className = t }, test: function (t, e) { return !!(t = document.id(t)) && this.options.test(t, e || this.getProps(t)) }, getError: function (t, e) { t = document.id(t); var i = this.options.errorMsg; return "function" == typeOf(i) && (i = i(t, e || this.getProps(t))), i }, getProps: function (t) { return (t = document.id(t)) ? t.get("validatorProps") : {} } }); Element.Properties.validators = { get: function () { return (this.get("data-validators") || this.className).clean().split(" ") } }, Element.Properties.validatorProps = { set: function (t) { return this.eliminate("$moo:validatorProps").store("$moo:validatorProps", t) }, get: function (i) { if (i && this.set(i), this.retrieve("$moo:validatorProps")) return this.retrieve("$moo:validatorProps"); if (this.getProperty("data-validator-properties") || this.getProperty("validatorProps")) try { this.store("$moo:validatorProps", JSON.decode(this.getProperty("validatorProps") || this.getProperty("data-validator-properties"))) } catch (t) { return {} } else { var t = this.get("validators").filter(function (t) { return t.test(":") }); t.length ? (i = {}, t.each(function (t) { var e = t.split(":"); if (e[1]) try { i[e[0]] = JSON.decode(e[1]) } catch (t) { } }), this.store("$moo:validatorProps", i)) : this.store("$moo:validatorProps", {}) } return this.retrieve("$moo:validatorProps") } }, Form.Validator = new Class({ Implements: [Options, Events], Binds: ["onSubmit"], options: { fieldSelectors: "input, select, textarea", ignoreHidden: !0, ignoreDisabled: !0, useTitles: !1, evaluateOnSubmit: !0, evaluateFieldsOnBlur: !0, evaluateFieldsOnChange: !0, serial: !0, stopOnFailure: !0, warningPrefix: function () { return Form.Validator.getMsg("warningPrefix") || "Warning: " }, errorPrefix: function () { return Form.Validator.getMsg("errorPrefix") || "Error: " } }, initialize: function (t, e) { this.setOptions(e), this.element = document.id(t), this.element.store("validator", this), this.warningPrefix = Function.from(this.options.warningPrefix)(), this.errorPrefix = Function.from(this.options.errorPrefix)(), this.options.evaluateOnSubmit && this.element.addEvent("submit", this.onSubmit), (this.options.evaluateFieldsOnBlur || this.options.evaluateFieldsOnChange) && this.watchFields(this.getFields()) }, toElement: function () { return this.element }, getFields: function () { return this.fields = this.element.getElements(this.options.fieldSelectors) }, watchFields: function (t) { t.each(function (t) { this.options.evaluateFieldsOnBlur && t.addEvent("blur", this.validationMonitor.pass([t, !1], this)), this.options.evaluateFieldsOnChange && t.addEvent("change", this.validationMonitor.pass([t, !0], this)) }, this) }, validationMonitor: function () { clearTimeout(this.timer), this.timer = this.validateField.delay(50, this, arguments) }, onSubmit: function (t) { this.validate(t) && this.reset() }, reset: function () { return this.getFields().each(this.resetField, this), this }, validate: function (t) { var e = this.getFields().map(function (t) { return this.validateField(t, !0) }, this).every(function (t) { return t }); return this.fireEvent("formValidate", [e, this.element, t]), this.options.stopOnFailure && !e && t && t.preventDefault(), e }, validateField: function (e, t) { if (this.paused) return !0; var i, n, s, r = !(e = document.id(e)).hasClass("validation-failed"); return this.options.serial && !t && (n = this.element.getElement(".validation-failed"), i = this.element.getElement(".warning")), e && (!n || t || e.hasClass("validation-failed") || n && !this.options.serial) && (n = (t = e.get("validators")).some(function (t) { return this.getValidator(t) }, this), s = [], t.each(function (t) { t && !this.test(t, e) && s.include(t) }, this), r = 0 === s.length, n && !this.hasValidator(e, "warnOnly") && (r ? (e.addClass("validation-passed").removeClass("validation-failed"), this.fireEvent("elementPass", [e])) : (e.addClass("validation-failed").removeClass("validation-passed"), this.fireEvent("elementFail", [e, s]))), i || (t.some(function (t) { return t.test("^warn") ? this.getValidator(t.replace(/^warn-/, "")) : null }, this), e.removeClass("warning"), t.map(function (t) { return t.test("^warn") ? this.test(t.replace(/^warn-/, ""), e, !0) : null }, this))), r }, test: function (t, e, i) { if (e = document.id(e), this.options.ignoreHidden && !e.isVisible() || this.options.ignoreDisabled && e.get("disabled")) return !0; var n = this.getValidator(t); null != i && (i = !1), this.hasValidator(e, "warnOnly") && (i = !0); var s = this.hasValidator(e, "ignoreValidation") || !n || n.test(e); return n && e.isVisible() && this.fireEvent("elementValidate", [s, e, t, i]), !!i || s }, hasValidator: function (t, e) { return t.get("validators").contains(e) }, resetField: function (e) { return (e = document.id(e)) && e.get("validators").each(function (t) { t.test("^warn-") && (t = t.replace(/^warn-/, "")), e.removeClass("validation-failed"), e.removeClass("warning"), e.removeClass("validation-passed") }, this), this }, stop: function () { return this.paused = !0, this }, start: function () { return this.paused = !1, this }, ignoreField: function (t, e) { return (t = document.id(t)) && (this.enforceField(t), e ? t.addClass("warnOnly") : t.addClass("ignoreValidation")), this }, enforceField: function (t) { return (t = document.id(t)) && t.removeClass("warnOnly").removeClass("ignoreValidation"), this } }), Form.Validator.getMsg = function (t) { return Locale.get("FormValidator." + t) }, Form.Validator.adders = { validators: {}, add: function (t, e) { this.validators[t] = new InputValidator(t, e), this.initialize || this.implement({ validators: this.validators }) }, addAllThese: function (t) { Array.from(t).each(function (t) { this.add(t[0], t[1]) }, this) }, getValidator: function (t) { return this.validators[t.split(":")[0]] } }, Object.append(Form.Validator, Form.Validator.adders), Form.Validator.implement(Form.Validator.adders), Form.Validator.add("IsEmpty", { errorMsg: !1, test: function (t) { return "select-one" == t.type || "select" == t.type ? !(0 <= t.selectedIndex && "" != t.options[t.selectedIndex].value) : null == t.get("value") || 0 == t.get("value").length } }), Form.Validator.addAllThese([["required", { errorMsg: function () { return Form.Validator.getMsg("required") }, test: function (t) { return !Form.Validator.getValidator("IsEmpty").test(t) } }], ["length", { errorMsg: function (t, e) { return "null" != typeOf(e.length) ? Form.Validator.getMsg("length").substitute({ length: e.length, elLength: t.get("value").length }) : "" }, test: function (t, e) { return "null" == typeOf(e.length) || (t.get("value").length == e.length || 0 == t.get("value").length) } }], ["minLength", { errorMsg: function (t, e) { return "null" != typeOf(e.minLength) ? Form.Validator.getMsg("minLength").substitute({ minLength: e.minLength, length: t.get("value").length }) : "" }, test: function (t, e) { return "null" == typeOf(e.minLength) || t.get("value").length >= (e.minLength || 0) } }], ["maxLength", { errorMsg: function (t, e) { return "null" != typeOf(e.maxLength) ? Form.Validator.getMsg("maxLength").substitute({ maxLength: e.maxLength, length: t.get("value").length }) : "" }, test: function (t, e) { return t.get("value").length <= (e.maxLength || 1e4) } }], ["validate-integer", { errorMsg: Form.Validator.getMsg.pass("integer"), test: function (t) { return Form.Validator.getValidator("IsEmpty").test(t) || /^(-?[1-9]\d*|0)$/.test(t.get("value")) } }], ["validate-numeric", { errorMsg: Form.Validator.getMsg.pass("numeric"), test: function (t) { return Form.Validator.getValidator("IsEmpty").test(t) || /^-?(?:0$0(?=\d*\.)|[1-9]|0)\d*(\.\d+)?$/.test(t.get("value")) } }], ["validate-digits", { errorMsg: Form.Validator.getMsg.pass("digits"), test: function (t) { return Form.Validator.getValidator("IsEmpty").test(t) || /^[\d() .:\-\+#]+$/.test(t.get("value")) } }], ["validate-alpha", { errorMsg: Form.Validator.getMsg.pass("alpha"), test: function (t) { return Form.Validator.getValidator("IsEmpty").test(t) || /^[a-zA-Z]+$/.test(t.get("value")) } }], ["validate-alphanum", { errorMsg: Form.Validator.getMsg.pass("alphanum"), test: function (t) { return Form.Validator.getValidator("IsEmpty").test(t) || !/\W/.test(t.get("value")) } }], ["validate-date", { errorMsg: function (t, e) { if (Date.parse) { e = e.dateFormat || "%x"; return Form.Validator.getMsg("dateSuchAs").substitute({ date: (new Date).format(e) }) } return Form.Validator.getMsg("dateInFormatMDY") }, test: function (t, e) { if (Form.Validator.getValidator("IsEmpty").test(t)) return !0; var i = Locale.getCurrent().sets.Date, n = new RegExp([i.days, i.days_abbr, i.months, i.months_abbr].flatten().join("|"), "i"), s = t.get("value"), i = s.match(/[a-z]+/gi); if (i && !i.every(n.exec, n)) return !1; s = Date.parse(s), e = e.dateFormat || "%x", e = s.format(e); return "invalid date" != e && t.set("value", e), s.isValid() } }], ["validate-email", { errorMsg: Form.Validator.getMsg.pass("email"), test: function (t) { return Form.Validator.getValidator("IsEmpty").test(t) || /^(?:[a-z0-9!#$%&'*+\/=?^_`{|}~-]\.?){0,63}[a-z0-9!#$%&'*+\/=?^_`{|}~-]@(?:(?:[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?\.)*[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\])$/i.test(t.get("value").trim()) } }], ["validate-url", { errorMsg: Form.Validator.getMsg.pass("url"), test: function (t) { return Form.Validator.getValidator("IsEmpty").test(t) || /^(https?|ftp|rmtp|mms):\/\/(([A-Z0-9][A-Z0-9_-]*)(\.[A-Z0-9][A-Z0-9_-]*)+)(:(\d+))?\/?/i.test(t.get("value")) } }], ["validate-currency-dollar", { errorMsg: Form.Validator.getMsg.pass("currencyDollar"), test: function (t) { return Form.Validator.getValidator("IsEmpty").test(t) || /^\$?\-?([1-9]{1}[0-9]{0,2}(\,[0-9]{3})*(\.[0-9]{0,2})?|[1-9]{1}\d*(\.[0-9]{0,2})?|0(\.[0-9]{0,2})?|(\.[0-9]{1,2})?)$/.test(t.get("value")) } }], ["validate-one-required", { errorMsg: Form.Validator.getMsg.pass("oneRequired"), test: function (t, e) { return (document.id(e["validate-one-required"]) || t.getParent(e["validate-one-required"])).getElements("input").some(function (t) { return ["checkbox", "radio"].contains(t.get("type")) ? t.get("checked") : t.get("value") }) } }]]), Element.Properties.validator = { set: function (t) { this.get("validator").setOptions(t) }, get: function () { var t = this.retrieve("validator"); return t || (t = new Form.Validator(this), this.store("validator", t)), t } }, Element.implement({ validate: function (t) { return t && this.set("validator", t), this.get("validator").validate() } }); var FormValidator = Form.Validator; Form.Validator.Inline = new Class({ Extends: Form.Validator, options: { showError: function (t) { t.reveal ? t.reveal() : t.setStyle("display", "block") }, hideError: function (t) { t.dissolve ? t.dissolve() : t.setStyle("display", "none") }, scrollToErrorsOnSubmit: !0, scrollToErrorsOnBlur: !1, scrollToErrorsOnChange: !1, scrollFxOptions: { transition: "quad:out", offset: { y: -20 } } }, initialize: function (t, e) { this.parent(t, e), this.addEvent("onElementValidate", function (t, e, i, n) { var s = this.getValidator(i); !t && s.getError(e) ? (n && e.addClass("warning"), n = this.makeAdvice(i, e, s.getError(e), n), this.insertAdvice(n, e), this.showAdvice(i, e)) : this.hideAdvice(i, e) }) }, makeAdvice: function (t, e, i, n) { var s = n ? this.warningPrefix : this.errorPrefix; s += this.options.useTitles && e.title || i; i = n ? "warning-advice" : "validation-advice", n = (n = this.getAdvice(t, e)) ? n.set("html", s) : new Element("div", { html: s, styles: { display: "none" }, id: "advice-" + t.split(":")[0] + "-" + this.getFieldId(e) }).addClass(i); return e.store("$moo:advice-" + t, n), n }, getFieldId: function (t) { return t.id ? t.id : t.id = "input_" + t.name }, showAdvice: function (t, e) { var i = this.getAdvice(t, e); !i || e.retrieve("$moo:" + this.getPropName(t)) || "none" != i.getStyle("display") && "hidden" != i.getStyle("visiblity") && 0 != i.getStyle("opacity") || (e.store("$moo:" + this.getPropName(t), !0), this.options.showError(i), this.fireEvent("showAdvice", [e, i, t])) }, hideAdvice: function (t, e) { var i = this.getAdvice(t, e); i && e.retrieve("$moo:" + this.getPropName(t)) && (e.store("$moo:" + this.getPropName(t), !1), this.options.hideError(i), this.fireEvent("hideAdvice", [e, i, t])) }, getPropName: function (t) { return "advice" + t }, resetField: function (e) { return (e = document.id(e)) && (this.parent(e), e.get("validators").each(function (t) { this.hideAdvice(t, e) }, this)), this }, getAllAdviceMessages: function (i, t) { var n = []; if (i.hasClass("ignoreValidation") && !t) return n; i.get("validators").some(function (t) { var e = t.test("^warn-") || i.hasClass("warnOnly"); e && (t = t.replace(/^warn-/, "")); t = this.getValidator(t); t && n.push({ message: t.getError(i), warnOnly: e, passed: t.test(), validator: t }) }, this); return n }, getAdvice: function (t, e) { return e.retrieve("$moo:advice-" + t) }, insertAdvice: function (t, e) { var i = e.get("validatorProps"); i.msgPos && document.id(i.msgPos) ? document.id(i.msgPos).grab(t) : e.type && "radio" == e.type.toLowerCase() ? e.getParent().adopt(t) : t.inject(document.id(e), "after") }, validateField: function (t, e, i) { t = this.parent(t, e); if ((this.options.scrollToErrorsOnSubmit && null == i || i) && !t) { for (var e = document.id(this).getElement(".validation-failed"), n = document.id(this).getParent(); n != document.body && n.getScrollSize().y <= n.getSize().y;)n = n.getParent(); i = n.retrieve("$moo:fvScroller"); !i && window.Fx && Fx.Scroll && (i = new Fx.Scroll(n, this.options.scrollFxOptions), n.store("$moo:fvScroller", i)), e && (i ? i.toElement(e) : n.scrollTo(n.getScroll().x, e.getPosition(n).y - 20)) } return t }, watchFields: function (t) { t.each(function (t) { this.options.evaluateFieldsOnBlur && t.addEvent("blur", this.validationMonitor.pass([t, !1, this.options.scrollToErrorsOnBlur], this)), this.options.evaluateFieldsOnChange && t.addEvent("change", this.validationMonitor.pass([t, !0, this.options.scrollToErrorsOnChange], this)) }, this) } }), Form.Validator.addAllThese([["validate-enforce-oncheck", { test: function (e, t) { var i = e.getParent("form").retrieve("validator"); return i && (t.toEnforce || document.id(t.enforceChildrenOf).getElements("input, select, textarea")).map(function (t) { e.checked ? i.enforceField(t) : (i.ignoreField(t), i.resetField(t)) }), !0 } }], ["validate-ignore-oncheck", { test: function (e, t) { var i = e.getParent("form").retrieve("validator"); return i && (t.toIgnore || document.id(t.ignoreChildrenOf).getElements("input, select, textarea")).each(function (t) { e.checked ? (i.ignoreField(t), i.resetField(t)) : i.enforceField(t) }), !0 } }], ["validate-nospace", { errorMsg: function () { return Form.Validator.getMsg("noSpace") }, test: function (t, e) { return !t.get("value").test(/\s/) } }], ["validate-toggle-oncheck", { test: function (t, e) { var i = t.getParent("form").retrieve("validator"); if (!i) return !0; e = e.toToggle || document.id(e.toToggleChildrenOf).getElements("input, select, textarea"); return t.checked ? e.each(function (t) { i.enforceField(t) }) : e.each(function (t) { i.ignoreField(t), i.resetField(t) }), !0 } }], ["validate-reqchk-bynode", { errorMsg: function () { return Form.Validator.getMsg("reqChkByNode") }, test: function (t, e) { return document.id(e.nodeId).getElements(e.selector || "input[type=checkbox], input[type=radio]").some(function (t) { return t.checked }) } }], ["validate-required-check", { errorMsg: function (t, e) { return e.useTitle ? t.get("title") : Form.Validator.getMsg("requiredChk") }, test: function (t, e) { return !!t.checked } }], ["validate-reqchk-byname", { errorMsg: function (t, e) { return Form.Validator.getMsg("reqChkByName").substitute({ label: e.label || t.get("type") }) }, test: function (t, e) { var i = e.groupName || t.get("name"), e = $$(document.getElementsByName(i)).some(function (t, e) { return t.checked }), i = t.getParent("form").retrieve("validator"); return e && i && i.resetField(t), e } }], ["validate-match", { errorMsg: function (t, e) { return Form.Validator.getMsg("match").substitute({ matchName: e.matchName || document.id(e.matchInput).get("name") }) }, test: function (t, e) { t = t.get("value"), e = document.id(e.matchInput) && document.id(e.matchInput).get("value"); return !t || !e || t == e } }], ["validate-after-date", { errorMsg: function (t, e) { return Form.Validator.getMsg("afterDate").substitute({ label: e.afterLabel || (e.afterElement ? Form.Validator.getMsg("startDate") : Form.Validator.getMsg("currentDate")) }) }, test: function (t, e) { e = document.id(e.afterElement) ? Date.parse(document.id(e.afterElement).get("value")) : new Date, t = Date.parse(t.get("value")); return !t || !e || e <= t } }], ["validate-before-date", { errorMsg: function (t, e) { return Form.Validator.getMsg("beforeDate").substitute({ label: e.beforeLabel || (e.beforeElement ? Form.Validator.getMsg("endDate") : Form.Validator.getMsg("currentDate")) }) }, test: function (t, e) { t = Date.parse(t.get("value")), e = document.id(e.beforeElement) ? Date.parse(document.id(e.beforeElement).get("value")) : new Date; return !e || !t || t <= e } }], ["validate-custom-required", { errorMsg: function () { return Form.Validator.getMsg("required") }, test: function (t, e) { return t.get("value") != e.emptyValue } }], ["validate-same-month", { errorMsg: function (t, e) { e = document.id(e.sameMonthAs) && document.id(e.sameMonthAs).get("value"); if ("" != t.get("value")) return Form.Validator.getMsg(e ? "sameMonth" : "startMonth") }, test: function (t, e) { t = Date.parse(t.get("value")), e = Date.parse(document.id(e.sameMonthAs) && document.id(e.sameMonthAs).get("value")); return !t || !e || t.format("%B") == e.format("%B") } }], ["validate-cc-num", { errorMsg: function (t) { t = t.get("value").replace(/[^0-9]/g, ""); return Form.Validator.getMsg("creditcard").substitute({ length: t.length }) }, test: function (t) { if (Form.Validator.getValidator("IsEmpty").test(t)) return !0; var e = t.get("value"), i = !1; if ((e = e.replace(/[^0-9]/g, "")).test(/^4[0-9]{12}([0-9]{3})?$/) ? i = "Visa" : e.test(/^5[1-5]([0-9]{14})$/) ? i = "Master Card" : e.test(/^3[47][0-9]{13}$/) ? i = "American Express" : e.test(/^6(?:011|5[0-9]{2})[0-9]{12}$/) ? i = "Discover" : e.test(/^3(?:0[0-5]|[68][0-9])[0-9]{11}$/) && (i = "Diners Club"), i) { for (var n = 0, s = 0, r = e.length - 1; 0 <= r; --r)0 != (s = e.charAt(r).toInt()) && ((e.length - r) % 2 == 0 && (s += s), 9 < s && (s = s.toString().charAt(0).toInt() + s.toString().charAt(1).toInt()), n += s); if (n % 10 == 0) return !0 } for (var o = ""; "" != e;)o += " " + e.substr(0, 4), e = e.substr(4); return t.getParent("form").retrieve("validator").ignoreField(t), t.set("value", o.clean()), t.getParent("form").retrieve("validator").enforceField(t), !1 } }]]); var OverText = new Class({ Implements: [Options, Events, Class.Occlude], Binds: ["reposition", "assert", "focus", "hide"], options: { element: "label", labelClass: "overTxtLabel", positionOptions: { position: "upperLeft", edge: "upperLeft", offset: { x: 4, y: 2 } }, poll: !1, pollInterval: 250, wrap: !1 }, property: "OverText", initialize: function (t, e) { if (t = this.element = document.id(t), this.occlude()) return this.occluded; this.setOptions(e), this.attach(t), OverText.instances.push(this), this.options.poll && this.poll() }, toElement: function () { return this.element }, attach: function () { var t = this.element, e = this.options, i = e.textOverride || t.get("alt") || t.get("title"); if (!i) return this; i = this.text = new Element(e.element, { class: e.labelClass, styles: { lineHeight: "normal", position: "absolute", cursor: "text" }, html: i, events: { click: this.hide.pass("label" == e.element, this) } }).inject(t, "after"); return "label" == e.element && (t.get("id") || t.set("id", "input_" + String.uniqueID()), i.set("for", t.get("id"))), e.wrap && (this.textHolder = new Element("div.overTxtWrapper", { styles: { lineHeight: "normal", position: "relative" } }).grab(i).inject(t, "before")), this.enable() }, destroy: function () { return this.element.eliminate(this.property), this.disable(), this.text && this.text.destroy(), this.textHolder && this.textHolder.destroy(), this }, disable: function () { return this.element.removeEvents({ focus: this.focus, blur: this.assert, change: this.assert }), window.removeEvent("resize", this.reposition), this.hide(!0, !0), this }, enable: function () { return this.element.addEvents({ focus: this.focus, blur: this.assert, change: this.assert }), window.addEvent("resize", this.reposition), this.reposition(), this }, wrap: function () { "label" == this.options.element && (this.element.get("id") || this.element.set("id", "input_" + String.uniqueID()), this.text.set("for", this.element.get("id"))) }, startPolling: function () { return this.pollingPaused = !1, this.poll() }, poll: function (t) { return this.poller && !t || (t ? clearInterval(this.poller) : this.poller = function () { this.pollingPaused || this.assert(!0) }.periodical(this.options.pollInterval, this)), this }, stopPolling: function () { return this.pollingPaused = !0, this.poll(!0) }, focus: function () { return !this.text || this.text.isDisplayed() && !this.element.get("disabled") ? this.hide() : this }, hide: function (t, e) { if (this.text && this.text.isDisplayed() && (!this.element.get("disabled") || e) && (this.text.hide(), this.fireEvent("textHide", [this.text, this.element]), this.pollingPaused = !0, !t)) try { this.element.fireEvent("focus"), this.element.focus() } catch (t) { } return this }, show: function () { return this.text && !this.text.isDisplayed() && (this.text.show(), this.reposition(), this.fireEvent("textShow", [this.text, this.element]), this.pollingPaused = !1), this }, test: function () { return !this.element.get("value") }, assert: function (t) { return this[this.test() ? "show" : "hide"](t) }, reposition: function () { return this.assert(!0), this.element.isVisible() ? (this.text && this.test() && this.text.position(Object.merge(this.options.positionOptions, { relativeTo: this.element })), this) : this.stopPolling().hide() } }); OverText.instances = [], Object.append(OverText, { each: function (i) { return OverText.instances.each(function (t, e) { t.element && t.text && i.call(OverText, t, e) }) }, update: function () { return OverText.each(function (t) { return t.reposition() }) }, hideAll: function () { return OverText.each(function (t) { return t.hide(!0, !0) }) }, showAll: function () { return OverText.each(function (t) { return t.show() }) } }), Fx.Elements = new Class({ Extends: Fx.CSS, initialize: function (t, e) { this.elements = this.subject = $$(t), this.parent(e) }, compute: function (t, e, i) { var n, s = {}; for (n in t) { var r, o = t[n], a = e[n], h = s[n] = {}; for (r in o) h[r] = this.parent(o[r], a[r], i) } return s }, set: function (t) { for (var e in t) if (this.elements[e]) { var i, n = t[e]; for (i in n) this.render(this.elements[e], i, n[i], this.options.unit) } return this }, start: function (t) { if (!this.check(t)) return this; var e, i = {}, n = {}; for (e in t) if (this.elements[e]) { var s, r = t[e], o = i[e] = {}, a = n[e] = {}; for (s in r) { var h = this.prepare(this.elements[e], s, r[s]); o[s] = h.from, a[s] = h.to } } return this.parent(i, n) } }), Fx.Accordion = new Class({ Extends: Fx.Elements, options: { fixedHeight: !1, fixedWidth: !1, display: 0, show: !1, height: !0, width: !1, opacity: !0, alwaysHide: !1, trigger: "click", initialDisplayFx: !0, resetHeight: !0 }, initialize: function () { var t = function (t) { return null != t }, t = Array.link(arguments, { container: Type.isElement, options: Type.isObject, togglers: t, elements: t }); this.parent(t.elements, t.options); var n = this.options, s = this.togglers = $$(t.togglers); this.previous = -1, this.internalChain = new Chain, n.alwaysHide && (this.options.link = "chain"), !n.show && 0 !== this.options.show || (n.display = !1, this.previous = n.show), n.start && (n.display = !1, n.show = !1); var r = this.effects = {}; n.opacity && (r.opacity = "fullOpacity"), n.width && (r.width = n.fixedWidth ? "fullWidth" : "offsetWidth"), n.height && (r.height = n.fixedHeight ? "fullHeight" : "scrollHeight"); for (var e = 0, i = s.length; e < i; e++)this.addSection(s[e], this.elements[e]); this.elements.each(function (t, e) { if (n.show === e) this.fireEvent("active", [s[e], t]); else for (var i in r) t.setStyle(i, 0) }, this), !n.display && 0 !== n.display && !1 !== n.initialDisplayFx || this.display(n.display, n.initialDisplayFx), !1 !== n.fixedHeight && (n.resetHeight = !1), this.addEvent("complete", this.internalChain.callChain.bind(this.internalChain)) }, addSection: function (t, e) { t = document.id(t), e = document.id(e), this.togglers.include(t), this.elements.include(e); var i = this.togglers, n = this.options, s = i.contains(t), i = i.indexOf(t), i = this.display.pass(i, this); if (t.store("accordion:display", i).addEvent(n.trigger, i), n.height && e.setStyles({ "padding-top": 0, "border-top": "none", "padding-bottom": 0, "border-bottom": "none" }), n.width && e.setStyles({ "padding-left": 0, "border-left": "none", "padding-right": 0, "border-right": "none" }), e.fullOpacity = 1, n.fixedWidth && (e.fullWidth = n.fixedWidth), n.fixedHeight && (e.fullHeight = n.fixedHeight), e.setStyle("overflow", "hidden"), !s) for (var r in this.effects) e.setStyle(r, 0); return this }, removeSection: function (t, e) { var i = this.togglers, n = i.indexOf(t), s = this.elements[n], r = function () { i.erase(t), this.elements.erase(s), this.detach(t) }.bind(this); return this.now == n || null != e ? this.display(null != e ? e : 0 <= n - 1 ? n - 1 : 0).chain(r) : r(), this }, detach: function (t) { var e = function (t) { t.removeEvent(this.options.trigger, t.retrieve("accordion:display")) }.bind(this); return t ? e(t) : this.togglers.each(e), this }, display: function (s, r) { if (!this.check(s, r)) return this; var o = {}, e = this.elements, a = this.options, h = this.effects; if (null == r && (r = !0), "element" == typeOf(s) && (s = e.indexOf(s)), s == this.previous && !a.alwaysHide) return this; if (a.resetHeight) { var t = e[this.previous]; if (t && !this.selfHidden) for (var i in h) t.setStyle(i, t[h[i]]) } return this.timer && "chain" == a.link || s === this.previous && !a.alwaysHide ? this : (this.previous = s, this.selfHidden = !1, e.each(function (t, e) { var i, n; for (n in o[e] = {}, e != s ? i = !0 : a.alwaysHide && (0 < t.offsetHeight && a.height || 0 < t.offsetWidth && a.width) && (i = !0, this.selfHidden = !0), this.fireEvent(i ? "background" : "active", [this.togglers[e], t]), h) o[e][n] = i ? 0 : t[h[n]]; r || i || !a.resetHeight || (o[e].height = "auto") }, this), this.internalChain.clearChain(), this.internalChain.chain(function () { var t; !a.resetHeight || this.selfHidden || (t = e[s]) && t.setStyle("height", "auto") }.bind(this)), r ? this.start(o) : this.set(o).internalChain.callChain()) } }); var Accordion = new Class({ Extends: Fx.Accordion, initialize: function () { this.parent.apply(this, arguments); var t = Array.link(arguments, { container: Type.isElement }); this.container = t.container }, addSection: function (t, e, i) { t = document.id(t), e = document.id(e); var n = this.togglers.contains(t), s = this.togglers.length; return !s || n && !i ? this.container && !n && (t.inject(this.container), e.inject(this.container)) : (i = null != i ? i : s - 1, t.inject(this.togglers[i], "before"), e.inject(t, "after")), this.parent.apply(this, arguments) } }); Fx.Move = new Class({ Extends: Fx.Morph, options: { relativeTo: document.body, position: "center", edge: !1, offset: { x: 0, y: 0 } }, start: function (t) { var e = this.element, i = e.getStyles("top", "left"); return "auto" != i.top && "auto" != i.left || e.setPosition(e.getPosition(e.getOffsetParent())), this.parent(e.position(Object.merge({}, this.options, t, { returnPos: !0 }))) } }), Element.Properties.move = { set: function (t) { return this.get("move").cancel().setOptions(t), this }, get: function () { var t = this.retrieve("move"); return t || (t = new Fx.Move(this, { link: "cancel" }), this.store("move", t)), t } }, Element.implement({ move: function (t) { return this.get("move").start(t), this } }), Fx.Scroll = new Class({ Extends: Fx, options: { offset: { x: 0, y: 0 }, wheelStops: !0 }, initialize: function (t, e) { var i, n; this.element = this.subject = document.id(t), this.parent(e), "element" != typeOf(this.element) && (this.element = document.id(this.element.getDocument().body)), this.options.wheelStops && (i = this.element, n = this.cancel.pass(!1, this), this.addEvent("start", function () { i.addEvent("mousewheel", n) }, !0), this.addEvent("complete", function () { i.removeEvent("mousewheel", n) }, !0)) }, set: function () { var t = Array.flatten(arguments); return Browser.firefox && (t = [Math.round(t[0]), Math.round(t[1])]), this.element.scrollTo(t[0], t[1]), this }, compute: function (e, i, n) { return [0, 1].map(function (t) { return Fx.compute(e[t], i[t], n) }) }, start: function (t, e) { if (!this.check(t, e)) return this; var i = this.element.getScroll(); return this.parent([i.x, i.y], [t, e]) }, calculateScroll: function (t, e) { var i, n = this.element, s = n.getScrollSize(), r = n.getScroll(), o = n.getSize(), a = this.options.offset, h = { x: t, y: e }; for (i in h) h[i] || 0 === h[i] || (h[i] = r[i]), "number" != typeOf(h[i]) && (h[i] = s[i] - o[i]), h[i] += a[i]; return [h.x, h.y] }, toTop: function () { return this.start.apply(this, this.calculateScroll(!1, 0)) }, toLeft: function () { return this.start.apply(this, this.calculateScroll(0, !1)) }, toRight: function () { return this.start.apply(this, this.calculateScroll("right", !1)) }, toBottom: function () { return this.start.apply(this, this.calculateScroll(!1, "bottom")) }, toElement: function (t, i) { i = i ? Array.from(i) : ["x", "y"]; var n = /^(?:body|html)$/i.test(this.element.tagName) ? { x: 0, y: 0 } : this.element.getScroll(), t = Object.map(document.id(t).getPosition(this.element), function (t, e) { return !!i.contains(e) && t + n[e] }); return this.start.apply(this, this.calculateScroll(t.x, t.y)) }, toElementEdge: function (t, e, i) { e = e ? Array.from(e) : ["x", "y"], t = document.id(t); var n = {}, s = t.getPosition(this.element), t = t.getSize(), r = this.element.getScroll(), o = this.element.getSize(), a = { x: s.x + t.x, y: s.y + t.y }; return ["x", "y"].each(function (t) { e.contains(t) && (a[t] > r[t] + o[t] && (n[t] = a[t] - o[t]), s[t] < r[t] && (n[t] = s[t])), null == n[t] && (n[t] = r[t]), i && i[t] && (n[t] = n[t] + i[t]) }, this), n.x == r.x && n.y == r.y || this.start(n.x, n.y), this }, toElementCenter: function (t, e, i) { e = e ? Array.from(e) : ["x", "y"], t = document.id(t); var n = {}, s = t.getPosition(this.element), r = t.getSize(), o = this.element.getScroll(), a = this.element.getSize(); return ["x", "y"].each(function (t) { e.contains(t) && (n[t] = s[t] - (a[t] - r[t]) / 2), null == n[t] && (n[t] = o[t]), i && i[t] && (n[t] = n[t] + i[t]) }, this), n.x == o.x && n.y == o.y || this.start(n.x, n.y), this } }), Fx.Scroll.implement({ scrollToCenter: function () { return this.toElementCenter.apply(this, arguments) }, scrollIntoView: function () { return this.toElementEdge.apply(this, arguments) } }), Fx.Slide = new Class({ Extends: Fx, options: { mode: "vertical", wrapper: !1, hideOverflow: !0, resetHeight: !1 }, initialize: function (t, e) { t = this.element = this.subject = document.id(t), this.parent(e), e = this.options; var i = t.retrieve("wrapper"), n = t.getStyles("margin", "position", "overflow"); e.hideOverflow && (n = Object.append(n, { overflow: "hidden" })), e.wrapper && (i = document.id(e.wrapper).setStyles(n)), i = i || new Element("div", { styles: n }).wraps(t), t.store("wrapper", i).setStyle("margin", 0), "visible" == t.getStyle("overflow") && t.setStyle("overflow", "hidden"), this.now = [], this.open = !0, this.wrapper = i, this.addEvent("complete", function () { this.open = 0 != i["offset" + this.layout.capitalize()], this.open && this.options.resetHeight && i.setStyle("height", "") }, !0) }, vertical: function () { this.margin = "margin-top", this.layout = "height", this.offset = this.element.offsetHeight }, horizontal: function () { this.margin = "margin-left", this.layout = "width", this.offset = this.element.offsetWidth }, set: function (t) { return this.element.setStyle(this.margin, t[0]), this.wrapper.setStyle(this.layout, t[1]), this }, compute: function (e, i, n) { return [0, 1].map(function (t) { return Fx.compute(e[t], i[t], n) }) }, start: function (t, e) { if (!this.check(t, e)) return this; this[e || this.options.mode](); var i, n = this.element.getStyle(this.margin).toInt(), s = this.wrapper.getStyle(this.layout).toInt(), e = [[n, s], [0, this.offset]], n = [[n, s], [-this.offset, 0]]; switch (t) { case "in": i = e; break; case "out": i = n; break; case "toggle": i = 0 == s ? e : n }return this.parent(i[0], i[1]) }, slideIn: function (t) { return this.start("in", t) }, slideOut: function (t) { return this.start("out", t) }, hide: function (t) { return this[t || this.options.mode](), this.open = !1, this.set([-this.offset, 0]) }, show: function (t) { return this[t || this.options.mode](), this.open = !0, this.set([0, this.offset]) }, toggle: function (t) { return this.start("toggle", t) } }), Element.Properties.slide = { set: function (t) { return this.get("slide").cancel().setOptions(t), this }, get: function () { var t = this.retrieve("slide"); return t || (t = new Fx.Slide(this, { link: "cancel" }), this.store("slide", t)), t } }, Element.implement({ slide: function (t, e) { t = t || "toggle"; var i = this.get("slide"); switch (t) { case "hide": i.hide(e); break; case "show": i.show(e); break; case "toggle": var n = this.retrieve("slide:flag", i.open); i[n ? "slideOut" : "slideIn"](e), this.store("slide:flag", !n), n = !0; break; default: i.start(t, e) }return n || this.eliminate("slide:flag"), this } }); var SmoothScroll = Fx.SmoothScroll = new Class({ Extends: Fx.Scroll, options: { axes: ["x", "y"] }, initialize: function (t, e) { e = e || document, this.doc = e.getDocument(), this.parent(this.doc, t); var i = e.getWindow(), n = i.location.href.match(/^[^#]*/)[0] + "#"; $$(this.options.links || this.doc.links).each(function (t) { var e; 0 != t.href.indexOf(n) || (e = t.href.substr(n.length)) && this.useLink(t, e) }, this), this.addEvent("complete", function () { i.location.hash = this.anchor, this.element.scrollTo(this.to[0], this.to[1]) }, !0) }, useLink: function (i, n) { return i.addEvent("click", function (t) { var e = document.id(n) || this.doc.getElement("a[name=" + n + "]"); e && (t.preventDefault(), this.toElement(e, this.options.axes).chain(function () { this.fireEvent("scrolledTo", [i, e]) }.bind(this)), this.anchor = n) }.bind(this)), this } }); Fx.Sort = new Class({ Extends: Fx.Elements, options: { mode: "vertical" }, initialize: function (t, e) { this.parent(t, e), this.elements.each(function (t) { "static" == t.getStyle("position") && t.setStyle("position", "relative") }), this.setDefaultOrder() }, setDefaultOrder: function () { this.currentOrder = this.elements.map(function (t, e) { return e }) }, sort: function () { if (!this.check(arguments)) return this; var e = Array.flatten(arguments), s = 0, r = 0, i = {}, o = {}, a = "vertical" == this.options.mode, n = this.elements.map(function (t, e) { var i, n = t.getComputedSize({ styles: ["border", "padding", "margin"] }); a ? (i = { top: s, margin: n["margin-top"], height: n.totalHeight }, s += i.height - n["margin-top"]) : (i = { left: r, margin: n["margin-left"], width: n.totalWidth }, r += i.width); n = a ? "top" : "left"; o[e] = {}; t = t.getStyle(n).toInt(); return o[e][n] = t || 0, i }, this); this.set(o), (e = e.map(function (t) { return t.toInt() })).length != this.elements.length && (this.currentOrder.each(function (t) { e.contains(t) || e.push(t) }), e.length > this.elements.length && e.splice(this.elements.length - 1, e.length - this.elements.length)); var h = 0, s = r = 0; e.each(function (t) { var e = {}; a ? (e.top = s - n[t].top - h, s += n[t].height) : (e.left = r - n[t].left, r += n[t].width), h += n[t].margin, i[t] = e }, this); var l = {}; return Array.clone(e).sort().each(function (t) { l[t] = i[t] }), this.start(l), this.currentOrder = e, this }, rearrangeDOM: function (t) { t = t || this.currentOrder; var e = this.elements[0].getParent(), i = []; return this.elements.setStyle("opacity", 0), t.each(function (t) { i.push(this.elements[t].inject(e).setStyles({ top: 0, left: 0 })) }, this), this.elements.setStyle("opacity", 1), this.elements = $$(i), this.setDefaultOrder(), this }, getDefaultOrder: function () { return this.elements.map(function (t, e) { return e }) }, getCurrentOrder: function () { return this.currentOrder }, forward: function () { return this.sort(this.getDefaultOrder()) }, backward: function () { return this.sort(this.getDefaultOrder().reverse()) }, reverse: function () { return this.sort(this.currentOrder.reverse()) }, sortByElements: function (t) { return this.sort(t.map(function (t) { return this.elements.indexOf(t) }, this)) }, swap: function (t, e) { "element" == typeOf(t) && (t = this.elements.indexOf(t)), "element" == typeOf(e) && (e = this.elements.indexOf(e)); var i = Array.clone(this.currentOrder); return i[this.currentOrder.indexOf(t)] = e, i[this.currentOrder.indexOf(e)] = t, this.sort(i) } }); var Drag = new Class({ Implements: [Events, Options], options: { snap: 6, unit: "px", grid: !1, style: !0, limit: !1, handle: !1, invert: !1, preventDefault: !1, stopPropagation: !1, modifiers: { x: "left", y: "top" } }, initialize: function () { var t = Array.link(arguments, { options: Type.isObject, element: function (t) { return null != t } }); this.element = document.id(t.element), this.document = this.element.getDocument(), this.setOptions(t.options || {}); t = typeOf(this.options.handle); this.handles = ("array" == t || "collection" == t ? $$(this.options.handle) : document.id(this.options.handle)) || this.element, this.mouse = { now: {}, pos: {} }, this.value = { start: {}, now: {} }, this.selection = Browser.ie ? "selectstart" : "mousedown", Browser.ie && !Drag.ondragstartFixed && (document.ondragstart = Function.from(!1), Drag.ondragstartFixed = !0), this.bound = { start: this.start.bind(this), check: this.check.bind(this), drag: this.drag.bind(this), stop: this.stop.bind(this), cancel: this.cancel.bind(this), eventStop: Function.from(!1) }, this.attach() }, attach: function () { return this.handles.addEvent("mousedown", this.bound.start), this }, detach: function () { return this.handles.removeEvent("mousedown", this.bound.start), this }, start: function (t) { var e = this.options; if (!t.rightClick) { e.preventDefault && t.preventDefault(), e.stopPropagation && t.stopPropagation(), this.mouse.start = t.page, this.fireEvent("beforeStart", this.element); var i, n, s = e.limit; for (i in this.limit = { x: [], y: [] }, e.modifiers) if (e.modifiers[i]) { var r = this.element.getStyle(e.modifiers[i]); if (r && !r.match(/px$/) && (r = (n = n || this.element.getCoordinates(this.element.getOffsetParent()))[e.modifiers[i]]), e.style ? this.value.now[i] = (r || 0).toInt() : this.value.now[i] = this.element[e.modifiers[i]], e.invert && (this.value.now[i] *= -1), this.mouse.pos[i] = t.page[i] - this.value.now[i], s && s[i]) for (var o = 2; o--;) { var a = s[i][o]; !a && 0 !== a || (this.limit[i][o] = "function" == typeof a ? a() : a) } } "number" == typeOf(this.options.grid) && (this.options.grid = { x: this.options.grid, y: this.options.grid }); var h = { mousemove: this.bound.check, mouseup: this.bound.cancel }; h[this.selection] = this.bound.eventStop, this.document.addEvents(h) } }, check: function (t) { this.options.preventDefault && t.preventDefault(), Math.round(Math.sqrt(Math.pow(t.page.x - this.mouse.start.x, 2) + Math.pow(t.page.y - this.mouse.start.y, 2))) > this.options.snap && (this.cancel(), this.document.addEvents({ mousemove: this.bound.drag, mouseup: this.bound.stop }), this.fireEvent("start", [this.element, t]).fireEvent("snap", this.element)) }, drag: function (t) { var e, i = this.options; for (e in i.preventDefault && t.preventDefault(), this.mouse.now = t.page, i.modifiers) i.modifiers[e] && (this.value.now[e] = this.mouse.now[e] - this.mouse.pos[e], i.invert && (this.value.now[e] *= -1), i.limit && this.limit[e] && ((this.limit[e][1] || 0 === this.limit[e][1]) && this.value.now[e] > this.limit[e][1] ? this.value.now[e] = this.limit[e][1] : (this.limit[e][0] || 0 === this.limit[e][0]) && this.value.now[e] < this.limit[e][0] && (this.value.now[e] = this.limit[e][0])), i.grid[e] && (this.value.now[e] -= (this.value.now[e] - (this.limit[e][0] || 0)) % i.grid[e]), i.style ? this.element.setStyle(i.modifiers[e], this.value.now[e] + i.unit) : this.element[i.modifiers[e]] = this.value.now[e]); this.fireEvent("drag", [this.element, t]) }, cancel: function (t) { this.document.removeEvents({ mousemove: this.bound.check, mouseup: this.bound.cancel }), t && (this.document.removeEvent(this.selection, this.bound.eventStop), this.fireEvent("cancel", this.element)) }, stop: function (t) { var e = { mousemove: this.bound.drag, mouseup: this.bound.stop }; e[this.selection] = this.bound.eventStop, this.document.removeEvents(e), t && this.fireEvent("complete", [this.element, t]) } }); Element.implement({ makeResizable: function (t) { var e = new Drag(this, Object.merge({ modifiers: { x: "width", y: "height" } }, t)); return this.store("resizer", e), e.addEvent("drag", function () { this.fireEvent("resize", e) }.bind(this)) } }), Drag.Move = new Class({ Extends: Drag, options: { droppables: [], container: !1, precalculate: !1, includeMargins: !0, checkDroppables: !0 }, initialize: function (t, e) { var i; this.parent(t, e), t = this.element, this.droppables = $$(this.options.droppables), this.container = document.id(this.options.container), this.container && "element" != typeOf(this.container) && (this.container = document.id(this.container.getDocument().body)), this.options.style && ("left" == this.options.modifiers.x && "top" == this.options.modifiers.y && (i = t.getOffsetParent(), e = t.getStyles("left", "top"), !i || "auto" != e.left && "auto" != e.top || t.setPosition(t.getPosition(i))), "static" == t.getStyle("position") && t.setStyle("position", "absolute")), this.addEvent("start", this.checkDroppables, !0), this.overed = null }, start: function (t) { this.container && (this.options.limit = this.calculateLimit()), this.options.precalculate && (this.positions = this.droppables.map(function (t) { return t.getCoordinates() })), this.parent(t) }, calculateLimit: function () { var e = this.element, i = this.container, n = document.id(e.getOffsetParent()) || document.body, t = i.getCoordinates(n), s = {}, r = {}, o = {}, a = {}, h = {};["top", "right", "bottom", "left"].each(function (t) { s[t] = e.getStyle("margin-" + t).toInt(), r[t] = e.getStyle("border-" + t).toInt(), o[t] = i.getStyle("margin-" + t).toInt(), a[t] = i.getStyle("border-" + t).toInt(), h[t] = n.getStyle("padding-" + t).toInt() }, this); var l = e.offsetWidth + s.left + s.right, u = e.offsetHeight + s.top + s.bottom, c = 0, d = 0, f = t.right - a.right - l, l = t.bottom - a.bottom - u; return this.options.includeMargins ? (c += s.left, d += s.top) : (f += s.right, l += s.bottom), "relative" == e.getStyle("position") ? ((u = e.getCoordinates(n)).left -= e.getStyle("left").toInt(), u.top -= e.getStyle("top").toInt(), c -= u.left, d -= u.top, "relative" != i.getStyle("position") && (c += a.left, d += a.top), f += s.left - u.left, l += s.top - u.top, i != n && (c += o.left + h.left, d += (Browser.ie6 || Browser.ie7 ? 0 : o.top) + h.top)) : (c -= s.left, d -= s.top, i != n && (c += t.left + a.left, d += t.top + a.top)), { x: [c, f], y: [d, l] } }, getDroppableCoordinates: function (t) { var e = t.getCoordinates(); return "fixed" == t.getStyle("position") && (t = window.getScroll(), e.left += t.x, e.right += t.x, e.top += t.y, e.bottom += t.y), e }, checkDroppables: function () { var t = this.droppables.filter(function (t, e) { t = this.positions ? this.positions[e] : this.getDroppableCoordinates(t); e = this.mouse.now; return e.x > t.left && e.x < t.right && e.y < t.bottom && e.y > t.top }, this).getLast(); this.overed != t && (this.overed && this.fireEvent("leave", [this.element, this.overed]), t && this.fireEvent("enter", [this.element, t]), this.overed = t) }, drag: function (t) { this.parent(t), this.options.checkDroppables && this.droppables.length && this.checkDroppables() }, stop: function (t) { return this.checkDroppables(), this.fireEvent("drop", [this.element, this.overed, t]), this.overed = null, this.parent(t) } }), Element.implement({ makeDraggable: function (t) { t = new Drag.Move(this, t); return this.store("dragger", t), t } }); var Slider = new Class({ Implements: [Events, Options], Binds: ["clickedElement", "draggedKnob", "scrolledElement"], options: { onTick: function (t) { this.setKnobPosition(t) }, initialStep: 0, snap: !1, offset: 0, range: !1, wheel: !1, steps: 100, mode: "horizontal" }, initialize: function (t, e, i) { this.setOptions(i), i = this.options, this.element = document.id(t), e = this.knob = document.id(e); var n = {}, t = { x: !(this.previousChange = this.previousEnd = this.step = -1), y: !1 }; switch (i.mode) { case "vertical": this.axis = "y", this.property = "top", this.offset = "offsetHeight"; break; case "horizontal": this.axis = "x", this.property = "left", this.offset = "offsetWidth" }this.setSliderDimensions(), this.setRange(i.range), "static" == e.getStyle("position") && e.setStyle("position", "relative"), e.setStyle(this.property, -i.offset), t[this.axis] = this.property, n[this.axis] = [-i.offset, this.full - i.offset]; t = { snap: 0, limit: n, modifiers: t, onDrag: this.draggedKnob, onStart: this.draggedKnob, onBeforeStart: function () { this.isDragging = !0 }.bind(this), onCancel: function () { this.isDragging = !1 }.bind(this), onComplete: function () { this.isDragging = !1, this.draggedKnob(), this.end() }.bind(this) }; i.snap && this.setSnap(t), this.drag = new Drag(e, t), this.attach(), null != i.initialStep && this.set(i.initialStep) }, attach: function () { return this.element.addEvent("mousedown", this.clickedElement), this.options.wheel && this.element.addEvent("mousewheel", this.scrolledElement), this.drag.attach(), this }, detach: function () { return this.element.removeEvent("mousedown", this.clickedElement).removeEvent("mousewheel", this.scrolledElement), this.drag.detach(), this }, autosize: function () { return this.setSliderDimensions().setKnobPosition(this.toPosition(this.step)), this.drag.options.limit[this.axis] = [-this.options.offset, this.full - this.options.offset], this.options.snap && this.setSnap(), this }, setSnap: function (t) { return (t = t || this.drag.options).grid = Math.ceil(this.stepWidth), t.limit[this.axis][1] = this.full, this }, setKnobPosition: function (t) { return this.options.snap && (t = this.toPosition(this.step)), this.knob.setStyle(this.property, t), this }, setSliderDimensions: function () { return this.full = this.element.measure(function () { return this.half = this.knob[this.offset] / 2, this.element[this.offset] - this.knob[this.offset] + 2 * this.options.offset }.bind(this)), this }, set: function (t) { return 0 < this.range ^ t < this.min || (t = this.min), 0 < this.range ^ t > this.max || (t = this.max), this.step = Math.round(t), this.checkStep().fireEvent("tick", this.toPosition(this.step)).end() }, setRange: function (t, e) { return this.min = Array.pick([t[0], 0]), this.max = Array.pick([t[1], this.options.steps]), this.range = this.max - this.min, this.steps = this.options.steps || this.full, this.stepSize = Math.abs(this.range) / this.steps, this.stepWidth = this.stepSize * this.full / Math.abs(this.range), t && this.set(Array.pick([e, this.step]).floor(this.min).max(this.max)), this }, clickedElement: function (t) { var e; this.isDragging || t.target == this.knob || (e = this.range < 0 ? -1 : 1, t = (t = t.page[this.axis] - this.element.getPosition()[this.axis] - this.half).limit(-this.options.offset, this.full - this.options.offset), this.step = Math.round(this.min + e * this.toStep(t)), this.checkStep().fireEvent("tick", t).end()) }, scrolledElement: function (t) { var e = "horizontal" == this.options.mode ? t.wheel < 0 : 0 < t.wheel; this.set(this.step + (e ? -1 : 1) * this.stepSize), t.stop() }, draggedKnob: function () { var t = this.range < 0 ? -1 : 1, e = (e = this.drag.value.now[this.axis]).limit(-this.options.offset, this.full - this.options.offset); this.step = Math.round(this.min + t * this.toStep(e)), this.checkStep() }, checkStep: function () { var t = this.step; return this.previousChange != t && (this.previousChange = t, this.fireEvent("change", t)), this }, end: function () { var t = this.step; return this.previousEnd !== t && (this.previousEnd = t, this.fireEvent("complete", t + "")), this }, toStep: function (t) { t = (t + this.options.offset) * this.stepSize / this.full * this.steps; return this.options.steps ? Math.round(t -= t % this.stepSize) : t }, toPosition: function (t) { return this.full * Math.abs(this.min - t) / (this.steps * this.stepSize) - this.options.offset } }), Sortables = new Class({ Implements: [Events, Options], options: { opacity: 1, clone: !1, revert: !1, handle: !1, dragOptions: {}, snap: 4, constrain: !1, preventDefault: !1 }, initialize: function (t, e) { this.setOptions(e), this.elements = [], this.lists = [], this.idle = !0, this.addLists($$(document.id(t) || t)), this.options.clone || (this.options.revert = !1), this.options.revert && (this.effect = new Fx.Morph(null, Object.merge({ duration: 250, link: "cancel" }, this.options.revert))) }, attach: function () { return this.addLists(this.lists), this }, detach: function () { return this.lists = this.removeLists(this.lists), this }, addItems: function () { return Array.flatten(arguments).each(function (e) { this.elements.push(e); var t = e.retrieve("sortables:start", function (t) { this.start.call(this, t, e) }.bind(this)); (this.options.handle && e.getElement(this.options.handle) || e).addEvent("mousedown", t) }, this), this }, addLists: function () { return Array.flatten(arguments).each(function (t) { this.lists.include(t), this.addItems(t.getChildren()) }, this), this }, removeItems: function () { return $$(Array.flatten(arguments).map(function (t) { this.elements.erase(t); var e = t.retrieve("sortables:start"); return (this.options.handle && t.getElement(this.options.handle) || t).removeEvent("mousedown", e), t }, this)) }, removeLists: function () { return $$(Array.flatten(arguments).map(function (t) { return this.lists.erase(t), this.removeItems(t.getChildren()), t }, this)) }, getClone: function (t, i) { if (!this.options.clone) return new Element(i.tagName).inject(document.body); if ("function" == typeOf(this.options.clone)) return this.options.clone.call(this, t, i, this.list); t = i.clone(!0).setStyles({ margin: 0, position: "absolute", visibility: "hidden", width: i.getStyle("width") }).addEvent("mousedown", function (t) { i.fireEvent("mousedown", t) }); return t.get("html").test("radio") && t.getElements("input[type=radio]").each(function (t, e) { t.set("name", "clone_" + e), t.get("checked") && i.getElements("input[type=radio]")[e].set("checked", !0) }), t.inject(this.list).setPosition(i.getPosition(i.getOffsetParent())) }, getDroppables: function () { var t = this.list.getChildren().erase(this.clone).erase(this.element); return this.options.constrain || t.append(this.lists).erase(this.list), t }, insert: function (t, e) { var i = "inside"; this.lists.contains(e) ? (this.list = e, this.drag.droppables = this.getDroppables()) : i = this.element.getAllPrevious().contains(e) ? "before" : "after", this.element.inject(e, i), this.fireEvent("sort", [this.element, this.clone]) }, start: function (t, e) { !this.idle || t.rightClick || ["button", "input", "a", "textarea"].contains(t.target.get("tag")) || (this.idle = !1, this.element = e, this.opacity = e.getStyle("opacity"), this.list = e.getParent(), this.clone = this.getClone(t, e), this.drag = new Drag.Move(this.clone, Object.merge({ preventDefault: this.options.preventDefault, snap: this.options.snap, container: this.options.constrain && this.element.getParent(), droppables: this.getDroppables() }, this.options.dragOptions)).addEvents({ onSnap: function () { t.stop(), this.clone.setStyle("visibility", "visible"), this.element.setStyle("opacity", this.options.opacity || 0), this.fireEvent("start", [this.element, this.clone]) }.bind(this), onEnter: this.insert.bind(this), onCancel: this.end.bind(this), onComplete: this.end.bind(this) }), this.clone.inject(this.element, "before"), this.drag.start(t)) }, end: function () { var t, e, i, n; this.drag.detach(), this.element.setStyle("opacity", this.opacity), this.effect ? (t = this.element.getStyles("width", "height"), i = (e = this.clone).computePosition(this.element.getPosition(this.clone.getOffsetParent())), n = function () { this.removeEvent("cancel", n), e.destroy() }, this.effect.element = e, this.effect.start({ top: i.top, left: i.left, width: t.width, height: t.height, opacity: .25 }).addEvent("cancel", n).chain(n)) : this.clone.destroy(), this.reset() }, reset: function () { this.idle = !0, this.fireEvent("complete", this.element) }, serialize: function () { var e = Array.link(arguments, { modifier: Type.isFunction, index: function (t) { return null != t } }), t = this.lists.map(function (t) { return t.getChildren().map(e.modifier || function (t) { return t.get("id") }, this) }, this), i = e.index; return 1 == this.lists.length && (i = 0), (i || 0 === i) && 0 <= i && i < this.lists.length ? t[i] : t } }); Request.JSONP = new Class({ Implements: [Chain, Events, Options], options: { onRequest: function (t) { this.options.log && window.console && console.log && console.log("JSONP retrieving script with url:" + t) }, onError: function (t) { this.options.log && window.console && console.warn && console.warn("JSONP " + t + " will fail in Internet Explorer, which enforces a 2083 bytes length limit on URIs") }, url: "", callbackKey: "callback", injectScript: document.head, data: "", link: "ignore", timeout: 0, log: !1 }, initialize: function (t) { this.setOptions(t) }, send: function (t) { if (!Request.prototype.check.call(this, t)) return this; this.running = !0; var e = typeOf(t); "string" != e && "element" != e || (t = { data: t }); var i = (t = Object.merge(this.options, t || {})).data; switch (typeOf(i)) { case "element": i = document.id(i).toQueryString(); break; case "object": case "hash": i = Object.toQueryString(i) }var n = this.index = Request.JSONP.counter++, e = t.url + (t.url.test("\\?") ? "&" : "?") + t.callbackKey + "=Request.JSONP.request_map.request_" + n + (i ? "&" + i : ""); 2083 < e.length && this.fireEvent("error", e), Request.JSONP.request_map["request_" + n] = function () { this.success(arguments, n) }.bind(this); i = this.getScript(e).inject(t.injectScript); return this.fireEvent("request", [e, i]), t.timeout && this.timeout.delay(t.timeout, this), this }, getScript: function (t) { return this.script || (this.script = new Element("script", { type: "text/javascript", async: !0, src: t })), this.script }, success: function (t, e) { this.running && this.clear().fireEvent("complete", t).fireEvent("success", t).callChain() }, cancel: function () { return this.running && this.clear().fireEvent("cancel"), this }, isRunning: function () { return !!this.running }, clear: function () { return this.running = !1, this.script && (this.script.destroy(), this.script = null), this }, timeout: function () { return this.running && (this.running = !1, this.fireEvent("timeout", [this.script.get("src"), this.script]).fireEvent("failure").cancel()), this } }), Request.JSONP.counter = 0, Request.JSONP.request_map = {}, Request.Queue = new Class({ Implements: [Options, Events], Binds: ["attach", "request", "complete", "cancel", "success", "failure", "exception"], options: { stopOnFailure: !0, autoAdvance: !0, concurrent: 1, requests: {} }, initialize: function (t) { var e; t && (e = t.requests, delete t.requests), this.setOptions(t), this.requests = {}, this.queue = [], this.reqBinders = {}, e && this.addRequests(e) }, addRequest: function (t, e) { return this.requests[t] = e, this.attach(t, e), this }, addRequests: function (t) { return Object.each(t, function (t, e) { this.addRequest(e, t) }, this), this }, getName: function (t) { return Object.keyOf(this.requests, t) }, attach: function (e, i) { return i._groupSend || (["request", "complete", "cancel", "success", "failure", "exception"].each(function (t) { this.reqBinders[e] || (this.reqBinders[e] = {}), this.reqBinders[e][t] = function () { this["on" + t.capitalize()].apply(this, [e, i].append(arguments)) }.bind(this), i.addEvent(t, this.reqBinders[e][t]) }, this), i._groupSend = i.send, i.send = function (t) { return this.send(e, t), i }.bind(this)), this }, removeRequest: function (e) { var i = "object" == typeOf(e) ? this.getName(e) : e; return (i || "string" == typeOf(i)) && (e = this.requests[i]) && (["request", "complete", "cancel", "success", "failure", "exception"].each(function (t) { e.removeEvent(t, this.reqBinders[i][t]) }, this), e.send = e._groupSend, delete e._groupSend), this }, getRunning: function () { return Object.filter(this.requests, function (t) { return t.running }) }, isRunning: function () { return !!Object.keys(this.getRunning()).length }, send: function (t, e) { var i = function () { this.requests[t]._groupSend(e), this.queue.erase(i) }.bind(this); return i.name = t, Object.keys(this.getRunning()).length >= this.options.concurrent || this.error && this.options.stopOnFailure ? this.queue.push(i) : i(), this }, hasNext: function (e) { return e ? !!this.queue.filter(function (t) { return t.name == e }).length : !!this.queue.length }, resume: function () { return this.error = !1, (this.options.concurrent - Object.keys(this.getRunning()).length).times(this.runNext, this), this }, runNext: function (e) { return this.queue.length && (e ? this.queue.each(function (t) { i || t.name != e || (i = !0, t()) }) : this.queue[0]()), this; var i }, runAll: function () { return this.queue.each(function (t) { t() }), this }, clear: function (e) { return e ? this.queue = this.queue.map(function (t) { return t.name != e && t }).filter(function (t) { return t }) : this.queue.empty(), this }, cancel: function (t) { return this.requests[t].cancel(), this }, onRequest: function () { this.fireEvent("request", arguments) }, onComplete: function () { this.fireEvent("complete", arguments), this.queue.length || this.fireEvent("end") }, onCancel: function () { this.options.autoAdvance && !this.error && this.runNext(), this.fireEvent("cancel", arguments) }, onSuccess: function () { this.options.autoAdvance && !this.error && this.runNext(), this.fireEvent("success", arguments) }, onFailure: function () { this.error = !0, !this.options.stopOnFailure && this.options.autoAdvance && this.runNext(), this.fireEvent("failure", arguments) }, onException: function () { this.error = !0, !this.options.stopOnFailure && this.options.autoAdvance && this.runNext(), this.fireEvent("exception", arguments) } }), Request.implement({ options: { initialDelay: 5e3, delay: 5e3, limit: 6e4 }, startTimer: function (t) { function e() { this.running || this.send({ data: t }) } return this.lastDelay = this.options.initialDelay, this.timer = e.delay(this.lastDelay, this), this.completeCheck = function (t) { clearTimeout(this.timer), this.lastDelay = t ? this.options.delay : (this.lastDelay + this.options.delay).min(this.options.limit), this.timer = e.delay(this.lastDelay, this) }, this.addEvent("complete", this.completeCheck) }, stopTimer: function () { return clearTimeout(this.timer), this.removeEvent("complete", this.completeCheck) } }); var Asset = { javascript: function (t, e) { e = e || {}; var i = new Element("script", { src: t, type: "text/javascript" }), t = e.document || document, n = e.onload || e.onLoad; return delete e.onload, delete e.onLoad, delete e.document, n && (void 0 !== i.onreadystatechange ? i.addEvent("readystatechange", function () { ["loaded", "complete"].contains(this.readyState) && n.call(this) }) : i.addEvent("load", n)), i.set(e).inject(t.head) }, css: function (t, e) { e = e || {}; var i = new Element("link", { rel: "stylesheet", media: "screen", type: "text/css", href: t }), n = e.onload || e.onLoad, t = e.document || document; return delete e.onload, delete e.onLoad, delete e.document, n && i.addEvent("load", n), i.set(e).inject(t.head) }, image: function (t, s) { s = s || {}; var r = new Image, o = document.id(r) || new Element("img"); return ["load", "abort", "error"].each(function (t) { var e = "on" + t, i = "on" + t.capitalize(), n = s[e] || s[i] || function () { }; delete s[i], delete s[e], r[e] = function () { r && (o.parentNode || (o.width = r.width, o.height = r.height), r = r.onload = r.onabort = r.onerror = null, n.delay(1, o, o), o.fireEvent(t, o, 1)) } }), r.src = o.src = t, r && r.complete && r.onload.delay(1), o.set(s) }, images: function (i, n) { i = Array.from(i); function t() { } var s = 0; return n = Object.merge({ onComplete: t, onProgress: t, onError: t, properties: {} }, n), new Elements(i.map(function (t, e) { return Asset.image(t, Object.append(n.properties, { onload: function () { s++, n.onProgress.call(this, s, e, t), s == i.length && n.onComplete() }, onerror: function () { s++, n.onError.call(this, s, e, t), s == i.length && n.onComplete() } })) })) } }; !function () { var s = this.Color = new Type("Color", function (t, e) { switch (3 <= arguments.length ? (e = "rgb", t = Array.slice(arguments, 0, 3)) : "string" == typeof t && (t = t.match(/rgb/) ? t.rgbToHex().hexToRgb(!0) : t.match(/hsb/) ? t.hsbToRgb() : t.hexToRgb(!0)), e = e || "rgb") { case "hsb": e = t; (t = t.hsbToRgb()).hsb = e; break; case "hex": t = t.hexToRgb(!0) }return t.rgb = t.slice(0, 3), t.hsb = t.hsb || t.rgbToHsb(), t.hex = t.rgbToHex(), Object.append(t, this) }); s.implement({ mix: function () { var t = Array.slice(arguments), i = "number" == typeOf(t.getLast()) ? t.pop() : 50, n = this.slice(); return t.each(function (t) { t = new s(t); for (var e = 0; e < 3; e++)n[e] = Math.round(n[e] / 100 * (100 - i) + t[e] / 100 * i) }), new s(n, "rgb") }, invert: function () { return new s(this.map(function (t) { return 255 - t })) }, setHue: function (t) { return new s([t, this.hsb[1], this.hsb[2]], "hsb") }, setSaturation: function (t) { return new s([this.hsb[0], t, this.hsb[2]], "hsb") }, setBrightness: function (t) { return new s([this.hsb[0], this.hsb[1], t], "hsb") } }), this.$RGB = function (t, e, i) { return new s([t, e, i], "rgb") }, this.$HSB = function (t, e, i) { return new s([t, e, i], "hsb") }, this.$HEX = function (t) { return new s(t, "hex") }, Array.implement({ rgbToHsb: function () { var t, e, i = this[0], n = this[1], s = this[2], r = 0, o = Math.max(i, n, s), a = o - Math.min(i, n, s), h = o / 255, l = 0 != o ? a / o : 0; return 0 != l && (t = (o - i) / a, e = (o - n) / a, a = (o - s) / a, r = i == o ? a - e : n == o ? 2 + t - a : 4 + e - t, (r /= 6) < 0 && r++), [Math.round(360 * r), Math.round(100 * l), Math.round(100 * h)] }, hsbToRgb: function () { var t = Math.round(this[2] / 100 * 255); if (0 == this[1]) return [t, t, t]; var e = this[0] % 360, i = e % 60, n = Math.round(this[2] * (100 - this[1]) / 1e4 * 255), s = Math.round(this[2] * (6e3 - this[1] * i) / 6e5 * 255), i = Math.round(this[2] * (6e3 - this[1] * (60 - i)) / 6e5 * 255); switch (Math.floor(e / 60)) { case 0: return [t, i, n]; case 1: return [s, t, n]; case 2: return [n, t, i]; case 3: return [n, s, t]; case 4: return [i, n, t]; case 5: return [t, n, s] }return !1 } }), String.implement({ rgbToHsb: function () { var t = this.match(/\d{1,3}/g); return t ? t.rgbToHsb() : null }, hsbToRgb: function () { var t = this.match(/\d{1,3}/g); return t ? t.hsbToRgb() : null } }) }(), function () { this.Group = new Class({ initialize: function () { this.instances = Array.flatten(arguments) }, addEvent: function (i, n) { var s = this.instances, r = s.length, o = r, a = new Array(r), h = this; s.each(function (t, e) { t.addEvent(i, function () { a[e] || o--, a[e] = arguments, o || (n.call(h, s, t, a), o = r, a = new Array(r)) }) }) } }) }(), Hash.Cookie = new Class({ Extends: Cookie, options: { autoSave: !0 }, initialize: function (t, e) { this.parent(t, e), this.load() }, save: function () { var t = JSON.encode(this.hash); return !(!t || 4096 < t.length) && ("{}" == t ? this.dispose() : this.write(t), !0) }, load: function () { return this.hash = new Hash(JSON.decode(this.read(), !0)), this } }), Hash.each(Hash.prototype, function (e, t) { "function" == typeof e && Hash.Cookie.implement(t, function () { var t = e.apply(this.hash, arguments); return this.options.autoSave && this.save(), t }) }), function () { var t = this.Table = function () { this.length = 0; var s = [], r = []; this.set = function (t, e) { var i, n = s.indexOf(t); return -1 == n ? (i = s.length, s[i] = t, r[i] = e, this.length++) : r[n] = e, this }, this.get = function (t) { t = s.indexOf(t); return -1 == t ? null : r[t] }, this.erase = function (t) { t = s.indexOf(t); return -1 != t ? (this.length--, s.splice(t, 1), r.splice(t, 1)[0]) : null }, this.each = this.forEach = function (t, e) { for (var i = 0, n = this.length; i < n; i++)t.call(e, s[i], r[i], this) } }; this.Type && new Type("Table", t) }(); var HtmlTable = new Class({ Implements: [Options, Events, Class.Occlude], options: { properties: { cellpadding: 0, cellspacing: 0, border: 0 }, rows: [], headers: [], footers: [] }, property: "HtmlTable", initialize: function () { var t = Array.link(arguments, { options: Type.isObject, table: Type.isElement, id: Type.isString }); if (this.setOptions(t.options), !t.table && t.id && (t.table = document.id(t.id)), this.element = t.table || new Element("table", this.options.properties), this.occlude()) return this.occluded; this.build() }, build: function () { this.element.store("HtmlTable", this), this.body = document.id(this.element.tBodies[0]) || new Element("tbody").inject(this.element), $$(this.body.rows), this.options.headers.length ? this.setHeaders(this.options.headers) : this.thead = document.id(this.element.tHead), this.thead && (this.head = this.getHead()), this.options.footers.length && this.setFooters(this.options.footers), this.tfoot = document.id(this.element.tFoot), this.tfoot && (this.foot = document.id(this.tfoot.rows[0])), this.options.rows.each(function (t) { this.push(t) }, this) }, toElement: function () { return this.element }, empty: function () { return this.body.empty(), this }, set: function (t, e) { var i = "headers" == t ? "tHead" : "tFoot", n = i.toLowerCase(); this[n] = (document.id(this.element[i]) || new Element(n).inject(this.element, "top")).empty(); n = this.push(e, {}, this[n], "headers" == t ? "th" : "td"); return "headers" == t ? this.head = this.getHead() : this.foot = this.getHead(), n }, getHead: function () { var t = this.thead.rows; return 1 < t.length ? $$(t) : !!t.length && document.id(t[0]) }, setHeaders: function (t) { return this.set("headers", t), this }, setFooters: function (t) { return this.set("footers", t), this }, update: function (r, t, o) { var a = r.getChildren(o || "td"), h = a.length - 1; return t.each(function (t, e) { var i = a[e] || new Element(o || "td").inject(r), n = (t ? t.content : "") || t, s = typeOf(n); t && t.properties && i.set(t.properties), /(element(s?)|array|collection)/.test(s) ? i.empty().adopt(n) : i.set("html", n), h < e ? a.push(i) : a[e] = i }), { tr: r, tds: a } }, push: function (t, e, i, n, s) { return "element" == typeOf(t) && "tr" == t.get("tag") ? (t.inject(i || this.body, s), { tr: t, tds: t.getChildren("td") }) : this.update(new Element("tr", e).inject(i || this.body, s), t, n) }, pushMany: function (t, e, i, n, s) { return t.map(function (t) { return this.push(t, e, i, n, s) }, this) } });["adopt", "inject", "wraps", "grab", "replaces", "dispose"].each(function (t) { HtmlTable.implement(t, function () { return this.element[t].apply(this.element, arguments), this }) }), HtmlTable = Class.refactor(HtmlTable, { options: { classZebra: "table-tr-odd", zebra: !0, zebraOnlyVisibleRows: !0 }, initialize: function () { if (this.previous.apply(this, arguments), this.occluded) return this.occluded; this.options.zebra && this.updateZebras() }, updateZebras: function () { var e = 0; Array.each(this.body.rows, function (t) { this.options.zebraOnlyVisibleRows && !t.isDisplayed() || this.zebra(t, e++) }, this) }, setRowStyle: function (t, e) { this.previous && this.previous(t, e), this.zebra(t, e) }, zebra: function (t, e) { return t[(e % 2 ? "remove" : "add") + "Class"](this.options.classZebra) }, push: function () { var t = this.previous.apply(this, arguments); return this.options.zebra && this.updateZebras(), t } }), HtmlTable = Class.refactor(HtmlTable, { options: { sortIndex: 0, sortReverse: !1, parsers: [], defaultParser: "string", classSortable: "table-sortable", classHeadSort: "table-th-sort", classHeadSortRev: "table-th-sort-rev", classNoSort: "table-th-nosort", classGroupHead: "table-tr-group-head", classGroup: "table-tr-group", classCellSort: "table-td-sort", classSortSpan: "table-th-sort-span", sortable: !1, thSelector: "th" }, initialize: function () { if (this.previous.apply(this, arguments), this.occluded) return this.occluded; this.sorted = { index: null, dir: 1 }, this.bound || (this.bound = {}), this.bound.headClick = this.headClick.bind(this), this.sortSpans = new Elements, this.options.sortable && (this.enableSort(), null != this.options.sortIndex && this.sort(this.options.sortIndex, this.options.sortReverse)) }, attachSorts: function (t) { this.detachSorts(), !1 !== t && this.element.addEvent("click:relay(" + this.options.thSelector + ")", this.bound.headClick) }, detachSorts: function () { this.element.removeEvents("click:relay(" + this.options.thSelector + ")") }, setHeaders: function () { this.previous.apply(this, arguments), this.sortEnabled && this.setParsers() }, setParsers: function () { this.parsers = this.detectParsers() }, detectParsers: function () { return this.head && this.head.getElements(this.options.thSelector).flatten().map(this.detectParser, this) }, detectParser: function (t, o) { if (t.hasClass(this.options.classNoSort) || t.retrieve("htmltable-parser")) return t.retrieve("htmltable-parser"); var e = new Element("div"); e.adopt(t.childNodes).inject(t); e = new Element("span", { class: this.options.classSortSpan }).inject(e, "top"); this.sortSpans.push(e); var i, a = this.options.parsers[o], h = this.body.rows; switch (typeOf(a)) { case "function": a = { convert: a }, i = !0; break; case "string": i = !0 }return i || HtmlTable.ParserPriority.some(function (t) { var e = HtmlTable.Parsers[t], i = e.match; if (!i) return !1; for (var n = 0, s = h.length; n < s; n++) { var r = document.id(h[n].cells[o]), r = r ? r.get("html").clean() : ""; if (r && i.test(r)) return a = e, !0 } }), a = a || this.options.defaultParser, t.store("htmltable-parser", a), a }, headClick: function (t, e) { if (this.head && !e.hasClass(this.options.classNoSort)) return this.sort(Array.indexOf(this.head.getElements(this.options.thSelector).flatten(), e) % this.body.rows[0].cells.length) }, serialize: function () { var t = this.previous.apply(this, arguments) || {}; return this.options.sortable && (t.sortIndex = this.sorted.index, t.sortReverse = this.sorted.reverse), t }, restore: function (t) { this.options.sortable && t.sortIndex && this.sort(t.sortIndex, t.sortReverse), this.previous.apply(this, arguments) }, setSortedState: function (t, e) { null != e ? this.sorted.reverse = e : this.sorted.index == t ? this.sorted.reverse = !this.sorted.reverse : this.sorted.reverse = null == this.sorted.index, null != t && (this.sorted.index = t) }, setHeadSort: function (t) { var e = $$(this.head.length ? this.head.map(function (t) { return t.getElements(this.options.thSelector)[this.sorted.index] }, this).clean() : this.head.cells[this.sorted.index]); e.length && (t ? (e.addClass(this.options.classHeadSort), this.sorted.reverse ? e.addClass(this.options.classHeadSortRev) : e.removeClass(this.options.classHeadSortRev)) : e.removeClass(this.options.classHeadSort).removeClass(this.options.classHeadSortRev)) }, setRowSort: function (t, e) { for (var i, n, s = t.length, r = this.body; s;) { var o = t[--s], a = o.position, h = r.rows[a]; if (!h.disabled) for (e || (i = this.setGroupSort(i, h, o), this.setRowStyle(h, s)), r.appendChild(h), n = 0; n < s; n++)t[n].position > a && t[n].position-- } }, setRowStyle: function (t, e) { this.previous(t, e), t.cells[this.sorted.index].addClass(this.options.classCellSort) }, setGroupSort: function (t, e, i) { return t == i.value ? e.removeClass(this.options.classGroupHead).addClass(this.options.classGroup) : e.removeClass(this.options.classGroup).addClass(this.options.classGroupHead), i.value }, getParser: function () { var t = this.parsers[this.sorted.index]; return "string" == typeOf(t) ? HtmlTable.Parsers[t] : t }, sort: function (t, e, i) { if (this.head) { i || (this.clearSort(), this.setSortedState(t, e), this.setHeadSort(!0)); var n, t = this.getParser(); if (t) { Browser.ie || (n = this.body.getParent(), this.body.dispose()); e = this.parseData(t).sort(function (t, e) { return t.value === e.value ? 0 : t.value > e.value ? 1 : -1 }); return this.sorted.reverse == (t == HtmlTable.Parsers["input-checked"]) && e.reverse(!0), this.setRowSort(e, i), n && n.grab(this.body), this.fireEvent("stateChanged"), this.fireEvent("sort", [this.body, this.sorted.index]) } } }, parseData: function (i) { return Array.map(this.body.rows, function (t, e) { return { position: e, value: i.convert.call(document.id(t.cells[this.sorted.index])) } }, this) }, clearSort: function () { this.setHeadSort(!1), this.body.getElements("td").removeClass(this.options.classCellSort) }, reSort: function () { return this.sortEnabled && this.sort.call(this, this.sorted.index, this.sorted.reverse), this }, enableSort: function () { return this.element.addClass(this.options.classSortable), this.attachSorts(!0), this.setParsers(), this.sortEnabled = !0, this }, disableSort: function () { return this.element.removeClass(this.options.classSortable), this.attachSorts(!1), this.sortSpans.each(function (t) { t.destroy() }), this.sortSpans.empty(), this.sortEnabled = !1, this } }), HtmlTable.ParserPriority = ["date", "input-checked", "input-value", "float", "number"], HtmlTable.Parsers = { date: { match: /^\d{2}[-\/ ]\d{2}[-\/ ]\d{2,4}$/, convert: function () { var t = Date.parse(this.get("text").stripTags()); return "date" == typeOf(t) ? t.format("db") : "" }, type: "date" }, "input-checked": { match: / type="(radio|checkbox)" /, convert: function () { return this.getElement("input").checked } }, "input-value": { match: /<input/, convert: function () { return this.getElement("input").value } }, number: { match: /^\d+[^\d.,]*$/, convert: function () { return this.get("text").stripTags().toInt() }, number: !0 }, numberLax: { match: /^[^\d]+\d+$/, convert: function () { return this.get("text").replace(/[^-?^0-9]/, "").stripTags().toInt() }, number: !0 }, float: { match: /^[\d]+\.[\d]+/, convert: function () { return this.get("text").replace(/[^-?^\d.]/, "").stripTags().toFloat() }, number: !0 }, floatLax: { match: /^[^\d]+[\d]+\.[\d]+$/, convert: function () { return this.get("text").replace(/[^-?^\d.]/, "").stripTags() }, number: !0 }, string: { match: null, convert: function () { return this.get("text").stripTags().toLowerCase() } }, title: { match: null, convert: function () { return this.title } } }, HtmlTable.Parsers = new Hash(HtmlTable.Parsers), HtmlTable.defineParsers = function (t) { for (var e in HtmlTable.Parsers = Object.append(HtmlTable.Parsers, t), t) HtmlTable.ParserPriority.unshift(e) }, function () { var n = this.Keyboard = new Class({ Extends: Events, Implements: [Options], options: { defaultEventType: "keydown", active: !1, manager: null, events: {}, nonParsedEvents: ["activate", "deactivate", "onactivate", "ondeactivate", "changed", "onchanged"] }, initialize: function (t) { t && t.manager && (this._manager = t.manager, delete t.manager), this.setOptions(t), this._setup() }, addEvent: function (t, e, i) { return this.parent(n.parse(t, this.options.defaultEventType, this.options.nonParsedEvents), e, i) }, removeEvent: function (t, e) { return this.parent(n.parse(t, this.options.defaultEventType, this.options.nonParsedEvents), e) }, toggleActive: function () { return this[this.isActive() ? "deactivate" : "activate"]() }, activate: function (t) { if (t) { if (t.isActive()) return this; this._activeKB && t != this._activeKB && (this.previous = this._activeKB, this.previous.fireEvent("deactivate")), this._activeKB = t.fireEvent("activate"), n.manager.fireEvent("changed") } else this._manager && this._manager.activate(this); return this }, isActive: function () { return this._manager ? this._manager._activeKB == this : n.manager == this }, deactivate: function (t) { return t ? t === this._activeKB && (this._activeKB = null, t.fireEvent("deactivate"), n.manager.fireEvent("changed")) : this._manager && this._manager.deactivate(this), this }, relinquish: function () { return this.isActive() && this._manager && this._manager.previous ? this._manager.activate(this._manager.previous) : this.deactivate(), this }, manage: function (t) { return t._manager && t._manager.drop(t), this._instances.push(t), (t._manager = this)._activeKB || this.activate(t), this }, drop: function (t) { return t.relinquish(), this._instances.erase(t), this._activeKB == t && (this.previous && this._instances.contains(this.previous) ? this.activate(this.previous) : this._activeKB = this._instances[0]), this }, trace: function () { n.trace(this) }, each: function (t) { n.each(this, t) }, _instances: [], _disable: function (t) { this._activeKB == t && (this._activeKB = null) }, _setup: function () { this.addEvents(this.options.events), n.manager && !this._manager && n.manager.manage(this), this.options.active ? this.activate() : this.relinquish() }, _handle: function (t, e) { var i; t.preventKeyboardPropagation || ((i = !!this._manager) && this._activeKB && (this._activeKB._handle(t, e), t.preventKeyboardPropagation) || (this.fireEvent(e, t), !i && this._activeKB && this._activeKB._handle(t, e))) } }), o = {}, a = ["shift", "control", "alt", "meta"], h = /^(?:shift|control|ctrl|alt|meta)$/; n.parse = function (t, i, e) { return e && e.contains(t.toLowerCase()) ? t : (t = t.toLowerCase().replace(/^(keyup|keydown):/, function (t, e) { return i = e, "" }), o[t] || (s = {}, t.split("+").each(function (t) { h.test(t) ? s[t] = !0 : n = t }), s.control = s.control || s.ctrl, r = [], a.each(function (t) { s[t] && r.push(t) }), n && r.push(n), o[t] = r.join("+")), i + ":keys(" + o[t] + ")"); var n, s, r }, n.each = function (t, e) { for (var i = t || n.manager; i;)e.run(i), i = i._activeKB }, n.stop = function (t) { t.preventKeyboardPropagation = !0 }, n.manager = new n({ active: !0 }), n.trace = function (t) { t = t || n.manager; var e = window.console && console.log; e && console.log("the following items have focus: "), n.each(t, function (t) { e && console.log(document.id(t.widget) || t.wiget || t) }) }; function t(e) { var i = []; a.each(function (t) { e[t] && i.push(t) }), h.test(e.key) || i.push(e.key), n.manager._handle(e, e.type + ":keys(" + i.join("+") + ")") } document.addEvents({ keyup: t, keydown: t }) }(), Keyboard.prototype.options.nonParsedEvents.combine(["rebound", "onrebound"]), Keyboard.implement({ addShortcut: function (t, e) { return this._shortcuts = this._shortcuts || [], this._shortcutIndex = this._shortcutIndex || {}, e.getKeyboard = Function.from(this), e.name = t, this._shortcutIndex[t] = e, this._shortcuts.push(e), e.keys && this.addEvent(e.keys, e.handler), this }, addShortcuts: function (t) { for (var e in t) this.addShortcut(e, t[e]); return this }, removeShortcut: function (t) { var e = this.getShortcut(t); return e && e.keys && (this.removeEvent(e.keys, e.handler), delete this._shortcutIndex[t], this._shortcuts.erase(e)), this }, removeShortcuts: function (t) { return t.each(this.removeShortcut, this), this }, getShortcuts: function () { return this._shortcuts || [] }, getShortcut: function (t) { return (this._shortcutIndex || {})[t] } }), Keyboard.rebind = function (e, t) { Array.from(t).each(function (t) { t.getKeyboard().removeEvent(t.keys, t.handler), t.getKeyboard().addEvent(e, t.handler), t.keys = e, t.getKeyboard().fireEvent("rebound") }) }, Keyboard.getActiveShortcuts = function (t) { var e = [], i = []; return Keyboard.each(t, [].push.bind(e)), e.each(function (t) { i.extend(t.getShortcuts()) }), i }, Keyboard.getShortcut = function (e, t, i) { var n = (i = i || {}).many ? [] : null, i = i.many ? function (t) { t = t.getShortcut(e); t && n.push(t) } : function (t) { n = n || t.getShortcut(e) }; return Keyboard.each(t, i), n }, Keyboard.getShortcuts = function (t, e) { return Keyboard.getShortcut(t, e, { many: !0 }) }, HtmlTable = Class.refactor(HtmlTable, { options: { useKeyboard: !0, classRowSelected: "table-tr-selected", classRowHovered: "table-tr-hovered", classSelectable: "table-selectable", shiftForMultiSelect: !0, allowMultiSelect: !0, selectable: !1, selectHiddenRows: !1 }, initialize: function () { if (this.previous.apply(this, arguments), this.occluded) return this.occluded; this.selectedRows = new Elements, this.bound || (this.bound = {}), this.bound.mouseleave = this.mouseleave.bind(this), this.bound.clickRow = this.clickRow.bind(this), this.bound.activateKeyboard = function () { this.keyboard && this.selectEnabled && this.keyboard.activate() }.bind(this), this.options.selectable && this.enableSelect() }, empty: function () { return this.selectNone(), this.previous() }, enableSelect: function () { return this.selectEnabled = !0, this.attachSelects(), this.element.addClass(this.options.classSelectable), this }, disableSelect: function () { return this.selectEnabled = !1, this.attachSelects(!1), this.element.removeClass(this.options.classSelectable), this }, push: function () { var t = this.previous.apply(this, arguments); return this.updateSelects(), t }, toggleRow: function (t) { return this[(this.isSelected(t) ? "de" : "") + "selectRow"](t) }, selectRow: function (t, e) { if (!this.isSelected(t) && (e || this.body.getChildren().contains(t))) return this.options.allowMultiSelect || this.selectNone(), this.isSelected(t) || (this.selectedRows.push(t), t.addClass(this.options.classRowSelected), this.fireEvent("rowFocus", [t, this.selectedRows]), this.fireEvent("stateChanged")), this.focused = t, document.clearSelection(), this }, isSelected: function (t) { return this.selectedRows.contains(t) }, getSelected: function () { return this.selectedRows }, serialize: function () { var t = this.previous.apply(this, arguments) || {}; return this.options.selectable && (t.selectedRows = this.selectedRows.map(function (t) { return Array.indexOf(this.body.rows, t) }.bind(this))), t }, restore: function (t) { this.options.selectable && t.selectedRows && t.selectedRows.each(function (t) { this.selectRow(this.body.rows[t]) }.bind(this)), this.previous.apply(this, arguments) }, deselectRow: function (t, e) { if (this.isSelected(t) && (e || this.body.getChildren().contains(t))) return this.selectedRows = new Elements(Array.from(this.selectedRows).erase(t)), t.removeClass(this.options.classRowSelected), this.fireEvent("rowUnfocus", [t, this.selectedRows]), this.fireEvent("stateChanged"), this }, selectAll: function (t) { if (t || this.options.allowMultiSelect) return this.selectRange(0, this.body.rows.length, t), this }, selectNone: function () { return this.selectAll(!0) }, selectRange: function (t, e, i) { if (this.options.allowMultiSelect || i) { var n = i ? "deselectRow" : "selectRow", s = Array.clone(this.body.rows); "element" == typeOf(t) && (t = s.indexOf(t)), "element" == typeOf(e) && (e = s.indexOf(e)), (e = e < s.length - 1 ? e : s.length - 1) < t && (i = t, t = e, e = i); for (var r = t; r <= e; r++)(this.options.selectHiddenRows || s[r].isDisplayed()) && this[n](s[r], !0); return this } }, deselectRange: function (t, e) { this.selectRange(t, e, !0) }, enterRow: function (t) { this.hovered && (this.hovered = this.leaveRow(this.hovered)), this.hovered = t.addClass(this.options.classRowHovered) }, leaveRow: function (t) { t.removeClass(this.options.classRowHovered) }, updateSelects: function () { Array.each(this.body.rows, function (t) { var e = t.retrieve("binders"); (e || this.selectEnabled) && (e || (e = { mouseenter: this.enterRow.pass([t], this), mouseleave: this.leaveRow.pass([t], this) }, t.store("binders", e)), this.selectEnabled ? t.addEvents(e) : t.removeEvents(e)) }, this) }, shiftFocus: function (t, e) { if (!this.focused) return this.selectRow(this.body.rows[0], e); t = this.getRowByOffset(t, this.options.selectHiddenRows); if (null === t || this.focused == this.body.rows[t]) return this; this.toggleRow(this.body.rows[t], e) }, clickRow: function (t, e) { (t.shift || t.meta || t.control) && this.options.shiftForMultiSelect || t.rightClick && this.isSelected(e) && this.options.allowMultiSelect || this.selectNone(), t.rightClick ? this.selectRow(e) : this.toggleRow(e), t.shift && (this.selectRange(this.rangeStart || this.body.rows[0], e, !this.rangeStart || !this.isSelected(e)), this.focused = e), this.rangeStart = e }, getRowByOffset: function (t, e) { if (!this.focused) return 0; var i = Array.indexOf(this.body.rows, this.focused); if (0 == i && t < 0 || i == this.body.rows.length - 1 && 0 < t) return null; if (e) i += t; else { var n = 0; if (0 < t) for (; n < t && i < this.body.rows.length - 1;)this.body.rows[++i].isDisplayed() && n++; else for (; t < n && 0 < i;)this.body.rows[--i].isDisplayed() && n-- } return i }, attachSelects: function (t) { var s, r, e, i = (t = null == t || t) ? "addEvents" : "removeEvents"; this.element[i]({ mouseleave: this.bound.mouseleave, click: this.bound.activateKeyboard }), this.body[i]({ "click:relay(tr)": this.bound.clickRow, "contextmenu:relay(tr)": this.bound.clickRow }), (this.options.useKeyboard || this.keyboard) && (this.keyboard || (this.keyboard = new Keyboard), this.selectKeysDefined || (this.selectKeysDefined = !0, e = function (i) { var n = function (t) { clearTimeout(s), t.preventDefault(); var e = this.body.rows[this.getRowByOffset(i, this.options.selectHiddenRows)]; t.shift && e && this.isSelected(e) ? (this.deselectRow(this.focused), this.focused = e) : (!e || this.options.allowMultiSelect && t.shift || this.selectNone(), this.shiftFocus(i, t)), s = r ? n.delay(100, this, t) : function () { r = !0, n(t) }.delay(400) }.bind(this); return n }.bind(this), i = function () { clearTimeout(s), r = !1 }, this.keyboard.addEvents({ "keydown:shift+up": e(-1), "keydown:shift+down": e(1), "keyup:shift+up": i, "keyup:shift+down": i, "keyup:up": i, "keyup:down": i }), i = "", this.options.allowMultiSelect && this.options.shiftForMultiSelect && this.options.useKeyboard && (i = " (Shift multi-selects)."), this.keyboard.addShortcuts({ "Select Previous Row": { keys: "up", shortcut: "up arrow", handler: e(-1), description: "Select the previous row in the table." + i }, "Select Next Row": { keys: "down", shortcut: "down arrow", handler: e(1), description: "Select the next row in the table." + i } })), this.keyboard[t ? "activate" : "deactivate"]()), this.updateSelects() }, mouseleave: function () { this.hovered && this.leaveRow(this.hovered) } }); var Scroller = new Class({ Implements: [Events, Options], options: { area: 20, velocity: 1, onChange: function (t, e) { this.element.scrollTo(t, e) }, fps: 50 }, initialize: function (t, e) { this.setOptions(e), this.element = document.id(t), this.docBody = document.id(this.element.getDocument().body), this.listener = "element" != typeOf(this.element) ? this.docBody : this.element, this.timer = null, this.bound = { attach: this.attach.bind(this), detach: this.detach.bind(this), getCoords: this.getCoords.bind(this) } }, start: function () { return this.listener.addEvents({ mouseover: this.bound.attach, mouseleave: this.bound.detach }), this }, stop: function () { return this.listener.removeEvents({ mouseover: this.bound.attach, mouseleave: this.bound.detach }), this.detach(), this.timer = clearInterval(this.timer), this }, attach: function () { this.listener.addEvent("mousemove", this.bound.getCoords) }, detach: function () { this.listener.removeEvent("mousemove", this.bound.getCoords), this.timer = clearInterval(this.timer) }, getCoords: function (t) { this.page = "body" == this.listener.get("tag") ? t.client : t.page, this.timer || (this.timer = this.scroll.periodical(Math.round(1e3 / this.options.fps), this)) }, scroll: function () { var t, e = this.element.getSize(), i = this.element.getScroll(), n = this.element != this.docBody ? this.element.getOffsets() : { x: 0, y: 0 }, s = this.element.getScrollSize(), r = { x: 0, y: 0 }, o = this.options.area.top || this.options.area, a = this.options.area.bottom || this.options.area; for (t in this.page) this.page[t] < o + n[t] && 0 != i[t] ? r[t] = (this.page[t] - o - n[t]) * this.options.velocity : this.page[t] + a > e[t] + n[t] && i[t] + e[t] != s[t] && (r[t] = (this.page[t] - e[t] + a - n[t]) * this.options.velocity), r[t] = r[t].round(); (r.y || r.x) && this.fireEvent("change", [i.x + r.x, i.y + r.y]) } }); !function () { function n(t, e) { return t ? "function" == typeOf(t) ? t(e) : e.get(t) : "" } this.Tips = new Class({ Implements: [Events, Options], options: { onShow: function () { this.tip.setStyle("display", "block") }, onHide: function () { this.tip.setStyle("display", "none") }, title: "title", text: function (t) { return t.get("rel") || t.get("href") }, showDelay: 100, hideDelay: 100, className: "tip-wrap", offset: { x: 16, y: 16 }, windowPadding: { x: 0, y: 0 }, fixed: !1, waiAria: !0 }, initialize: function () { var t = Array.link(arguments, { options: Type.isObject, elements: function (t) { return null != t } }); this.setOptions(t.options), t.elements && this.attach(t.elements), this.container = new Element("div", { class: "tip" }), this.options.id && (this.container.set("id", this.options.id), this.options.waiAria && this.attachWaiAria()) }, toElement: function () { return this.tip || (this.tip = new Element("div", { class: this.options.className, styles: { position: "absolute", top: 0, left: 0 } }).adopt(new Element("div", { class: "tip-top" }), this.container, new Element("div", { class: "tip-bottom" }))), this.tip }, attachWaiAria: function () { var e = this.options.id; this.container.set("role", "tooltip"), this.waiAria || (this.waiAria = { show: function (t) { e && t.set("aria-describedby", e), this.container.set("aria-hidden", "false") }, hide: function (t) { e && t.erase("aria-describedby"), this.container.set("aria-hidden", "true") } }), this.addEvents(this.waiAria) }, detachWaiAria: function () { this.waiAria && (this.container.erase("role"), this.container.erase("aria-hidden"), this.removeEvents(this.waiAria)) }, attach: function (t) { return $$(t).each(function (i) { var t = n(this.options.title, i), e = n(this.options.text, i); i.set("title", "").store("tip:native", t).retrieve("tip:title", t), i.retrieve("tip:text", e), this.fireEvent("attach", [i]); e = ["enter", "leave"]; this.options.fixed || e.push("move"), e.each(function (e) { var t = (t = i.retrieve("tip:" + e)) || function (t) { this["element" + e.capitalize()].apply(this, [t, i]) }.bind(this); i.store("tip:" + e, t).addEvent("mouse" + e, t) }, this) }, this), this }, detach: function (t) { return $$(t).each(function (e) { var t;["enter", "leave", "move"].each(function (t) { e.removeEvent("mouse" + t, e.retrieve("tip:" + t)).eliminate("tip:" + t) }), this.fireEvent("detach", [e]), "title" != this.options.title || (t = e.retrieve("tip:native")) && e.set("title", t) }, this), this }, elementEnter: function (t, i) { clearTimeout(this.timer), this.timer = function () { this.container.empty(), ["title", "text"].each(function (t) { var e = i.retrieve("tip:" + t), t = this["_" + t + "Element"] = new Element("div", { class: "tip-" + t }).inject(this.container); e && this.fill(t, e) }, this), this.show(i), this.position(this.options.fixed ? { page: i.getPosition() } : t) }.delay(this.options.showDelay, this) }, elementLeave: function (t, e) { clearTimeout(this.timer), this.timer = this.hide.delay(this.options.hideDelay, this, e), this.fireForParent(t, e) }, setTitle: function (t) { return this._titleElement && (this._titleElement.empty(), this.fill(this._titleElement, t)), this }, setText: function (t) { return this._textElement && (this._textElement.empty(), this.fill(this._textElement, t)), this }, fireForParent: function (t, e) { (e = e.getParent()) && e != document.body && (e.retrieve("tip:enter") ? e.fireEvent("mouseenter", t) : this.fireForParent(t, e)) }, elementMove: function (t, e) { this.position(t) }, position: function (t) { this.tip || document.id(this); var e, i = window.getSize(), n = window.getScroll(), s = { x: this.tip.offsetWidth, y: this.tip.offsetHeight }, r = { x: "left", y: "top" }, o = { y: !1, x2: !1, y2: !1, x: !1 }, a = {}; for (e in r) a[r[e]] = t.page[e] + this.options.offset[e], a[r[e]] < 0 && (o[e] = !0), a[r[e]] + s[e] - n[e] > i[e] - this.options.windowPadding[e] && (a[r[e]] = t.page[e] - this.options.offset[e] - s[e], o[e + "2"] = !0); this.fireEvent("bound", o), this.tip.setStyles(a) }, fill: function (t, e) { "string" == typeof e ? t.set("html", e) : t.adopt(e) }, show: function (t) { this.tip || document.id(this), this.tip.getParent() || this.tip.inject(document.body), this.fireEvent("show", [this.tip, t]) }, hide: function (t) { this.tip || document.id(this), this.fireEvent("hide", [this.tip, t]) } }) }(), function () { var i = { json: JSON.decode }; Locale.Set.defineParser = function (t, e) { i[t] = e }, Locale.Set.from = function (t, e) { if (instanceOf(t, Locale.Set)) return t; e || "string" != typeOf(t) || (e = "json"), i[e] && (t = i[e](t)); e = new Locale.Set; return e.sets = t.sets || {}, t.inherits && (e.inherits.locales = Array.from(t.inherits.locales), e.inherits.sets = t.inherits.sets || {}), e } }(), Locale.define("de-DE", "Date", { months: ["Januar", "Februar", "März", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember"], months_abbr: ["Jan", "Feb", "Mär", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez"], days: ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"], days_abbr: ["So.", "Mo.", "Di.", "Mi.", "Do.", "Fr.", "Sa."], dateOrder: ["date", "month", "year"], shortDate: "%d.%m.%Y", shortTime: "%H:%M", AM: "vormittags", PM: "nachmittags", firstDayOfWeek: 1, ordinal: ".", lessThanMinuteAgo: "vor weniger als einer Minute", minuteAgo: "vor einer Minute", minutesAgo: "vor {delta} Minuten", hourAgo: "vor einer Stunde", hoursAgo: "vor {delta} Stunden", dayAgo: "vor einem Tag", daysAgo: "vor {delta} Tagen", weekAgo: "vor einer Woche", weeksAgo: "vor {delta} Wochen", monthAgo: "vor einem Monat", monthsAgo: "vor {delta} Monaten", yearAgo: "vor einem Jahr", yearsAgo: "vor {delta} Jahren", lessThanMinuteUntil: "in weniger als einer Minute", minuteUntil: "in einer Minute", minutesUntil: "in {delta} Minuten", hourUntil: "in ca. einer Stunde", hoursUntil: "in ca. {delta} Stunden", dayUntil: "in einem Tag", daysUntil: "in {delta} Tagen", weekUntil: "in einer Woche", weeksUntil: "in {delta} Wochen", monthUntil: "in einem Monat", monthsUntil: "in {delta} Monaten", yearUntil: "in einem Jahr", yearsUntil: "in {delta} Jahren" }), Locale.define("de-DE", "FormValidator", { required: "Dieses Eingabefeld muss ausgefüllt werden.", minLength: "Geben Sie bitte mindestens {minLength} Zeichen ein (Sie haben nur {length} Zeichen eingegeben).", maxLength: "Geben Sie bitte nicht mehr als {maxLength} Zeichen ein (Sie haben {length} Zeichen eingegeben).", integer: 'Geben Sie in diesem Eingabefeld bitte eine ganze Zahl ein. Dezimalzahlen (z.B. "1.25") sind nicht erlaubt.', numeric: 'Geben Sie in diesem Eingabefeld bitte nur Zahlenwerte (z.B. "1", "1.1", "-1" oder "-1.1") ein.', digits: "Geben Sie in diesem Eingabefeld bitte nur Zahlen und Satzzeichen ein (z.B. eine Telefonnummer mit Bindestrichen und Punkten ist erlaubt).", alpha: "Geben Sie in diesem Eingabefeld bitte nur Buchstaben (a-z) ein. Leerzeichen und andere Zeichen sind nicht erlaubt.", alphanum: "Geben Sie in diesem Eingabefeld bitte nur Buchstaben (a-z) und Zahlen (0-9) ein. Leerzeichen oder andere Zeichen sind nicht erlaubt.", dateSuchAs: 'Geben Sie bitte ein gültiges Datum ein (z.B. "{date}").', dateInFormatMDY: 'Geben Sie bitte ein gültiges Datum im Format TT.MM.JJJJ ein (z.B. "31.12.1999").', email: 'Geben Sie bitte eine gültige E-Mail-Adresse ein (z.B. "max@mustermann.de").', url: 'Geben Sie bitte eine gültige URL ein (z.B. "http://www.example.com").', currencyDollar: "Geben Sie bitte einen gültigen Betrag in EURO ein (z.B. 100.00€).", oneRequired: "Bitte füllen Sie mindestens ein Eingabefeld aus.", errorPrefix: "Fehler: ", warningPrefix: "Warnung: ", noSpace: "Es darf kein Leerzeichen in diesem Eingabefeld sein.", reqChkByNode: "Es wurden keine Elemente gewählt.", requiredChk: "Dieses Feld muss ausgefüllt werden.", reqChkByName: "Bitte wählen Sie ein {label}.", match: "Dieses Eingabefeld muss mit dem {matchName} Eingabefeld übereinstimmen.", startDate: "Das Anfangsdatum", endDate: "Das Enddatum", currendDate: "Das aktuelle Datum", afterDate: "Das Datum sollte zur gleichen Zeit oder später sein als {label}.", beforeDate: "Das Datum sollte zur gleichen Zeit oder früher sein als {label}.", startMonth: "Wählen Sie bitte einen Anfangsmonat", sameMonth: "Diese zwei Datumsangaben müssen im selben Monat sein - Sie müssen eines von beiden verändern.", creditcard: "Die eingegebene Kreditkartennummer ist ungültig. Bitte überprüfen Sie diese und versuchen Sie es erneut. {length} Zahlen eingegeben." }), Locale.define("EU", "Number", { decimal: ",", group: ".", currency: { prefix: "€ " } }), Locale.define("de-DE").inherit("EU", "Number"), Locale.define("en-GB", "Date", { dateOrder: ["date", "month", "year"], shortDate: "%d/%m/%Y", shortTime: "%H:%M" }).inherit("en-US", "Date"), Locale.define("es-ES", "Date", { months: ["Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio", "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"], months_abbr: ["ene", "feb", "mar", "abr", "may", "jun", "jul", "ago", "sep", "oct", "nov", "dic"], days: ["Domingo", "Lunes", "Martes", "Miércoles", "Jueves", "Viernes", "Sábado"], days_abbr: ["dom", "lun", "mar", "mié", "juv", "vie", "sáb"], dateOrder: ["date", "month", "year"], shortDate: "%d/%m/%Y", shortTime: "%H:%M", AM: "AM", PM: "PM", firstDayOfWeek: 1, ordinal: "", lessThanMinuteAgo: "hace menos de un minuto", minuteAgo: "hace un minuto", minutesAgo: "hace {delta} minutos", hourAgo: "hace una hora", hoursAgo: "hace unas {delta} horas", dayAgo: "hace un día", daysAgo: "hace {delta} días", weekAgo: "hace una semana", weeksAgo: "hace unas {delta} semanas", monthAgo: "hace un mes", monthsAgo: "hace {delta} meses", yearAgo: "hace un año", yearsAgo: "hace {delta} años", lessThanMinuteUntil: "menos de un minuto desde ahora", minuteUntil: "un minuto desde ahora", minutesUntil: "{delta} minutos desde ahora", hourUntil: "una hora desde ahora", hoursUntil: "unas {delta} horas desde ahora", dayUntil: "un día desde ahora", daysUntil: "{delta} días desde ahora", weekUntil: "una semana desde ahora", weeksUntil: "unas {delta} semanas desde ahora", monthUntil: "un mes desde ahora", monthsUntil: "{delta} meses desde ahora", yearUntil: "un año desde ahora", yearsUntil: "{delta} años desde ahora" }), Locale.define("es-ES", "FormValidator", { required: "Este campo es obligatorio.", minLength: "Por favor introduce al menos {minLength} caracteres (has introducido {length} caracteres).", maxLength: "Por favor introduce no m&aacute;s de {maxLength} caracteres (has introducido {length} caracteres).", integer: "Por favor introduce un n&uacute;mero entero en este campo. N&uacute;meros con decimales (p.e. 1,25) no se permiten.", numeric: 'Por favor introduce solo valores num&eacute;ricos en este campo (p.e. "1" o "1,1" o "-1" o "-1,1").', digits: "Por favor usa solo n&uacute;meros y puntuaci&oacute;n en este campo (por ejemplo, un n&uacute;mero de tel&eacute;fono con guiones y puntos no esta permitido).", alpha: "Por favor usa letras solo (a-z) en este campo. No se admiten espacios ni otros caracteres.", alphanum: "Por favor, usa solo letras (a-z) o n&uacute;meros (0-9) en este campo. No se admiten espacios ni otros caracteres.", dateSuchAs: "Por favor introduce una fecha v&aacute;lida como {date}", dateInFormatMDY: 'Por favor introduce una fecha v&aacute;lida como DD/MM/YYYY (p.e. "31/12/1999")', email: 'Por favor, introduce una direcci&oacute;n de email v&aacute;lida. Por ejemplo, "fred@domain.com".', url: "Por favor introduce una URL v&aacute;lida como http://www.example.com.", currencyDollar: "Por favor introduce una cantidad v&aacute;lida de €. Por ejemplo €100,00 .", oneRequired: "Por favor introduce algo para por lo menos una de estas entradas.", errorPrefix: "Error: ", warningPrefix: "Aviso: ", noSpace: "No pueden haber espacios en esta entrada.", reqChkByNode: "No hay elementos seleccionados.", requiredChk: "Este campo es obligatorio.", reqChkByName: "Por favor selecciona una {label}.", match: "Este campo necesita coincidir con el campo {matchName}", startDate: "la fecha de inicio", endDate: "la fecha de fin", currendDate: "la fecha actual", afterDate: "La fecha debe ser igual o posterior a {label}.", beforeDate: "La fecha debe ser igual o anterior a {label}.", startMonth: "Por favor selecciona un mes de origen", sameMonth: "Estas dos fechas deben estar en el mismo mes - debes cambiar una u otra." }), Locale.define("fr-FR", "Date", { months: ["Janvier", "Février", "Mars", "Avril", "Mai", "Juin", "Juillet", "Août", "Septembre", "Octobre", "Novembre", "Décembre"], months_abbr: ["janv.", "févr.", "mars", "avr.", "mai", "juin", "juil.", "août", "sept.", "oct.", "nov.", "déc."], days: ["Dimanche", "Lundi", "Mardi", "Mercredi", "Jeudi", "Vendredi", "Samedi"], days_abbr: ["dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam."], dateOrder: ["date", "month", "year"], shortDate: "%d/%m/%Y", shortTime: "%H:%M", AM: "AM", PM: "PM", firstDayOfWeek: 1, ordinal: function (t) { return 1 < t ? "" : "er" }, lessThanMinuteAgo: "il y a moins d'une minute", minuteAgo: "il y a une minute", minutesAgo: "il y a {delta} minutes", hourAgo: "il y a une heure", hoursAgo: "il y a {delta} heures", dayAgo: "il y a un jour", daysAgo: "il y a {delta} jours", weekAgo: "il y a une semaine", weeksAgo: "il y a {delta} semaines", monthAgo: "il y a 1 mois", monthsAgo: "il y a {delta} mois", yearthAgo: "il y a 1 an", yearsAgo: "il y a {delta} ans", lessThanMinuteUntil: "dans moins d'une minute", minuteUntil: "dans une minute", minutesUntil: "dans {delta} minutes", hourUntil: "dans une heure", hoursUntil: "dans {delta} heures", dayUntil: "dans un jour", daysUntil: "dans {delta} jours", weekUntil: "dans 1 semaine", weeksUntil: "dans {delta} semaines", monthUntil: "dans 1 mois", monthsUntil: "dans {delta} mois", yearUntil: "dans 1 an", yearsUntil: "dans {delta} ans" }), Locale.define("fr-FR", "FormValidator", { required: "Ce champ est obligatoire.", length: "Veuillez saisir {length} caract&egrave;re(s) (vous avez saisi {elLength} caract&egrave;re(s)", minLength: "Veuillez saisir un minimum de {minLength} caract&egrave;re(s) (vous avez saisi {length} caract&egrave;re(s)).", maxLength: "Veuillez saisir un maximum de {maxLength} caract&egrave;re(s) (vous avez saisi {length} caract&egrave;re(s)).", integer: 'Veuillez saisir un nombre entier dans ce champ. Les nombres d&eacute;cimaux (ex : "1,25") ne sont pas autoris&eacute;s.', numeric: 'Veuillez saisir uniquement des chiffres dans ce champ (ex : "1" ou "1,1" ou "-1" ou "-1,1").', digits: "Veuillez saisir uniquement des chiffres et des signes de ponctuation dans ce champ (ex : un num&eacute;ro de t&eacute;l&eacute;phone avec des traits d'union est autoris&eacute;).", alpha: "Veuillez saisir uniquement des lettres (a-z) dans ce champ. Les espaces ou autres caract&egrave;res ne sont pas autoris&eacute;s.", alphanum: "Veuillez saisir uniquement des lettres (a-z) ou des chiffres (0-9) dans ce champ. Les espaces ou autres caract&egrave;res ne sont pas autoris&eacute;s.", dateSuchAs: "Veuillez saisir une date correcte comme {date}", dateInFormatMDY: 'Veuillez saisir une date correcte, au format JJ/MM/AAAA (ex : "31/11/1999").', email: 'Veuillez saisir une adresse de courrier &eacute;lectronique. Par example "fred@domaine.com".', url: "Veuillez saisir une URL, comme http://www.example.com.", currencyDollar: "Veuillez saisir une quantit&eacute; correcte. Par example 100,00&euro;.", oneRequired: "Veuillez s&eacute;lectionner au moins une de ces options.", errorPrefix: "Erreur : ", warningPrefix: "Attention : ", noSpace: "Ce champ n'accepte pas les espaces.", reqChkByNode: "Aucun &eacute;l&eacute;ment n'est s&eacute;lectionn&eacute;.", requiredChk: "Ce champ est obligatoire.", reqChkByName: "Veuillez s&eacute;lectionner un(e) {label}.", match: "Ce champ doit correspondre avec le champ {matchName}.", startDate: "date de d&eacute;but", endDate: "date de fin", currendDate: "date actuelle", afterDate: "La date doit &ecirc;tre identique ou post&eacute;rieure &agrave; {label}.", beforeDate: "La date doit &ecirc;tre identique ou ant&eacute;rieure &agrave; {label}.", startMonth: "Veuillez s&eacute;lectionner un mois de d&eacute;but.", sameMonth: "Ces deux dates doivent &ecirc;tre dans le m&ecirc;me mois - vous devez en modifier une.", creditcard: "Le num&eacute;ro de carte de cr&eacute;dit est invalide. Merci de v&eacute;rifier le num&eacute;ro et de r&eacute;essayer. Vous avez entr&eacute; {length} chiffre(s)." }), Locale.define("fr-FR", "Number", { group: " " }).inherit("EU", "Number"), Locale.define("it-IT", "Date", { months: ["Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno", "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"], months_abbr: ["gen", "feb", "mar", "apr", "mag", "giu", "lug", "ago", "set", "ott", "nov", "dic"], days: ["Domenica", "Lunedì", "Martedì", "Mercoledì", "Giovedì", "Venerdì", "Sabato"], days_abbr: ["dom", "lun", "mar", "mer", "gio", "ven", "sab"], dateOrder: ["date", "month", "year"], shortDate: "%d/%m/%Y", shortTime: "%H.%M", AM: "AM", PM: "PM", firstDayOfWeek: 1, ordinal: "º", lessThanMinuteAgo: "meno di un minuto fa", minuteAgo: "circa un minuto fa", minutesAgo: "circa {delta} minuti fa", hourAgo: "circa un'ora fa", hoursAgo: "circa {delta} ore fa", dayAgo: "circa 1 giorno fa", daysAgo: "circa {delta} giorni fa", weekAgo: "una settimana fa", weeksAgo: "{delta} settimane fa", monthAgo: "un mese fa", monthsAgo: "{delta} mesi fa", yearAgo: "un anno fa", yearsAgo: "{delta} anni fa", lessThanMinuteUntil: "tra meno di un minuto", minuteUntil: "tra circa un minuto", minutesUntil: "tra circa {delta} minuti", hourUntil: "tra circa un'ora", hoursUntil: "tra circa {delta} ore", dayUntil: "tra circa un giorno", daysUntil: "tra circa {delta} giorni", weekUntil: "tra una settimana", weeksUntil: "tra {delta} settimane", monthUntil: "tra un mese", monthsUntil: "tra {delta} mesi", yearUntil: "tra un anno", yearsUntil: "tra {delta} anni" }), Locale.define("it-IT", "FormValidator", { required: "Il campo &egrave; obbligatorio.", minLength: "Inserire almeno {minLength} caratteri (ne sono stati inseriti {length}).", maxLength: "Inserire al massimo {maxLength} caratteri (ne sono stati inseriti {length}).", integer: "Inserire un numero intero. Non sono consentiti decimali (es.: 1.25).", numeric: 'Inserire solo valori numerici (es.: "1" oppure "1.1" oppure "-1" oppure "-1.1").', digits: "Inserire solo numeri e caratteri di punteggiatura. Per esempio &egrave; consentito un numero telefonico con trattini o punti.", alpha: "Inserire solo lettere (a-z). Non sono consentiti spazi o altri caratteri.", alphanum: "Inserire solo lettere (a-z) o numeri (0-9). Non sono consentiti spazi o altri caratteri.", dateSuchAs: "Inserire una data valida del tipo {date}", dateInFormatMDY: 'Inserire una data valida nel formato MM/GG/AAAA (es.: "12/31/1999")', email: 'Inserire un indirizzo email valido. Per esempio "nome@dominio.com".', url: 'Inserire un indirizzo valido. Per esempio "http://www.example.com".', currencyDollar: 'Inserire un importo valido. Per esempio "$100.00".', oneRequired: "Completare almeno uno dei campi richiesti.", errorPrefix: "Errore: ", warningPrefix: "Attenzione: ", noSpace: "Non sono consentiti spazi.", reqChkByNode: "Nessuna voce selezionata.", requiredChk: "Il campo &egrave; obbligatorio.", reqChkByName: "Selezionare un(a) {label}.", match: "Il valore deve corrispondere al campo {matchName}", startDate: "data d'inizio", endDate: "data di fine", currendDate: "data attuale", afterDate: "La data deve corrispondere o essere successiva al {label}.", beforeDate: "La data deve corrispondere o essere precedente al {label}.", startMonth: "Selezionare un mese d'inizio", sameMonth: "Le due date devono essere dello stesso mese - occorre modificarne una.", creditcard: "Il numero di carta di credito inserito non &egrave; valido. Controlla il numero e prova di nuovo. Inserite {length} cifre." }), Locale.define("ja-JP", "Date", { months: ["1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"], months_abbr: ["1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"], days: ["日曜日", "月曜日", "火曜日", "水曜日", "木曜日", "金曜日", "土曜日"], days_abbr: ["日", "月", "火", "水", "木", "金", "土"], dateOrder: ["year", "month", "date"], shortDate: "%Y/%m/%d", shortTime: "%H:%M", AM: "午前", PM: "午後", firstDayOfWeek: 0, ordinal: "", lessThanMinuteAgo: "1分以内前", minuteAgo: "約1分前", minutesAgo: "約{delta}分前", hourAgo: "約1時間前", hoursAgo: "約{delta}時間前", dayAgo: "1日前", daysAgo: "{delta}日前", weekAgo: "1週間前", weeksAgo: "{delta}週間前", monthAgo: "1ヶ月前", monthsAgo: "{delta}ヶ月前", yearAgo: "1年前", yearsAgo: "{delta}年前", lessThanMinuteUntil: "今から約1分以内", minuteUntil: "今から約1分", minutesUntil: "今から約{delta}分", hourUntil: "今から約1時間", hoursUntil: "今から約{delta}時間", dayUntil: "今から1日間", daysUntil: "今から{delta}日間", weekUntil: "今から1週間", weeksUntil: "今から{delta}週間", monthUntil: "今から1ヶ月", monthsUntil: "今から{delta}ヶ月", yearUntil: "今から1年", yearsUntil: "今から{delta}年" }), Locale.define("ja-JP", "FormValidator", { required: "入力は必須です。", minLength: "入力文字数は{minLength}以上にしてください。({length}文字)", maxLength: "入力文字数は{maxLength}以下にしてください。({length}文字)", integer: "整数を入力してください。", numeric: '入力できるのは数値だけです。(例: "1", "1.1", "-1", "-1.1"....)', digits: "入力できるのは数値と句読記号です。 (例: -や+を含む電話番号など).", alpha: "入力できるのは半角英字だけです。それ以外の文字は入力できません。", alphanum: "入力できるのは半角英数字だけです。それ以外の文字は入力できません。", dateSuchAs: "有効な日付を入力してください。{date}", dateInFormatMDY: '日付の書式に誤りがあります。YYYY/MM/DD (i.e. "1999/12/31")', email: "メールアドレスに誤りがあります。", url: "URLアドレスに誤りがあります。", currencyDollar: "金額に誤りがあります。", oneRequired: "ひとつ以上入力してください。", errorPrefix: "エラー: ", warningPrefix: "警告: ", noSpace: "スペースは入力できません。", reqChkByNode: "選択されていません。", requiredChk: "この項目は必須です。", reqChkByName: "{label}を選択してください。", match: "{matchName}が入力されている場合必須です。", startDate: "開始日", endDate: "終了日", currendDate: "今日", afterDate: "{label}以降の日付にしてください。", beforeDate: "{label}以前の日付にしてください。", startMonth: "開始月を選択してください。", sameMonth: "日付が同一です。どちらかを変更してください。" }), Locale.define("ja-JP", "Number", { decimal: ".", group: ",", currency: { decimals: 0, prefix: "\\" } }), Locale.define("pt-PT", "Date", { months: ["Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"], months_abbr: ["Jan", "Fev", "Mar", "Abr", "Mai", "Jun", "Jul", "Ago", "Set", "Out", "Nov", "Dez"], days: ["Domingo", "Segunda-feira", "Terça-feira", "Quarta-feira", "Quinta-feira", "Sexta-feira", "Sábado"], days_abbr: ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sáb"], dateOrder: ["date", "month", "year"], shortDate: "%d-%m-%Y", shortTime: "%H:%M", AM: "AM", PM: "PM", firstDayOfWeek: 1, ordinal: "º", lessThanMinuteAgo: "há menos de um minuto", minuteAgo: "há cerca de um minuto", minutesAgo: "há {delta} minutos", hourAgo: "há cerca de uma hora", hoursAgo: "há cerca de {delta} horas", dayAgo: "há um dia", daysAgo: "há {delta} dias", weekAgo: "há uma semana", weeksAgo: "há {delta} semanas", monthAgo: "há um mês", monthsAgo: "há {delta} meses", yearAgo: "há um ano", yearsAgo: "há {delta} anos", lessThanMinuteUntil: "em menos de um minuto", minuteUntil: "em um minuto", minutesUntil: "em {delta} minutos", hourUntil: "em uma hora", hoursUntil: "em {delta} horas", dayUntil: "em um dia", daysUntil: "em {delta} dias", weekUntil: "em uma semana", weeksUntil: "em {delta} semanas", monthUntil: "em um mês", monthsUntil: "em {delta} meses", yearUntil: "em um ano", yearsUntil: "em {delta} anos" }), Locale.define("pt-BR", "Date", { shortDate: "%d/%m/%Y" }).inherit("pt-PT", "Date"), Locale.define("pt-BR", "FormValidator", { required: "Este campo é obrigatório.", minLength: "Digite pelo menos {minLength} caracteres (tamanho atual: {length}).", maxLength: "Não digite mais de {maxLength} caracteres (tamanho atual: {length}).", integer: "Por favor digite apenas um número inteiro neste campo. Não são permitidos números decimais (por exemplo, 1,25).", numeric: 'Por favor digite apenas valores numéricos neste campo (por exemplo, "1" ou "1.1" ou "-1" ou "-1,1").', digits: "Por favor use apenas números e pontuação neste campo (por exemplo, um número de telefone com traços ou pontos é permitido).", alpha: "Por favor use somente letras (a-z). Espaço e outros caracteres não são permitidos.", alphanum: "Use somente letras (a-z) ou números (0-9) neste campo. Espaço e outros caracteres não são permitidos.", dateSuchAs: "Digite uma data válida, como {date}", dateInFormatMDY: 'Digite uma data válida, como DD/MM/YYYY (por exemplo, "31/12/1999")', email: 'Digite um endereço de email válido. Por exemplo "nome@dominio.com".', url: "Digite uma URL válida. Exemplo: http://www.example.com.", currencyDollar: "Digite um valor em dinheiro válido. Exemplo: R$100,00 .", oneRequired: "Digite algo para pelo menos um desses campos.", errorPrefix: "Erro: ", warningPrefix: "Aviso: ", noSpace: "Não é possível digitar espaços neste campo.", reqChkByNode: "Não foi selecionado nenhum item.", requiredChk: "Este campo é obrigatório.", reqChkByName: "Por favor digite um {label}.", match: "Este campo deve ser igual ao campo {matchName}.", startDate: "a data inicial", endDate: "a data final", currendDate: "a data atual", afterDate: "A data deve ser igual ou posterior a {label}.", beforeDate: "A data deve ser igual ou anterior a {label}.", startMonth: "Por favor selecione uma data inicial.", sameMonth: "Estas duas datas devem ter o mesmo mês - você deve modificar uma das duas.", creditcard: "O número do cartão de crédito informado é inválido. Por favor verifique o valor e tente novamente. {length} números informados." }), Locale.define("pt-PT", "FormValidator", { required: "Este campo é necessário.", minLength: "Digite pelo menos{minLength} caracteres (comprimento {length} caracteres).", maxLength: "Não insira mais de {maxLength} caracteres (comprimento {length} caracteres).", integer: "Digite um número inteiro neste domínio. Com números decimais (por exemplo, 1,25), não são permitidas.", numeric: 'Digite apenas valores numéricos neste domínio (p.ex., "1" ou "1.1" ou "-1" ou "-1,1").', digits: "Por favor, use números e pontuação apenas neste campo (p.ex., um número de telefone com traços ou pontos é permitida).", alpha: "Por favor use somente letras (a-z), com nesta área. Não utilize espaços nem outros caracteres são permitidos.", alphanum: "Use somente letras (a-z) ou números (0-9) neste campo. Não utilize espaços nem outros caracteres são permitidos.", dateSuchAs: "Digite uma data válida, como {date}", dateInFormatMDY: 'Digite uma data válida, como DD/MM/YYYY (p.ex. "31/12/1999")', email: 'Digite um endereço de email válido. Por exemplo "fred@domain.com".', url: "Digite uma URL válida, como http://www.example.com.", currencyDollar: "Digite um valor válido $. Por exemplo $ 100,00. ", oneRequired: "Digite algo para pelo menos um desses insumos.", errorPrefix: "Erro: ", warningPrefix: "Aviso: " }), function () { function e(t, e, i, n, s) { var r = t % 10, t = t % 100; return 1 == r && 11 != t ? e : 2 != r && 3 != r && 4 != r || 12 == t || 13 == t || 14 == t ? 0 == r || 5 == r || 6 == r || 7 == r || 8 == r || 9 == r || 11 == t || 12 == t || 13 == t || 14 == t ? n : s : i } Locale.define("ru-RU", "Date", { months: ["Январь", "Февраль", "Март", "Апрель", "Май", "Июнь", "Июль", "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь"], months_abbr: ["янв", "февр", "март", "апр", "май", "июнь", "июль", "авг", "сент", "окт", "нояб", "дек"], days: ["Воскресенье", "Понедельник", "Вторник", "Среда", "Четверг", "Пятница", "Суббота"], days_abbr: ["Вс", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб"], dateOrder: ["date", "month", "year"], shortDate: "%d.%m.%Y", shortTime: "%H:%M", AM: "AM", PM: "PM", firstDayOfWeek: 1, ordinal: "", lessThanMinuteAgo: "меньше минуты назад", minuteAgo: "минуту назад", minutesAgo: function (t) { return "{delta} " + e(t, "минуту", "минуты", "минут") + " назад" }, hourAgo: "час назад", hoursAgo: function (t) { return "{delta} " + e(t, "час", "часа", "часов") + " назад" }, dayAgo: "вчера", daysAgo: function (t) { return "{delta} " + e(t, "день", "дня", "дней") + " назад" }, weekAgo: "неделю назад", weeksAgo: function (t) { return "{delta} " + e(t, "неделя", "недели", "недель") + " назад" }, monthAgo: "месяц назад", monthsAgo: function (t) { return "{delta} " + e(t, "месяц", "месяца", "месецев") + " назад" }, yearAgo: "год назад", yearsAgo: function (t) { return "{delta} " + e(t, "год", "года", "лет") + " назад" }, lessThanMinuteUntil: "меньше чем через минуту", minuteUntil: "через минуту", minutesUntil: function (t) { return "через {delta} " + e(t, "час", "часа", "часов") }, hourUntil: "через час", hoursUntil: function (t) { return "через {delta} " + e(t, "час", "часа", "часов") }, dayUntil: "завтра", daysUntil: function (t) { return "через {delta} " + e(t, "день", "дня", "дней") }, weekUntil: "через неделю", weeksUntil: function (t) { return "через {delta} " + e(t, "неделю", "недели", "недель") }, monthUntil: "через месяц", monthsUntil: function (t) { return "через {delta} " + e(t, "месяц", "месяца", "месецев") }, yearUntil: "через", yearsUntil: function (t) { return "через {delta} " + e(t, "год", "года", "лет") } }), Locale.define("ru-RU-unicode").inherit("ru-RU", "Date") }(), Locale.define("ru-RU", "FormValidator", { required: "Это поле обязательно к заполнению.", minLength: "Пожалуйста, введите хотя бы {minLength} символов (Вы ввели {length}).", maxLength: "Пожалуйста, введите не больше {maxLength} символов (Вы ввели {length}).", integer: "Пожалуйста, введите в это поле число. Дробные числа (например 1.25) тут не разрешены.", numeric: 'Пожалуйста, введите в это поле число (например "1" или "1.1", или "-1", или "-1.1").', digits: "В этом поле Вы можете использовать только цифры и знаки пунктуации (например, телефонный номер со знаками дефиса или с точками).", alpha: "В этом поле можно использовать только латинские буквы (a-z). Пробелы и другие символы запрещены.", alphanum: "В этом поле можно использовать только латинские буквы (a-z) и цифры (0-9). Пробелы и другие символы запрещены.", dateSuchAs: "Пожалуйста, введите корректную дату {date}", dateInFormatMDY: 'Пожалуйста, введите дату в формате ММ/ДД/ГГГГ (например "12/31/1999")', email: 'Пожалуйста, введите корректный емейл-адрес. Для примера "fred@domain.com".', url: "Пожалуйста, введите правильную ссылку вида http://www.example.com.", currencyDollar: "Пожалуйста, введите сумму в долларах. Например: $100.00 .", oneRequired: "Пожалуйста, выберите хоть что-нибудь в одном из этих полей.", errorPrefix: "Ошибка: ", warningPrefix: "Внимание: " }), Locale.define("ru-RU-unicode").inherit("ru-RU", "FormValidator");

var Collapsible = new Class({ Extends: Fx.Reveal, initialize: function (t, i, e) { this.clicker = document.id(t), this.section = document.id(i), this.parent(this.section, e), this.boundtoggle = this.toggle.bind(this), this.attach() }, attach: function () { this.clicker.addEvent("click", this.boundtoggle) }, detach: function () { this.clicker.removeEvent("click", this.boundtoggle) } }), Collapsable = Collapsible, Clientcide = { version: "3.0.10", assetLocation: "/salsa_javascripts/clientcide_assets", setAssetLocation: function (t) { Clientcide.assetLocation = t, Clientcide.preloaded && Clientcide.preLoadCss() }, preLoadCss: function () { return window.StickyWin && StickyWin.ui && StickyWin.ui(), window.StickyWin && StickyWin.pointy && StickyWin.pointy(), Clientcide.preloaded = !0 }, preloaded: !1 }; !function () { var t; window.addEvent && (t = function () { window.dbug && dbug.log("preloading clientcide css"), Clientcide.preloaded || Clientcide.preLoadCss() }, window.addEvent("domready", t), window.addEvent("load", t)) }(), setCNETAssetBaseHref = Clientcide.setAssetLocation; var value, debugCookie, MooScroller = new Class({ Implements: [Options, Events], options: { maxThumbSize: 10, mode: "vertical", width: 0, scrollSteps: 10, wheel: !0, scrollLinks: { forward: "scrollForward", back: "scrollBack" }, hideWhenNoOverflow: !0 }, initialize: function (t, i, e) { this.setOptions(e), this.horz = "horizontal" == this.options.mode, this.content = document.id(t).setStyle("overflow", "hidden"), this.knob = document.id(i), this.track = this.knob.getParent(), this.setPositions(), this.horz && this.options.width && (this.wrapper = new Element("div"), this.content.getChildren().each(function (t) { this.wrapper.adopt(t) }, this), this.wrapper.inject(this.content).setStyle("width", this.options.width)), this.bound = { start: this.start.bind(this), end: this.end.bind(this), drag: this.drag.bind(this), wheel: this.wheel.bind(this), page: this.page.bind(this) }, this.position = {}, this.mouse = {}, this.update(), this.attach(), this.clearScroll = function () { clearInterval(this.scrolling) }.bind(this), ["forward", "back"].each(function (t) { var i = document.id(this.options.scrollLinks[t]); i && i.addEvents({ mousedown: function () { this.scrolling = this[t].periodical(50, this) }.bind(this), mouseup: this.clearScroll.bind(this), click: this.clearScroll.bind(this) }) }, this), this.knob.addEvent("click", this.clearScroll.bind(this)), window.addEvent("domready", function () { try { document.id(document.body).addEvent("mouseup", this.clearScroll) } catch (t) { } }.bind(this)) }, setPositions: function () { [this.track, this.knob].each(function (t) { "static" == t.getStyle("position") && t.setStyle("position", "relative") }) }, toElement: function () { return this.content }, update: function () { var t = this.horz ? "Width" : "Height"; this.contentSize = this.content["offset" + t], this.contentScrollSize = this.content["scroll" + t], this.trackSize = this.track["offset" + t], this.contentRatio = this.contentSize / this.contentScrollSize, this.knobSize = (this.trackSize * this.contentRatio).limit(this.options.maxThumbSize, this.trackSize), this.options.hideWhenNoOverflow && (this.hidden = this.knobSize == this.trackSize, this.track.setStyle("opacity", this.hidden ? 0 : 1)), this.scrollRatio = this.contentScrollSize / this.trackSize, this.knob.setStyle(t.toLowerCase(), this.knobSize), this.updateThumbFromContentScroll(), this.updateContentFromThumbPosition() }, updateContentFromThumbPosition: function () { this.content[this.horz ? "scrollLeft" : "scrollTop"] = this.position.now * this.scrollRatio }, updateThumbFromContentScroll: function () { this.position.now = (this.content[this.horz ? "scrollLeft" : "scrollTop"] / this.scrollRatio).limit(0, this.trackSize - this.knobSize), this.knob.setStyle(this.horz ? "left" : "top", this.position.now) }, attach: function () { this.knob.addEvent("mousedown", this.bound.start), this.options.wheel && (this.content.addEvent("mousewheel", this.bound.wheel), this.track.addEvent("mousewheel", this.bound.wheel)), this.track.addEvent("mouseup", this.bound.page) }, detach: function () { this.knob.removeEvent("mousedown", this.bound.start), this.options.wheel && (this.content.removeEvent("mousewheel", this.bound.wheel), this.track.removeEvent("mousewheel", this.bound.wheel)), this.track.removeEvent("mouseup", this.bound.page), document.id(document.body).removeEvent("mouseup", this.clearScroll) }, wheel: function (t) { this.hidden || (this.scroll(-(t.wheel * this.options.scrollSteps)), this.updateThumbFromContentScroll(), t.stop()) }, scroll: function (t) { t = t || this.options.scrollSteps, this.content[this.horz ? "scrollLeft" : "scrollTop"] += t, this.updateThumbFromContentScroll(), this.fireEvent("onScroll", t) }, forward: function (t) { this.scroll(t) }, back: function (t) { t = t || this.options.scrollSteps, this.scroll(-t) }, page: function (t) { var i = this.horz ? "x" : "y", i = t.page[i] > this.knob.getPosition()[i]; this.scroll((i ? 1 : -1) * this.content["offset" + (this.horz ? "Width" : "Height")]), this.updateThumbFromContentScroll(), this.fireEvent("onPage", i), t.stop() }, start: function (t) { var i = this.horz ? "x" : "y"; this.mouse.start = t.page[i], this.position.start = this.knob.getStyle(this.horz ? "left" : "top").toInt(), document.addEvent("mousemove", this.bound.drag), document.addEvent("mouseup", this.bound.end), this.knob.addEvent("mouseup", this.bound.end), t.stop() }, end: function (t) { document.removeEvent("mousemove", this.bound.drag), document.removeEvent("mouseup", this.bound.end), this.knob.removeEvent("mouseup", this.bound.end), t.stop() }, drag: function (t) { var i = this.horz ? "x" : "y"; this.mouse.now = t.page[i], this.position.now = (this.position.start + (this.mouse.now - this.mouse.start)).limit(0, this.trackSize - this.knobSize), this.updateContentFromThumbPosition(), this.updateThumbFromContentScroll(), t.stop() } }), MultipleOpenAccordion = new Class({ Implements: [Options, Events, Chain], options: { togglers: [], elements: [], openAll: !1, firstElementsOpen: [0], fixedHeight: null, fixedWidth: null, height: !0, opacity: !0, width: !1 }, togglers: [], elements: [], initialize: function (t) { var i = Array.link(arguments, { options: Type.isObject, elements: Type.isElements }); this.setOptions(i.options), elements = $$(this.options.elements), $$(this.options.togglers).each(function (t, i) { this.addSection(t, elements[i], i) }, this), this.togglers.length && (this.options.openAll ? this.showAll() : this.toggleSections(this.options.firstElementsOpen, !1, !0)), this.openSections = this.showSections.bind(this), this.closeSections = this.hideSections.bind(this) }, addSection: function (t, i) { t = document.id(t), i = document.id(i); this.togglers.contains(t), this.togglers.length; this.togglers.include(t), this.elements.include(i); var e = this.togglers.indexOf(t), e = this.toggleSection.bind(this, e); return t.addEvent("click", e).store("multipleOpenAccordion:display", e), e = this.options.height && this.options.width ? "both" : this.options.height ? "vertical" : "horizontal", i.store("moa:reveal", new Fx.Reveal(i, { transitionOpacity: this.options.opacity, mode: e, heightOverride: this.options.fixedHeight, widthOverride: this.options.fixedWidth })), this }, removeSection: function (t) { var i = this.togglers.indexOf(t), i = this.elements[i]; return i.dissolve(), this.togglers.erase(t), this.elements.erase(i), this.detach(t), this }, detach: function (t) { var i = function (t) { t.removeEvent(this.options.trigger, t.retrieve("multipleOpenAccordion:display")) }.bind(this); return t ? i(t) : this.togglers.each(i), this }, onComplete: function (t, i) { return this.fireEvent(this.elements[t].isDisplayed() ? "onActive" : "onBackground", [this.togglers[t], this.elements[t]]), this.callChain(), this }, showSection: function (t, i) { this.toggleSection(t, i, !0) }, hideSection: function (t, i) { this.toggleSection(t, i, !1) }, toggleSection: function (t, i, e, s) { var n = e ? "reveal" : null != e ? "dissolve" : "toggle"; s = [s, !0].pick(); e = this.elements[t]; return null == i || i ? e.retrieve("moa:reveal")[n]().chain(this.onComplete.bind(this, t, s)) : ("toggle" == n ? e.toggle() : e["reveal" == n ? "show" : "hide"](), this.onComplete(t, s)), this }, toggleAll: function (e, s) { var n = this.elements.getLast(); return this.elements.each(function (t, i) { this.toggleSection(i, e, s, t == n) }, this), this }, toggleSections: function (e, s, n) { return last = e.getLast(), this.elements.each(function (t, i) { this.toggleSection(i, s, e.contains(i) ? n : !n, i == last) }, this), this }, showSections: function (t, i) { t.each(function (t) { this.showSection(t, i) }, this) }, hideSections: function (t, i) { t.each(function (t) { this.hideSection(t, i) }, this) }, showAll: function (t) { return this.toggleAll(t, !0) }, hideAll: function (t) { return this.toggleAll(t, !1) } }), dbug = { logged: [], timers: {}, firebug: !1, enabled: !1, log: function () { dbug.logged.push(arguments) }, nolog: function (t) { dbug.logged.push(arguments) }, time: function (t) { dbug.timers[t] = (new Date).getTime() }, timeEnd: function (t) { var i; dbug.timers[t] ? (i = (new Date).getTime() - dbug.timers[t], dbug.timers[t] = !1, dbug.log("%s: %s", t, i)) : dbug.log("no such timer: %s", t) }, enable: function (t) { var i = window.firebug ? firebug.d.console.cmd : window.console; if (window.console && window.console.warn || window.firebug) try { dbug.enabled = !0, dbug.log = function () { try { (i.debug || i.log).apply(i, arguments) } catch (t) { console.log(Array.slice(arguments)) } }, dbug.time = function () { i.time.apply(i, arguments) }, dbug.timeEnd = function () { i.timeEnd.apply(i, arguments) }, t || dbug.log("enabling dbug"); for (var e = 0; e < dbug.logged.length; e++)dbug.log.apply(i, dbug.logged[e]); dbug.logged = [] } catch (t) { dbug.enable.delay(400) } }, disable: function () { dbug.firebug && (dbug.enabled = !1), dbug.log = dbug.nolog, dbug.time = function () { }, dbug.timeEnd = function () { } }, cookie: function (t) { var i = document.cookie.match("(?:^|;)\\s*jsdebug=([^;]*)"), i = !!i && unescape(i[1]); null == t && "true" != i || null != t && t ? (dbug.enable(), dbug.log("setting debugging cookie"), (t = new Date).setTime(t.getTime() + 864e5), document.cookie = "jsdebug=true;expires=" + t.toGMTString() + ";path=/;") : dbug.disableCookie() }, disableCookie: function () { dbug.log("disabling debugging cookie"), document.cookie = "jsdebug=false;path=/;" }, conditional: function (t, i) { if (dbug.enabled) return t(); try { return t() } catch (t) { i && i(t) } } }; !function () { var n = !!window.console || !!window.firebug, o = window.firebug ? window.firebug.d.console.cmd : window.console; function t(t, i) { for (var e = 0; e < t.length; e++) { var s = t[e]; n && o[s] ? dbug[s] = function (t) { return function () { o[t].apply(o, arguments) } }(s) : dbug[s] = i } } t(["debug", "info", "warn", "error", "assert", "dir", "dirxml"], dbug.log), t(["trace", "group", "groupEnd", "profile", "profileEnd", "count"], function () { }) }(), (window.console && window.console.warn || window.firebug) && (dbug.firebug = !0, debugCookie = !!(value = document.cookie.match("(?:^|;)\\s*jsdebug=([^;]*)")) && unescape(value[1]), (0 < window.location.href.indexOf("jsdebug=true") || "true" == debugCookie) && dbug.enable(), "true" == debugCookie && dbug.log("debugging cookie enabled"), 0 < window.location.href.indexOf("jsdebugCookie=true") && (dbug.cookie(), dbug.enabled || dbug.enable()), 0 < window.location.href.indexOf("jsdebugCookie=false") && dbug.disableCookie()); var StyleWriter = new Class({ createStyle: function (i, e) { window.addEvent("domready", function () { try { if (document.id(e) && e) return; var t = new Element("style", { id: e || "" }).inject($$("head")[0]); Browser.ie ? t.styleSheet.cssText = i : t.set("text", i) } catch (t) { dbug.log("error: %s", t) } }.bind(this)) } }), StickyWin = new Class({ Binds: ["destroy", "hide", "togglepin", "esc"], Implements: [Options, Events, StyleWriter], options: { closeClassName: "closeSticky", pinClassName: "pinSticky", content: "", zIndex: 1e4, className: "", width: !1, height: !1, timeout: -1, allowMultipleByClass: !0, allowMultiple: !0, showNow: !0, useIframeShim: !0, iframeShimSelector: "", destroyOnClose: !1, closeOnClickOut: !1, closeOnEsc: !1, getWindowManager: function () { return StickyWin.WM } }, css: '.SWclearfix:after {content: "."; display: block; height: 0; clear: both; visibility: hidden;}.SWclearfix {display: inline-table;} * html .SWclearfix {height: 1%;} .SWclearfix {display: block;}', initialize: function (t) { this.options.inject = this.options.inject || { target: document.body, where: "bottom" }, this.setOptions(t), this.windowManager = this.options.getWindowManager(), this.id = this.options.id || "StickyWin_" + (new Date).getTime(), this.makeWindow(), this.windowManager && this.windowManager.add(this), this.options.content && this.setContent(this.options.content), 0 < this.options.timeout && this.addEvent("onDisplay", function () { this.hide.delay(this.options.timeout, this) }.bind(this)), this.createStyle(this.css, "StickyWinClearFix"), (this.options.closeOnClickOut || this.options.closeOnEsc) && this.attach(), this.options.destroyOnClose && this.addEvent("close", this.destroy), this.options.showNow && this.show() }, toElement: function () { return this.element }, attach: function (t) { var i = t ? "removeEvents" : "addEvents", t = {}; this.options.closeOnClickOut && (t.click = this.esc), this.options.closeOnEsc && (t.keyup = this.esc), document[i](t) }, esc: function (t) { "esc" == t.key && this.hide(), "click" != t.type || this.element == t.target || this.element.contains(t.target) || this.hide() }, makeWindow: function () { return this.destroyOthers(), document.id(this.id) ? this.win = document.id(this.id) : this.win = new Element("div", { id: this.id }).addClass(this.options.className).addClass("StickyWinInstance").addClass("SWclearfix").setStyles({ display: "none", position: "absolute", zIndex: this.options.zIndex }).inject(this.options.inject.target, this.options.inject.where).store("StickyWin", this), this.element = this.win, this.options.width && "number" == typeOf(this.options.width.toInt()) && this.win.setStyle("width", this.options.width.toInt()), this.options.height && "number" == typeOf(this.options.height.toInt()) && this.win.setStyle("height", this.options.height.toInt()), this }, show: function (t) { return this.showWin(), t || this.fireEvent("display"), this.options.useIframeShim && this.showIframeShim(), this.visible = !0, this }, showWin: function () { this.windowManager && this.windowManager.focus(this), this.positioned || this.position(), this.win.show() }, hide: function (t) { return "event" != typeOf(t) && t || this.fireEvent("close"), this.hideWin(), this.options.useIframeShim && this.hideIframeShim(), this.visible = !1, this }, hideWin: function () { this.win.setStyle("display", "none") }, destroyOthers: function () { this.options.allowMultipleByClass && this.options.allowMultiple || $$("div.StickyWinInstance").each(function (t) { this.options.allowMultiple && (this.options.allowMultipleByClass || !t.hasClass(this.options.className)) || t.retrieve("StickyWin").destroy() }, this) }, setContent: function (t) { return 0 < this.win.getChildren().length && this.win.empty(), "string" == typeOf(t) ? this.win.set("html", t) : document.id(t) && this.win.adopt(t), this.win.getElements("." + this.options.closeClassName).each(function (t) { t.addEvent("click", this.hide) }, this), this.win.getElements("." + this.options.pinClassName).each(function (t) { t.addEvent("click", this.togglepin) }, this), this }, position: function (t) { return this.positioned = !0, this.setOptions(t), this.win.position(Object.cleanValues({ allowNegative: [this.options.allowNegative, this.options.relativeTo != document.body].pick(), relativeTo: this.options.relativeTo, position: this.options.position, offset: this.options.offset, edge: this.options.edge })), this.shim && this.shim.position(), this }, pin: function (t) { return this.win.pin ? (this.pinned = null != t && t, this.win.pin(t)) : dbug.log("you must include element.pin.js!"), this }, unpin: function () { return this.pin(!1) }, togglepin: function () { return this.pin(!this.pinned) }, makeIframeShim: function () { var t; this.shim || (t = this.options.iframeShimSelector ? this.win.getElement(this.options.iframeShimSelector) : this.win, this.shim = new IframeShim(t, { display: !1, name: "StickyWinShim" })) }, showIframeShim: function () { this.options.useIframeShim && (this.makeIframeShim(), this.shim.show()) }, hideIframeShim: function () { this.shim && this.shim.hide() }, destroy: function () { this.destroyed = !0, this.attach(!0), this.windowManager && this.windowManager.remove(this), this.win && this.win.destroy(), this.options.useIframeShim && this.shim && this.shim.destroy(), document.id("modalOverlay") && document.id("modalOverlay").destroy(), this.fireEvent("destroy") } }); StickyWin.Stacker = new Class({ Implements: [Options, Events], Binds: ["click"], instances: [], options: { zIndexBase: 9e3 }, initialize: function (t) { this.setOptions(t) }, add: function (t) { this.instances.include(t), $(t).addEvent("mousedown", this.click) }, click: function (e) { this.instances.each(function (t) { var i = $(t); i != e.target && !i.contains($(e.target)) || this.focus(t) }, this) }, focus: function (t) { this.focused != t && ((this.focused = t) && this.instances.erase(t).push(t), this.instances.each(function (t, i) { $(t).setStyle("z-index", this.options.zIndexBase + i) }, this), this.focused = t) }, remove: function (t) { this.instances.erase(t), $(t).removeEvent("click", this.click) } }), StickyWin.WM = new StickyWin.Stacker, StickyWin.UI = new Class({ Implements: [Options, StyleWriter], options: { width: 300, css: "div.DefaultStickyWin {font-family:verdana; font-size:11px; line-height: 13px;position: relative;}div.DefaultStickyWin div.top{-moz-user-select: none;-khtml-user-select: none;}div.DefaultStickyWin div.top_ul{background:url({%baseHref%}full.png) top left no-repeat; height:30px; width:15px; float:left}div.DefaultStickyWin div.top_ur{position:relative; left:0px !important; left:-4px; background:url({%baseHref%}full.png) top right !important; height:30px; margin:0px 0px 0px 15px !important; margin-right:-4px; padding:0px}div.DefaultStickyWin h1.caption{clear: none !important; margin:0px !important; overflow: hidden; padding:0 !important; font-weight:bold; color:#555; font-size:14px !important; position:relative; top:8px !important; left:5px !important; float: left; height: 22px !important;}div.DefaultStickyWin div.middle, div.DefaultStickyWin div.closeBody {background:url({%baseHref%}body.png) top left repeat-y; margin:0px 20px 0px 0px !important;\tmargin-bottom: -3px; position: relative;\ttop: 0px !important; top: -3px;}div.DefaultStickyWin div.body{background:url({%baseHref%}body.png) top right repeat-y; padding:8px 23px 8px 0px !important; margin-left:5px !important; position:relative; right:-20px !important; z-index: 1;}div.DefaultStickyWin div.bottom{clear:both;}div.DefaultStickyWin div.bottom_ll{background:url({%baseHref%}full.png) bottom left no-repeat; width:15px; height:15px; float:left}div.DefaultStickyWin div.bottom_lr{background:url({%baseHref%}full.png) bottom right; position:relative; left:0px !important; left:-4px; margin:0px 0px 0px 15px !important; margin-right:-4px; height:15px}div.DefaultStickyWin div.closeButtons{text-align: center; background:url({%baseHref%}body.png) top right repeat-y; padding: 4px 30px 8px 0px; margin-left:5px; position:relative; right:-20px}div.DefaultStickyWin a.button:hover{background:url({%baseHref%}big_button_over.gif) repeat-x}div.DefaultStickyWin a.button {background:url({%baseHref%}big_button.gif) repeat-x; margin: 2px 8px 2px 8px; padding: 2px 12px; cursor:pointer; border: 1px solid #999 !important; text-decoration:none; color: #000 !important;}div.DefaultStickyWin div.closeButton{width:13px; height:13px; background:url({%baseHref%}closebtn.gif) no-repeat; position: absolute; right: 0px; margin:10px 15px 0px 0px !important; cursor:pointer;top:0px}div.DefaultStickyWin div.dragHandle {\twidth: 11px;\theight: 25px;\tposition: relative;\ttop: 5px;\tleft: -3px;\tcursor: move;\tbackground: url({%baseHref%}drag_corner.gif); float: left;}", cornerHandle: !1, cssClass: "", buttons: [], cssId: "defaultStickyWinStyle", cssClassName: "DefaultStickyWin", closeButton: !0 }, initialize: function () { var t = this.getArgs(arguments); this.setOptions(t.options), this.legacy(); var i = this.options.css.substitute({ baseHref: this.options.baseHref || Clientcide.assetLocation + "/stickyWinHTML/" }, /\\?\{%([^}]+)%\}/g); Browser.ie && (i = i.replace(/png/g, "gif")), this.createStyle(i, this.options.cssId), this.build(), (t.caption || t.body) && this.setContent(t.caption, t.body) }, toElement: function () { return this.element }, getArgs: function () { return StickyWin.UI.getArgs.apply(this, arguments) }, legacy: function () { var t = this.options; t.confirmTxt && t.buttons.push({ text: t.confirmTxt, onClick: t.onConfirm || function () { } }), t.closeTxt && t.buttons.push({ text: t.closeTxt, onClick: t.onClose || function () { } }) }, build: function () { var t = this.options, i = new Element("div", { class: t.cssClassName }); t.width && i.setStyle("width", t.width), this.element = i, this.element.store("StickyWinUI", this), t.cssClass && i.addClass(t.cssClass); var e = new Element("div").addClass("body"); this.body = e; var s, n = new Element("div").addClass("top_ur"); return this.top_ur = n, this.top = new Element("div").addClass("top").adopt(new Element("div").addClass("top_ul")).adopt(n), i.adopt(this.top), t.cornerHandle && new Element("div").addClass("dragHandle").inject(n, "top"), i.adopt(new Element("div").addClass("middle").adopt(e)), 0 < t.buttons.length && (s = new Element("div").addClass("closeButtons"), t.buttons.each(function (t) { t.properties && t.properties.className && (t.properties.class = t.properties.className, delete t.properties.className); var i = Object.merge({ class: "closeSticky" }, t.properties); new Element("a").addEvent("click", t.onClick || function () { }).appendText(t.text).inject(s).set(i).addClass("button") }), i.adopt(new Element("div").addClass("closeBody").adopt(s))), i.adopt(new Element("div").addClass("bottom").adopt(new Element("div").addClass("bottom_ll")).adopt(new Element("div").addClass("bottom_lr"))), this.options.closeButton && i.adopt(new Element("div").addClass("closeButton").addClass("closeSticky")), this }, setCaption: function (t) { return this.caption = t, this.h1 ? document.id(t) ? this.h1.adopt(t) : this.h1.set("html", t) : this.makeCaption(t), this }, makeCaption: function (t) { if (!t) return this.destroyCaption(); var i = this.options; return this.h1 = new Element("h1").addClass("caption"), i.width && this.h1.setStyle("width", i.width.toInt() - (i.cornerHandle ? 55 : 40) - (i.closeButton ? 10 : 0)), this.setCaption(t), this.top_ur.adopt(this.h1), this.options.cornerHandle || this.h1.addClass("dragHandle"), this }, destroyCaption: function () { return this.h1 && (this.h1.destroy(), this.h1 = null), this }, setContent: function () { var t = this.getArgs.apply(this, arguments), i = t.caption, t = t.body; return this.setCaption(i), document.id(t) ? this.body.empty().adopt(t) : this.body.set("html", t), this } }), StickyWin.UI.getArgs = function () { var t = "arguments" == typeOf(arguments[0]) ? arguments[0] : arguments; Browser.opera && 1 === t.length && (t = t[0]); var i = t[0], e = t[1], s = Array.link(t, { options: Type.isObject }); return 3 == t.length || !s.options && 2 == t.length ? (s.caption = i, s.body = e) : "object" != typeOf(e) && e || !i || "object" == typeOf(i) || (s.body = i), s }, StickyWin.ui = function (t, i, e) { return document.id(new StickyWin.UI(t, i, e)) }, (StickyWin = Class.refactor(StickyWin, { options: { draggable: !1, dragOptions: { onComplete: function () { } }, dragHandleSelector: ".dragHandle", resizable: !1, resizeOptions: { onComplete: function () { } }, resizeHandleSelector: "" }, setContent: function () { return this.previous.apply(this, arguments), this.options.draggable && this.makeDraggable(), this.options.resizable && this.makeResizable(), this }, makeDraggable: function () { var t, i, e = this.toggleVisible(!0); this.options.useIframeShim && (this.makeIframeShim(), t = this.options.dragOptions.onComplete, this.options.dragOptions.onComplete = function () { t(), this.shim.position() }.bind(this)), !this.options.dragHandleSelector || (i = this.win.getElement(this.options.dragHandleSelector)) && (i.setStyle("cursor", "move"), this.options.dragOptions.handle = i), this.win.makeDraggable(this.options.dragOptions), e && this.toggleVisible(!1) }, makeResizable: function () { var t, i = this.toggleVisible(!0); this.options.useIframeShim && (this.makeIframeShim(), t = this.options.resizeOptions.onComplete, this.options.resizeOptions.onComplete = function () { t(), this.shim.position() }.bind(this)), this.options.resizeHandleSelector && this.win.getElement(this.options.resizeHandleSelector) && (this.options.resizeOptions.handle = this.win.getElement(this.options.resizeHandleSelector)), this.win.makeResizable(this.options.resizeOptions), i && this.toggleVisible(!1) }, toggleVisible: function (t) { return !this.visible && null == t || t ? (this.win.setStyles({ display: "block", opacity: 0 }), !0) : (null == t || t || this.win.setStyles({ display: "none", opacity: 1 }), !1) } })).Fx = StickyWin, Fx.Marquee = new Class({ Extends: Fx.Morph, options: { mode: "horizontal", message: "", revert: !0, delay: 5e3, cssClass: "msg", showEffect: { opacity: 1 }, hideEffect: { opacity: 0 }, revertEffect: { opacity: [0, 1] }, currentMessage: null }, initialize: function (t, i) { t = document.id(t); var e = this.options.currentMessage || 1 == t.getChildren().length ? t.getFirst() : "", t = new Element("div", { styles: { position: "relative" }, class: "fxMarqueeWrapper" }).inject(t); this.parent(t, i), this.current = this.wrapMessage(e) }, wrapMessage: function (t) { var i; return document.id(t) && document.id(t).hasClass("fxMarquee") ? i = document.id(t) : (i = new Element("span", { class: "fxMarquee", styles: { position: "relative" } }), document.id(t) ? i.grab(document.id(t)) : "string" == typeOf(t) && i.set("html", t)), i.inject(this.element) }, announce: function (t) { return this.setOptions(t).showMessage(), this }, showMessage: function (i) { return function () { var t = this.$chain ? Array.clone(this.$chain) : []; this.clearChain(), this.element = document.id(this.element), this.current = document.id(this.current), this.message = document.id(this.message), this.start(this.options.hideEffect).chain(function () { i ? (this.message.hide(), this.current && this.current.show()) : (this.message && this.message.dispose(), this.message = this.wrapMessage(this.options.message), this.current && this.current.hide()), this.start(i ? this.options.revertEffect : this.options.showEffect).chain(function () { this.$chain ? this.$chain.combine(t) : this.$chain = t, this.fireEvent(i ? "onRevert" : "onMessage"), !i && this.options.revert ? this.showMessage(!0) : this.callChain.delay(this.options.delay, this) }.bind(this)) }.bind(this)) }.delay(i ? this.options.delay : 10, this), this } }), StickyWin.UI.Pointy = new Class({ Extends: StickyWin.UI, options: { theme: "dark", themes: { dark: { bgColor: "#333", fgColor: "#ddd", imgset: "dark" }, light: { bgColor: "#ccc", fgColor: "#333", imgset: "light" } }, css: "div.DefaultPointyTip {vertical-align: auto; position: relative;}div.DefaultPointyTip * {text-align:left !important}div.DefaultPointyTip .pointyWrapper div.body{background: {%bgColor%}; color: {%fgColor%}; left: 0px; right: 0px !important;padding:  0px 10px !important;margin-left: 0px !important;font-family: verdana;font-size: 11px;line-height: 13px;position: relative;}div.DefaultPointyTip .pointyWrapper div.top {position: relative;height: 25px; overflow: visible;}div.DefaultPointyTip .pointyWrapper div.top_ul{background: url({%baseHref%}{%imgset%}_back.png) top left no-repeat;width: 8px;height: 25px; position: absolute; left: 0px;}div.DefaultPointyTip .pointyWrapper div.top_ur{background: url({%baseHref%}{%imgset%}_back.png) top right !important;margin: 0 0 0 8px !important;height: 25px;position: relative;left: 0px !important;padding: 0;}div.DefaultPointyTip .pointyWrapper h1.caption{color: {%fgColor%};left: 0px !important;top: 4px !important;clear: none !important;overflow: hidden;font-weight: 700;font-size: 12px !important;position: relative;float: left;height: 22px !important;margin: 0 !important;padding: 0 !important;}div.DefaultPointyTip .pointyWrapper div.middle, div.DefaultPointyTip .pointyWrapper div.closeBody{background:  {%bgColor%};margin: 0 0px 0 0 !important;position: relative;top: 0 !important;}div.DefaultPointyTip .pointyWrapper div.middle {min-height: 16px; background:  {%bgColor%};margin: 0 0px 0 0 !important;position: relative;top: 0 !important;}div.DefaultPointyTip .pointyWrapper div.bottom {clear: both; width: 100% !important; background: none; height: 6px} div.DefaultPointyTip .pointyWrapper div.bottom_ll{font-size:1; background: url({%baseHref%}{%imgset%}_back.png) bottom left no-repeat;width: 6px;height: 6px;position: absolute; left: 0px;}div.DefaultPointyTip .pointyWrapper div.bottom_lr{font-size:1; background: url({%baseHref%}{%imgset%}_back.png) bottom right;height: 6px;margin: 0 0 0 6px !important;position: relative;left: 0 !important;}div.DefaultPointyTip .pointyWrapper div.noCaption{ height: 6px; overflow: hidden}div.DefaultPointyTip .pointyWrapper div.closeButton{width:13px; height:13px; background:url({%baseHref%}{%imgset%}_x.png) no-repeat; position: absolute; right: 0px; margin:0px !important; cursor:pointer; z-index: 1; top: 4px;}div.DefaultPointyTip .pointyWrapper div.pointyDivot {background: url({%divot%}) no-repeat;}", divot: "{%baseHref%}{%imgset%}_divot.png", divotSize: 22, direction: 12, cssId: "defaultPointyTipStyle", cssClassName: "DefaultPointyTip" }, initialize: function () { var t = this.getArgs(arguments); if (this.setOptions(t.options), Object.append(this.options, this.options.themes[this.options.theme]), this.options.baseHref = this.options.baseHref || Clientcide.assetLocation + "/PointyTip/", this.options.divot = this.options.divot.substitute(this.options, /\\?\{%([^}]+)%\}/g), Browser.ie && (this.options.divot = this.options.divot.replace(/png/g, "gif")), this.options.css = this.options.css.substitute(this.options, /\\?\{%([^}]+)%\}/g), t.options && t.options.theme) { for (; !this.id;) { var i = Number.random(0, 999999999); StickyWin.UI.Pointy[i] || ((StickyWin.UI.Pointy[i] = this).id = i) } this.options.css = this.options.css.replace(/div\.DefaultPointyTip/g, "div#pointy_" + this.id), this.options.cssId = "pointyTipStyle_" + this.id } "string" == typeOf(this.options.direction) && (this.options.direction = { left: 9, right: 3, up: 12, down: 6 }[this.options.direction]), this.parent(t.caption, t.body, this.options), this.id && document.id(this).set("id", "pointy_" + this.id) }, build: function () { this.parent(); var t = this.options; this.pointyWrapper = new Element("div", { class: "pointyWrapper" }).inject(document.id(this)), document.id(this).getChildren().each(function (t) { t != this.pointyWrapper && this.pointyWrapper.grab(t) }, this); var i = t.divotSize, e = i; t.width.toInt(), t.divotSize; this.pointer = new Element("div", { styles: Object.append({ width: i, height: e, overflow: "hidden" }, function () { switch (t.direction) { case 12: case 1: case 11: return { height: e / 2 }; case 5: case 6: case 7: return { height: e / 2, backgroundPosition: "0 -" + e / 2 + "px" }; case 8: case 9: case 10: return { width: i / 2 }; case 2: case 3: case 4: return { width: i / 2, backgroundPosition: "100%" } } }()), class: "pointyDivot pointy_" + t.direction }).inject(this.pointyWrapper) }, expose: function () { return "none" != document.id(this).getStyle("display") && document.body != document.id(this) && document.id(document.body).contains(document.id(this)) ? function () { } : (document.id(this).setStyles({ visibility: "hidden", position: "absolute" }), document.body == document.id(this) || document.body.contains(document.id(this)) || (document.id(this).inject(document.body), t = !0), function () { t && document.id(this).dispose(), document.id(this).setStyles({ visibility: "visible", position: "relative" }) }.bind(this)); var t }, positionPointer: function (t) { if (this.pointer) { var i, e = t || this.options, s = e.direction; switch (s) { case 12: case 1: case 11: i = { edge: { x: "center", y: "bottom" }, position: { x: 12 == s ? "center" : 1 == s ? "right" : "left", y: "top" }, offset: { x: (12 == s ? 0 : 1 == s ? -1 : 1) * e.divotSize, y: 1 } }; break; case 2: case 3: case 4: i = { edge: { x: "left", y: "center" }, position: { x: "right", y: 3 == s ? "center" : 2 == s ? "top" : "bottom" }, offset: { x: -1, y: (3 == s ? 0 : 4 == s ? -1 : 1) * e.divotSize } }; break; case 5: case 6: case 7: i = { edge: { x: "center", y: "top" }, position: { x: 6 == s ? "center" : 5 == s ? "right" : "left", y: "bottom" }, offset: { x: (6 == s ? 0 : 5 == s ? -1 : 1) * e.divotSize, y: -1 } }; break; case 8: case 9: case 10: i = { edge: { x: "right", y: "center" }, position: { x: "left", y: 9 == s ? "center" : 10 == s ? "top" : "bottom" }, offset: { x: 1, y: (9 == s ? 0 : 8 == s ? -1 : 1) * e.divotSize } } }e = this.expose(); this.pointer.position(Object.append({ relativeTo: this.pointyWrapper, allowNegative: !0 }, i, t)), e() } }, setContent: function (t, i) { return this.parent(t, i), this.top[this.h1 ? "removeClass" : "addClass"]("noCaption"), Browser.ie && document.id(this).getElements(".bottom_ll, .bottom_lr").setStyle("font-size", 1), this.options.closeButton && this.body.setStyle("margin-right", 6), this.positionPointer(), this }, makeCaption: function (t) { this.parent(t), this.options.width && this.h1 && this.h1.setStyle("width", this.options.width.toInt() - (this.options.closeButton ? 25 : 15)) } }), StickyWin.UI.pointy = function (t, i, e) { return document.id(new StickyWin.UI.Pointy(t, i, e)) }, StickyWin.ui.pointy = StickyWin.UI.pointy, StickyWin.PointyTip = new Class({ Extends: StickyWin, options: { point: "left", pointyOptions: {} }, initialize: function () { var t = this.getArgs(arguments); this.setOptions(t.options); var i = this.options.pointyOptions, e = i.direction; e || (e = (e = { left: 9, right: 3, up: 12, down: 6 }[this.options.point]) || this.options.point, i.direction = e), i.width || (i.width = this.options.width), this.pointy = new StickyWin.UI.Pointy(t.caption, t.body, i), this.options.content = null, this.setOptions(t.options, this.getPositionSettings()), this.parent(this.options), this.win.empty().adopt(document.id(this.pointy)), this.attachHandlers(this.win), this.options.showNow && this.position() }, getArgs: function () { return StickyWin.UI.getArgs.apply(this, arguments) }, getPositionSettings: function () { var t = this.pointy.options.divotSize, i = this.options.point, e = this.options.offset || {}; switch (i) { case "left": case 8: case 9: case 10: return { edge: { x: "left", y: 10 == i ? "top" : 8 == i ? "bottom" : "center" }, position: { x: "right", y: "center" }, offset: { x: t + (e.x || 0), y: e.y || 0 } }; case "right": case 2: case 3: case 4: return { edge: { x: "right", y: (2 == i ? "top" : 4 == i ? "bottom" : "center") + (e.y || 0) }, position: { x: "left", y: "center" }, offset: { x: -t + (e.x || 0), y: e.y || 0 } }; case "up": case 11: case 12: case 1: return { edge: { x: 11 == i ? "left" : 1 == i ? "right" : "center", y: "top" }, position: { x: "center", y: "bottom" }, offset: { y: t + (e.y || 0), x: (11 == i ? -t : 1 == i ? t : 0) + (e.x || 0) } }; case "down": case 5: case 6: case 7: return { edge: { x: (7 == i ? "left" : 5 == i ? "right" : "center") + (e.x || 0), y: "bottom" }, position: { x: "center", y: "top" }, offset: { y: -t + (e.y || 0), x: (7 == i ? -t : 5 == i ? t : 0) + (e.x || 0) } } } }, setContent: function () { var t = this.getArgs(arguments); return this.pointy.setContent(t.caption, t.body), [this.pointy.h1, this.pointy.body].each(this.attachHandlers, this), this.visible && this.position(), this }, showWin: function () { this.parent(), this.pointy.positionPointer() }, position: function (t) { this.parent(t), this.pointy.positionPointer() }, attachHandlers: function (t) { t && (t.getElements("." + this.options.closeClassName).addEvent("click", function () { this.hide() }.bind(this)), t.getElements("." + this.options.pinClassName).addEvent("click", function () { this.togglepin() }.bind(this))) } }), Tips.Pointy = new Class({ Extends: Tips, options: { onShow: function (t, i) { i.show() }, onHide: function (t, i) { i.hide() }, pointyTipOptions: { point: 11, width: 150, pointyOptions: { closeButton: !1 } } }, initialize: function () { var t = Array.link(arguments, { options: Type.isObject, elements: function (t) { return null != t } }); this.setOptions(t.options), this.tip = new StickyWin.PointyTip(Object.append(this.options.pointyTipOptions, { showNow: !1 })), this.options.className && document.id(this.tip).addClass(this.options.className), t.elements && this.attach(t.elements) }, elementEnter: function (t, i) { var e = i.retrieve("tip:title"), s = i.retrieve("tip:text"); this.tip.setContent(e, s), this.timer = clearTimeout(this.timer), this.timer = this.show.delay(this.options.showDelay, this), this.position(i) }, elementLeave: function (t) { clearTimeout(this.timer), this.timer = this.hide.delay(this.options.hideDelay, this) }, elementMove: function (t) { }, position: function (t) { this.tip.setOptions({ relativeTo: t }), this.tip.position() }, show: function () { this.fireEvent("show", [document.id(this.tip), this.tip]) }, hide: function () { this.fireEvent("hide", [document.id(this.tip), this.tip]) }, destroy: function () { this.detach(), this.tip.destroy() } }), StickyWin.Modal = new Class({ Extends: StickyWin, options: { modalize: !0, maskOptions: { style: { "background-color": "#333", opacity: .8 } }, hideOnClick: !0, getWindowManager: function () { return StickyWin.ModalWM } }, initialize: function (t) { this.options.maskTarget = this.options.maskTarget || document.body, this.setOptions(t), this.mask = new Mask(this.options.maskTarget, this.options.maskOptions).addEvent("click", function () { this.options.hideOnClick && this.hide() }.bind(this)), this.parent(t) }, show: function (t) { [t, this.options.modalize].pick() && this.mask.show(), this.parent() }, hide: function (t) { [t, !0].pick() && this.mask.hide(), this.parent() }, destroy: function () { this.mask.destroy(), this.parent.apply(this, arguments) } }), StickyWin.ModalWM = new StickyWin.Stacker({ zIndexBase: 11e3 }), StickyWin.Fx && (StickyWin.Fx.Modal = StickyWin.Modal), StickyWin.Alert = new Class({ Implements: Options, Extends: StickyWin.Modal, options: { destroyOnClose: !0, modalOptions: { modalStyle: { zIndex: 11e3 } }, zIndex: 110001, uiOptions: { width: 250, buttons: [{ text: "Ok" }] }, getWindowManager: function () { } }, initialize: function (t, i, e) { this.message = i, this.caption = t, this.setOptions(e), this.setOptions({ content: this.build() }), this.parent(e) }, makeMessage: function () { return new Element("p", { class: "errorMsg SWclearfix", styles: { margin: 0, minHeight: 10 }, html: this.message }) }, build: function () { return StickyWin.ui(this.caption, this.makeMessage(), this.options.uiOptions) } }), StickyWin.Error = new Class({ Extends: StickyWin.Alert, makeMessage: function () { var t = this.parent(); return new Element("img", { src: (this.options.baseHref || Clientcide.assetLocation + "/simple.error.popup") + "/icon_problems_sm.gif", class: "bang clearfix", styles: { float: "left", width: 30, height: 30, margin: "3px 5px 5px 0px" } }).inject(t, "top"), t } }), StickyWin.alert = function (t, i, e) { return "string" == typeOf(e) && (e = { baseHref: e }), new StickyWin.Alert(t, i, e) }, StickyWin.error = function (t, i, e) { return new StickyWin.Error(t, i, e) }, StickyWin.Confirm = new Class({ Extends: StickyWin.Alert, options: { uiOptions: { width: 250 } }, build: function (t) { return this.setOptions({ uiOptions: { buttons: [{ text: "Cancel" }, { text: "Ok", onClick: t || function () { this.fireEvent("confirm") }.bind(this) }] } }), this.parent() } }), StickyWin.confirm = function (t, i, e, s) { return new StickyWin.Confirm(t, i, s).addEvent("confirm", e) }, Form.Validator.Tips = new Class({ Extends: Form.Validator.Inline, options: { pointyTipOptions: { point: "left", width: 250 }, tipCaption: "" }, showAdvice: function (t, i) { i = this.getAdvice(i); i && !i.visible && (i.show(), i.position(), i.pointy.positionPointer()) }, hideAdvice: function (t, i) { i = this.getAdvice(i); i && i.visible && i.hide() }, getAdvice: function (t, i) { return Array.link(arguments, { field: Type.isElement }).field.retrieve("PointyTip") }, advices: [], makeAdvice: function (t, i, e, s) { if (e || s) { var n, o, h, a = i.retrieve("PointyTip"); return a || (n = s ? "warning-advice" : "validation-advice", o = new Element("ul", { styles: { margin: 0, padding: 0, listStyle: "none" } }), (h = this.makeAdviceItem(t, i)) && o.adopt(h), i.store("validationMsgs", o), a = new StickyWin.PointyTip(this.options.tipCaption, o, Object.merge(this.options.pointyTipOptions, { showNow: !1, relativeTo: i, inject: { target: this.element } })), this.advices.push(a), a.msgs = {}, i.store("PointyTip", a), document.id(a).addClass(n).set("id", "advice-" + t + "-" + this.getFieldId(i))), i.store("advice-" + t, a), this.appendAdvice(t, i, e, s), a.pointy.positionPointer(), a } }, validateField: function (t, i) { var e = this.getAdvice(t); if (this.advices.some(function (t) { return t.visible }) && this.options.serial) return e && e.visible && (s = this.parent(t, i), t.hasClass("validation-failed") || e.hide()), s; var s = t.retrieve("validationMsgs"); return s && s.getChildren().hide(), (t.hasClass("validation-failed") || t.hasClass("warning")) && e && e.show(), !this.options.serial || (e = this.element.getElements(".validation-failed, .warning")).length && e.each(function (t, i) { t = this.getAdvice(t); t && t.hide() }, this), this.parent(t, i) }, makeAdviceItem: function (t, i, e, s) { if (e || s) { var n = this.getAdvice(i), s = this.makeAdviceMsg(i, e, s); return n && n.msgs[t] ? n.msgs[t].set("html", s) : new Element("li", { html: s, style: { display: "none" } }) } }, makeAdviceMsg: function (t, i, e) { e = e ? this.warningPrefix : this.errorPrefix; return e += this.options.useTitles && t.title || i }, appendAdvice: function (t, i, e, s) { var n = this.getAdvice(i); if (n.msgs[t]) return n.msgs[t].set("html", this.makeAdviceMsg(i, e, s)).show(); s = this.makeAdviceItem(t, i, e, s); s && (s.inject(i.retrieve("validationMsgs")).show(), n.msgs[t] = s) }, insertAdvice: function (t, i) { var e = i.get("validatorProps"); e.msgPos && document.id(e.msgPos) ? document.id(e.msgPos).grab(t) : "radio" === i.type.toLowerCase() ? i.getParent().adopt(t) : document.id(t).inject(document.id(i), "after"), t.position() } }), window.FormValidator && (FormValidator.Tips = Form.Validator.Tips); var HoverGroup = new Class({ Implements: [Options, Events], Binds: ["enter", "leave", "remain"], options: { elements: [], delay: 300, start: ["mouseenter"], remain: [], end: ["mouseleave"] }, initialize: function (t) { this.setOptions(t), this.attachTo(this.options.elements), this.addEvents({ leave: function () { this.active = !1 }, enter: function () { this.active = !0 } }) }, elements: [], attachTo: function (t, i) { var e = {}, s = {}, n = {}; return t = Array.from(document.id(t) || $$(t)), this.options.start.each(function (t) { e[t] = this.enter }, this), this.options.end.each(function (t) { n[t] = this.leave }, this), this.options.remain.each(function (t) { s[t] = this.remain }, this), i ? t.each(function (t) { t.removeEvents(e).removeEvents(n).removeEvents(s), this.elements.erase(t) }, this) : (t.each(function (t) { t.addEvents(e).addEvents(n).addEvents(s) }), this.elements.combine(t)), this }, detachFrom: function (t) { this.attachTo(t, !0) }, enter: function (t) { this.isMoused = !0, this.assert(t) }, leave: function (t) { this.isMoused = !1, this.assert(t) }, remain: function (t) { this.active && this.enter(t) }, assert: function (t) { clearTimeout(this.assertion), this.assertion = function () { !this.isMoused && this.active ? this.fireEvent("leave", t) : this.isMoused && !this.active && this.fireEvent("enter", t) }.delay(this.options.delay, this) } }); Browser.ie || (StickyWin = Class.refactor(StickyWin, { options: { fade: !0, fadeDuration: 150 }, hideWin: function () { this.options.fade ? this.fade(0) : this.previous() }, showWin: function () { this.options.fade ? this.fade(1) : this.previous() }, hide: function () { this.previous(this.options.fade) }, show: function () { this.previous(this.options.fade) }, fade: function (t) { var i; return this.fadeFx || (this.win.setStyles({ opacity: 0, display: "block" }), i = { property: "opacity", duration: this.options.fadeDuration }, this.options.fadeTransition && (i.transition = this.options.fadeTransition), this.fadeFx = new Fx.Tween(this.win, i)), 0 < t && (this.win.setStyle("display", "block"), this.position()), this.fadeFx.clearChain(), this.fadeFx.start(t).chain(function () { 0 == t ? (this.win.setStyle("display", "none"), this.fireEvent("onClose")) : this.fireEvent("onDisplay") }.bind(this)), this } })), StickyWin.Fx = StickyWin; var Observer = new Class({ Implements: [Options, Events], options: { periodical: !1, delay: 1e3 }, initialize: function (t, i, e) { this.setOptions(e), this.addEvent("onFired", i), this.element = document.id(t) || $$(t), this.boundChange = this.changed.bind(this), this.resume() }, changed: function () { var t = this.element.get("value"); $equals(this.value, t) || (this.clear(), this.value = t, this.timeout = this.onFired.delay(this.options.delay, this)) }, setValue: function (t) { return this.value = t, this.element.set("value", t), this.clear() }, onFired: function () { this.fireEvent("onFired", [this.value, this.element]) }, clear: function () { return clearTimeout(this.timeout || null), this }, pause: function () { return clearTimeout(this.timeout), clearTimeout(this.timer), this.element.removeEvent("keyup", this.boundChange), this }, resume: function () { return this.value = this.element.get("value"), this.options.periodical ? this.timer = this.changed.periodical(this.options.periodical, this) : this.element.addEvent("keyup", this.boundChange), this } }), $equals = function (t, i) { return t == i || JSON.encode(t) == JSON.encode(i) }, Autocompleter = {}, OverlayFix = IframeShim; Autocompleter.Base = new Class({ Implements: [Options, Events], options: { minLength: 1, markQuery: !0, width: "inherit", maxChoices: 10, className: "autocompleter-choices", zIndex: 42, delay: 400, observerOptions: {}, fxOptions: {}, autoSubmit: !1, overflow: !1, overflowMargin: 25, selectFirst: !1, filter: null, filterCase: !1, filterSubset: !1, forceSelect: !1, selectMode: !0, choicesMatch: null, multiple: !1, separator: ", ", autoTrim: !0, allowDupes: !1, cache: !0, relative: !1 }, initialize: function (t, i) { this.element = document.id(t), this.setOptions(i), this.options.separatorSplit = new RegExp("s*[" + this.options.separator == " " ? " " : this.options.separator.trim() + "]s*/"), this.build(), this.observer = new Observer(this.element, this.prefetch.bind(this), Object.merge({ delay: this.options.delay }, this.options.observerOptions)), this.queryValue = null, this.options.filter && (this.filter = this.options.filter.bind(this)); i = this.options.selectMode; this.typeAhead = "type-ahead" == i, this.selectMode = !0 === i ? "selection" : i, this.cached = [] }, build: function () { document.id(this.options.customChoices) ? this.choices = this.options.customChoices : (this.choices = new Element("ul", { class: this.options.className, styles: { zIndex: this.options.zIndex } }).inject(document.body), this.relative = !1, !this.options.relative && this.element.getOffsetParent() == document.body || (this.choices.inject(this.element, "after"), this.relative = this.element.getOffsetParent()), this.fix = new OverlayFix(this.choices)), this.options.separator.test(this.options.separatorSplit) || (this.options.separatorSplit = this.options.separator), this.fx = this.options.fxOptions ? new Fx.Tween(this.choices, Object.merge({ property: "opacity", link: "cancel", duration: 200 }, this.options.fxOptions)).addEvent("onStart", Chain.prototype.clearChain).set(0) : null, this.element.setProperty("autocomplete", "off").addEvent(Browser.ie || Browser.chrome || Browser.safari ? "keydown" : "keypress", this.onCommand.bind(this)).addEvent("click", this.onCommand.bind(this, !1)).addEvent("focus", function () { this.toggleFocus.delay(100, this, [!0]) }.bind(this)), document.addEvent("click", function (t) { t.target != this.choices && this.toggleFocus(!1) }.bind(this)) }, destroy: function () { this.fix && this.fix.dispose(), this.choices = this.selected = this.choices.destroy() }, toggleFocus: function (t) { (this.focussed = t) || this.hideChoices(!0), this.fireEvent(t ? "onFocus" : "onBlur", [this.element]) }, onCommand: function (t) { if (!t && this.focussed) return this.prefetch(); if (t && t.key && !t.shift) switch (t.key) { case "enter": case "tab": if (this.element.value != this.opted) return !0; if (this.selected && this.visible) return this.choiceSelect(this.selected), this.fireEvent("choiceConfirm", this.selected), !!this.options.autoSubmit; break; case "up": case "down": return this.prefetch() || null === this.queryValue || (t = "up" == t.key, this.choiceOver((this.selected || this.choices)[this.selected ? t ? "getPrevious" : "getNext" : t ? "getLast" : "getFirst"](this.options.choicesMatch), !0)), !1; case "esc": this.hideChoices(!0) }return !0 }, setSelection: function (t) { var i, e, s = this.selected.inputValue, n = s, o = this.queryValue.length, h = s.length; s.substr(0, o).toLowerCase() != this.queryValue.toLowerCase() && (o = 0), this.options.multiple && (e = this.options.separatorSplit, n = this.element.value, o += this.queryIndex, h += this.queryIndex, i = n.substr(this.queryIndex).split(e, 1)[0], n = n.substr(0, this.queryIndex) + s + n.substr(this.queryIndex + i.length), t && (e = /[^\s,]+/, i = n.split(this.options.separatorSplit).filter(e.test, e), this.options.allowDupes || (i = [].combine(i)), e = this.options.separator, h = (n = i.join(e) + e).length)), this.observer.setValue(n), this.opted = n, !t && "pick" != this.selectMode || (o = h), this.element.selectRange(o, h), this.fireEvent("onSelection", [this.element, this.selected, n, s]) }, showChoices: function () { var t, i, e = this.options.choicesMatch, s = this.choices.getFirst(e); this.selected = this.selectedValue = null, this.fix && (t = this.element.getCoordinates(this.relative), i = this.options.width || "auto", this.choices.setStyles({ left: t.left, top: t.bottom, width: !0 === i || "inherit" == i ? t.width : i })), s && (this.visible || (this.visible = !0, this.choices.setStyle("display", ""), this.fx && this.fx.start(1), this.fireEvent("onShow", [this.element, this.choices])), (this.options.selectFirst || this.typeAhead || s.inputValue == this.queryValue) && this.choiceOver(s, this.typeAhead), i = this.choices.getChildren(e), s = this.options.maxChoices, e = { overflowY: "hidden", height: "" }, this.overflown = !1, i.length > s && (s = i[s - 1], e.overflowY = "scroll", e.height = s.getCoordinates(this.choices).bottom, this.overflown = !0), this.choices.setStyles(e), this.fix && this.fix.show()) }, hideChoices: function (t) { var i; t && (i = this.element.value, this.options.forceSelect && (i = this.opted), this.options.autoTrim && (i = i.split(this.options.separatorSplit).filter(function () { return arguments[0] }).join(this.options.separator)), this.observer.setValue(i)), this.visible && (this.visible = !1, this.observer.clear(), i = function () { this.choices.setStyle("display", "none"), this.fix && this.fix.hide() }.bind(this), this.fx ? this.fx.start(0).chain(i) : i(), this.fireEvent("onHide", [this.element, this.choices])) }, prefetch: function () { var t, i, e, s = this.element.value, n = s; if (this.options.multiple && (e = this.options.separatorSplit, t = s.split(e), i = this.element.getCaretPosition(), i -= (e = s.substr(0, i).split(e))[e = e.length - 1].length, n = t[e]), n.length < this.options.minLength) this.hideChoices(); else if (n === this.queryValue || this.visible && n == this.selectedValue) { if (this.visible) return !1; this.showChoices() } else this.queryValue = n, this.queryIndex = i, this.fetchCached() || this.query(); return !0 }, fetchCached: function () { return !(!(this.options.cache && this.cached && this.cached.length) || this.cached.length >= this.options.maxChoices || this.queryValue) && (this.update(this.filter(this.cached)), !0) }, update: function (t) { this.choices.empty(), (this.cached = t) && t.length ? (this.options.maxChoices < t.length && !this.options.overflow && (t.length = this.options.maxChoices), t.each(this.options.injectChoice || function (t) { var i = new Element("li", { html: this.markQueryValue(t) }); i.inputValue = t, this.addChoiceEvents(i).inject(this.choices) }, this), this.showChoices()) : this.hideChoices() }, choiceOver: function (t, i) { var e, s, n; t && t != this.selected && (this.selected && this.selected.removeClass("autocompleter-selected"), this.selected = t.addClass("autocompleter-selected"), this.fireEvent("onSelect", [this.element, this.selected, i]), i && (this.selectedValue = this.selected.inputValue, this.overflown && (e = this.selected.getCoordinates(this.choices), s = this.options.overflowMargin, i = (n = this.choices.scrollTop) + (t = this.choices.offsetHeight), e.top - s < n && n ? this.choices.scrollTop = Math.max(e.top - s, 0) : e.bottom + s > i && (this.choices.scrollTop = Math.min(e.bottom - t + s, i))), this.selectMode && this.setSelection())) }, choiceSelect: function (t) { t && this.choiceOver(t), this.setSelection(!0), this.queryValue = !1, this.hideChoices() }, filter: function (t) { return (t || this.tokens).filter(function (t) { return this.test(t) }, new RegExp((this.options.filterSubset ? "" : "^") + this.queryValue.escapeRegExp(), this.options.filterCase ? "" : "i")) }, markQueryValue: function (t) { if (!this.options.markQuery || !this.queryValue) return t; var i = new RegExp("(" + (this.options.filterSubset ? "" : "^") + this.queryValue.escapeRegExp() + ")", this.options.filterCase ? "" : "i"); return t.replace(i, '<span class="autocompleter-queried">$1</span>') }, addChoiceEvents: function (i) { return i.addEvents({ mouseover: this.choiceOver.bind(this, i), click: function () { var t = this.choiceSelect(i); return this.fireEvent("choiceConfirm", this.selected), t }.bind(this) }) } }), Autocompleter.Ajax = {}, Autocompleter.Ajax.Base = new Class({ Extends: Autocompleter.Base, options: { postVar: "value", postData: {}, ajaxOptions: {} }, initialize: function (t, i) { this.parent(t, i); i = document.id(this.options.indicator); i && this.addEvents({ onRequest: i.show.bind(i), onComplete: i.hide.bind(i) }, !0) }, query: function () { var t = Object.clone(this.options.postData); t[this.options.postVar] = this.queryValue, this.fireEvent("onRequest", [this.element, this.request, t, this.queryValue]), this.request.send({ data: t }) }, queryResponse: function () { this.fireEvent("onComplete", [this.element, this.request, this.response]) } }), Autocompleter.Ajax.Json = new Class({ Extends: Autocompleter.Ajax.Base, initialize: function (t, i, e) { this.parent(t, e), this.request = new Request.JSON(Object.merge({ url: i, link: "cancel" }, this.options.ajaxOptions)).addEvent("onComplete", this.queryResponse.bind(this)) }, queryResponse: function (t) { this.parent(), this.update(t) } }), Autocompleter.Ajax.Xhtml = new Class({ Extends: Autocompleter.Ajax.Base, initialize: function (t, i, e) { this.parent(t, e), this.request = new Request.HTML(Object.merge({ url: i, link: "cancel", update: this.choices }, this.options.ajaxOptions)).addEvent("onComplete", this.queryResponse.bind(this)) }, queryResponse: function (t, i) { this.parent(), i && i.length ? (this.choices.getChildren(this.options.choicesMatch).each(this.options.injectChoice || function (t) { var i = t.innerHTML; t.inputValue = i, this.addChoiceEvents(t.set("html", this.markQueryValue(i))) }, this), this.showChoices()) : this.hideChoices() } }), Autocompleter.Local = new Class({ Extends: Autocompleter.Base, options: { minLength: 0, delay: 200 }, initialize: function (t, i, e) { this.parent(t, e), this.tokens = i }, query: function () { this.update(this.filter()) } }), Autocompleter.Base = Class.refactor(Autocompleter.Base, { initialize: function (t, i, e) { this.previous(t, i, e), this.writeStyle() }, writeStyle: function () { window.addEvent("domready", function () { document.id("AutocompleterCss") || new Element("link", { rel: "stylesheet", media: "screen", type: "text/css", href: (this.options.baseHref || Clientcide.assetLocation + "/autocompleter") + "/Autocompleter.css", id: "AutocompleterCss" }).inject(document.head) }.bind(this)) } }), function () { function t(t) { return { Extends: t, options: { url: "", showNow: !1, cacheRequest: !1, requestOptions: { method: "get", evalScripts: !0 }, wrapWithUi: !1, caption: "", uiOptions: {}, handleResponse: function (t) { this.options.cacheRequest && this.element.store(this.Request.options.url, t); var i = ""; this.Request.response.text.stripScripts(function (t) { i += t }), this.options.wrapWithUi && (t = StickyWin.ui(this.options.caption, t, this.options.uiOptions)), this.setContent(t), this.show(), this.evalScripts && Browser.exec(i), this.fireEvent("update") } }, initialize: function (t) { var i; t && t.showNow && (i = !0, t.showNow = !1), this.parent(t), this.evalScripts = this.options.requestOptions.evalScripts, this.options.requestOptions.evalScripts = !1, this.createRequest(), i && this.update() }, createRequest: function () { this.Request = new Request(this.options.requestOptions).addEvent("onSuccess", this.options.handleResponse.bind(this)) }, update: function (t, i) { var e; return this.Request.options.url = t || i.url, this.options.cacheRequest && (e = this.element.retrieve(t)), e ? this.Request.fireEvent("onSuccess", e) : this.Request.setOptions(i).send({ url: t || this.options.url }), this } } } try { StickyWin.Ajax = new Class(t(StickyWin)) } catch (t) { } try { StickyWin.Modal.Ajax = new Class(t(StickyWin.Modal)) } catch (t) { } try { StickyWin.PointyTip.Ajax = new Class(t(StickyWin.PointyTip)) } catch (t) { } }(), Autocompleter.JSONP = new Class({ Extends: Autocompleter.Ajax.Json, options: { postVar: "query", jsonpOptions: {}, minLength: 1 }, initialize: function (t, i, e) { this.url = i, this.setOptions(e), this.parent(t, e) }, query: function () { var t = Object.clone(this.options.jsonpOptions.data || {}); t[this.options.postVar] = this.queryValue, this.jsonp = new Request.JSONP(Object.merge({ url: this.url, data: t }, this.options.jsonpOptions)), this.jsonp.addEvent("onComplete", this.queryResponse.bind(this)), this.fireEvent("onRequest", [this.element, this.jsonp, t, this.queryValue]), this.jsonp.send() }, queryResponse: function (t) { this.parent(); t = this.options.filter ? this.options.filter.apply(this, [t]) : t; this.update(t) } }), Autocompleter.JsonP = Autocompleter.JSONP, StickyWin.Prompt = new Class({ Extends: StickyWin.Confirm, options: { defaultValue: "" }, initialize: function (t, i, e) { this.addEvent("display", function () { this.input.select() }.bind(this)), this.parent.apply(this, arguments) }, makeMessage: function () { return this.input = new Element("input", { value: this.options.defaultValue, type: "text", id: "foo", styles: { width: "100%" }, events: { keyup: function (t) { "enter" == t.key && (this.fireEvent("confirm", this.input.get("value")), this.hide()) }.bind(this) } }), new Element("div").adopt(this.parent()).adopt(this.input) }, build: function () { return this.parent(function () { this.fireEvent("confirm", this.input.get("value")) }.bind(this)) } }), StickyWin.prompt = function (t, i, e, s) { return new StickyWin.Prompt(t, i, s).addEvent("confirm", e) }; var TabSwapper = new Class({ Implements: [Options, Events], options: { preventDefault: !0, selectedClass: "tabSelected", mouseoverClass: "tabOver", deselectedClass: "", rearrangeDOM: !0, effectOptions: { duration: 500 }, cookieDays: 999 }, tabs: [], sections: [], clickers: [], sectionFx: [], initialize: function (t) { this.setOptions(t); t = this.setup(); if (t) return t; null != this.options.initPanel ? this.show(this.options.initPanel) : this.options.cookieName && this.recall() ? this.show(this.recall().toInt()) : this.show(0) }, setup: function () { var t = this.options, e = $$(t.sections), i = $$(t.tabs); if (i[0] && i[0].retrieve("tabSwapper")) return i[0].retrieve("tabSwapper"); var s = $$(t.clickers); i.each(function (t, i) { this.addTab(t, e[i], s[i], i) }, this) }, addTab: function (i, t, e, s) { return i = document.id(i), e = document.id(e), t = document.id(t), 0 <= this.tabs.indexOf(i) && i.retrieve("tabbered") && this.tabs.indexOf(i) != s && this.options.rearrangeDOM ? this.moveTab(this.tabs.indexOf(i), s) : (null == s && (s = this.tabs.length), 0 < s && this.tabs[s - 1] && this.options.rearrangeDOM && (i.inject(this.tabs[s - 1], "after"), t.inject(this.tabs[s - 1].retrieve("section"), "after")), this.tabs.splice(s, 0, i), e = e || i, i.addEvents({ mouseout: function () { i.removeClass(this.options.mouseoverClass) }.bind(this), mouseover: function () { i.addClass(this.options.mouseoverClass) }.bind(this) }), e.addEvent("click", function (t) { this.options.preventDefault && t.preventDefault(), this.show(this.tabs.indexOf(i)) }.bind(this)), i.store("tabbered", !0), i.store("section", t), i.store("clicker", e), this.hideSection(s)), this }, removeTab: function (t) { var i = this.tabs[this.now]; return this.now == t && (0 < t ? this.show(t - 1) : t < this.tabs.length && this.show(t + 1)), this.now = this.tabs.indexOf(i), this }, moveTab: function (t, i) { var e = this.tabs[t], s = e.retrieve("clicker"), n = e.retrieve("section"), o = this.tabs[i], h = o.retrieve("clicker"), t = o.retrieve("section"); return this.tabs.erase(e).splice(i, 0, e), e.inject(o, "before"), s.inject(h, "before"), n.inject(t, "before"), this }, show: function (e) { return null == this.now && this.tabs.each(function (t, i) { e != i && this.hideSection(i) }, this), this.showSection(e).save(e), this }, save: function (t) { return this.options.cookieName && Cookie.write(this.options.cookieName, t, { duration: this.options.cookieDays }), this }, recall: function () { return !!this.options.cookieName && Cookie.read(this.options.cookieName) }, hideSection: function (t) { var i = this.tabs[t]; if (!i) return this; var e = i.retrieve("section"); return e && "none" != e.getStyle("display") && (this.lastHeight = e.getSize().y, e.setStyle("display", "none"), i.swapClass(this.options.selectedClass, this.options.deselectedClass), this.fireEvent("onBackground", [t, e, i])), this }, showSection: function (t) { var i = this.tabs[t]; if (!i) return this; var e = i.retrieve("section"); if (!e) return this; var s, n, o, h = this.options.smooth && !Browser.ie; return this.now != t && (i.retrieve("tabFx") || i.store("tabFx", new Fx.Morph(e, this.options.effectOptions)), s = e.getStyle("overflow"), o = { display: "block", overflow: "hidden" }, h && (o.opacity = 0), n = !1, h ? n = { opacity: 1 } : e.getStyle("opacity").toInt() < 1 && (e.setStyle("opacity", 1), this.options.smoothSize || this.fireEvent("onActiveAfterFx", [t, e, i])), this.options.smoothSize && (h = e.getDimensions().height, null != this.options.maxSize && this.options.maxSize < h && (h = this.options.maxSize), (n = n || {}).height = h), null != this.now && this.hideSection(this.now), this.options.smoothSize && this.lastHeight && (o.height = this.lastHeight), e.setStyles(o), o = function () { this.fireEvent("onActiveAfterFx", [t, e, i]), e.setStyles({ height: this.options.maxSize == n.height ? this.options.maxSize : "auto", overflow: s }), e.getElements("input, textarea").setStyle("opacity", 1) }.bind(this), n ? i.retrieve("tabFx").start(n).chain(o) : o(), this.now = t, this.fireEvent("onActive", [t, e, i])), i.swapClass(this.options.deselectedClass, this.options.selectedClass), this } });

var SalsaTips = new Class({ Implements: [Options, Events], options: { class_name: "" }, initialize: function (s) { this.setOptions(s), new Tips(this.options.class_name, { offset: { x: 20, y: 20 }, fixed: !0 }) } }); document.addEvent("domready", function () { new SalsaTips({ class_name: ".salsa-tip" }) });

var SalsaDropdown = new Class({ Implements: [Options, Events], options: { container: ".dropdown-container", toggler: ".dropdown-button", panel: ".dropdown-panel", activeClass: "dropdown-active", closeClass: "dropdown-close", keepOpen: "" }, initialize: function (t) { this.setOptions(t), this.opened_panel = null, this._init_document_event(), this._init_toggler_event() }, _init_document_event: function () { document.addEvent("click", function (t) { !t.target.hasClass(this.options.closeClass) && (t.target.hasClass(this.options.panel) || t.target.getParent(this.options.container) || this.options.keepOpen && t.target.getParents(this.options.keepOpen).getLast()) || this._hide_panels() }.bind(this)) }, _init_toggler_event: function () { var t = "click:relay(" + this.options.container + " " + this.options.toggler + ")"; document.getElement("body").addEvent(t, function (t, e) { t.preventDefault(); var n = e.getParent(this.options.container), t = n.hasClass(this.options.activeClass), e = n.getElements(this.options.panel); this._hide_panels(), t || this._show_panel(n, e), e.getPosition()[0].x + e.getSize()[0].x > window.getSize().x ? e.addClass("dropdown-panel-right") : e.removeClass("dropdown-panel-right") }.bind(this)) }, _hide_panels: function () { null !== this.opened_panel && (document.getElements(this.options.container).removeClass(this.options.activeClass), document.getElements(this.options.panel).setStyle("display", "none"), this.fireEvent("hidden", this.opened_panel), this.opened_panel = null) }, _show_panel: function (t, e) { this.opened_panel = e, t.addClass(this.options.activeClass), e.setStyle("display", ""), this.fireEvent("visible", e) } });

var SlideoutMenu = new Class
    ({
        Implements: Options,

        options: {
            slideout_menu_toggler_id: "",
            slideout_menu_panel_id: "",
            header_id: "",
            wrapper_id: "",
            panel_width: ""
        },

        initialize: function (options) {
            this.setOptions(options);

            this.slideout_menu_toggler = document.id(this.options.slideout_menu_toggler_id);
            this.slideout_menu_panel = document.id(this.options.slideout_menu_panel_id);
            this.body = document.getElement('body');
            this.header = document.id(this.options.header_id);
            this.wrapper = document.id(this.options.wrapper_id);

            this.asideFX = new Fx.Tween(this.options.slideout_menu_panel_id);

            this._init_events();
        },

        _init_events: function () {
            this.slideout_menu_toggler.addEvent('click', function (event) {
                event.preventDefault();

                this.body.toggleClass('slideout-menu-open');
                this.header.toggleClass('slideout-menu-open');
                this.wrapper.toggleClass('slideout-menu-open');
                this.slideout_menu_panel.toggleClass('slideout-menu-open');

                if (this.wrapper.hasClass("slideout-menu-open")) {
                    this.asideFX
                        .set('left', '-' + this.options.panel_width + 'px')
                        .set('display', 'block')
                        .start('left', '-' + this.options.panel_width + 'px', '0')
                        .chain(function () {
                            this.slideout_menu_toggler.addClass("slideout-menu-open");
                        }.bind(this));
                }
                else {
                    this.asideFX
                        .start('left', '0', '-' + this.options.panel_width + 'px')
                        .chain(function () {
                            console.log(this);
                            this.slideout_menu_panel.set('display', 'none');
                            this.slideout_menu_panel.set('left', '0');
                            this.slideout_menu_toggler.removeClass("slideout-menu-open");
                        }.bind(this));
                }
            }.bind(this));

            this.wrapper.addEvent('click', function (event) {
                if ((event.target.get("id") !== this.options.slideout_menu_toggler_id) && (event.target.getParent(".slideout-menu-open"))) {
                    this.body.toggleClass('slideout-menu-open');
                    this.header.toggleClass('slideout-menu-open');
                    this.wrapper.toggleClass('slideout-menu-open');
                    this.slideout_menu_panel.toggleClass('slideout-menu-open');

                    this.asideFX
                        .start('left', '0', '-' + this.options.panel_width + 'px')
                        .chain(function () {
                            console.log(this);
                            this.slideout_menu_panel.set('display', 'none');
                            this.slideout_menu_panel.set('left', '0');
                            this.slideout_menu_toggler.removeClass("slideout-menu-open");
                        }.bind(this));
                }
            }.bind(this));
        }
    });

function salsa_slide(n, t, e, i) { var o = new Fx.Slide(document.id(n), { resetHeight: !0 }), d = document.id(t); null == i || "closed" == i ? o.hide() : d.toggleClass(e), d.addEvent("click", function (n) { n = new Event(n), o.toggle(), n.stop(), null != e && d.toggleClass(e) }) } function salsa_go_to_top(t) { document.id(t).set("opacity", "0").setStyle("display", "block"), window.addEvent("scroll", function (n) { document.id(t).fade(400 < window.getScroll().y ? "in" : "out") }) } function salsa_curvy_corners(n, t, e, i, o, d) { var s = { tl: { radius: t }, tr: { radius: e }, bl: { radius: i }, br: { radius: o }, antiAlias: d }; document.getElements(n).each(function (n) { curvyCorners(s, n) }) } function salsa_is_mobile() { return (0 < window.innerWidth ? window.innerWidth : screen.width) <= 480 }

var Mediabox; !function () { var l, i, o, a, c, r, e, s, t, n, m, d, p, w, h, u, f, g, b, y, v, x, S, k, j, E, I, C, B, T, F, N, P, W = new Image, _ = new Image, D = !1, H = "none", L = "mediaBox"; function A() { h.setStyles({ top: window.getScrollTop(), left: window.getScrollLeft() }) } function M() { n = window.getWidth(), m = window.getHeight(), h.setStyles({ width: n, height: m }) } function $(t) { Browser.Engine.gecko && ["object", window.ie ? "select" : "embed"].forEach(function (e) { Array.forEach(document.getElementsByTagName(e), function (e) { t && (e._mediabox = e.style.visibility), e.style.visibility = t ? "hidden" : e._mediabox }) }), h.style.display = t ? "" : "none"; var e = t ? "addEvent" : "removeEvent"; D && window[e]("scroll", A), window[e]("resize", M), l.keyboard && document[e]("keydown", z) } function z(e) { if (l.alpha) switch (e.code) { case 27: case 88: case 67: G(); break; case 37: case 80: O(); break; case 39: case 78: R() } else switch (e.code) { case 27: G(); break; case 37: O(); break; case 39: R() }if (l.stopKey) return !1 } function O() { return q(a) } function R() { return q(c) } function q(e) { var t; return 0 <= e && (f.set("html", ""), a = ((o = e) || !l.loop ? o : i.length) - 1, (c = o + 1) == i.length && (c = l.loop ? 0 : -1), function () { p && (p.onload = $empty); d.resize.cancel(), d.image.cancel().set(0), d.bottom.cancel().set(0), $$(x, k).setStyle("display", "none") }(), (t = u.getProperty("class")) && t.split(" ").each(function (e) { "mbType-" === e.substring(0, 7) && u.removeClass(e) }), u.addClass("mbLoading"), i[e][2] || (i[e][2] = ""), E = i[e][2].split(" "), I = E.length, T = 1 < I ? (B = E[I - 2].match("%") ? window.getWidth() * (.01 * E[I - 2].replace("%", "")) + "px" : "auto" == E[I - 2] ? "auto" : E[I - 2] + "px", E[I - 1].match("%") ? window.getHeight() * (.01 * E[I - 1].replace("%", "")) + "px" : "auto" == E[I - 1] ? "auto" : E[I - 1] + "px") : B = "", j = i[e][0], b = i[o][1].split("::"), j.match(/quietube\.com/i) ? j = (F = j.split("v.php/"))[1] : j.match(/\/\/yfrog/i) && ((H = j.substring(j.length - 1)).match(/b|g|j|p|t/i) && (H = "image"), "s" == H && (H = "flash"), H.match(/f|z/i) && (H = "video"), j += ":iphone"), j.match(/\.gif|\.jpg|\.jpeg|\.png|twitpic\.com/i) || "image" == H ? (H = "img", j = j.replace(/twitpic\.com/i, "twitpic.com/show/full"), (p = new Image).onload = V, p.src = j) : (j.match(/\.flv|\.mp4/i) || "video" == H ? (H = "obj", B = B || l.defaultWidth, T = T || l.defaultHeight, p = l.useNB ? new Swiff(l.playerpath + "?mediaURL=" + j + "&allowSmoothing=true&autoPlay=" + l.autoplay + "&buffer=6&showTimecode=" + l.showTimecode + "&loop=" + l.medialoop + "&controlColor=" + l.controlColor + "&controlBackColor=" + l.controlBackColor + "&defaultVolume=" + l.volume + "&scaleIfFullScreen=true&showScalingButton=true&crop=false", { id: "MediaboxSWF", width: B, height: T, params: { wmode: l.wmode, bgcolor: l.bgcolor, allowscriptaccess: l.scriptaccess, allowfullscreen: l.fullscreen } }) : new Swiff(l.JWplayerpath + "?file=" + j + "&backcolor=" + l.backcolor + "&frontcolor=" + l.frontcolor + "&lightcolor=" + l.lightcolor + "&screencolor=" + l.screencolor + "&autostart=" + l.autoplay + "&controlbar=" + l.controlbar, { id: "MediaboxSWF", width: B, height: T, params: { wmode: l.wmode, bgcolor: l.bgcolor, allowscriptaccess: l.scriptaccess, allowfullscreen: l.fullscreen } })) : j.match(/\.mp3|\.aac|tweetmic\.com|tmic\.fm/i) || "audio" == H ? (H = "obj", B = B || l.defaultWidth, T = T || "20px", j.match(/tweetmic\.com|tmic\.fm/i) && ((j = j.split("/"))[4] = j[4] || j[3], j = "http://media4.fjarnet.net/tweet/tweetmicapp-" + j[4] + ".mp3"), p = l.useNB ? new Swiff(l.playerpath + "?mediaURL=" + j + "&allowSmoothing=true&autoPlay=" + l.autoplay + "&buffer=6&showTimecode=" + l.showTimecode + "&loop=" + l.medialoop + "&controlColor=" + l.controlColor + "&controlBackColor=" + l.controlBackColor + "&defaultVolume=" + l.volume + "&scaleIfFullScreen=true&showScalingButton=true&crop=false", { id: "MediaboxSWF", width: B, height: T, params: { wmode: l.wmode, bgcolor: l.bgcolor, allowscriptaccess: l.scriptaccess, allowfullscreen: l.fullscreen } }) : new Swiff(l.JWplayerpath + "?file=" + j + "&backcolor=" + l.backcolor + "&frontcolor=" + l.frontcolor + "&lightcolor=" + l.lightcolor + "&screencolor=" + l.screencolor + "&autostart=" + l.autoplay, { id: "MediaboxSWF", width: B, height: T, params: { wmode: l.wmode, bgcolor: l.bgcolor, allowscriptaccess: l.scriptaccess, allowfullscreen: l.fullscreen } })) : j.match(/\.swf/i) || "flash" == H ? (H = "obj", B = B || l.defaultWidth, T = T || l.defaultHeight, p = new Swiff(j, { id: "MediaboxSWF", width: B, height: T, params: { wmode: l.wmode, bgcolor: l.bgcolor, allowscriptaccess: l.scriptaccess, allowfullscreen: l.fullscreen } })) : j.match(/\.mov|\.m4v|\.m4a|\.aiff|\.avi|\.caf|\.dv|\.mid|\.m3u|\.mp3|\.mp2|\.mp4|\.qtz/i) || "qt" == H ? (H = "qt", B = B || l.defaultWidth, T = parseInt(T) + 16 + "px" || l.defaultHeight, p = new Quickie(j, { id: "MediaboxQT", width: B, height: T, container: "mbImage", attributes: { controller: l.controller, autoplay: l.autoplay, volume: l.volume, loop: l.medialoop, bgcolor: l.bgcolor } })) : j.match(/blip\.tv/i) ? (H = "obj", B = B || "640px", T = T || "390px", p = new Swiff(j, { src: j, width: B, height: T, params: { wmode: l.wmode, bgcolor: l.bgcolor, allowscriptaccess: l.scriptaccess, allowfullscreen: l.fullscreen } })) : j.match(/break\.com/i) ? (H = "obj", B = B || "464px", T = T || "376px", L = j.match(/\d{6}/g), p = new Swiff("http://embed.break.com/" + L, { width: B, height: T, params: { wmode: l.wmode, bgcolor: l.bgcolor, allowscriptaccess: l.scriptaccess, allowfullscreen: l.fullscreen } })) : j.match(/dailymotion\.com/i) ? (H = "obj", B = B || "480px", T = T || "381px", p = new Swiff(j, { id: L, width: B, height: T, params: { wmode: l.wmode, bgcolor: l.bgcolor, allowscriptaccess: l.scriptaccess, allowfullscreen: l.fullscreen } })) : j.match(/facebook\.com/i) ? (H = "obj", B = B || "320px", T = T || "240px", F = (F = j.split("v="))[1].split("&"), L = F[0], p = new Swiff("http://www.facebook.com/v/" + L, { movie: "http://www.facebook.com/v/" + L, classid: "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000", width: B, height: T, params: { wmode: l.wmode, bgcolor: l.bgcolor, allowscriptaccess: l.scriptaccess, allowfullscreen: l.fullscreen } })) : j.match(/flickr\.com/i) ? (H = "obj", B = B || "500px", T = T || "375px", F = j.split("/"), L = F[5], p = new Swiff("http://www.flickr.com/apps/video/stewart.swf", { id: L, classid: "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000", width: B, height: T, params: { flashvars: "photo_id=" + L + "&amp;show_info_box=" + l.flInfo, wmode: l.wmode, bgcolor: l.bgcolor, allowscriptaccess: l.scriptaccess, allowfullscreen: l.fullscreen } })) : j.match(/gametrailers\.com/i) ? (H = "obj", B = B || "480px", T = T || "392px", L = j.match(/\d{5}/g), p = new Swiff("http://www.gametrailers.com/remote_wrap.php?mid=" + L, { id: L, width: B, height: T, params: { wmode: l.wmode, bgcolor: l.bgcolor, allowscriptaccess: l.scriptaccess, allowfullscreen: l.fullscreen } })) : j.match(/google\.com\/videoplay/i) ? (H = "obj", B = B || "400px", T = T || "326px", F = j.split("="), L = F[1], p = new Swiff("http://video.google.com/googleplayer.swf?docId=" + L + "&autoplay=" + l.autoplayNum, { id: L, width: B, height: T, params: { wmode: l.wmode, bgcolor: l.bgcolor, allowscriptaccess: l.scriptaccess, allowfullscreen: l.fullscreen } })) : j.match(/megavideo\.com/i) ? (H = "obj", B = B || "640px", T = T || "360px", F = j.split("="), L = F[1], p = new Swiff("http://wwwstatic.megavideo.com/mv_player.swf?v=" + L, { id: L, width: B, height: T, params: { wmode: l.wmode, bgcolor: l.bgcolor, allowscriptaccess: l.scriptaccess, allowfullscreen: l.fullscreen } })) : j.match(/metacafe\.com\/watch/i) ? (H = "obj", B = B || "400px", T = T || "345px", F = j.split("/"), L = F[4], p = new Swiff("http://www.metacafe.com/fplayer/" + L + "/.swf?playerVars=autoPlay=" + l.autoplayYes, { id: L, width: B, height: T, params: { wmode: l.wmode, bgcolor: l.bgcolor, allowscriptaccess: l.scriptaccess, allowfullscreen: l.fullscreen } })) : j.match(/vids\.myspace\.com/i) ? (H = "obj", B = B || "425px", T = T || "360px", p = new Swiff(j, { id: L, width: B, height: T, params: { wmode: l.wmode, bgcolor: l.bgcolor, allowscriptaccess: l.scriptaccess, allowfullscreen: l.fullscreen } })) : j.match(/revver\.com/i) ? (H = "obj", B = B || "480px", T = T || "392px", F = j.split("/"), L = F[4], p = new Swiff("http://flash.revver.com/player/1.0/player.swf?mediaId=" + L + "&affiliateId=" + l.revverID + "&allowFullScreen=" + l.revverFullscreen + "&autoStart=" + l.autoplay + "&backColor=#" + l.revverBack + "&frontColor=#" + l.revverFront + "&gradColor=#" + l.revverGrad + "&shareUrl=revver", { id: L, width: B, height: T, params: { wmode: l.wmode, bgcolor: l.bgcolor, allowscriptaccess: l.scriptaccess, allowfullscreen: l.fullscreen } })) : j.match(/rutube\.ru/i) ? (H = "obj", B = B || "470px", T = T || "353px", F = j.split("="), L = F[1], p = new Swiff("http://video.rutube.ru/" + L, { movie: "http://video.rutube.ru/" + L, width: B, height: T, params: { wmode: l.wmode, bgcolor: l.bgcolor, allowscriptaccess: l.scriptaccess, allowfullscreen: l.fullscreen } })) : j.match(/seesmic\.com/i) ? (H = "obj", B = B || "435px", T = T || "355px", F = j.split("/"), L = F[5], p = new Swiff("http://seesmic.com/Standalone.swf?video=" + L, { id: L, width: B, height: T, params: { wmode: l.wmode, bgcolor: l.bgcolor, allowscriptaccess: l.scriptaccess, allowfullscreen: l.fullscreen } })) : j.match(/tudou\.com/i) ? (H = "obj", B = B || "400px", T = T || "340px", F = j.split("/"), L = F[5], p = new Swiff("http://www.tudou.com/v/" + L, { width: B, height: T, params: { wmode: l.wmode, bgcolor: l.bgcolor, allowscriptaccess: l.scriptaccess, allowfullscreen: l.fullscreen } })) : j.match(/twitcam\.com/i) ? (H = "obj", B = B || "320px", T = T || "265px", F = j.split("/"), L = F[3], p = new Swiff("http://static.livestream.com/chromelessPlayer/wrappers/TwitcamPlayer.swf?hash=" + L, { width: B, height: T, params: { wmode: l.wmode, bgcolor: l.bgcolor, allowscriptaccess: l.scriptaccess, allowfullscreen: l.fullscreen } })) : j.match(/twiturm\.com/i) ? (H = "obj", B = B || "402px", T = T || "48px", F = j.split("/"), L = F[3], p = new Swiff("http://twiturm.com/flash/twiturm_mp3.swf?playerID=0&sf=" + L, { width: B, height: T, params: { wmode: l.wmode, bgcolor: l.bgcolor, allowscriptaccess: l.scriptaccess, allowfullscreen: l.fullscreen } })) : j.match(/twitvid\.com/i) ? (H = "obj", B = B || "600px", T = T || "338px", F = j.split("/"), L = F[3], p = new Swiff("http://www.twitvid.com/player/" + L, { width: B, height: T, params: { wmode: l.wmode, bgcolor: l.bgcolor, allowscriptaccess: l.scriptaccess, allowfullscreen: l.fullscreen } })) : j.match(/ustream\.tv/i) ? (H = "obj", B = B || "400px", T = T || "326px", p = new Swiff(j + "&amp;viewcount=" + l.usViewers + "&amp;autoplay=" + l.autoplay, { width: B, height: T, params: { wmode: l.wmode, bgcolor: l.bgcolor, allowscriptaccess: l.scriptaccess, allowfullscreen: l.fullscreen } })) : j.match(/youku\.com/i) ? (H = "obj", B = B || "480px", T = T || "400px", F = j.split("id_"), L = F[1], p = new Swiff("http://player.youku.com/player.php/sid/" + L + "=/v.swf", { width: B, height: T, params: { wmode: l.wmode, bgcolor: l.bgcolor, allowscriptaccess: l.scriptaccess, allowfullscreen: l.fullscreen } })) : j.match(/youtube\.com\/watch/i) ? (F = j.split("v="), p = l.html5 ? (H = "url", B = B || "640px", T = T || "385px", L = "mediaId_" + (new Date).getTime(), new Element("iframe", { src: "http://www.youtube.com/embed/" + F[1], id: L, width: B, height: T, frameborder: 0 })) : (H = "obj", L = F[1], T = L.match(/fmt=22/i) ? (N = "&ap=%2526fmt%3D22", B = B || "640px", T || "385px") : L.match(/fmt=18/i) ? (N = "&ap=%2526fmt%3D18", B = B || "560px", T || "345px") : (N = l.ytQuality, B = B || "480px", T || "295px"), new Swiff("http://www.youtube.com/v/" + L + "&autoplay=" + l.autoplayNum + "&fs=" + l.fullscreenNum + N + "&border=" + l.ytBorder + "&color1=0x" + l.ytColor1 + "&color2=0x" + l.ytColor2 + "&rel=" + l.ytRel + "&showinfo=" + l.ytInfo + "&showsearch=" + l.ytSearch, { id: L, width: B, height: T, params: { wmode: l.wmode, bgcolor: l.bgcolor, allowscriptaccess: l.scriptaccess, allowfullscreen: l.fullscreen } }))) : j.match(/youtube\.com\/view/i) ? (H = "obj", F = j.split("p="), L = F[1], B = B || "480px", T = T || "385px", p = new Swiff("http://www.youtube.com/p/" + L + "&autoplay=" + l.autoplayNum + "&fs=" + l.fullscreenNum + N + "&border=" + l.ytBorder + "&color1=0x" + l.ytColor1 + "&color2=0x" + l.ytColor2 + "&rel=" + l.ytRel + "&showinfo=" + l.ytInfo + "&showsearch=" + l.ytSearch, { id: L, width: B, height: T, params: { wmode: l.wmode, bgcolor: l.bgcolor, allowscriptaccess: l.scriptaccess, allowfullscreen: l.fullscreen } })) : j.match(/veoh\.com/i) ? (H = "obj", B = B || "410px", T = T || "341px", j = j.replace("%3D", "/"), F = j.split("watch/"), L = F[1], p = new Swiff("http://www.veoh.com/static/swf/webplayer/WebPlayer.swf?version=AFrontend.5.5.2.1001&permalinkId=" + L + "&player=videodetailsembedded&videoAutoPlay=" + l.AutoplayNum + "&id=anonymous", { id: L, width: B, height: T, params: { wmode: l.wmode, bgcolor: l.bgcolor, allowscriptaccess: l.scriptaccess, allowfullscreen: l.fullscreen } })) : j.match(/viddler\.com/i) ? (H = "obj", B = B || "437px", T = T || "370px", F = j.split("/"), L = F[4], p = new Swiff(j, { id: "viddler_" + L, movie: j, classid: "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000", width: B, height: T, params: { wmode: l.wmode, bgcolor: l.bgcolor, allowscriptaccess: l.scriptaccess, allowfullscreen: l.fullscreen, id: "viddler_" + L, movie: j } })) : j.match(/viddyou\.com/i) ? (H = "obj", B = B || "416px", T = T || "312px", F = j.split("="), L = F[1], p = new Swiff("http://www.viddyou.com/get/v2_" + l.vuPlayer + "/" + L + ".swf", { id: L, movie: "http://www.viddyou.com/get/v2_" + l.vuPlayer + "/" + L + ".swf", width: B, height: T, params: { wmode: l.wmode, bgcolor: l.bgcolor, allowscriptaccess: l.scriptaccess, allowfullscreen: l.fullscreen } })) : j.match(/vimeo\.com/i) ? (B = B || "640px", T = T || "360px", F = j.split("/"), L = F[3], p = l.html5 ? (H = "url", L = "mediaId_" + (new Date).getTime(), new Element("iframe", { src: "http://player.vimeo.com/video/" + F[3] + "?portrait=" + l.vmPortrait, id: L, width: B, height: T, frameborder: 0 })) : (H = "obj", new Swiff("http://www.vimeo.com/moogaloop.swf?clip_id=" + L + "&amp;server=www.vimeo.com&amp;fullscreen=" + l.fullscreenNum + "&amp;autoplay=" + l.autoplayNum + "&amp;show_title=" + l.vmTitle + "&amp;show_byline=" + l.vmByline + "&amp;show_portrait=" + l.vmPortrait + "&amp;color=" + l.vmColor, { id: L, width: B, height: T, params: { wmode: l.wmode, bgcolor: l.bgcolor, allowscriptaccess: l.scriptaccess, allowfullscreen: l.fullscreen } }))) : j.match(/12seconds\.tv/i) ? (H = "obj", B = B || "430px", T = T || "360px", F = j.split("/"), L = F[5], p = new Swiff("http://embed.12seconds.tv/players/remotePlayer.swf", { id: L, width: B, height: T, params: { flashvars: "vid=" + L, wmode: l.wmode, bgcolor: l.bgcolor, allowscriptaccess: l.scriptaccess, allowfullscreen: l.fullscreen } })) : j.match(/\#mb_/i) ? (H = "inline", B = B || l.defaultWidth, T = T || l.defaultHeight, URLsplit = j.split("#"), p = document.id(URLsplit[1]).get("html")) : l.mediaTypeAjax ? (H = "ajax", l.resizeOpening = !1, l.keyboard = !1, l.alpha = !1, B = B || l.defaultWidth, T = T || l.defaultHeight, new Request.HTML({ url: j, async: !1, evalScripts: !1, onSuccess: function (e, t, o, l) { p = o, w = l } }).send()) : (H = "url", B = B || l.defaultWidth, T = T || l.defaultHeight, L = "mediaId_" + (new Date).getTime(), p = new Element("iframe", { src: j, id: L, width: B, height: T, frameborder: 0 })), V())), -1 === document.body.className.search(" salsa-lightbox-opened") && (document.body.className += " salsa-lightbox-opened"), "img" !== H && -1 === document.body.className.search(" salsa-lightbox-not-image") && (document.body.className += " salsa-lightbox-not-image"), u.addClass("mbType-" + H), !1 } function V() { "img" == H ? (B = p.width, T = p.height, l.imgBackground ? f.setStyles({ backgroundImage: "url(" + j + ")", display: "" }) : (T >= m - l.imgPadding && B / n <= T / m ? (T = m - l.imgPadding, B = p.width = parseInt(T / p.height * B), p.height = T) : B >= n - l.imgPadding && T / m < B / n && (B = n - l.imgPadding, T = p.height = parseInt(B / p.width * T), p.width = B), Browser.Engine.trident && (p = document.id(p)), p.addEvent("mousedown", function (e) { e.stop() }).addEvent("contextmenu", function (e) { e.stop() }), f.setStyles({ backgroundImage: "none", display: "" }), p.inject(f))) : "obj" == H ? Browser.Plugins.Flash.version < 8 ? (f.setStyles({ backgroundImage: "none", display: "" }), f.set("html", '<div id="mbError"><b>Error</b><br/>Adobe Flash is either not installed or not up to date, please visit <a href="http://www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash" title="Get Flash" target="_new">Adobe.com</a> to download the free player.</div>'), B = l.DefaultWidth, T = l.DefaultHeight) : (f.setStyles({ backgroundImage: "none", display: "" }), p.inject(f)) : "qt" == H ? f.setStyles({ backgroundImage: "none", display: "" }) : "inline" == H ? (f.setStyles({ backgroundImage: "none", display: "" }), f.set("html", p)) : "ajax" == H ? (f.setStyles({ backgroundImage: "none", display: "" }), f.set("html", p), $exec(w)) : "url" == H ? (f.setStyles({ backgroundImage: "none", display: "" }), p.inject(f)) : (f.setStyles({ backgroundImage: "none", display: "" }), f.set("html", '<div id="mbError"><b>Error</b><br/>A file type error has occoured, please visit <a href="iaian7.com/webcode/mediaboxAdvanced" title="mediaboxAdvanced" target="_new">iaian7.com</a> or contact the website author for more information.</div>'), B = l.defaultWidth, T = l.defaultHeight), f.setStyles({ width: B, height: T }), v.setStyles({ width: B }), y.set("html", l.showCaption ? b[0] : ""), v.set("html", l.showCaption && 1 < b.length ? b[1] : ""), S.set("html", l.showCounter && 1 < i.length ? l.counterText.replace(/{x}/, o + 1).replace(/{y}/, i.length) : ""), 0 <= a && i[a][0].match(/\.gif|\.jpg|\.jpeg|\.png|twitpic\.com/i) && (W.src = i[a][0].replace(/twitpic\.com/i, "twitpic.com/show/full")), 0 <= c && i[c][0].match(/\.gif|\.jpg|\.jpeg|\.png|twitpic\.com/i) && (_.src = i[c][0].replace(/twitpic\.com/i, "twitpic.com/show/full")), B = f.offsetWidth, T = f.offsetHeight + g.offsetHeight, e = r + r <= T ? -r : -T / 2, t = s + s <= B ? -s : -B / 2, l.resizeOpening ? d.resize.start({ width: B, height: T, marginTop: e - P, marginLeft: t - P }) : (u.setStyles({ width: B, height: T, marginTop: e - P, marginLeft: t - P }), U()), "ajax" == H && u.setStyle("height", "auto") } function U() { d.image.start(1) } function Q() { u.removeClass("mbLoading"), 0 <= a && (x.style.display = ""), 0 <= c && (k.style.display = ""), d.bottom.start(1) } function G() { if (0 <= o) { for (var e in p.onload = $empty, f.set("html", ""), d) d[e].cancel(); u.setStyle("display", "none"), d.overlay.chain($).start(0) } return document.body.className = document.body.className.replace(" salsa-lightbox-opened", ""), document.body.className = document.body.className.replace(" salsa-lightbox-not-image", ""), !1 } window.addEvent("domready", function () { document.id(document.body).adopt($$([h = new Element("div", { id: "mbOverlay" }).addEvent("click", G), u = new Element("div", { id: "mbCenter" })]).setStyle("display", "none")), f = new Element("div", { id: "mbImage" }).injectInside(u), g = new Element("div", { id: "mbBottom" }).injectInside(u).adopt(closeLink = new Element("a", { id: "mbCloseLink", href: "#" }).addEvent("click", G), k = new Element("a", { id: "mbNextLink", href: "#" }).addEvent("click", R), x = new Element("a", { id: "mbPrevLink", href: "#" }).addEvent("click", O), y = new Element("div", { id: "mbTitle" }), v = new Element("div", { id: "mbCaption" }), S = new Element("div", { id: "mbNumber" })), d = { overlay: new Fx.Tween(h, { property: "opacity", duration: 360 }).set(0), image: new Fx.Tween(f, { property: "opacity", duration: 360, onComplete: Q }), bottom: new Fx.Tween(g, { property: "opacity", duration: 240 }).set(0) } }), Mediabox = { close: function () { G() }, open: function (e, t, o) { return l = $extend({ text: ["<big>&laquo;</big>", "<big>&raquo;</big>", "<big>&times;</big>"], loop: !1, keyboard: !0, alpha: !0, stopKey: !1, overlayOpacity: .7, resizeOpening: !0, resizeDuration: 240, resizeTransition: !1, initialWidth: 320, initialHeight: 180, defaultWidth: 640, defaultHeight: 360, showCaption: !0, showCounter: !0, counterText: "({x} of {y})", imgBackground: !1, imgPadding: 100, html5: "true", scriptaccess: "true", fullscreen: "true", fullscreenNum: "1", autoplay: "true", autoplayNum: "1", autoplayYes: "yes", volume: "100", medialoop: "true", bgcolor: "#000000", wmode: "opaque", useNB: !0, playerpath: "/js/NonverBlaster.swf", controlColor: "0xFFFFFF", controlBackColor: "0x000000", showTimecode: "false", JWplayerpath: "/js/player.swf", backcolor: "000000", frontcolor: "999999", lightcolor: "000000", screencolor: "000000", controlbar: "over", controller: "true", flInfo: "true", revverID: "187866", revverFullscreen: "true", revverBack: "000000", revverFront: "ffffff", revverGrad: "000000", usViewers: "true", ytBorder: "0", ytColor1: "000000", ytColor2: "333333", ytQuality: "&ap=%2526fmt%3D18", ytRel: "0", ytInfo: "1", ytSearch: "0", vuPlayer: "basic", vmTitle: "1", vmByline: "1", vmPortrait: "1", vmColor: "ffffff", mediaTypeAjax: !1 }, o || {}), x.set("html", l.text[0]), k.set("html", l.text[1]), closeLink.set("html", l.text[2]), P = u.getStyle("padding-left").toInt() + f.getStyle("margin-left").toInt() + f.getStyle("padding-left").toInt(), Browser.Engine.gecko && Browser.Engine.version < 19 && (l.overlayOpacity = 1, h.className = "mbOverlayFF"), Browser.Engine.trident && Browser.Engine.version < 5 && (D = !0, h.className = "mbOverlayIE", h.setStyle("position", "absolute"), A()), "string" == typeof e && (e = [[e, t, o]], t = 0), i = e, l.loop = l.loop && 1 < i.length, M(), $(!0), r = window.getScrollTop() + window.getHeight() / 2, s = window.getScrollLeft() + window.getWidth() / 2, d.resize = new Fx.Morph(u, $extend({ duration: l.resizeDuration, onComplete: U }, l.resizeTransition ? { transition: l.resizeTransition } : {})), u.setStyles({ top: r, left: s, width: l.initialWidth, height: l.initialHeight, marginTop: -l.initialHeight / 2 - P, marginLeft: -l.initialWidth / 2 - P, display: "" }), d.overlay.start(l.overlayOpacity), q(t) } }, Element.implement({ mediabox: function (e, t) { return $$(this).mediabox(e, t), this } }), Elements.implement({ mediabox: function (e, t, a) { t = t || function (e) { return C = e.rel.split(/[\[\]]/)[1], [e.href, e.title, C] }, a = a || function () { return !0 }; var c = this; return c.addEvent("contextmenu", function (e) { this.toString().match(/\.gif|\.jpg|\.jpeg|\.png/i) && e.stop() }), c.removeEvents("click").addEvent("click", function () { var o = c.filter(a, this), l = [], i = []; return o.each(function (e, t) { i.indexOf(e.toString()) < 0 && (l.include(o[t]), i.include(o[t].toString())) }), Mediabox.open(l.map(t), i.indexOf(this.toString()), e) }), c } }) }(), Mediabox.scanPage = function () { var e = $$("a").filter(function (e) { return e.rel && e.rel.test(/^lightbox/i) }); $$(e).mediabox({}, null, function (e) { var t = this.rel.replace(/[[]|]/gi, " ").split(" "); return this == e || 8 < this.rel.length && e.rel.match(t[1]) }) }, Mediabox.scanPageRelay = function () { document.addEvent("click:relay(a[rel*=lightbox])", function (e) { e.stop(); e = document.getElements("a[rel*=lightbox]"); e.addEvent("contextmenu", function (e) { this.toString().match(/\.gif|\.jpg|\.jpeg|\.png/i) && e.stop() }); var o = e.filter(function (e) { var t = this.rel.replace(/[[]|]/gi, " ").split(" "); return this == e || 8 < this.rel.length && e.rel.match(t[1]) }, this), l = [], i = []; o.each(function (e, t) { i.indexOf(e.toString()) < 0 && (l.include(o[t]), i.include(o[t].toString())) }); e = { mediaTypeAjax: l.map(function (e) { return "1" == e.get("data-ajax") }).reduce(function (e, t) { return e || t }) }; return Mediabox.open(l.map(function (e) { var t = (t = e.rel.split(/[\[\]]/))[1]; return [e.href, e.title, t] }), i.indexOf(this.toString()), e) }) }, window.addEvent("domready", Mediabox.scanPageRelay);

var SalsaPolicies = new Class({ Implements: [Options, Events], options: { container: "", advice_view_url: "" }, initialize: function (i) { this.setOptions(i), this.cookie_name = "salsa_policies_advice", this.container = document.id(this.options.container), this._load_advice() }, _load_advice: function () { null === Cookie.read(this.cookie_name) && new Request.HTML({ url: this.options.advice_view_url, onSuccess: function (i, n, t) { this.container.set("html", t), this._init_events() }.bind(this) }).send() }, _init_events: function () { document.getElements(".salsa-policies-advice-button").each(function (i) { i.addEvent("click", function (i) { this.container.empty(), Cookie.write(this.cookie_name, "1", { duration: 3650 }) }.bind(this)) }.bind(this)) } });

var viewer = new Class({ mode: "rand", modes: ["top", "right", "bottom", "left", "alpha"], sizes: { w: 480, h: 240 }, fxOptions: { duration: 500 }, interval: 5e3, initialize: function (t, s) { if (s) for (var i in s) this[i] = s[i]; this.buttons && (this.buttons.previous.addEvent("click", this.previous.pass([!0], this)), this.buttons.next.addEvent("click", this.next.pass([!0], this))), this.__current = 0, this.__previous = null, this.items = t.setStyle("display", "none"), this.items[this.__current].setStyle("display", "block"), this.disabled = !1, this.attrs = { left: ["left", -this.sizes.w, 0, "px"], top: ["top", -this.sizes.h, 0, "px"], right: ["left", this.sizes.w, 0, "px"], bottom: ["top", this.sizes.h, 0, "px"], alpha: ["opacity", 0, 1, ""] }, this.rand = "rand" == this.mode, this.sequence = "object" == typeof this.mode && this.mode, this.curseq = 0, this.timer = null }, walk: function (t, s) { if (this.__current !== t && !this.disabled) { this.disabled = !0, s && this.stop(), this.rand ? this.mode = this.modes.getRandom() : this.sequence && (this.mode = this.sequence[this.curseq], this.curseq += this.curseq + 1 < this.sequence.length ? 1 : -this.curseq), this.__previous = this.__current, this.__current = t; for (var i = this.attrs[this.mode].associate(["p", "f", "t", "u"]), e = 0; e < this.items.length; e++)this.__current === e ? this.items[e].setStyles($extend({ display: "block", "z-index": "2" }, JSON.parse('{"' + i.p + '":"' + i.f + i.u + '"}'))) : this.__previous === e ? this.items[e].setStyles({ "z-index": "1" }) : this.items[e].setStyles({ display: "none", "z-index": "0" }); this.items[t].set("tween", $merge(this.fxOptions, { onComplete: this.onComplete.bind(this) })).tween(i.p, i.f, i.t) } }, play: function (t) { this.stop(), t || this.next(), this.timer = this.next.periodical(this.interval, this, [!1]) }, stop: function () { $clear(this.timer) }, next: function (t) { this.walk(this.__current + 1 < this.items.length ? this.__current + 1 : 0, t) }, previous: function (t) { this.walk(0 < this.__current ? this.__current - 1 : this.items.length - 1, t) }, onComplete: function () { this.disabled = !1, this.items[this.__previous].setStyle("display", "none"), this.onWalk && this.onWalk(this.__current) } });

!function (t, e) { "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : t.mapboxgl = e() }(this, function () { "use strict"; var r, o, a; function t(t, e) { var n, i; r ? o ? (n = "var sharedChunk = {}; (" + r + ")(sharedChunk); (" + o + ")(sharedChunk);", r(i = {}), (a = e(i)).workerUrl = window.URL.createObjectURL(new Blob([n], { type: "text/javascript" }))) : o = e : r = e } return t(0, function (t) { function e(t, e) { return t(e = { exports: {} }, e.exports), e.exports } var o = n; function n(t, e, n, i) { this.cx = 3 * t, this.bx = 3 * (n - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e, this.by = 3 * (i - e) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = i, this.p2x = n, this.p2y = i } n.prototype.sampleCurveX = function (t) { return ((this.ax * t + this.bx) * t + this.cx) * t }, n.prototype.sampleCurveY = function (t) { return ((this.ay * t + this.by) * t + this.cy) * t }, n.prototype.sampleCurveDerivativeX = function (t) { return (3 * this.ax * t + 2 * this.bx) * t + this.cx }, n.prototype.solveCurveX = function (t, e) { var n, i, r, o, a; for (void 0 === e && (e = 1e-6), r = t, a = 0; a < 8; a++) { if (o = this.sampleCurveX(r) - t, Math.abs(o) < e) return r; var s = this.sampleCurveDerivativeX(r); if (Math.abs(s) < 1e-6) break; r -= o / s } if ((r = t) < (n = 0)) return n; if (r > (i = 1)) return i; for (; n < i;) { if (o = this.sampleCurveX(r), Math.abs(o - t) < e) return r; o < t ? n = r : i = r, r = .5 * (i - n) + n } return r }, n.prototype.solve = function (t, e) { return this.sampleCurveY(this.solveCurveX(t, e)) }; function l(t, e, n) { this.column = t, this.row = e, this.zoom = n } l.prototype.clone = function () { return new l(this.column, this.row, this.zoom) }, l.prototype.zoomTo = function (t) { return this.clone()._zoomTo(t) }, l.prototype.sub = function (t) { return this.clone()._sub(t) }, l.prototype._zoomTo = function (t) { var e = Math.pow(2, t - this.zoom); return this.column *= e, this.row *= e, this.zoom = t, this }, l.prototype._sub = function (t) { return t = t.zoomTo(this.zoom), this.column -= t.column, this.row -= t.row, this }; var p = i; function i(t, e) { this.x = t, this.y = e } function u(t, e) { if (Array.isArray(t)) { if (!Array.isArray(e) || t.length !== e.length) return !1; for (var n = 0; n < t.length; n++)if (!u(t[n], e[n])) return !1; return !0 } if ("object" != typeof t || null === t || null === e) return t === e; if ("object" != typeof e) return !1; if (Object.keys(t).length !== Object.keys(e).length) return !1; for (var i in t) if (!u(t[i], e[i])) return !1; return !0 } function r(t, e, n, i) { var r = new o(t, e, n, i); return function (t) { return r.solve(t) } } i.prototype = { clone: function () { return new i(this.x, this.y) }, add: function (t) { return this.clone()._add(t) }, sub: function (t) { return this.clone()._sub(t) }, multByPoint: function (t) { return this.clone()._multByPoint(t) }, divByPoint: function (t) { return this.clone()._divByPoint(t) }, mult: function (t) { return this.clone()._mult(t) }, div: function (t) { return this.clone()._div(t) }, rotate: function (t) { return this.clone()._rotate(t) }, rotateAround: function (t, e) { return this.clone()._rotateAround(t, e) }, matMult: function (t) { return this.clone()._matMult(t) }, unit: function () { return this.clone()._unit() }, perp: function () { return this.clone()._perp() }, round: function () { return this.clone()._round() }, mag: function () { return Math.sqrt(this.x * this.x + this.y * this.y) }, equals: function (t) { return this.x === t.x && this.y === t.y }, dist: function (t) { return Math.sqrt(this.distSqr(t)) }, distSqr: function (t) { var e = t.x - this.x, t = t.y - this.y; return e * e + t * t }, angle: function () { return Math.atan2(this.y, this.x) }, angleTo: function (t) { return Math.atan2(this.y - t.y, this.x - t.x) }, angleWith: function (t) { return this.angleWithSep(t.x, t.y) }, angleWithSep: function (t, e) { return Math.atan2(this.x * e - this.y * t, this.x * t + this.y * e) }, _matMult: function (t) { var e = t[0] * this.x + t[1] * this.y, t = t[2] * this.x + t[3] * this.y; return this.x = e, this.y = t, this }, _add: function (t) { return this.x += t.x, this.y += t.y, this }, _sub: function (t) { return this.x -= t.x, this.y -= t.y, this }, _mult: function (t) { return this.x *= t, this.y *= t, this }, _div: function (t) { return this.x /= t, this.y /= t, this }, _multByPoint: function (t) { return this.x *= t.x, this.y *= t.y, this }, _divByPoint: function (t) { return this.x /= t.x, this.y /= t.y, this }, _unit: function () { return this._div(this.mag()), this }, _perp: function () { var t = this.y; return this.y = this.x, this.x = -t, this }, _rotate: function (t) { var e = Math.cos(t), n = Math.sin(t), t = e * this.x - n * this.y, e = n * this.x + e * this.y; return this.x = t, this.y = e, this }, _rotateAround: function (t, e) { var n = Math.cos(t), i = Math.sin(t), t = e.x + n * (this.x - e.x) - i * (this.y - e.y), e = e.y + i * (this.x - e.x) + n * (this.y - e.y); return this.x = t, this.y = e, this }, _round: function () { return this.x = Math.round(this.x), this.y = Math.round(this.y), this } }, i.convert = function (t) { return !(t instanceof i) && Array.isArray(t) ? new i(t[0], t[1]) : t }; var a = r(.25, .1, .25, 1); function d(t, e, n) { return Math.min(n, Math.max(e, t)) } function c(t) { for (var e = [], n = arguments.length - 1; 0 < n--;)e[n] = arguments[n + 1]; for (var i = 0, r = e; i < r.length; i += 1) { var o, a = r[i]; for (o in a) t[o] = a[o] } return t } var s = 1; function h() { return s++ } function f(t, e) { t.forEach(function (t) { e[t] && (e[t] = e[t].bind(e)) }) } function m(t, e) { return -1 !== t.indexOf(e, t.length - e.length) } function y(t, e, n) { var i, r = {}; for (i in t) r[i] = e.call(n || this, t[i], i, t); return r } function g(t, e, n) { var i, r = {}; for (i in t) e.call(n || this, t[i], i, t) && (r[i] = t[i]); return r } function v(t) { return Array.isArray(t) ? t.map(v) : "object" == typeof t && t ? y(t, v) : t } var _ = {}; function x(t) { _[t] || ("undefined" != typeof console && console.warn(t), _[t] = !0) } function b(t, e, n) { return (n.y - t.y) * (e.x - t.x) > (e.y - t.y) * (n.x - t.x) } var w = self.performance && self.performance.now ? self.performance.now.bind(self.performance) : Date.now.bind(Date), E = self.requestAnimationFrame || self.mozRequestAnimationFrame || self.webkitRequestAnimationFrame || self.msRequestAnimationFrame, S = self.cancelAnimationFrame || self.mozCancelAnimationFrame || self.webkitCancelAnimationFrame || self.msCancelAnimationFrame, T = { now: w, frame: function (t) { var e = E(t); return { cancel: function () { return S(e) } } }, getImageData: function (t) { var e = self.document.createElement("canvas"), n = e.getContext("2d"); if (!n) throw new Error("failed to create canvas 2d context"); return e.width = t.width, e.height = t.height, n.drawImage(t, 0, 0, t.width, t.height), n.getImageData(0, 0, t.width, t.height) }, resolveURL: function (t) { var e = self.document.createElement("a"); return e.href = t, e.href }, hardwareConcurrency: self.navigator.hardwareConcurrency || 4, get devicePixelRatio() { return self.devicePixelRatio }, supportsWebp: !1 }; self.document && ((oi = self.document.createElement("img")).onload = function () { T.supportsWebp = !0 }, oi.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="); var A = { Unknown: "Unknown", Style: "Style", Source: "Source", Tile: "Tile", Glyphs: "Glyphs", SpriteImage: "SpriteImage", SpriteJSON: "SpriteJSON", Image: "Image" }; "function" == typeof Object.freeze && Object.freeze(A); var z, I = ((z = Error) && (k.__proto__ = z), ((k.prototype = Object.create(z && z.prototype)).constructor = k).prototype.toString = function () { return this.name + ": " + this.message + " (" + this.status + "): " + this.url }, k); function k(t, e, n) { z.call(this, t), this.status = e, this.url = n, this.name = this.constructor.name, this.message = t } function C(t) { var e, n = new self.XMLHttpRequest; for (e in n.open(t.method || "GET", t.url, !0), t.headers) n.setRequestHeader(e, t.headers[e]); return n.withCredentials = "include" === t.credentials, n } function M(e, n) { var i = C(e); return i.responseType = "arraybuffer", i.onerror = function () { n(new Error(i.statusText)) }, i.onload = function () { var t = i.response; if (0 === t.byteLength && 200 === i.status) return n(new Error("http status 200 returned without content.")); 200 <= i.status && i.status < 300 && i.response ? n(null, { data: t, cacheControl: i.getResponseHeader("Cache-Control"), expires: i.getResponseHeader("Expires") }) : n(new I(i.statusText, i.status, e.url)) }, i.send(), { cancel: function () { return i.abort() } } } function P(t, e, n) { n[t] && -1 !== n[t].indexOf(e) || (n[t] = n[t] || [], n[t].push(e)) } function L(t, e, n) { n && n[t] && (-1 !== (e = n[t].indexOf(e)) && n[t].splice(e, 1)) } function D(t, e) { void 0 === e && (e = {}), c(this, e), this.type = t } function R() { } var B, O = ((B = D) && (F.__proto__ = B), (F.prototype = Object.create(B && B.prototype)).constructor = F); function F(t, e) { void 0 === e && (e = {}), B.call(this, "error", c({ error: t }, e)) } R.prototype.on = function (t, e) { return this._listeners = this._listeners || {}, P(t, e, this._listeners), this }, R.prototype.off = function (t, e) { return L(t, e, this._listeners), L(t, e, this._oneTimeListeners), this }, R.prototype.once = function (t, e) { return this._oneTimeListeners = this._oneTimeListeners || {}, P(t, e, this._oneTimeListeners), this }, R.prototype.fire = function (t) { "string" == typeof t && (t = new D(t, arguments[1] || {})); var e = t.type; if (this.listens(e)) { for (var n = 0, i = (t.target = this)._listeners && this._listeners[e] ? this._listeners[e].slice() : []; n < i.length; n += 1)i[n].call(this, t); for (var r = 0, o = this._oneTimeListeners && this._oneTimeListeners[e] ? this._oneTimeListeners[e].slice() : []; r < o.length; r += 1) { var a = o[r]; L(e, a, this._oneTimeListeners), a.call(this, t) } var s = this._eventedParent; s && (c(t, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), s.fire(t)) } else t instanceof O && console.error(t.error); return this }, R.prototype.listens = function (t) { return this._listeners && this._listeners[t] && 0 < this._listeners[t].length || this._oneTimeListeners && this._oneTimeListeners[t] && 0 < this._oneTimeListeners[t].length || this._eventedParent && this._eventedParent.listens(t) }; var V = { $version: 8, $root: { version: { required: !0, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, light: { type: "light" }, sources: { required: !0, type: "sources" }, sprite: { type: "string" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: !0, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: !0, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, "*": { type: "*" } }, source_raster: { type: { required: !0, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, "*": { type: "*" } }, source_raster_dem: { type: { required: !0, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {} }, default: "mapbox" }, "*": { type: "*" } }, source_geojson: { type: { required: !0, type: "enum", values: { geojson: {} } }, data: { type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, tolerance: { type: "number", default: .375 }, cluster: { type: "boolean", default: !(R.prototype.setEventedParent = function (t, e) { return this._eventedParent = t, this._eventedParentData = e, this }) }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, lineMetrics: { type: "boolean", default: !1 }, generateId: { type: "boolean", default: !1 } }, source_video: { type: { required: !0, type: "enum", values: { video: {} } }, urls: { required: !0, type: "array", value: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: !0, type: "enum", values: { image: {} } }, url: { required: !0, type: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: !0 }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {} }, required: !0 }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: !1, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: !1, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: !1, requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "string", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-keep-upright": { type: "boolean", default: !1, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: !0, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: !1, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: !1, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: !1, requires: ["text-field", "icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function_stop: { type: "array", minimum: 0, maximum: 22, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, expression_name: { type: "enum", values: { let: { group: "Variable binding" }, var: { group: "Variable binding" }, literal: { group: "Types" }, array: { group: "Types" }, at: { group: "Lookup" }, case: { group: "Decision" }, match: { group: "Decision" }, coalesce: { group: "Decision" }, step: { group: "Ramps, scales, curves" }, interpolate: { group: "Ramps, scales, curves" }, ln2: { group: "Math" }, pi: { group: "Math" }, e: { group: "Math" }, typeof: { group: "Types" }, string: { group: "Types" }, number: { group: "Types" }, boolean: { group: "Types" }, object: { group: "Types" }, collator: { group: "Types" }, format: { group: "Types" }, "to-string": { group: "Types" }, "to-number": { group: "Types" }, "to-boolean": { group: "Types" }, "to-rgba": { group: "Color" }, "to-color": { group: "Types" }, rgb: { group: "Color" }, rgba: { group: "Color" }, get: { group: "Lookup" }, has: { group: "Lookup" }, length: { group: "Lookup" }, properties: { group: "Feature data" }, "feature-state": { group: "Feature data" }, "geometry-type": { group: "Feature data" }, id: { group: "Feature data" }, zoom: { group: "Zoom" }, "heatmap-density": { group: "Heatmap" }, "line-progress": { group: "Heatmap" }, "+": { group: "Math" }, "*": { group: "Math" }, "-": { group: "Math" }, "/": { group: "Math" }, "%": { group: "Math" }, "^": { group: "Math" }, sqrt: { group: "Math" }, log10: { group: "Math" }, ln: { group: "Math" }, log2: { group: "Math" }, sin: { group: "Math" }, cos: { group: "Math" }, tan: { group: "Math" }, asin: { group: "Math" }, acos: { group: "Math" }, atan: { group: "Math" }, min: { group: "Math" }, max: { group: "Math" }, round: { group: "Math" }, abs: { group: "Math" }, ceil: { group: "Math" }, floor: { group: "Math" }, "==": { group: "Decision" }, "!=": { group: "Decision" }, ">": { group: "Decision" }, "<": { group: "Decision" }, ">=": { group: "Decision" }, "<=": { group: "Decision" }, all: { group: "Decision" }, any: { group: "Decision" }, "!": { group: "Decision" }, "is-supported-script": { group: "String" }, upcase: { group: "String" }, downcase: { group: "String" }, concat: { group: "String" }, "resolved-locale": { group: "String" } } }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: !1, expression: { interpolated: !1, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, intensity: { type: "number", "property-type": "data-constant", default: .5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: !0, requires: [{ "!": "fill-pattern" }, { "fill-antialias": !0 }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "string", transition: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "line-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: !0, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "string", transition: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-gradient": { type: "color", transition: !1, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: !0 } }], expression: { interpolated: !0, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: !1, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", .1, "royalblue", .3, "cyan", .5, "lime", .7, "yellow", 1, "red"], transition: !1, expression: { interpolated: !0, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: !0, units: "degrees", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: !1, units: "milliseconds", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "number", default: 335, minimum: 0, maximum: 359, transition: !1, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: .5, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "color", default: "#FFFFFF", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "background-pattern" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "string", transition: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: !1 } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "string", transition: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, requires: ["fill-extrusion-height"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } } }, N = function (t, e, n, i) { this.message = (t ? t + ": " : "") + n, i && (this.identifier = i), null != e && e.__line__ && (this.line = e.__line__) }; function j(t) { var e = t.key, t = t.value; return t ? [new N(e, t, "constants have been deprecated as of v8")] : [] } function U(t) { for (var e = [], n = arguments.length - 1; 0 < n--;)e[n] = arguments[n + 1]; for (var i = 0, r = e; i < r.length; i += 1) { var o, a = r[i]; for (o in a) t[o] = a[o] } return t } function q(t) { return t instanceof Number || t instanceof String || t instanceof Boolean ? t.valueOf() : t } function Z(t) { return Array.isArray(t) ? t.map(Z) : q(t) } function G(t, e) { void 0 === e && (e = []), this.parent = t, this.bindings = {}; for (var n = 0, i = e; n < i.length; n += 1) { var r = i[n], o = r[0], r = r[1]; this.bindings[o] = r } } var X, W = ((X = Error) && (H.__proto__ = X), (H.prototype = Object.create(X && X.prototype)).constructor = H); function H(t, e) { X.call(this, e), this.message = e, this.key = t } G.prototype.concat = function (t) { return new G(this, t) }, G.prototype.get = function (t) { if (this.bindings[t]) return this.bindings[t]; if (this.parent) return this.parent.get(t); throw new Error(t + " not found in scope.") }, G.prototype.has = function (t) { return !!this.bindings[t] || !!this.parent && this.parent.has(t) }; var K = { kind: "null" }, J = { kind: "number" }, Y = { kind: "string" }, $ = { kind: "boolean" }, Q = { kind: "color" }, tt = { kind: "object" }, et = { kind: "value" }, nt = { kind: "collator" }, it = { kind: "formatted" }; function rt(t, e) { return { kind: "array", itemType: t, N: e } } function ot(t) { if ("array" !== t.kind) return t.kind; var e = ot(t.itemType); return "number" == typeof t.N ? "array<" + e + ", " + t.N + ">" : "value" === t.itemType.kind ? "array" : "array<" + e + ">" } var at = [K, J, Y, $, Q, it, tt, rt(et)]; function st(t, e) { if ("error" === e.kind) return null; if ("array" === t.kind) { if ("array" === e.kind && !st(t.itemType, e.itemType) && ("number" != typeof t.N || t.N === e.N)) return null } else { if (t.kind === e.kind) return null; if ("value" === t.kind) for (var n = 0, i = at; n < i.length; n += 1)if (!st(i[n], e)) return null } return "Expected " + ot(t) + " but found " + ot(e) + " instead." } var lt = e(function (t, e) { var r = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], rebeccapurple: [102, 51, 153, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] }; function o(t) { return (t = Math.round(t)) < 0 ? 0 : 255 < t ? 255 : t } function n(t) { return t < 0 ? 0 : 1 < t ? 1 : t } function a(t) { return "%" === t[t.length - 1] ? o(parseFloat(t) / 100 * 255) : o(parseInt(t)) } function s(t) { return "%" === t[t.length - 1] ? n(parseFloat(t) / 100) : n(parseFloat(t)) } function l(t, e, n) { return n < 0 ? n += 1 : 1 < n && --n, 6 * n < 1 ? t + (e - t) * n * 6 : 2 * n < 1 ? e : 3 * n < 2 ? t + (e - t) * (2 / 3 - n) * 6 : t } try { e.parseCSSColor = function (t) { var e = t.replace(/ /g, "").toLowerCase(); if (e in r) return r[e].slice(); if ("#" === e[0]) return 4 === e.length ? 0 <= (i = parseInt(e.substr(1), 16)) && i <= 4095 ? [(3840 & i) >> 4 | (3840 & i) >> 8, 240 & i | (240 & i) >> 4, 15 & i | (15 & i) << 4, 1] : null : 7 === e.length && 0 <= (i = parseInt(e.substr(1), 16)) && i <= 16777215 ? [(16711680 & i) >> 16, (65280 & i) >> 8, 255 & i, 1] : null; var n = e.indexOf("("), t = e.indexOf(")"); if (-1 !== n && t + 1 === e.length) { var i = e.substr(0, n), e = e.substr(n + 1, t - (n + 1)).split(","), t = 1; switch (i) { case "rgba": if (4 !== e.length) return null; t = s(e.pop()); case "rgb": return 3 !== e.length ? null : [a(e[0]), a(e[1]), a(e[2]), t]; case "hsla": if (4 !== e.length) return null; t = s(e.pop()); case "hsl": if (3 !== e.length) return null; n = (parseFloat(e[0]) % 360 + 360) % 360 / 360, i = s(e[1]), e = s(e[2]), i = e <= .5 ? e * (i + 1) : e + i - e * i, e = 2 * e - i; return [o(255 * l(e, i, n + 1 / 3)), o(255 * l(e, i, n)), o(255 * l(e, i, n - 1 / 3)), t]; default: return null } } return null } } catch (t) { } }).parseCSSColor, ut = function (t, e, n, i) { void 0 === i && (i = 1), this.r = t, this.g = e, this.b = n, this.a = i }; ut.parse = function (t) { if (t) { if (t instanceof ut) return t; if ("string" == typeof t) { t = lt(t); if (t) return new ut(t[0] / 255 * t[3], t[1] / 255 * t[3], t[2] / 255 * t[3], t[3]) } } }, ut.prototype.toString = function () { var t = this.toArray(), e = t[0], n = t[1], i = t[2], t = t[3]; return "rgba(" + Math.round(e) + "," + Math.round(n) + "," + Math.round(i) + "," + t + ")" }, ut.prototype.toArray = function () { var t = this.r, e = this.g, n = this.b, i = this.a; return 0 === i ? [0, 0, 0, 0] : [255 * t / i, 255 * e / i, 255 * n / i, i] }, ut.black = new ut(0, 0, 0, 1), ut.white = new ut(1, 1, 1, 1), ut.transparent = new ut(0, 0, 0, 0); var ct = function (t, e, n) { this.sensitivity = t ? e ? "variant" : "case" : e ? "accent" : "base", this.locale = n, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" }) }; ct.prototype.compare = function (t, e) { return this.collator.compare(t, e) }, ct.prototype.resolvedLocale = function () { return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale }; function ht(t, e, n) { this.type = nt, this.locale = n, this.caseSensitive = t, this.diacriticSensitive = e } function pt(t, e, n, i) { return "number" == typeof t && 0 <= t && t <= 255 && "number" == typeof e && 0 <= e && e <= 255 && "number" == typeof n && 0 <= n && n <= 255 ? void 0 === i || "number" == typeof i && 0 <= i && i <= 1 ? null : "Invalid rgba value [" + [t, e, n, i].join(", ") + "]: 'a' must be between 0 and 1." : "Invalid rgba value [" + ("number" == typeof i ? [t, e, n, i] : [t, e, n]).join(", ") + "]: 'r', 'g', and 'b' must be between 0 and 255." } function ft(t) { if (null === t) return K; if ("string" == typeof t) return Y; if ("boolean" == typeof t) return $; if ("number" == typeof t) return J; if (t instanceof ut) return Q; if (t instanceof ct) return nt; if (Array.isArray(t)) { for (var e, n = t.length, i = 0, r = t; i < r.length; i += 1) { var o = ft(r[i]); if (e) { if (e === o) continue; e = et; break } e = o } return rt(e || et, n) } return tt } ht.parse = function (t, e) { if (2 !== t.length) return e.error("Expected one argument."); var n = t[1]; if ("object" != typeof n || Array.isArray(n)) return e.error("Collator options argument must be an object."); var i = e.parse(void 0 !== n["case-sensitive"] && n["case-sensitive"], 1, $); if (!i) return null; var r = e.parse(void 0 !== n["diacritic-sensitive"] && n["diacritic-sensitive"], 1, $); if (!r) return null; t = null; return n.locale && !(t = e.parse(n.locale, 1, Y)) ? null : new ht(i, r, t) }, ht.prototype.evaluate = function (t) { return new ct(this.caseSensitive.evaluate(t), this.diacriticSensitive.evaluate(t), this.locale ? this.locale.evaluate(t) : null) }, ht.prototype.eachChild = function (t) { t(this.caseSensitive), t(this.diacriticSensitive), this.locale && t(this.locale) }, ht.prototype.possibleOutputs = function () { return [void 0] }, ht.prototype.serialize = function () { var t = {}; return t["case-sensitive"] = this.caseSensitive.serialize(), t["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (t.locale = this.locale.serialize()), ["collator", t] }; function dt(t, e, n) { this.text = t, this.scale = e, this.fontStack = n } var mt = function (t) { this.sections = t }; mt.prototype.toString = function () { return this.sections.map(function (t) { return t.text }).join("") }, mt.prototype.serialize = function () { for (var t = ["format"], e = 0, n = this.sections; e < n.length; e += 1) { var i = n[e]; t.push(i.text); var r = i.fontStack ? ["literal", i.fontStack.split(",")] : null; t.push({ "text-font": r, "font-scale": i.scale }) } return t }; function yt(t) { this.type = it, this.sections = t } yt.parse = function (t, e) { if (t.length < 3) return e.error("Expected at least two arguments."); if ((t.length - 1) % 2 != 0) return e.error("Expected an even number of arguments."); for (var n = [], i = 1; i < t.length - 1; i += 2) { var r = e.parse(t[i], 1, et); if (!r) return null; var o = r.type.kind; if ("string" !== o && "value" !== o && "null" !== o) return e.error("Formatted text type must be 'string', 'value', or 'null'."); var a = t[i + 1]; if ("object" != typeof a || Array.isArray(a)) return e.error("Format options argument must be an object."); var s = null; if (a["font-scale"] && !(s = e.parse(a["font-scale"], 1, J))) return null; o = null; if (a["text-font"] && !(o = e.parse(a["text-font"], 1, rt(Y)))) return null; n.push({ text: r, scale: s, font: o }) } return new yt(n) }, yt.prototype.evaluate = function (e) { return new mt(this.sections.map(function (t) { return new dt(t.text.evaluate(e) || "", t.scale ? t.scale.evaluate(e) : null, t.font ? t.font.evaluate(e).join(",") : null) })) }, yt.prototype.eachChild = function (t) { for (var e = 0, n = this.sections; e < n.length; e += 1) { var i = n[e]; t(i.text), i.scale && t(i.scale), i.font && t(i.font) } }, yt.prototype.possibleOutputs = function () { return [void 0] }, yt.prototype.serialize = function () { for (var t = ["format"], e = 0, n = this.sections; e < n.length; e += 1) { var i = n[e]; t.push(i.text.serialize()); var r = {}; i.scale && (r["font-scale"] = i.scale.serialize()), i.font && (r["text-font"] = i.font.serialize()), t.push(r) } return t }; function gt(t, e) { this.type = t, this.value = e } gt.parse = function (t, e) { if (2 !== t.length) return e.error("'literal' expression requires exactly one argument, but found " + (t.length - 1) + " instead."); if (!function t(e) { if (null === e) return 1; if ("string" == typeof e) return 1; if ("boolean" == typeof e) return 1; if ("number" == typeof e) return 1; if (e instanceof ut) return 1; if (e instanceof ct) return 1; if (Array.isArray(e)) { for (var n = 0, i = e; n < i.length; n += 1)if (!t(i[n])) return; return 1 } if ("object" == typeof e) { for (var r in e) if (!t(e[r])) return; return 1 } }(t[1])) return e.error("invalid value"); var n = t[1], t = ft(n), e = e.expectedType; return "array" !== t.kind || 0 !== t.N || !e || "array" !== e.kind || "number" == typeof e.N && 0 !== e.N || (t = e), new gt(t, n) }, gt.prototype.evaluate = function () { return this.value }, gt.prototype.eachChild = function () { }, gt.prototype.possibleOutputs = function () { return [this.value] }, gt.prototype.serialize = function () { return "array" === this.type.kind || "object" === this.type.kind ? ["literal", this.value] : this.value instanceof ut ? ["rgba"].concat(this.value.toArray()) : this.value instanceof mt ? this.value.serialize() : this.value }; function vt(t) { this.name = "ExpressionEvaluationError", this.message = t } vt.prototype.toJSON = function () { return this.message }; function _t(t, e) { this.type = t, this.args = e } var xt = { string: Y, number: J, boolean: $, object: tt }; _t.parse = function (t, e) { if (t.length < 2) return e.error("Expected at least one argument."); for (var n = t[0], n = xt[n], i = [], r = 1; r < t.length; r++) { var o = e.parse(t[r], r, et); if (!o) return null; i.push(o) } return new _t(n, i) }, _t.prototype.evaluate = function (t) { for (var e = 0; e < this.args.length; e++) { var n = this.args[e].evaluate(t); if (!st(this.type, ft(n))) return n; if (e === this.args.length - 1) throw new vt("Expected value to be of type " + ot(this.type) + ", but found " + ot(ft(n)) + " instead.") } return null }, _t.prototype.eachChild = function (t) { this.args.forEach(t) }, _t.prototype.possibleOutputs = function () { return (t = []).concat.apply(t, this.args.map(function (t) { return t.possibleOutputs() })); var t }, _t.prototype.serialize = function () { return [this.type.kind].concat(this.args.map(function (t) { return t.serialize() })) }; function bt(t, e) { this.type = t, this.input = e } var wt = { string: Y, number: J, boolean: $ }; bt.parse = function (t, e) { if (t.length < 2 || 4 < t.length) return e.error("Expected 1, 2, or 3 arguments, but found " + (t.length - 1) + " instead."); if (2 < t.length) { var n = t[1]; if ("string" != typeof n || !(n in wt)) return e.error('The item type argument of "array" must be one of string, number, boolean', 1); n = wt[n] } else n = et; if (3 < t.length) { if ("number" != typeof t[2] || t[2] < 0 || t[2] !== Math.floor(t[2])) return e.error('The length argument to "array" must be a positive integer literal', 2); i = t[2] } var i = rt(n, i), t = e.parse(t[t.length - 1], t.length - 1, et); return t ? new bt(i, t) : null }, bt.prototype.evaluate = function (t) { t = this.input.evaluate(t); if (st(this.type, ft(t))) throw new vt("Expected value to be of type " + ot(this.type) + ", but found " + ot(ft(t)) + " instead."); return t }, bt.prototype.eachChild = function (t) { t(this.input) }, bt.prototype.possibleOutputs = function () { return this.input.possibleOutputs() }, bt.prototype.serialize = function () { var t = ["array"], e = this.type.itemType; return "string" !== e.kind && "number" !== e.kind && "boolean" !== e.kind || (t.push(e.kind), "number" == typeof (e = this.type.N) && t.push(e)), t.push(this.input.serialize()), t }; function Et(t, e) { this.type = t, this.args = e } var St = { "to-number": J, "to-color": Q }; Et.parse = function (t, e) { if (t.length < 2) return e.error("Expected at least one argument."); for (var n = t[0], n = St[n], i = [], r = 1; r < t.length; r++) { var o = e.parse(t[r], r, et); if (!o) return null; i.push(o) } return new Et(n, i) }, Et.prototype.evaluate = function (t) { if ("color" === this.type.kind) { for (var e, n, i = 0, r = this.args; i < r.length; i += 1)if (n = null, "string" == typeof (e = r[i].evaluate(t))) { var o = t.parseColor(e); if (o) return o } else if (Array.isArray(e) && !(n = e.length < 3 || 4 < e.length ? "Invalid rbga value " + JSON.stringify(e) + ": expected an array containing either three or four numeric values." : pt(e[0], e[1], e[2], e[3]))) return new ut(e[0] / 255, e[1] / 255, e[2] / 255, e[3]); throw new vt(n || "Could not parse color from value '" + ("string" == typeof e ? e : JSON.stringify(e)) + "'") } if ("formatted" === this.type.kind) { for (var a, s = 0, l = this.args; s < l.length; s += 1)if ("string" == typeof (a = l[s].evaluate(t))) return new mt([new dt(a, null, null)]); throw new vt("Could not parse formatted text from value '" + ("string" == typeof a ? a : JSON.stringify(a)) + "'") } for (var u = null, c = 0, h = this.args; c < h.length; c += 1)if (null !== (u = h[c].evaluate(t))) { var p = Number(u); if (!isNaN(p)) return p } throw new vt("Could not convert " + JSON.stringify(u) + " to number.") }, Et.prototype.eachChild = function (t) { this.args.forEach(t) }, Et.prototype.possibleOutputs = function () { return (t = []).concat.apply(t, this.args.map(function (t) { return t.possibleOutputs() })); var t }, Et.prototype.serialize = function () { var e = ["to-" + this.type.kind]; return this.eachChild(function (t) { e.push(t.serialize()) }), e }; function Tt() { this._parseColorCache = {} } var At = ["Unknown", "Point", "LineString", "Polygon"]; Tt.prototype.id = function () { return this.feature && "id" in this.feature ? this.feature.id : null }, Tt.prototype.geometryType = function () { return this.feature ? "number" == typeof this.feature.type ? At[this.feature.type] : this.feature.type : null }, Tt.prototype.properties = function () { return this.feature && this.feature.properties || {} }, Tt.prototype.parseColor = function (t) { return this._parseColorCache[t] || (this._parseColorCache[t] = ut.parse(t)) }; var zt = function (t, e, n, i) { this.name = t, this.type = e, this._evaluate = n, this.args = i }; function It(t) { if (t instanceof zt) { if ("get" === t.name && 1 === t.args.length) return !1; if ("feature-state" === t.name) return !1; if ("has" === t.name && 1 === t.args.length) return !1; if ("properties" === t.name || "geometry-type" === t.name || "id" === t.name) return !1; if (/^filter-/.test(t.name)) return !1 } var e = !0; return t.eachChild(function (t) { e && !It(t) && (e = !1) }), e } function kt(t) { if (!(t instanceof zt && "feature-state" === t.name)) { var e = !0; return t.eachChild(function (t) { e && !kt(t) && (e = !1) }), e } } function Ct(t, e) { if (t instanceof zt && 0 <= e.indexOf(t.name)) return !1; var n = !0; return t.eachChild(function (t) { n && !Ct(t, e) && (n = !1) }), n } zt.prototype.evaluate = function (t) { return this._evaluate(t, this.args) }, zt.prototype.eachChild = function (t) { this.args.forEach(t) }, zt.prototype.possibleOutputs = function () { return [void 0] }, zt.prototype.serialize = function () { return [this.name].concat(this.args.map(function (t) { return t.serialize() })) }, zt.parse = function (e, t) { var n = e[0], i = zt.definitions[n]; if (!i) return t.error('Unknown expression "' + n + '". If you wanted a literal array, use ["literal", [...]].', 0); for (var r = Array.isArray(i) ? i[0] : i.type, o = Array.isArray(i) ? [[i[1], i[2]]] : i.overloads, i = o.filter(function (t) { t = t[0]; return !Array.isArray(t) || t.length === e.length - 1 }), a = null, s = 0, l = i; s < l.length; s += 1) { for (var u = l[s], c = u[0], u = u[1], a = new Pt(t.registry, t.path, null, t.scope), h = [], p = !1, f = 1; f < e.length; f++) { var d = e[f], m = Array.isArray(c) ? c[f - 1] : c.type, m = a.parse(d, 1 + h.length, m); if (!m) { p = !0; break } h.push(m) } if (!p) if (Array.isArray(c) && c.length !== h.length) a.error("Expected " + c.length + " arguments, but found " + h.length + " instead."); else { for (var y = 0; y < h.length; y++) { var g = Array.isArray(c) ? c[y] : c.type, v = h[y]; a.concat(y + 1).checkSubtype(g, v.type) } if (0 === a.errors.length) return new zt(n, r, u, h) } } if (1 === i.length) t.errors.push.apply(t.errors, a.errors); else { for (var o = (i.length ? i : o).map(function (t) { t = t[0]; return Array.isArray(t) ? "(" + t.map(ot).join(", ") + ")" : "(" + ot(t.type) + "...)" }).join(" | "), _ = [], x = 1; x < e.length; x++) { var b = t.parse(e[x], 1 + _.length); if (!b) return null; _.push(ot(b.type)) } t.error("Expected arguments of type " + o + ", but found (" + _.join(", ") + ") instead.") } return null }, zt.register = function (t, e) { for (var n in zt.definitions = e) t[n] = zt }; function Mt(t, e) { this.type = e.type, this.name = t, this.boundExpression = e } Mt.parse = function (t, e) { if (2 !== t.length || "string" != typeof t[1]) return e.error("'var' expression requires exactly one string literal argument."); t = t[1]; return e.scope.has(t) ? new Mt(t, e.scope.get(t)) : e.error('Unknown variable "' + t + '". Make sure "' + t + '" has been bound in an enclosing "let" expression before using it.', 1) }, Mt.prototype.evaluate = function (t) { return this.boundExpression.evaluate(t) }, Mt.prototype.eachChild = function () { }, Mt.prototype.possibleOutputs = function () { return [void 0] }, Mt.prototype.serialize = function () { return ["var", this.name] }; var Pt = function (t, e, n, i, r) { void 0 === e && (e = []), void 0 === i && (i = new G), void 0 === r && (r = []), this.registry = t, this.path = e, this.key = e.map(function (t) { return "[" + t + "]" }).join(""), this.scope = i, this.errors = r, this.expectedType = n }; function Lt(t, e) { for (var n, i, r = 0, o = t.length - 1, a = 0; r <= o;) { if (n = t[a = Math.floor((r + o) / 2)], i = t[a + 1], e === n || n < e && e < i) return a; if (n < e) r = a + 1; else { if (!(e < n)) throw new vt("Input is not a number."); o = a - 1 } } return Math.max(a - 1, 0) } Pt.prototype.parse = function (t, e, n, i, r) { return void 0 === r && (r = {}), (e ? this.concat(e, n, i) : this)._parse(t, r) }, Pt.prototype._parse = function (t, e) { if (null !== t && "string" != typeof t && "boolean" != typeof t && "number" != typeof t || (t = ["literal", t]), Array.isArray(t)) { if (0 === t.length) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].'); var n = t[0]; if ("string" != typeof n) return this.error("Expression name must be a string, but found " + typeof n + ' instead. If you wanted a literal array, use ["literal", [...]].', 0), null; var i = this.registry[n]; if (i) { var r = i.parse(t, this); if (!r) return null; if (this.expectedType) { var o = this.expectedType, i = r.type; if ("string" !== o.kind && "number" !== o.kind && "boolean" !== o.kind && "object" !== o.kind || "value" !== i.kind) if ("array" === o.kind && "value" === i.kind) e.omitTypeAnnotations || (r = new bt(o, r)); else if ("color" !== o.kind || "value" !== i.kind && "string" !== i.kind) if ("formatted" !== o.kind || "value" !== i.kind && "string" !== i.kind) { if (this.checkSubtype(this.expectedType, r.type)) return null } else e.omitTypeAnnotations || (r = new Et(o, [r])); else e.omitTypeAnnotations || (r = new Et(o, [r])); else e.omitTypeAnnotations || (r = new _t(o, [r])) } if (!(r instanceof gt) && function e(t) { if (t instanceof Mt) return e(t.boundExpression); if (t instanceof zt && "error" === t.name) return !1; if (t instanceof ht) return !1; var n = t instanceof Et || t instanceof _t || t instanceof bt, i = !0; return t.eachChild(function (t) { i = n ? i && e(t) : i && t instanceof gt }), !!i && (It(t) && Ct(t, ["zoom", "heatmap-density", "line-progress", "is-supported-script"])) }(r)) { var a = new Tt; try { r = new gt(r.type, r.evaluate(a)) } catch (t) { return this.error(t.message), null } } return r } return this.error('Unknown expression "' + n + '". If you wanted a literal array, use ["literal", [...]].', 0) } return void 0 === t ? this.error("'undefined' value invalid. Use null instead.") : "object" == typeof t ? this.error('Bare objects invalid. Use ["literal", {...}] instead.') : this.error("Expected an array, but found " + typeof t + " instead.") }, Pt.prototype.concat = function (t, e, n) { t = "number" == typeof t ? this.path.concat(t) : this.path, n = n ? this.scope.concat(n) : this.scope; return new Pt(this.registry, t, e || null, n, this.errors) }, Pt.prototype.error = function (t) { for (var e = [], n = arguments.length - 1; 0 < n--;)e[n] = arguments[n + 1]; var i = "" + this.key + e.map(function (t) { return "[" + t + "]" }).join(""); this.errors.push(new W(i, t)) }, Pt.prototype.checkSubtype = function (t, e) { e = st(t, e); return e && this.error(e), e }; var Dt = function (t, e, n) { this.type = t, this.input = e, this.labels = [], this.outputs = []; for (var i = 0, r = n; i < r.length; i += 1) { var o = r[i], a = o[0], o = o[1]; this.labels.push(a), this.outputs.push(o) } }; function Rt(t, e, n) { return t * (1 - n) + e * n } Dt.parse = function (t, e) { var n = t[1], i = t.slice(2); if (t.length - 1 < 4) return e.error("Expected at least 4 arguments, but found only " + (t.length - 1) + "."); if ((t.length - 1) % 2 != 0) return e.error("Expected an even number of arguments."); if (!(n = e.parse(n, 1, J))) return null; var r = [], o = null; e.expectedType && "value" !== e.expectedType.kind && (o = e.expectedType), i.unshift(-1 / 0); for (var a = 0; a < i.length; a += 2) { var s = i[a], l = i[a + 1], u = a + 1, c = a + 2; if ("number" != typeof s) return e.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', u); if (r.length && r[r.length - 1][0] >= s) return e.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', u); c = e.parse(l, c, o); if (!c) return null; o = o || c.type, r.push([s, c]) } return new Dt(o, n, r) }, Dt.prototype.evaluate = function (t) { var e = this.labels, n = this.outputs; if (1 === e.length) return n[0].evaluate(t); var i = this.input.evaluate(t); if (i <= e[0]) return n[0].evaluate(t); var r = e.length; return (i >= e[r - 1] ? n[r - 1] : n[Lt(e, i)]).evaluate(t) }, Dt.prototype.eachChild = function (t) { t(this.input); for (var e = 0, n = this.outputs; e < n.length; e += 1)t(n[e]) }, Dt.prototype.possibleOutputs = function () { return (t = []).concat.apply(t, this.outputs.map(function (t) { return t.possibleOutputs() })); var t }, Dt.prototype.serialize = function () { for (var t = ["step", this.input.serialize()], e = 0; e < this.labels.length; e++)0 < e && t.push(this.labels[e]), t.push(this.outputs[e].serialize()); return t }; var Bt = Object.freeze({ number: Rt, color: function (t, e, n) { return new ut(Rt(t.r, e.r, n), Rt(t.g, e.g, n), Rt(t.b, e.b, n), Rt(t.a, e.a, n)) }, array: function (t, n, i) { return t.map(function (t, e) { return Rt(t, n[e], i) }) } }), Ot = function (t, e, n, i) { this.type = t, this.interpolation = e, this.input = n, this.labels = [], this.outputs = []; for (var r = 0, o = i; r < o.length; r += 1) { var a = o[r], s = a[0], a = a[1]; this.labels.push(s), this.outputs.push(a) } }; function Ft(t, e, n, i) { i -= n, n = t - n; return 0 == i ? 0 : 1 === e ? n / i : (Math.pow(e, n) - 1) / (Math.pow(e, i) - 1) } Ot.interpolationFactor = function (t, e, n, i) { var r = 0; return "exponential" === t.name ? r = Ft(e, t.base, n, i) : "linear" === t.name ? r = Ft(e, 1, n, i) : "cubic-bezier" === t.name && (t = t.controlPoints, r = new o(t[0], t[1], t[2], t[3]).solve(Ft(e, 1, n, i))), r }, Ot.parse = function (t, e) { var n = t[1], i = t[2], r = t.slice(3); if (!Array.isArray(n) || 0 === n.length) return e.error("Expected an interpolation type expression.", 1); if ("linear" === n[0]) n = { name: "linear" }; else if ("exponential" === n[0]) { var o = n[1]; if ("number" != typeof o) return e.error("Exponential interpolation requires a numeric base.", 1, 1); n = { name: "exponential", base: o } } else { if ("cubic-bezier" !== n[0]) return e.error("Unknown interpolation type " + String(n[0]), 1, 0); o = n.slice(1); if (4 !== o.length || o.some(function (t) { return "number" != typeof t || t < 0 || 1 < t })) return e.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1); n = { name: "cubic-bezier", controlPoints: o } } if (t.length - 1 < 4) return e.error("Expected at least 4 arguments, but found only " + (t.length - 1) + "."); if ((t.length - 1) % 2 != 0) return e.error("Expected an even number of arguments."); if (!(i = e.parse(i, 2, J))) return null; var a = [], s = null; e.expectedType && "value" !== e.expectedType.kind && (s = e.expectedType); for (var l = 0; l < r.length; l += 2) { var u = r[l], c = r[l + 1], h = l + 3, p = l + 4; if ("number" != typeof u) return e.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', h); if (a.length && a[a.length - 1][0] >= u) return e.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', h); p = e.parse(c, p, s); if (!p) return null; s = s || p.type, a.push([u, p]) } return "number" === s.kind || "color" === s.kind || "array" === s.kind && "number" === s.itemType.kind && "number" == typeof s.N ? new Ot(s, n, i, a) : e.error("Type " + ot(s) + " is not interpolatable.") }, Ot.prototype.evaluate = function (t) { var e = this.labels, n = this.outputs; if (1 === e.length) return n[0].evaluate(t); var i = this.input.evaluate(t); if (i <= e[0]) return n[0].evaluate(t); var r = e.length; if (i >= e[r - 1]) return n[r - 1].evaluate(t); var o = Lt(e, i), r = e[o], e = e[o + 1], r = Ot.interpolationFactor(this.interpolation, i, r, e), e = n[o].evaluate(t), t = n[o + 1].evaluate(t); return Bt[this.type.kind.toLowerCase()](e, t, r) }, Ot.prototype.eachChild = function (t) { t(this.input); for (var e = 0, n = this.outputs; e < n.length; e += 1)t(n[e]) }, Ot.prototype.possibleOutputs = function () { return (t = []).concat.apply(t, this.outputs.map(function (t) { return t.possibleOutputs() })); var t }, Ot.prototype.serialize = function () { for (var t = ["interpolate", "linear" === this.interpolation.name ? ["linear"] : "exponential" === this.interpolation.name ? 1 === this.interpolation.base ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier"].concat(this.interpolation.controlPoints), this.input.serialize()], e = 0; e < this.labels.length; e++)t.push(this.labels[e], this.outputs[e].serialize()); return t }; var Vt = function (t, e) { this.type = t, this.args = e }; Vt.parse = function (t, e) { if (t.length < 2) return e.error("Expectected at least one argument."); var n = null, i = e.expectedType; i && "value" !== i.kind && (n = i); for (var r = [], o = 0, a = t.slice(1); o < a.length; o += 1) { var s = a[o], s = e.parse(s, 1 + r.length, n, void 0, { omitTypeAnnotations: !0 }); if (!s) return null; n = n || s.type, r.push(s) } t = i && r.some(function (t) { return st(i, t.type) }); return new Vt(t ? et : n, r) }, Vt.prototype.evaluate = function (t) { for (var e = null, n = 0, i = this.args; n < i.length && null === (e = i[n].evaluate(t)); n += 1); return e }, Vt.prototype.eachChild = function (t) { this.args.forEach(t) }, Vt.prototype.possibleOutputs = function () { return (t = []).concat.apply(t, this.args.map(function (t) { return t.possibleOutputs() })); var t }, Vt.prototype.serialize = function () { var e = ["coalesce"]; return this.eachChild(function (t) { e.push(t.serialize()) }), e }; var Nt = function (t, e) { this.type = e.type, this.bindings = [].concat(t), this.result = e }; Nt.prototype.evaluate = function (t) { return this.result.evaluate(t) }, Nt.prototype.eachChild = function (t) { for (var e = 0, n = this.bindings; e < n.length; e += 1)t(n[e][1]); t(this.result) }, Nt.parse = function (t, e) { if (t.length < 4) return e.error("Expected at least 3 arguments, but found " + (t.length - 1) + " instead."); for (var n = [], i = 1; i < t.length - 1; i += 2) { var r = t[i]; if ("string" != typeof r) return e.error("Expected string, but found " + typeof r + " instead.", i); if (/[^a-zA-Z0-9_]/.test(r)) return e.error("Variable names must contain only alphanumeric characters or '_'.", i); var o = e.parse(t[i + 1], i + 1); if (!o) return null; n.push([r, o]) } var a = e.parse(t[t.length - 1], t.length - 1, void 0, n); return a ? new Nt(n, a) : null }, Nt.prototype.possibleOutputs = function () { return this.result.possibleOutputs() }, Nt.prototype.serialize = function () { for (var t = ["let"], e = 0, n = this.bindings; e < n.length; e += 1) { var i = n[e], r = i[0], i = i[1]; t.push(r, i.serialize()) } return t.push(this.result.serialize()), t }; function jt(t, e, n) { this.type = t, this.index = e, this.input = n } jt.parse = function (t, e) { if (3 !== t.length) return e.error("Expected 2 arguments, but found " + (t.length - 1) + " instead."); var n = e.parse(t[1], 1, J), t = e.parse(t[2], 2, rt(e.expectedType || et)); if (!n || !t) return null; e = t.type; return new jt(e.itemType, n, t) }, jt.prototype.evaluate = function (t) { var e = this.index.evaluate(t), t = this.input.evaluate(t); if (e < 0) throw new vt("Array index out of bounds: " + e + " < 0."); if (e >= t.length) throw new vt("Array index out of bounds: " + e + " > " + (t.length - 1) + "."); if (e !== Math.floor(e)) throw new vt("Array index must be an integer, but found " + e + " instead."); return t[e] }, jt.prototype.eachChild = function (t) { t(this.index), t(this.input) }, jt.prototype.possibleOutputs = function () { return [void 0] }, jt.prototype.serialize = function () { return ["at", this.index.serialize(), this.input.serialize()] }; function Ut(t, e, n, i, r, o) { this.inputType = t, this.type = e, this.input = n, this.cases = i, this.outputs = r, this.otherwise = o } Ut.parse = function (t, e) { if (t.length < 5) return e.error("Expected at least 4 arguments, but found only " + (t.length - 1) + "."); if (t.length % 2 != 1) return e.error("Expected an even number of arguments."); var n, i; e.expectedType && "value" !== e.expectedType.kind && (i = e.expectedType); for (var r = {}, o = [], a = 2; a < t.length - 1; a += 2) { var s = t[a], l = t[a + 1]; Array.isArray(s) || (s = [s]); var u = e.concat(a); if (0 === s.length) return u.error("Expected at least one branch label."); for (var c = 0, h = s; c < h.length; c += 1) { var p = h[c]; if ("number" != typeof p && "string" != typeof p) return u.error("Branch labels must be numbers or strings."); if ("number" == typeof p && Math.abs(p) > Number.MAX_SAFE_INTEGER) return u.error("Branch labels must be integers no larger than " + Number.MAX_SAFE_INTEGER + "."); if ("number" == typeof p && Math.floor(p) !== p) return u.error("Numeric branch labels must be integer values."); if (n) { if (u.checkSubtype(n, ft(p))) return null } else n = ft(p); if (void 0 !== r[String(p)]) return u.error("Branch labels must be unique."); r[String(p)] = o.length } l = e.parse(l, a, i); if (!l) return null; i = i || l.type, o.push(l) } var f = e.parse(t[1], 1, et); if (!f) return null; var d = e.parse(t[t.length - 1], t.length - 1, i); return !d || "value" !== f.type.kind && e.concat(1).checkSubtype(n, f.type) ? null : new Ut(n, i, f, r, o, d) }, Ut.prototype.evaluate = function (t) { var e = this.input.evaluate(t); return (ft(e) === this.inputType && this.outputs[this.cases[e]] || this.otherwise).evaluate(t) }, Ut.prototype.eachChild = function (t) { t(this.input), this.outputs.forEach(t), t(this.otherwise) }, Ut.prototype.possibleOutputs = function () { return (t = []).concat.apply(t, this.outputs.map(function (t) { return t.possibleOutputs() })).concat(this.otherwise.possibleOutputs()); var t }, Ut.prototype.serialize = function () { for (var e = this, t = ["match", this.input.serialize()], n = [], i = {}, r = 0, o = Object.keys(this.cases).sort(); r < o.length; r += 1) { var a = o[r], s = i[e.cases[a]]; void 0 === s ? (i[e.cases[a]] = n.length, n.push([e.cases[a], [a]])) : n[s][1].push(a) } for (var l = function (t) { return "number" === e.inputType.kind ? Number(t) : t }, u = 0, c = n; u < c.length; u += 1) { var h = c[u], p = h[0], h = h[1]; 1 === h.length ? t.push(l(h[0])) : t.push(h.map(l)), t.push(e.outputs[p].serialize()) } return t.push(this.otherwise.serialize()), t }; function qt(t, e, n) { this.type = t, this.branches = e, this.otherwise = n } function Zt(t, e) { return "==" === t || "!=" === t ? "boolean" === e.kind || "string" === e.kind || "number" === e.kind || "null" === e.kind || "value" === e.kind : "string" === e.kind || "number" === e.kind || "value" === e.kind } function Gt(t, e, n, i) { return 0 === i.compare(e, n) } function Xt(o, a, s) { var l = "==" !== o && "!=" !== o; return u.parse = function (t, e) { if (3 !== t.length && 4 !== t.length) return e.error("Expected two or three arguments."); var n = t[0], i = e.parse(t[1], 1, et); if (!i) return null; if (!Zt(n, i.type)) return e.concat(1).error('"' + n + "\" comparisons are not supported for type '" + ot(i.type) + "'."); var r = e.parse(t[2], 2, et); if (!r) return null; if (!Zt(n, r.type)) return e.concat(2).error('"' + n + "\" comparisons are not supported for type '" + ot(r.type) + "'."); if (i.type.kind !== r.type.kind && "value" !== i.type.kind && "value" !== r.type.kind) return e.error("Cannot compare types '" + ot(i.type) + "' and '" + ot(r.type) + "'."); l && ("value" === i.type.kind && "value" !== r.type.kind ? i = new _t(r.type, [i]) : "value" !== i.type.kind && "value" === r.type.kind && (r = new _t(i.type, [r]))); n = null; if (4 === t.length) { if ("string" !== i.type.kind && "string" !== r.type.kind && "value" !== i.type.kind && "value" !== r.type.kind) return e.error("Cannot use collator to compare non-string types."); if (!(n = e.parse(t[3], 3, nt))) return null } return new u(i, r, n) }, u.prototype.evaluate = function (t) { var e = this.lhs.evaluate(t), n = this.rhs.evaluate(t); if (l && this.hasUntypedArgument) { var i = ft(e), r = ft(n); if (i.kind !== r.kind || "string" !== i.kind && "number" !== i.kind) throw new vt('Expected arguments for "' + o + '" to be (string, string) or (number, number), but found (' + i.kind + ", " + r.kind + ") instead.") } if (this.collator && !l && this.hasUntypedArgument) { i = ft(e), r = ft(n); if ("string" !== i.kind || "string" !== r.kind) return a(t, e, n) } return this.collator ? s(t, e, n, this.collator.evaluate(t)) : a(t, e, n) }, u.prototype.eachChild = function (t) { t(this.lhs), t(this.rhs), this.collator && t(this.collator) }, u.prototype.possibleOutputs = function () { return [!0, !1] }, u.prototype.serialize = function () { var e = [o]; return this.eachChild(function (t) { e.push(t.serialize()) }), e }, u; function u(t, e, n) { this.type = $, this.lhs = t, this.rhs = e, this.collator = n, this.hasUntypedArgument = "value" === t.type.kind || "value" === e.type.kind } } qt.parse = function (t, e) { if (t.length < 4) return e.error("Expected at least 3 arguments, but found only " + (t.length - 1) + "."); if (t.length % 2 != 0) return e.error("Expected an odd number of arguments."); var n; e.expectedType && "value" !== e.expectedType.kind && (n = e.expectedType); for (var i = [], r = 1; r < t.length - 1; r += 2) { var o = e.parse(t[r], r, $); if (!o) return null; var a = e.parse(t[r + 1], r + 1, n); if (!a) return null; i.push([o, a]), n = n || a.type } var s = e.parse(t[t.length - 1], t.length - 1, n); return s ? new qt(n, i, s) : null }, qt.prototype.evaluate = function (t) { for (var e = 0, n = this.branches; e < n.length; e += 1) { var i = n[e], r = i[0], i = i[1]; if (r.evaluate(t)) return i.evaluate(t) } return this.otherwise.evaluate(t) }, qt.prototype.eachChild = function (t) { for (var e = 0, n = this.branches; e < n.length; e += 1) { var i = n[e], r = i[0], i = i[1]; t(r), t(i) } t(this.otherwise) }, qt.prototype.possibleOutputs = function () { return (t = []).concat.apply(t, this.branches.map(function (t) { return t[0], t[1].possibleOutputs() })).concat(this.otherwise.possibleOutputs()); var t }, qt.prototype.serialize = function () { var e = ["case"]; return this.eachChild(function (t) { e.push(t.serialize()) }), e }; function Wt(t) { this.type = J, this.input = t } var Ht = Xt("==", function (t, e, n) { return e === n }, Gt), Kt = Xt("!=", function (t, e, n) { return e !== n }, function (t, e, n, i) { return !Gt(0, e, n, i) }), Jt = Xt("<", function (t, e, n) { return e < n }, function (t, e, n, i) { return i.compare(e, n) < 0 }), Yt = Xt(">", function (t, e, n) { return n < e }, function (t, e, n, i) { return 0 < i.compare(e, n) }), $t = Xt("<=", function (t, e, n) { return e <= n }, function (t, e, n, i) { return i.compare(e, n) <= 0 }), Qt = Xt(">=", function (t, e, n) { return n <= e }, function (t, e, n, i) { return 0 <= i.compare(e, n) }); Wt.parse = function (t, e) { if (2 !== t.length) return e.error("Expected 1 argument, but found " + (t.length - 1) + " instead."); t = e.parse(t[1], 1); return t ? "array" !== t.type.kind && "string" !== t.type.kind && "value" !== t.type.kind ? e.error("Expected argument of type string or array, but found " + ot(t.type) + " instead.") : new Wt(t) : null }, Wt.prototype.evaluate = function (t) { t = this.input.evaluate(t); if ("string" == typeof t) return t.length; if (Array.isArray(t)) return t.length; throw new vt("Expected value to be of type string or array, but found " + ot(ft(t)) + " instead.") }, Wt.prototype.eachChild = function (t) { t(this.input) }, Wt.prototype.possibleOutputs = function () { return [void 0] }, Wt.prototype.serialize = function () { var e = ["length"]; return this.eachChild(function (t) { e.push(t.serialize()) }), e }; var te = { "==": Ht, "!=": Kt, ">": Yt, "<": Jt, ">=": Qt, "<=": $t, array: bt, at: jt, boolean: _t, case: qt, coalesce: Vt, collator: ht, format: yt, interpolate: Ot, length: Wt, let: Nt, literal: gt, match: Ut, number: _t, object: _t, step: Dt, string: _t, "to-color": Et, "to-number": Et, var: Mt }; function ee(t, e) { var n = e[0], i = e[1], r = e[2], e = e[3], n = n.evaluate(t), i = i.evaluate(t), r = r.evaluate(t), e = e ? e.evaluate(t) : 1, t = pt(n, i, r, e); if (t) throw new vt(t); return new ut(n / 255 * e, i / 255 * e, r / 255 * e, e) } function ne(t, e) { t = e[t]; return void 0 === t ? null : t } function ie(t) { return { type: t } } function re(t) { return { result: "success", value: t } } function oe(t) { return { result: "error", value: t } } function ae(t) { return "data-driven" === t["property-type"] || "cross-faded-data-driven" === t["property-type"] } function se(t) { return t.expression && -1 < t.expression.parameters.indexOf("zoom") } function le(t) { return t.expression && t.expression.interpolated } zt.register(te, { error: [{ kind: "error" }, [Y], function (t, e) { e = e[0]; throw new vt(e.evaluate(t)) }], typeof: [Y, [et], function (t, e) { return ot(ft(e[0].evaluate(t))) }], "to-string": [Y, [et], function (t, e) { e = e[0], t = typeof (e = e.evaluate(t)); return null === e ? "" : "string" == t || "number" == t || "boolean" == t ? String(e) : e instanceof ut || e instanceof mt ? e.toString() : JSON.stringify(e) }], "to-boolean": [$, [et], function (t, e) { e = e[0]; return Boolean(e.evaluate(t)) }], "to-rgba": [rt(J, 4), [Q], function (t, e) { return e[0].evaluate(t).toArray() }], rgb: [Q, [J, J, J], ee], rgba: [Q, [J, J, J, J], ee], has: { type: $, overloads: [[[Y], function (t, e) { return e[0].evaluate(t) in t.properties() }], [[Y, tt], function (t, e) { var n = e[0], e = e[1]; return n.evaluate(t) in e.evaluate(t) }]] }, get: { type: et, overloads: [[[Y], function (t, e) { return ne(e[0].evaluate(t), t.properties()) }], [[Y, tt], function (t, e) { var n = e[0], e = e[1]; return ne(n.evaluate(t), e.evaluate(t)) }]] }, "feature-state": [et, [Y], function (t, e) { return ne(e[0].evaluate(t), t.featureState || {}) }], properties: [tt, [], function (t) { return t.properties() }], "geometry-type": [Y, [], function (t) { return t.geometryType() }], id: [et, [], function (t) { return t.id() }], zoom: [J, [], function (t) { return t.globals.zoom }], "heatmap-density": [J, [], function (t) { return t.globals.heatmapDensity || 0 }], "line-progress": [J, [], function (t) { return t.globals.lineProgress || 0 }], "+": [J, ie(J), function (t, e) { for (var n = 0, i = 0, r = e; i < r.length; i += 1)n += r[i].evaluate(t); return n }], "*": [J, ie(J), function (t, e) { for (var n = 1, i = 0, r = e; i < r.length; i += 1)n *= r[i].evaluate(t); return n }], "-": { type: J, overloads: [[[J, J], function (t, e) { var n = e[0], e = e[1]; return n.evaluate(t) - e.evaluate(t) }], [[J], function (t, e) { return -e[0].evaluate(t) }]] }, "/": [J, [J, J], function (t, e) { var n = e[0], e = e[1]; return n.evaluate(t) / e.evaluate(t) }], "%": [J, [J, J], function (t, e) { var n = e[0], e = e[1]; return n.evaluate(t) % e.evaluate(t) }], ln2: [J, [], function () { return Math.LN2 }], pi: [J, [], function () { return Math.PI }], e: [J, [], function () { return Math.E }], "^": [J, [J, J], function (t, e) { var n = e[0], e = e[1]; return Math.pow(n.evaluate(t), e.evaluate(t)) }], sqrt: [J, [J], function (t, e) { e = e[0]; return Math.sqrt(e.evaluate(t)) }], log10: [J, [J], function (t, e) { e = e[0]; return Math.log10(e.evaluate(t)) }], ln: [J, [J], function (t, e) { e = e[0]; return Math.log(e.evaluate(t)) }], log2: [J, [J], function (t, e) { e = e[0]; return Math.log2(e.evaluate(t)) }], sin: [J, [J], function (t, e) { e = e[0]; return Math.sin(e.evaluate(t)) }], cos: [J, [J], function (t, e) { e = e[0]; return Math.cos(e.evaluate(t)) }], tan: [J, [J], function (t, e) { e = e[0]; return Math.tan(e.evaluate(t)) }], asin: [J, [J], function (t, e) { e = e[0]; return Math.asin(e.evaluate(t)) }], acos: [J, [J], function (t, e) { e = e[0]; return Math.acos(e.evaluate(t)) }], atan: [J, [J], function (t, e) { e = e[0]; return Math.atan(e.evaluate(t)) }], min: [J, ie(J), function (e, t) { return Math.min.apply(Math, t.map(function (t) { return t.evaluate(e) })) }], max: [J, ie(J), function (e, t) { return Math.max.apply(Math, t.map(function (t) { return t.evaluate(e) })) }], abs: [J, [J], function (t, e) { e = e[0]; return Math.abs(e.evaluate(t)) }], round: [J, [J], function (t, e) { t = e[0].evaluate(t); return t < 0 ? -Math.round(-t) : Math.round(t) }], floor: [J, [J], function (t, e) { e = e[0]; return Math.floor(e.evaluate(t)) }], ceil: [J, [J], function (t, e) { e = e[0]; return Math.ceil(e.evaluate(t)) }], "filter-==": [$, [Y, et], function (t, e) { var n = e[0], e = e[1]; return t.properties()[n.value] === e.value }], "filter-id-==": [$, [et], function (t, e) { e = e[0]; return t.id() === e.value }], "filter-type-==": [$, [Y], function (t, e) { e = e[0]; return t.geometryType() === e.value }], "filter-<": [$, [Y, et], function (t, e) { var n = e[0], e = e[1], n = t.properties()[n.value], e = e.value; return typeof n == typeof e && n < e }], "filter-id-<": [$, [et], function (t, e) { e = e[0], t = t.id(), e = e.value; return typeof t == typeof e && t < e }], "filter->": [$, [Y, et], function (t, e) { var n = e[0], e = e[1], n = t.properties()[n.value], e = e.value; return typeof n == typeof e && e < n }], "filter-id->": [$, [et], function (t, e) { e = e[0], t = t.id(), e = e.value; return typeof t == typeof e && e < t }], "filter-<=": [$, [Y, et], function (t, e) { var n = e[0], e = e[1], n = t.properties()[n.value], e = e.value; return typeof n == typeof e && n <= e }], "filter-id-<=": [$, [et], function (t, e) { e = e[0], t = t.id(), e = e.value; return typeof t == typeof e && t <= e }], "filter->=": [$, [Y, et], function (t, e) { var n = e[0], e = e[1], n = t.properties()[n.value], e = e.value; return typeof n == typeof e && e <= n }], "filter-id->=": [$, [et], function (t, e) { e = e[0], t = t.id(), e = e.value; return typeof t == typeof e && e <= t }], "filter-has": [$, [et], function (t, e) { return e[0].value in t.properties() }], "filter-has-id": [$, [], function (t) { return null !== t.id() }], "filter-type-in": [$, [rt(Y)], function (t, e) { return 0 <= e[0].value.indexOf(t.geometryType()) }], "filter-id-in": [$, [rt(et)], function (t, e) { return 0 <= e[0].value.indexOf(t.id()) }], "filter-in-small": [$, [Y, rt(et)], function (t, e) { var n = e[0]; return 0 <= e[1].value.indexOf(t.properties()[n.value]) }], "filter-in-large": [$, [Y, rt(et)], function (t, e) { var n = e[0], e = e[1]; return function (t, e, n, i) { for (; n <= i;) { var r = n + i >> 1; if (e[r] === t) return !0; e[r] > t ? i = r - 1 : n = 1 + r } return !1 }(t.properties()[n.value], e.value, 0, e.value.length - 1) }], all: { type: $, overloads: [[[$, $], function (t, e) { var n = e[0], e = e[1]; return n.evaluate(t) && e.evaluate(t) }], [ie($), function (t, e) { for (var n = 0, i = e; n < i.length; n += 1)if (!i[n].evaluate(t)) return !1; return !0 }]] }, any: { type: $, overloads: [[[$, $], function (t, e) { var n = e[0], e = e[1]; return n.evaluate(t) || e.evaluate(t) }], [ie($), function (t, e) { for (var n = 0, i = e; n < i.length; n += 1)if (i[n].evaluate(t)) return !0; return !1 }]] }, "!": [$, [$], function (t, e) { return !e[0].evaluate(t) }], "is-supported-script": [$, [Y], function (t, e) { var n = e[0], e = t.globals && t.globals.isSupportedScript; return !e || e(n.evaluate(t)) }], upcase: [Y, [Y], function (t, e) { return e[0].evaluate(t).toUpperCase() }], downcase: [Y, [Y], function (t, e) { return e[0].evaluate(t).toLowerCase() }], concat: [Y, ie(Y), function (e, t) { return t.map(function (t) { return t.evaluate(e) }).join("") }], "resolved-locale": [Y, [nt], function (t, e) { return e[0].evaluate(t).resolvedLocale() }] }); var ue = 4 / 29, ce = 6 / 29, he = 3 * ce * ce, pe = ce * ce * ce, fe = Math.PI / 180, de = 180 / Math.PI; function me(t) { return pe < t ? Math.pow(t, 1 / 3) : t / he + ue } function ye(t) { return ce < t ? t * t * t : he * (t - ue) } function ge(t) { return 255 * (t <= .0031308 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - .055) } function ve(t) { return (t /= 255) <= .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4) } function _e(t) { var e = ve(t.r), n = ve(t.g), i = ve(t.b), r = me((.4124564 * e + .3575761 * n + .1804375 * i) / .95047), o = me(.2126729 * e + .7151522 * n + .072175 * i); return { l: 116 * o - 16, a: 500 * (r - o), b: 200 * (o - me((.0193339 * e + .119192 * n + .9503041 * i) / 1.08883)), alpha: t.a } } function xe(t) { var e = (t.l + 16) / 116, n = isNaN(t.a) ? e : e + t.a / 500, i = isNaN(t.b) ? e : e - t.b / 200, e = +ye(e), n = .95047 * ye(n), i = 1.08883 * ye(i); return new ut(ge(3.2404542 * n - 1.5371385 * e - .4985314 * i), ge(-.969266 * n + 1.8760108 * e + .041556 * i), ge(.0556434 * n - .2040259 * e + 1.0572252 * i), t.alpha) } var be = { forward: _e, reverse: xe, interpolate: function (t, e, n) { return { l: Rt(t.l, e.l, n), a: Rt(t.a, e.a, n), b: Rt(t.b, e.b, n), alpha: Rt(t.alpha, e.alpha, n) } } }, we = { forward: function (t) { var e = _e(t), n = e.l, i = e.a, r = e.b, e = Math.atan2(r, i) * de; return { h: e < 0 ? 360 + e : e, c: Math.sqrt(i * i + r * r), l: n, alpha: t.a } }, reverse: function (t) { var e = t.h * fe, n = t.c; return xe({ l: t.l, a: Math.cos(e) * n, b: Math.sin(e) * n, alpha: t.alpha }) }, interpolate: function (t, e, n) { return { h: function (t, e) { e -= t; return t + n * (180 < e || e < -180 ? e - 360 * Math.round(e / 360) : e) }(t.h, e.h), c: Rt(t.c, e.c, n), l: Rt(t.l, e.l, n), alpha: Rt(t.alpha, e.alpha, n) } } }, Ee = Object.freeze({ lab: be, hcl: we }); function Se(t) { return t instanceof Number ? "number" : t instanceof String ? "string" : t instanceof Boolean ? "boolean" : Array.isArray(t) ? "array" : null === t ? "null" : typeof t } function Te(t) { return "object" == typeof t && null !== t && !Array.isArray(t) } function Ae(t) { return t } function ze(t, e, n) { return void 0 !== t ? t : void 0 !== e ? e : void 0 !== n ? n : void 0 } function Ie(t, e, n, i, r) { return ze(typeof n === r ? i[n] : void 0, t.default, e.default) } function ke(t, e, n) { if ("number" !== Se(n)) return ze(t.default, e.default); e = t.stops.length; if (1 === e) return t.stops[0][1]; if (n <= t.stops[0][0]) return t.stops[0][1]; if (n >= t.stops[e - 1][0]) return t.stops[e - 1][1]; n = Pe(t.stops, n); return t.stops[n][1] } function Ce(t, e, n) { var i = void 0 !== t.base ? t.base : 1; if ("number" !== Se(n)) return ze(t.default, e.default); var r = t.stops.length; if (1 === r) return t.stops[0][1]; if (n <= t.stops[0][0]) return t.stops[0][1]; if (n >= t.stops[r - 1][0]) return t.stops[r - 1][1]; var o, a, s = Pe(t.stops, n), l = (o = i, r = t.stops[s][0], i = t.stops[s + 1][0] - r, r = n - r, 0 == i ? 0 : 1 === o ? r / i : (Math.pow(o, r) - 1) / (Math.pow(o, i) - 1)), u = t.stops[s][1], c = t.stops[s + 1][1], h = Bt[e.type] || Ae; return t.colorSpace && "rgb" !== t.colorSpace && (a = Ee[t.colorSpace], h = function (t, e) { return a.reverse(a.interpolate(a.forward(t), a.forward(e), l)) }), "function" == typeof u.evaluate ? { evaluate: function () { for (var t = [], e = arguments.length; e--;)t[e] = arguments[e]; var n = u.evaluate.apply(void 0, t), i = c.evaluate.apply(void 0, t); if (void 0 !== n && void 0 !== i) return h(n, i, l) } } : h(u, c, l) } function Me(t, e, n) { return "color" === e.type ? n = ut.parse(n) : Se(n) === e.type || "enum" === e.type && e.values[n] || (n = void 0), ze(n, t.default, e.default) } function Pe(t, e) { for (var n, i, r = 0, o = t.length - 1, a = 0; r <= o;) { if (n = t[a = Math.floor((r + o) / 2)][0], i = t[a + 1][0], e === n || n < e && e < i) return a; n < e ? r = a + 1 : e < n && (o = a - 1) } return Math.max(a - 1, 0) } var Le = function (t, e) { this.expression = t, this._warningHistory = {}, this._defaultValue = "color" === (t = e).type && Te(t.default) ? new ut(0, 0, 0, 0) : "color" === t.type ? ut.parse(t.default) || null : void 0 === t.default ? null : t.default, "enum" === e.type && (this._enumValues = e.values) }; function De(t) { return Array.isArray(t) && 0 < t.length && "string" == typeof t[0] && t[0] in te } function Re(t, e) { var n, n = new Pt(te, [], (n = { color: Q, string: Y, number: J, enum: Y, boolean: $ }, "array" === e.type ? rt(n[e.value] || et, e.length) : n[e.type] || null)), t = n.parse(t); return t ? re(new Le(t, e)) : oe(n.errors) } Le.prototype.evaluateWithoutErrorHandling = function (t, e, n) { return this._evaluator || (this._evaluator = new Tt), this._evaluator.globals = t, this._evaluator.feature = e, this._evaluator.featureState = n, this.expression.evaluate(this._evaluator) }, Le.prototype.evaluate = function (t, e, n) { this._evaluator || (this._evaluator = new Tt), this._evaluator.globals = t, this._evaluator.feature = e, this._evaluator.featureState = n; try { var i = this.expression.evaluate(this._evaluator); if (null == i) return this._defaultValue; if (this._enumValues && !(i in this._enumValues)) throw new vt("Expected value to be one of " + Object.keys(this._enumValues).map(function (t) { return JSON.stringify(t) }).join(", ") + ", but found " + JSON.stringify(i) + " instead."); return i } catch (t) { return this._warningHistory[t.message] || (this._warningHistory[t.message] = !0, "undefined" != typeof console && console.warn(t.message)), this._defaultValue } }; var Be = function (t, e) { this.kind = t, this._styleExpression = e, this.isStateDependent = "constant" !== t && !kt(e.expression) }; Be.prototype.evaluateWithoutErrorHandling = function (t, e, n) { return this._styleExpression.evaluateWithoutErrorHandling(t, e, n) }, Be.prototype.evaluate = function (t, e, n) { return this._styleExpression.evaluate(t, e, n) }; var Oe = function (t, e, n) { this.kind = t, this.zoomStops = n.labels, this._styleExpression = e, this.isStateDependent = "camera" !== t && !kt(e.expression), n instanceof Ot && (this._interpolationType = n.interpolation) }; function Fe(t, e) { if ("error" === (t = Re(t, e)).result) return t; var n = t.value.expression, i = It(n); if (!i && !ae(e)) return oe([new W("", "data expressions not supported")]); var r = Ct(n, ["zoom"]); if (!r && !se(e)) return oe([new W("", "zoom expressions not supported")]); n = function e(t) { var n = null; if (t instanceof Nt) n = e(t.result); else if (t instanceof Vt) for (var i = 0, r = t.args; i < r.length; i += 1) { var o = r[i]; if (n = e(o)) break } else (t instanceof Dt || t instanceof Ot) && t.input instanceof zt && "zoom" === t.input.name && (n = t); return n instanceof W || t.eachChild(function (t) { t = e(t); t instanceof W ? n = t : !n && t ? n = new W("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : n && t && n !== t && (n = new W("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.')) }), n }(n); return n || r ? n instanceof W ? oe([n]) : n instanceof Ot && !le(e) ? oe([new W("", '"interpolate" expressions cannot be used with this property')]) : re(n ? new Oe(i ? "camera" : "composite", t.value, n) : new Be(i ? "constant" : "source", t.value)) : oe([new W("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]) } Oe.prototype.evaluateWithoutErrorHandling = function (t, e, n) { return this._styleExpression.evaluateWithoutErrorHandling(t, e, n) }, Oe.prototype.evaluate = function (t, e, n) { return this._styleExpression.evaluate(t, e, n) }, Oe.prototype.interpolationFactor = function (t, e, n) { return this._interpolationType ? Ot.interpolationFactor(this._interpolationType, t, e, n) : 0 }; function Ve(t, e) { this._parameters = t, this._specification = e, U(this, function t(n, i) { var r, o, a, e = "color" === i.type, s = n.stops && "object" == typeof n.stops[0][0], l = s || void 0 !== n.property, u = s || !l, l = n.type || (le(i) ? "exponential" : "interval"); if (e && ((n = U({}, n)).stops && (n.stops = n.stops.map(function (t) { return [t[0], ut.parse(t[1])] })), n.default ? n.default = ut.parse(n.default) : n.default = ut.parse(i.default)), n.colorSpace && "rgb" !== n.colorSpace && !Ee[n.colorSpace]) throw new Error("Unknown color space: " + n.colorSpace); if ("exponential" === l) r = Ce; else if ("interval" === l) r = ke; else if ("categorical" === l) { r = Ie, o = Object.create(null); for (var c = 0, h = n.stops; c < h.length; c += 1) { var p = h[c]; o[p[0]] = p[1] } a = typeof n.stops[0][0] } else { if ("identity" !== l) throw new Error('Unknown function type "' + l + '"'); r = Me } if (s) { for (var f = {}, d = [], m = 0; m < n.stops.length; m++) { var y = n.stops[m], g = y[0].zoom; void 0 === f[g] && (f[g] = { zoom: g, type: n.type, property: n.property, default: n.default, stops: [] }, d.push(g)), f[g].stops.push([y[0].value, y[1]]) } for (var v = [], _ = 0, x = d; _ < x.length; _ += 1) { var b = x[_]; v.push([f[b].zoom, t(f[b], i)]) } return { kind: "composite", interpolationFactor: Ot.interpolationFactor.bind(void 0, { name: "linear" }), zoomStops: v.map(function (t) { return t[0] }), evaluate: function (t, e) { t = t.zoom; return Ce({ stops: v, base: n.base }, i, t).evaluate(t, e) } } } return u ? { kind: "camera", interpolationFactor: "exponential" === l ? Ot.interpolationFactor.bind(void 0, { name: "exponential", base: void 0 !== n.base ? n.base : 1 }) : function () { return 0 }, zoomStops: n.stops.map(function (t) { return t[0] }), evaluate: function (t) { t = t.zoom; return r(n, i, t, o, a) } } : { kind: "source", evaluate: function (t, e) { e = e && e.properties ? e.properties[n.property] : void 0; return void 0 === e ? ze(n.default, i.default) : r(n, i, e, o, a) } } }(this._parameters, this._specification)) } function Ne(t, e) { if (Te(t)) return new Ve(t, e); if (De(t)) { var n = Fe(t, e); if ("error" === n.result) throw new Error(n.value.map(function (t) { return t.key + ": " + t.message }).join(", ")); return n.value } var i = t; return "string" == typeof t && "color" === e.type && (i = ut.parse(t)), { kind: "constant", evaluate: function () { return i } } } function je(t) { var e, n, i = t.key, r = t.value, o = t.valueSpec || {}, a = t.objectElementValidators || {}, s = t.style, l = t.styleSpec, u = [], t = Se(r); if ("object" !== t) return [new N(i, r, "object expected, " + t + " found")]; for (e in r) { var c = e.split(".")[0], h = o[c] || o["*"], p = void 0; if (a[c]) p = a[c]; else if (o[c]) p = pn; else if (a["*"]) p = a["*"]; else { if (!o["*"]) { u.push(new N(i, r[e], 'unknown property "' + e + '"')); continue } p = pn } u = u.concat(p({ key: (i ? i + "." : i) + e, value: r[e], valueSpec: h, style: s, styleSpec: l, object: r, objectKey: e }, r)) } for (n in o) a[n] || o[n].required && void 0 === o[n].default && void 0 === r[n] && u.push(new N(i, r, 'missing required property "' + n + '"')); return u } function Ue(t) { var e = t.value, n = t.valueSpec, i = t.style, r = t.styleSpec, o = t.key, a = t.arrayElementValidator || pn; if ("array" !== Se(e)) return [new N(o, e, "array expected, " + Se(e) + " found")]; if (n.length && e.length !== n.length) return [new N(o, e, "array length " + n.length + " expected, length " + e.length + " found")]; if (n["min-length"] && e.length < n["min-length"]) return [new N(o, e, "array length at least " + n["min-length"] + " expected, length " + e.length + " found")]; var s = { type: n.value }; r.$version < 7 && (s.function = n.function), "object" === Se(n.value) && (s = n.value); for (var l = [], u = 0; u < e.length; u++)l = l.concat(a({ array: e, arrayIndex: u, value: e[u], valueSpec: s, style: i, styleSpec: r, key: o + "[" + u + "]" })); return l } function qe(t) { var e = t.key, n = t.value, i = t.valueSpec, t = Se(n); return "number" !== t ? [new N(e, n, "number expected, " + t + " found")] : "minimum" in i && n < i.minimum ? [new N(e, n, n + " is less than the minimum value " + i.minimum)] : "maximum" in i && n > i.maximum ? [new N(e, n, n + " is greater than the maximum value " + i.maximum)] : [] } function Ze(t) { var r, o, a, s = t.valueSpec, l = q(t.value.type), u = {}, e = "categorical" !== l && void 0 === t.value.property, n = !e, c = "array" === Se(t.value.stops) && "array" === Se(t.value.stops[0]) && "object" === Se(t.value.stops[0][0]), i = je({ key: t.key, value: t.value, valueSpec: t.styleSpec.function, style: t.style, styleSpec: t.styleSpec, objectElementValidators: { stops: function (t) { if ("identity" === l) return [new N(t.key, t.value, 'identity function may not have a "stops" property')]; var e = [], n = t.value, e = e.concat(Ue({ key: t.key, value: n, valueSpec: t.valueSpec, style: t.style, styleSpec: t.styleSpec, arrayElementValidator: h })); return "array" === Se(n) && 0 === n.length && e.push(new N(t.key, n, "array must have at least one stop")), e }, default: function (t) { return pn({ key: t.key, value: t.value, valueSpec: s, style: t.style, styleSpec: t.styleSpec }) } } }); return "identity" === l && e && i.push(new N(t.key, t.value, 'missing required property "property"')), "identity" === l || t.value.stops || i.push(new N(t.key, t.value, 'missing required property "stops"')), "exponential" === l && t.valueSpec.expression && !le(t.valueSpec) && i.push(new N(t.key, t.value, "exponential functions not supported")), 8 <= t.styleSpec.$version && (n && !ae(t.valueSpec) ? i.push(new N(t.key, t.value, "property functions not supported")) : e && !se(t.valueSpec) && i.push(new N(t.key, t.value, "zoom functions not supported"))), "categorical" !== l && !c || void 0 !== t.value.property || i.push(new N(t.key, t.value, '"property" property is required')), i; function h(t) { var e = [], n = t.value, i = t.key; if ("array" !== Se(n)) return [new N(i, n, "array expected, " + Se(n) + " found")]; if (2 !== n.length) return [new N(i, n, "array length 2 expected, length " + n.length + " found")]; if (c) { if ("object" !== Se(n[0])) return [new N(i, n, "object expected, " + Se(n[0]) + " found")]; if (void 0 === n[0].zoom) return [new N(i, n, "object stop key must have zoom")]; if (void 0 === n[0].value) return [new N(i, n, "object stop key must have value")]; if (a && a > q(n[0].zoom)) return [new N(i, n[0].zoom, "stop zoom values must appear in ascending order")]; q(n[0].zoom) !== a && (a = q(n[0].zoom), o = void 0, u = {}), e = e.concat(je({ key: i + "[0]", value: n[0], valueSpec: { zoom: {} }, style: t.style, styleSpec: t.styleSpec, objectElementValidators: { zoom: qe, value: p } })) } else e = e.concat(p({ key: i + "[0]", value: n[0], valueSpec: {}, style: t.style, styleSpec: t.styleSpec }, n)); return e.concat(pn({ key: i + "[1]", value: n[1], valueSpec: s, style: t.style, styleSpec: t.styleSpec })) } function p(t, e) { var n = Se(t.value), i = q(t.value), e = null !== t.value ? t.value : e; if (r) { if (n !== r) return [new N(t.key, e, n + " stop domain type must match previous stop domain type " + r)] } else r = n; if ("number" !== n && "string" !== n && "boolean" !== n) return [new N(t.key, e, "stop domain value must be a number, string, or boolean")]; if ("number" === n || "categorical" === l) return "categorical" !== l || "number" !== n || isFinite(i) && Math.floor(i) === i ? "categorical" !== l && "number" === n && void 0 !== o && i < o ? [new N(t.key, e, "stop domain values must appear in ascending order")] : (o = i, "categorical" === l && i in u ? [new N(t.key, e, "stop domain values must be unique")] : (u[i] = !0, [])) : [new N(t.key, e, "integer expected, found " + i)]; n = "number expected, " + n + " found"; return ae(s) && void 0 === l && (n += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new N(t.key, e, n)] } } function Ge(e) { var t = ("property" === e.expressionContext ? Fe : Re)(Z(e.value), e.valueSpec); return "error" === t.result ? t.value.map(function (t) { return new N("" + e.key + t.key, e.value, t.message) }) : "property" === e.expressionContext && "text-font" === e.propertyKey && -1 !== t.value._styleExpression.expression.possibleOutputs().indexOf(void 0) ? [new N(e.key, e.value, 'Invalid data expression for "text-font". Output values must be contained as literals within the expression.')] : "property" !== e.expressionContext || "layout" !== e.propertyType || kt(t.value._styleExpression.expression) ? [] : [new N(e.key, e.value, '"feature-state" data expressions are not supported with layout properties.')] } function Xe(t) { var e = t.key, n = t.value, i = t.valueSpec, t = []; return Array.isArray(i.values) ? -1 === i.values.indexOf(q(n)) && t.push(new N(e, n, "expected one of [" + i.values.join(", ") + "], " + JSON.stringify(n) + " found")) : -1 === Object.keys(i.values).indexOf(q(n)) && t.push(new N(e, n, "expected one of [" + Object.keys(i.values).join(", ") + "], " + JSON.stringify(n) + " found")), t } function We(t) { if (Array.isArray(t) && 0 !== t.length) switch (t[0]) { case "has": return 2 <= t.length && "$id" !== t[1] && "$type" !== t[1]; case "in": case "!in": case "!has": case "none": return; case "==": case "!=": case ">": case ">=": case "<": case "<=": return 3 !== t.length || Array.isArray(t[1]) || Array.isArray(t[2]); case "any": case "all": for (var e = 0, n = t.slice(1); e < n.length; e += 1) { var i = n[e]; if (!We(i) && "boolean" != typeof i) return } return 1; default: return 1 } } Ve.deserialize = function (t) { return new Ve(t._parameters, t._specification) }; var He = { type: "boolean", default: !(Ve.serialize = function (t) { return { _parameters: t._parameters, _specification: t._specification } }), transition: !1, "property-type": "data-driven", expression: { interpolated: !1, parameters: ["zoom", "feature"] } }; function Ke(t) { if (!t) return function () { return !0 }; We(t) || (t = Ye(t)); var n = Re(t, He); if ("error" === n.result) throw new Error(n.value.map(function (t) { return t.key + ": " + t.message }).join(", ")); return function (t, e) { return n.value.evaluate(t, e) } } function Je(t, e) { return t < e ? -1 : e < t ? 1 : 0 } function Ye(t) { if (!t) return !0; var e, n = t[0]; return t.length <= 1 ? "any" !== n : "==" === n ? $e(t[1], t[2], "==") : "!=" === n ? en($e(t[1], t[2], "==")) : "<" === n || ">" === n || "<=" === n || ">=" === n ? $e(t[1], t[2], n) : "any" === n ? (e = t.slice(1), ["any"].concat(e.map(Ye))) : "all" === n ? ["all"].concat(t.slice(1).map(Ye)) : "none" === n ? ["all"].concat(t.slice(1).map(Ye).map(en)) : "in" === n ? Qe(t[1], t.slice(2)) : "!in" === n ? en(Qe(t[1], t.slice(2))) : "has" === n ? tn(t[1]) : "!has" !== n || en(tn(t[1])) } function $e(t, e, n) { switch (t) { case "$type": return ["filter-type-" + n, e]; case "$id": return ["filter-id-" + n, e]; default: return ["filter-" + n, t, e] } } function Qe(t, e) { if (0 === e.length) return !1; switch (t) { case "$type": return ["filter-type-in", ["literal", e]]; case "$id": return ["filter-id-in", ["literal", e]]; default: return 200 < e.length && !e.some(function (t) { return typeof t != typeof e[0] }) ? ["filter-in-large", t, ["literal", e.sort(Je)]] : ["filter-in-small", t, ["literal", e]] } } function tn(t) { switch (t) { case "$type": return !0; case "$id": return ["filter-has-id"]; default: return ["filter-has", t] } } function en(t) { return ["!", t] } function nn(t) { return We(Z(t.value)) ? Ge(U({}, t, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : function t(e) { var n = e.value, i = e.key; if ("array" !== Se(n)) return [new N(i, n, "array expected, " + Se(n) + " found")]; var r, o = e.styleSpec, a = []; if (n.length < 1) return [new N(i, n, "filter array must have at least 1 element")]; switch (a = a.concat(Xe({ key: i + "[0]", value: n[0], valueSpec: o.filter_operator, style: e.style, styleSpec: e.styleSpec })), q(n[0])) { case "<": case "<=": case ">": case ">=": 2 <= n.length && "$type" === q(n[1]) && a.push(new N(i, n, '"$type" cannot be use with operator "' + n[0] + '"')); case "==": case "!=": 3 !== n.length && a.push(new N(i, n, 'filter array for operator "' + n[0] + '" must have 3 elements')); case "in": case "!in": 2 <= n.length && "string" !== (r = Se(n[1])) && a.push(new N(i + "[1]", n[1], "string expected, " + r + " found")); for (var s = 2; s < n.length; s++)r = Se(n[s]), "$type" === q(n[1]) ? a = a.concat(Xe({ key: i + "[" + s + "]", value: n[s], valueSpec: o.geometry_type, style: e.style, styleSpec: e.styleSpec })) : "string" !== r && "number" !== r && "boolean" !== r && a.push(new N(i + "[" + s + "]", n[s], "string, number, or boolean expected, " + r + " found")); break; case "any": case "all": case "none": for (var l = 1; l < n.length; l++)a = a.concat(t({ key: i + "[" + l + "]", value: n[l], style: e.style, styleSpec: e.styleSpec })); break; case "has": case "!has": r = Se(n[1]), 2 !== n.length ? a.push(new N(i, n, 'filter array for "' + n[0] + '" operator must have 2 elements')) : "string" !== r && a.push(new N(i + "[1]", n[1], "string expected, " + r + " found")) }return a }(t) } function rn(t, e) { var n = t.key, i = t.style, r = t.styleSpec, o = t.value, a = t.objectKey, s = r[e + "_" + t.layerType]; if (!s) return []; var l = a.match(/^(.*)-transition$/); if ("paint" === e && l && s[l[1]] && s[l[1]].transition) return pn({ key: n, value: o, valueSpec: r.transition, style: i, styleSpec: r }); s = t.valueSpec || s[a]; if (!s) return [new N(n, o, 'unknown property "' + a + '"')]; if ("string" === Se(o) && ae(s) && !s.tokens && (u = /^{([^}]+)}$/.exec(o))) return [new N(n, o, '"' + a + '" does not support interpolation syntax\nUse an identity property function instead: `{ "type": "identity", "property": ' + JSON.stringify(u[1]) + " }`.")]; var u = []; return "symbol" === t.layerType && ("text-field" === a && i && !i.glyphs && u.push(new N(n, o, 'use of "text-field" requires a style "glyphs" property')), "text-font" === a && Te(Z(o)) && "identity" === q(o.type) && u.push(new N(n, o, '"text-font" does not support identity functions'))), u.concat(pn({ key: t.key, value: o, valueSpec: s, style: i, styleSpec: r, expressionContext: "property", propertyType: e, propertyKey: a })) } function on(t) { return rn(t, "paint") } function an(t) { return rn(t, "layout") } function sn(t) { var e = [], n = t.value, i = t.key, r = t.style, o = t.styleSpec; n.type || n.ref || e.push(new N(i, n, 'either "type" or "ref" is required')); var a, s, l, u = q(n.type), c = q(n.ref); if (n.id) for (var h = q(n.id), p = 0; p < t.arrayIndex; p++) { var f = r.layers[p]; q(f.id) === h && e.push(new N(i, n.id, 'duplicate layer id "' + n.id + '", previously used at line ' + f.id.__line__)) } return "ref" in n ? (["type", "source", "source-layer", "filter", "layout"].forEach(function (t) { t in n && e.push(new N(i, n[t], '"' + t + '" is prohibited for ref layers')) }), r.layers.forEach(function (t) { q(t.id) === c && (a = t) }), a ? a.ref ? e.push(new N(i, n.ref, "ref cannot reference another ref layer")) : u = q(a.type) : e.push(new N(i, n.ref, 'ref layer "' + c + '" not found'))) : "background" !== u && (n.source ? (l = (s = r.sources && r.sources[n.source]) && q(s.type), s ? "vector" === l && "raster" === u ? e.push(new N(i, n.source, 'layer "' + n.id + '" requires a raster source')) : "raster" === l && "raster" !== u ? e.push(new N(i, n.source, 'layer "' + n.id + '" requires a vector source')) : "vector" !== l || n["source-layer"] ? "raster-dem" === l && "hillshade" !== u ? e.push(new N(i, n.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "line" !== u || !n.paint || !n.paint["line-gradient"] || "geojson" === l && s.lineMetrics || e.push(new N(i, n, 'layer "' + n.id + '" specifies a line-gradient, which requires a GeoJSON source with `lineMetrics` enabled.')) : e.push(new N(i, n, 'layer "' + n.id + '" must specify a "source-layer"')) : e.push(new N(i, n.source, 'source "' + n.source + '" not found'))) : e.push(new N(i, n, 'missing required property "source"'))), e = e.concat(je({ key: i, value: n, valueSpec: o.layer, style: t.style, styleSpec: t.styleSpec, objectElementValidators: { "*": function () { return [] }, type: function () { return pn({ key: i + ".type", value: n.type, valueSpec: o.layer.type, style: t.style, styleSpec: t.styleSpec, object: n, objectKey: "type" }) }, filter: nn, layout: function (t) { return je({ layer: n, key: t.key, value: t.value, style: t.style, styleSpec: t.styleSpec, objectElementValidators: { "*": function (t) { return an(U({ layerType: u }, t)) } } }) }, paint: function (t) { return je({ layer: n, key: t.key, value: t.value, style: t.style, styleSpec: t.styleSpec, objectElementValidators: { "*": function (t) { return on(U({ layerType: u }, t)) } } }) } } })) } function ln(t) { var e = t.value, n = t.key, i = t.styleSpec, r = t.style; if (!e.type) return [new N(n, e, '"type" is required')]; var o = q(e.type), a = []; switch (o) { case "vector": case "raster": case "raster-dem": if (a = a.concat(je({ key: n, value: e, valueSpec: i["source_" + o.replace("-", "_")], style: t.style, styleSpec: i })), "url" in e) for (var s in e) ["type", "url", "tileSize"].indexOf(s) < 0 && a.push(new N(n + "." + s, e[s], 'a source with a "url" property may not include a "' + s + '" property')); return a; case "geojson": return je({ key: n, value: e, valueSpec: i.source_geojson, style: r, styleSpec: i }); case "video": return je({ key: n, value: e, valueSpec: i.source_video, style: r, styleSpec: i }); case "image": return je({ key: n, value: e, valueSpec: i.source_image, style: r, styleSpec: i }); case "canvas": return a.push(new N(n, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")), a; default: return Xe({ key: n + ".type", value: e.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] }, style: r, styleSpec: i }) } } function un(t) { var e, n = t.value, i = t.styleSpec, r = i.light, o = t.style, a = [], t = Se(n); if (void 0 === n) return a; if ("object" !== t) return a.concat([new N("light", n, "object expected, " + t + " found")]); for (e in n) var s = e.match(/^(.*)-transition$/), a = s && r[s[1]] && r[s[1]].transition ? a.concat(pn({ key: e, value: n[e], valueSpec: i.transition, style: o, styleSpec: i })) : r[e] ? a.concat(pn({ key: e, value: n[e], valueSpec: r[e], style: o, styleSpec: i })) : a.concat([new N(e, n[e], 'unknown property "' + e + '"')]); return a } function cn(t) { var e = t.value, n = t.key, t = Se(e); return "string" !== t ? [new N(n, e, "string expected, " + t + " found")] : [] } var hn = { "*": function () { return [] }, array: Ue, boolean: function (t) { var e = t.value, n = t.key, t = Se(e); return "boolean" !== t ? [new N(n, e, "boolean expected, " + t + " found")] : [] }, number: qe, color: function (t) { var e = t.key, n = t.value, t = Se(n); return "string" !== t ? [new N(e, n, "color expected, " + t + " found")] : null === lt(n) ? [new N(e, n, 'color expected, "' + n + '" found')] : [] }, constants: j, enum: Xe, filter: nn, function: Ze, layer: sn, object: je, source: ln, light: un, string: cn, formatted: function (t) { return 0 === cn(t).length ? [] : Ge(t) } }; function pn(t) { var e = t.value, n = t.valueSpec, i = t.styleSpec; return n.expression && Te(q(e)) ? Ze(t) : n.expression && De(Z(e)) ? Ge(t) : n.type && hn[n.type] ? hn[n.type](t) : je(U({}, t, { valueSpec: n.type ? i[n.type] : n })) } function fn(t) { var e = t.value, n = t.key, t = cn(t); return t.length || (-1 === e.indexOf("{fontstack}") && t.push(new N(n, e, '"glyphs" url must include a "{fontstack}" token')), -1 === e.indexOf("{range}") && t.push(new N(n, e, '"glyphs" url must include a "{range}" token'))), t } function dn(t, e) { var n = (n = []).concat(pn({ key: "", value: t, valueSpec: (e = e || V).$root, styleSpec: e, style: t, objectElementValidators: { glyphs: fn, "*": function () { return [] } } })); return t.constants && (n = n.concat(j({ key: "constants", value: t.constants, style: t, styleSpec: e }))), mn(n) } function mn(t) { return [].concat(t).sort(function (t, e) { return t.line - e.line }) } function yn(t) { return function () { return mn(t.apply(this, arguments)) } } dn.source = yn(ln), dn.light = yn(un), dn.layer = yn(sn), dn.filter = yn(nn), dn.paintProperty = yn(on), dn.layoutProperty = yn(an); var gn = dn, vn = dn.light, _n = dn.paintProperty, xn = dn.layoutProperty; function bn(t, e) { var n = !1; if (e && e.length) for (var i = 0, r = e; i < r.length; i += 1) { var o = r[i]; t.fire(new O(new Error(o.message))), n = !0 } return n } var wn = Sn, En = 3; function Sn(t, e, n) { var i = this.cells = []; if (t instanceof ArrayBuffer) { this.arrayBuffer = t; var r = new Int32Array(this.arrayBuffer); t = r[0], e = r[1], n = r[2], this.d = e + 2 * n; for (var o = 0; o < this.d * this.d; o++) { var a = r[En + o], s = r[En + o + 1]; i.push(a === s ? null : r.subarray(a, s)) } var l = r[En + i.length], u = r[En + i.length + 1]; this.keys = r.subarray(l, u), this.bboxes = r.subarray(u), this.insert = this._insertReadonly } else { this.d = e + 2 * n; for (var c = 0; c < this.d * this.d; c++)i.push([]); this.keys = [], this.bboxes = [] } this.n = e, this.extent = t, this.padding = n, this.scale = e / t, this.uid = 0; e = n / e * t; this.min = -e, this.max = t + e } Sn.prototype.insert = function (t, e, n, i, r) { this._forEachCell(e, n, i, r, this._insertCell, this.uid++), this.keys.push(t), this.bboxes.push(e), this.bboxes.push(n), this.bboxes.push(i), this.bboxes.push(r) }, Sn.prototype._insertReadonly = function () { throw "Cannot insert into a GridIndex created from an ArrayBuffer." }, Sn.prototype._insertCell = function (t, e, n, i, r, o) { this.cells[r].push(o) }, Sn.prototype.query = function (t, e, n, i) { var r = this.min, o = this.max; if (t <= r && e <= r && o <= n && o <= i) return Array.prototype.slice.call(this.keys); o = []; return this._forEachCell(t, e, n, i, this._queryCell, o, {}), o }, Sn.prototype._queryCell = function (t, e, n, i, r, o, a) { var s = this.cells[r]; if (null !== s) for (var l = this.keys, u = this.bboxes, c = 0; c < s.length; c++) { var h, p = s[c]; void 0 === a[p] && (t <= u[2 + (h = 4 * p)] && e <= u[3 + h] && n >= u[0 + h] && i >= u[1 + h] ? (a[p] = !0, o.push(l[p])) : a[p] = !1) } }, Sn.prototype._forEachCell = function (t, e, n, i, r, o, a) { for (var s = this._convertToCellCoord(t), l = this._convertToCellCoord(e), u = this._convertToCellCoord(n), c = this._convertToCellCoord(i), h = s; h <= u; h++)for (var p = l; p <= c; p++) { var f = this.d * p + h; if (r.call(this, t, e, n, i, f, o, a)) return } }, Sn.prototype._convertToCellCoord = function (t) { return Math.max(0, Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding)) }, Sn.prototype.toArrayBuffer = function () { if (this.arrayBuffer) return this.arrayBuffer; for (var t = this.cells, e = En + this.cells.length + 1 + 1, n = 0, i = 0; i < this.cells.length; i++)n += this.cells[i].length; var r = new Int32Array(e + n + this.keys.length + this.bboxes.length); r[0] = this.extent, r[1] = this.n, r[2] = this.padding; for (var o = e, a = 0; a < t.length; a++) { var s = t[a]; r[En + a] = o, r.set(s, o), o += s.length } return r[En + t.length] = o, r.set(this.keys, o), o += this.keys.length, r[En + t.length + 1] = o, r.set(this.bboxes, o), o += this.bboxes.length, r.buffer }; var Tn, An = self.ImageData, zn = {}; function In(t, e, n) { void 0 === n && (n = {}), Object.defineProperty(e, "_classRegistryKey", { value: t, writeable: !1 }), zn[t] = { klass: e, omit: n.omit || [], shallow: n.shallow || [] } } for (Tn in In("Object", Object), wn.serialize = function (t, e) { t = t.toArrayBuffer(); return e && e.push(t), t }, wn.deserialize = function (t) { return new wn(t) }, In("Grid", wn), In("Color", ut), In("Error", Error), In("StylePropertyFunction", Ve), In("StyleExpression", Le, { omit: ["_evaluator"] }), In("ZoomDependentExpression", Oe), In("ZoomConstantExpression", Be), In("CompoundExpression", zt, { omit: ["_evaluate"] }), te) te[Tn]._classRegistryKey || In("Expression_" + Tn, te[Tn]); function kn(t, e) { if (null == t || "boolean" == typeof t || "number" == typeof t || "string" == typeof t || t instanceof Boolean || t instanceof Number || t instanceof String || t instanceof Date || t instanceof RegExp) return t; if (t instanceof ArrayBuffer) return e && e.push(t), t; if (ArrayBuffer.isView(t)) { var n = t; return e && e.push(n.buffer), n } if (t instanceof An) return e && e.push(t.data.buffer), t; if (Array.isArray(t)) { for (var i = [], r = 0, o = t; r < o.length; r += 1) { var a = o[r]; i.push(kn(a, e)) } return i } if ("object" != typeof t) throw new Error("can't serialize object of type " + typeof t); var n = t.constructor, s = n._classRegistryKey; if (!s) throw new Error("can't serialize object of unregistered class"); var l, u = {}; if (n.serialize) u._serialized = n.serialize(t, e); else { for (var c in t) { !t.hasOwnProperty(c) || 0 <= zn[s].omit.indexOf(c) || (l = t[c], u[c] = 0 <= zn[s].shallow.indexOf(c) ? l : kn(l, e)) } t instanceof Error && (u.message = t.message) } return { name: s, properties: u } } function Cn(t) { if (null == t || "boolean" == typeof t || "number" == typeof t || "string" == typeof t || t instanceof Boolean || t instanceof Number || t instanceof String || t instanceof Date || t instanceof RegExp || t instanceof ArrayBuffer || ArrayBuffer.isView(t) || t instanceof An) return t; if (Array.isArray(t)) return t.map(Cn); if ("object" != typeof t) throw new Error("can't deserialize object of type " + typeof t); var e = t.name, n = t.properties; if (!e) throw new Error("can't deserialize object of anonymous class"); t = zn[e].klass; if (!t) throw new Error("can't deserialize unregistered class " + e); if (t.deserialize) return t.deserialize(n._serialized); for (var i = Object.create(t.prototype), r = 0, o = Object.keys(n); r < o.length; r += 1) { var a = o[r]; i[a] = 0 <= zn[e].shallow.indexOf(a) ? n[a] : Cn(n[a]) } return i } function Mn() { this.first = !0 } var Pn = { "Latin-1 Supplement": function (t) { return 128 <= t && t <= 255 }, Arabic: function (t) { return 1536 <= t && t <= 1791 }, "Arabic Supplement": function (t) { return 1872 <= t && t <= 1919 }, "Arabic Extended-A": function (t) { return 2208 <= t && t <= 2303 }, "Hangul Jamo": function (t) { return 4352 <= t && t <= 4607 }, "Unified Canadian Aboriginal Syllabics": function (t) { return 5120 <= t && t <= 5759 }, Khmer: function (t) { return 6016 <= t && t <= 6143 }, "Unified Canadian Aboriginal Syllabics Extended": function (t) { return 6320 <= t && t <= 6399 }, "General Punctuation": function (t) { return 8192 <= t && t <= 8303 }, "Letterlike Symbols": function (t) { return 8448 <= t && t <= 8527 }, "Number Forms": function (t) { return 8528 <= t && t <= 8591 }, "Miscellaneous Technical": function (t) { return 8960 <= t && t <= 9215 }, "Control Pictures": function (t) { return 9216 <= t && t <= 9279 }, "Optical Character Recognition": function (t) { return 9280 <= t && t <= 9311 }, "Enclosed Alphanumerics": function (t) { return 9312 <= t && t <= 9471 }, "Geometric Shapes": function (t) { return 9632 <= t && t <= 9727 }, "Miscellaneous Symbols": function (t) { return 9728 <= t && t <= 9983 }, "Miscellaneous Symbols and Arrows": function (t) { return 11008 <= t && t <= 11263 }, "CJK Radicals Supplement": function (t) { return 11904 <= t && t <= 12031 }, "Kangxi Radicals": function (t) { return 12032 <= t && t <= 12255 }, "Ideographic Description Characters": function (t) { return 12272 <= t && t <= 12287 }, "CJK Symbols and Punctuation": function (t) { return 12288 <= t && t <= 12351 }, Hiragana: function (t) { return 12352 <= t && t <= 12447 }, Katakana: function (t) { return 12448 <= t && t <= 12543 }, Bopomofo: function (t) { return 12544 <= t && t <= 12591 }, "Hangul Compatibility Jamo": function (t) { return 12592 <= t && t <= 12687 }, Kanbun: function (t) { return 12688 <= t && t <= 12703 }, "Bopomofo Extended": function (t) { return 12704 <= t && t <= 12735 }, "CJK Strokes": function (t) { return 12736 <= t && t <= 12783 }, "Katakana Phonetic Extensions": function (t) { return 12784 <= t && t <= 12799 }, "Enclosed CJK Letters and Months": function (t) { return 12800 <= t && t <= 13055 }, "CJK Compatibility": function (t) { return 13056 <= t && t <= 13311 }, "CJK Unified Ideographs Extension A": function (t) { return 13312 <= t && t <= 19903 }, "Yijing Hexagram Symbols": function (t) { return 19904 <= t && t <= 19967 }, "CJK Unified Ideographs": function (t) { return 19968 <= t && t <= 40959 }, "Yi Syllables": function (t) { return 40960 <= t && t <= 42127 }, "Yi Radicals": function (t) { return 42128 <= t && t <= 42191 }, "Hangul Jamo Extended-A": function (t) { return 43360 <= t && t <= 43391 }, "Hangul Syllables": function (t) { return 44032 <= t && t <= 55215 }, "Hangul Jamo Extended-B": function (t) { return 55216 <= t && t <= 55295 }, "Private Use Area": function (t) { return 57344 <= t && t <= 63743 }, "CJK Compatibility Ideographs": function (t) { return 63744 <= t && t <= 64255 }, "Arabic Presentation Forms-A": function (t) { return 64336 <= t && t <= 65023 }, "Vertical Forms": function (t) { return 65040 <= t && t <= 65055 }, "CJK Compatibility Forms": function (t) { return 65072 <= t && t <= 65103 }, "Small Form Variants": function (t) { return 65104 <= t && t <= 65135 }, "Arabic Presentation Forms-B": function (t) { return 65136 <= t && t <= 65279 }, "Halfwidth and Fullwidth Forms": function (t) { return 65280 <= t && t <= 65519 } }; function Ln(t) { for (var e = 0, n = t; e < n.length; e += 1)if (Dn(n[e].charCodeAt(0))) return !0; return !1 } function Dn(t) { return 746 === t || 747 === t || !(t < 4352) && (Pn["Bopomofo Extended"](t) || Pn.Bopomofo(t) || Pn["CJK Compatibility Forms"](t) && !(65097 <= t && t <= 65103) || Pn["CJK Compatibility Ideographs"](t) || Pn["CJK Compatibility"](t) || Pn["CJK Radicals Supplement"](t) || Pn["CJK Strokes"](t) || !(!Pn["CJK Symbols and Punctuation"](t) || 12296 <= t && t <= 12305 || 12308 <= t && t <= 12319 || 12336 === t) || Pn["CJK Unified Ideographs Extension A"](t) || Pn["CJK Unified Ideographs"](t) || Pn["Enclosed CJK Letters and Months"](t) || Pn["Hangul Compatibility Jamo"](t) || Pn["Hangul Jamo Extended-A"](t) || Pn["Hangul Jamo Extended-B"](t) || Pn["Hangul Jamo"](t) || Pn["Hangul Syllables"](t) || Pn.Hiragana(t) || Pn["Ideographic Description Characters"](t) || Pn.Kanbun(t) || Pn["Kangxi Radicals"](t) || Pn["Katakana Phonetic Extensions"](t) || Pn.Katakana(t) && 12540 !== t || !(!Pn["Halfwidth and Fullwidth Forms"](t) || 65288 === t || 65289 === t || 65293 === t || 65306 <= t && t <= 65310 || 65339 === t || 65341 === t || 65343 === t || 65371 <= t && t <= 65503 || 65507 === t || 65512 <= t && t <= 65519) || !(!Pn["Small Form Variants"](t) || 65112 <= t && t <= 65118 || 65123 <= t && t <= 65126) || Pn["Unified Canadian Aboriginal Syllabics"](t) || Pn["Unified Canadian Aboriginal Syllabics Extended"](t) || Pn["Vertical Forms"](t) || Pn["Yijing Hexagram Symbols"](t) || Pn["Yi Syllables"](t) || Pn["Yi Radicals"](t)) } function Rn(t) { return !(Dn(t) || (t = t, Pn["Latin-1 Supplement"](t) && (167 === t || 169 === t || 174 === t || 177 === t || 188 === t || 189 === t || 190 === t || 215 === t || 247 === t) || Pn["General Punctuation"](t) && (8214 === t || 8224 === t || 8225 === t || 8240 === t || 8241 === t || 8251 === t || 8252 === t || 8258 === t || 8263 === t || 8264 === t || 8265 === t || 8273 === t) || Pn["Letterlike Symbols"](t) || Pn["Number Forms"](t) || Pn["Miscellaneous Technical"](t) && (8960 <= t && t <= 8967 || 8972 <= t && t <= 8991 || 8996 <= t && t <= 9e3 || 9003 === t || 9085 <= t && t <= 9114 || 9150 <= t && t <= 9165 || 9167 === t || 9169 <= t && t <= 9179 || 9186 <= t && t <= 9215) || Pn["Control Pictures"](t) && 9251 !== t || Pn["Optical Character Recognition"](t) || Pn["Enclosed Alphanumerics"](t) || Pn["Geometric Shapes"](t) || Pn["Miscellaneous Symbols"](t) && !(9754 <= t && t <= 9759) || Pn["Miscellaneous Symbols and Arrows"](t) && (11026 <= t && t <= 11055 || 11088 <= t && t <= 11097 || 11192 <= t && t <= 11243) || Pn["CJK Symbols and Punctuation"](t) || Pn.Katakana(t) || Pn["Private Use Area"](t) || Pn["CJK Compatibility Forms"](t) || Pn["Small Form Variants"](t) || Pn["Halfwidth and Fullwidth Forms"](t) || 8734 === t || 8756 === t || 8757 === t || 9984 <= t && t <= 10087 || 10102 <= t && t <= 10131 || 65532 === t || 65533 === t)) } function Bn(t, e) { this.zoom = t, e ? (this.now = e.now, this.fadeDuration = e.fadeDuration, this.zoomHistory = e.zoomHistory, this.transition = e.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new Mn, this.transition = {}) } var On, Fn = !(Mn.prototype.update = function (t, e) { var n = Math.floor(t); return this.first ? (this.first = !1, this.lastIntegerZoom = n, this.lastIntegerZoomTime = 0, this.lastZoom = t, this.lastFloorZoom = n, !0) : (this.lastFloorZoom > n ? (this.lastIntegerZoom = n + 1, this.lastIntegerZoomTime = e) : this.lastFloorZoom < n && (this.lastIntegerZoom = n, this.lastIntegerZoomTime = e), t !== this.lastZoom && (this.lastZoom = t, this.lastFloorZoom = n, !0)) }), Vn = null, Nn = !1, jn = new R, Un = { applyArabicShaping: null, processBidirectionalText: null, processStyledBidirectionalText: null, isLoaded: function () { return Nn || null != Un.applyArabicShaping } }; Bn.prototype.isSupportedScript = function (t) { return function (t, e) { for (var n, i = 0, r = t; i < r.length; i += 1)if (n = r[i].charCodeAt(0), !e && (1424 <= n && n <= 2303 || Pn["Arabic Presentation Forms-A"](n) || Pn["Arabic Presentation Forms-B"](n)) || (2304 <= n && n <= 3583 || 3840 <= n && n <= 4255 || Pn.Khmer(n))) return !1; return !0 }(t, Un.isLoaded()) }, Bn.prototype.crossFadingFactor = function () { return 0 === this.fadeDuration ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1) }; function qn(t, e) { this.property = t, this.value = e, this.expression = Ne(void 0 === e ? t.specification.default : e, t.specification) } qn.prototype.isDataDriven = function () { return "source" === this.expression.kind || "composite" === this.expression.kind }, qn.prototype.possiblyEvaluate = function (t) { return this.property.possiblyEvaluate(this, t) }; function Zn(t) { this.property = t, this.value = new qn(t, void 0) } Zn.prototype.transitioned = function (t, e) { return new Xn(this.property, this.value, e, c({}, t.transition, this.transition), t.now) }, Zn.prototype.untransitioned = function () { return new Xn(this.property, this.value, null, {}, 0) }; function Gn(t) { this._properties = t, this._values = Object.create(t.defaultTransitionablePropertyValues) } Gn.prototype.getValue = function (t) { return v(this._values[t].value.value) }, Gn.prototype.setValue = function (t, e) { this._values.hasOwnProperty(t) || (this._values[t] = new Zn(this._values[t].property)), this._values[t].value = new qn(this._values[t].property, null === e ? void 0 : v(e)) }, Gn.prototype.getTransition = function (t) { return v(this._values[t].transition) }, Gn.prototype.setTransition = function (t, e) { this._values.hasOwnProperty(t) || (this._values[t] = new Zn(this._values[t].property)), this._values[t].transition = v(e) || void 0 }, Gn.prototype.serialize = function () { for (var t = {}, e = 0, n = Object.keys(this._values); e < n.length; e += 1) { var i = n[e], r = this.getValue(i); void 0 !== r && (t[i] = r); r = this.getTransition(i); void 0 !== r && (t[i + "-transition"] = r) } return t }, Gn.prototype.transitioned = function (t, e) { for (var n = new Wn(this._properties), i = 0, r = Object.keys(this._values); i < r.length; i += 1) { var o = r[i]; n._values[o] = this._values[o].transitioned(t, e._values[o]) } return n }, Gn.prototype.untransitioned = function () { for (var t = new Wn(this._properties), e = 0, n = Object.keys(this._values); e < n.length; e += 1) { var i = n[e]; t._values[i] = this._values[i].untransitioned() } return t }; var Xn = function (t, e, n, i, r) { this.property = t, this.value = e, this.begin = r + i.delay || 0, this.end = this.begin + i.duration || 0, t.specification.transition && (i.delay || i.duration) && (this.prior = n) }; Xn.prototype.possiblyEvaluate = function (t) { var e = t.now || 0, n = this.value.possiblyEvaluate(t), i = this.prior; if (i) { if (e > this.end) return this.prior = null, n; if (this.value.isDataDriven()) return this.prior = null, n; if (e < this.begin) return i.possiblyEvaluate(t); var r = (e - this.begin) / (this.end - this.begin); return this.property.interpolate(i.possiblyEvaluate(t), n, function () { if (r <= 0) return 0; if (1 <= r) return 1; var t = r * r, e = t * r; return 4 * (r < .5 ? e : 3 * (r - t) + e - .75) }()) } return n }; var Wn = function (t) { this._properties = t, this._values = Object.create(t.defaultTransitioningPropertyValues) }; Wn.prototype.possiblyEvaluate = function (t) { for (var e = new Jn(this._properties), n = 0, i = Object.keys(this._values); n < i.length; n += 1) { var r = i[n]; e._values[r] = this._values[r].possiblyEvaluate(t) } return e }, Wn.prototype.hasTransition = function () { for (var t = 0, e = Object.keys(this._values); t < e.length; t += 1) { var n = e[t]; if (this._values[n].prior) return !0 } return !1 }; function Hn(t) { this._properties = t, this._values = Object.create(t.defaultPropertyValues) } Hn.prototype.getValue = function (t) { return v(this._values[t].value) }, Hn.prototype.setValue = function (t, e) { this._values[t] = new qn(this._values[t].property, null === e ? void 0 : v(e)) }, Hn.prototype.serialize = function () { for (var t = {}, e = 0, n = Object.keys(this._values); e < n.length; e += 1) { var i = n[e], r = this.getValue(i); void 0 !== r && (t[i] = r) } return t }, Hn.prototype.possiblyEvaluate = function (t) { for (var e = new Jn(this._properties), n = 0, i = Object.keys(this._values); n < i.length; n += 1) { var r = i[n]; e._values[r] = this._values[r].possiblyEvaluate(t) } return e }; function Kn(t, e, n) { this.property = t, this.value = e, this.globals = n } Kn.prototype.isConstant = function () { return "constant" === this.value.kind }, Kn.prototype.constantOr = function (t) { return "constant" === this.value.kind ? this.value.value : t }, Kn.prototype.evaluate = function (t, e) { return this.property.evaluate(this.value, this.globals, t, e) }; var Jn = function (t) { this._properties = t, this._values = Object.create(t.defaultPossiblyEvaluatedValues) }; Jn.prototype.get = function (t) { return this._values[t] }; function Yn(t) { this.specification = t } Yn.prototype.possiblyEvaluate = function (t, e) { return t.expression.evaluate(e) }, Yn.prototype.interpolate = function (t, e, n) { var i = Bt[this.specification.type]; return i ? i(t, e, n) : t }; function $n(t) { this.specification = t } $n.prototype.possiblyEvaluate = function (t, e) { return "constant" === t.expression.kind || "camera" === t.expression.kind ? new Kn(this, { kind: "constant", value: t.expression.evaluate(e) }, e) : new Kn(this, t.expression, e) }, $n.prototype.interpolate = function (t, e, n) { if ("constant" !== t.value.kind || "constant" !== e.value.kind) return t; if (void 0 === t.value.value || void 0 === e.value.value) return new Kn(this, { kind: "constant", value: void 0 }, t.globals); var i = Bt[this.specification.type]; return i ? new Kn(this, { kind: "constant", value: i(t.value.value, e.value.value, n) }, t.globals) : t }, $n.prototype.evaluate = function (t, e, n, i) { return "constant" === t.kind ? t.value : t.evaluate(e, n, i) }; var Qn = function (t) { this.specification = t }; Qn.prototype.possiblyEvaluate = function (t, e) { if (void 0 !== t.value) { if ("constant" !== t.expression.kind) return this._calculate(t.expression.evaluate(new Bn(Math.floor(e.zoom - 1), e)), t.expression.evaluate(new Bn(Math.floor(e.zoom), e)), t.expression.evaluate(new Bn(Math.floor(e.zoom + 1), e)), e); t = t.expression.evaluate(e); return this._calculate(t, t, t, e) } }, Qn.prototype._calculate = function (t, e, n, i) { var r = i.zoom, o = r - Math.floor(r), a = i.crossFadingFactor(); return r > i.zoomHistory.lastIntegerZoom ? { from: t, to: e, fromScale: 2, toScale: 1, t: o + (1 - o) * a } : { from: n, to: e, fromScale: .5, toScale: 1, t: 1 - (1 - a) * o } }, Qn.prototype.interpolate = function (t) { return t }; var ti = function (t) { this.specification = t }; ti.prototype.possiblyEvaluate = function (t, e) { return !!t.expression.evaluate(e) }, ti.prototype.interpolate = function () { return !1 }; function ei(t) { for (var e in this.properties = t, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, t) { var n = t[e], i = this.defaultPropertyValues[e] = new qn(n, void 0), n = this.defaultTransitionablePropertyValues[e] = new Zn(n); this.defaultTransitioningPropertyValues[e] = n.untransitioned(), this.defaultPossiblyEvaluatedValues[e] = i.possiblyEvaluate({}) } } In("DataDrivenProperty", $n), In("DataConstantProperty", Yn), In("CrossFadedProperty", Qn), In("ColorRampProperty", ti); var ni, ii = ((ni = R) && (ai.__proto__ = ni), ((ai.prototype = Object.create(ni && ni.prototype)).constructor = ai).prototype.getLayoutProperty = function (t) { return "visibility" === t ? this.visibility : this._unevaluatedLayout.getValue(t) }, ai.prototype.setLayoutProperty = function (t, e, n) { if (null != e) { var i = "layers." + this.id + ".layout." + t; if (this._validate(xn, i, t, e, n)) return } "visibility" !== t ? this._unevaluatedLayout.setValue(t, e) : this.visibility = "none" === e ? e : "visible" }, ai.prototype.getPaintProperty = function (t) { return m(t, "-transition") ? this._transitionablePaint.getTransition(t.slice(0, -"-transition".length)) : this._transitionablePaint.getValue(t) }, ai.prototype.setPaintProperty = function (t, e, n) { if (null != e) { var i = "layers." + this.id + ".paint." + t; if (this._validate(_n, i, t, e, n)) return !1 } if (m(t, "-transition")) return this._transitionablePaint.setTransition(t.slice(0, -"-transition".length), e || void 0), !1; n = this._transitionablePaint._values[t].value.isDataDriven(); this._transitionablePaint.setValue(t, e); e = this._transitionablePaint._values[t].value.isDataDriven(); return this._handleSpecialPaintPropertyUpdate(t), e || n }, ai.prototype._handleSpecialPaintPropertyUpdate = function (t) { }, ai.prototype.isHidden = function (t) { return !!(this.minzoom && t < this.minzoom) || !!(this.maxzoom && t >= this.maxzoom) || "none" === this.visibility }, ai.prototype.updateTransitions = function (t) { this._transitioningPaint = this._transitionablePaint.transitioned(t, this._transitioningPaint) }, ai.prototype.hasTransition = function () { return this._transitioningPaint.hasTransition() }, ai.prototype.recalculate = function (t) { this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t)), this.paint = this._transitioningPaint.possiblyEvaluate(t) }, ai.prototype.serialize = function () { var t = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() }; return "none" === this.visibility && (t.layout = t.layout || {}, t.layout.visibility = "none"), g(t, function (t, e) { return !(void 0 === t || "layout" === e && !Object.keys(t).length || "paint" === e && !Object.keys(t).length) }) }, ai.prototype._validate = function (t, e, n, i, r) { return (!r || !1 !== r.validate) && bn(this, t.call(gn, { key: e, layerType: this.type, objectKey: n, value: i, styleSpec: V, style: { glyphs: !0, sprite: !0 } })) }, ai.prototype.hasOffscreenPass = function () { return !1 }, ai.prototype.resize = function () { }, ai.prototype.isStateDependent = function () { for (var t in this.paint._values) { var e = this.paint.get(t); if (e instanceof Kn && ae(e.property.specification) && ("source" === e.value.kind || "composite" === e.value.kind) && e.value.isStateDependent) return !0 } return !1 }, ai), ri = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array }, w = function (t, e) { this._structArray = t, this._pos1 = e * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8 }, oi = function () { this.isTransferred = !1, this.capacity = -1, this.resize(0) }; function ai(t, e) { for (var n in ni.call(this), this.id = t.id, this.metadata = t.metadata, this.type = t.type, this.minzoom = t.minzoom, this.maxzoom = t.maxzoom, this.visibility = "visible", "background" !== t.type && (this.source = t.source, this.sourceLayer = t["source-layer"], this.filter = t.filter), this._featureFilter = function () { return !0 }, e.layout && (this._unevaluatedLayout = new Hn(e.layout)), this._transitionablePaint = new Gn(e.paint), t.paint) this.setPaintProperty(n, t.paint[n], { validate: !1 }); for (var i in t.layout) this.setLayoutProperty(i, t.layout[i], { validate: !1 }); this._transitioningPaint = this._transitionablePaint.untransitioned() } function si(t, r) { void 0 === r && (r = 1); var o = 0, a = 0; return { members: t.map(function (t) { var e = (i = t.type, ri[i].BYTES_PER_ELEMENT), n = o = li(o, Math.max(r, e)), i = t.components || 1; return a = Math.max(a, e), o += e * i, { name: t.name, type: t.type, components: i, offset: n } }), size: li(o, Math.max(a, r)), alignment: r } } function li(t, e) { return Math.ceil(t / e) * e } oi.serialize = function (t, e) { return t._trim(), e && (t.isTransferred = !0, e.push(t.arrayBuffer)), { length: t.length, arrayBuffer: t.arrayBuffer } }, oi.deserialize = function (t) { var e = Object.create(this.prototype); return e.arrayBuffer = t.arrayBuffer, e.length = t.length, e.capacity = t.arrayBuffer.byteLength / e.bytesPerElement, e._refreshViews(), e }, oi.prototype._trim = function () { this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews()) }, oi.prototype.clear = function () { this.length = 0 }, oi.prototype.resize = function (t) { this.reserve(t), this.length = t }, oi.prototype.reserve = function (t) { t > this.capacity && (this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement), t = this.uint8, this._refreshViews(), t && this.uint8.set(t)) }, oi.prototype._refreshViews = function () { throw new Error("_refreshViews() must be implemented by each concrete StructArray layout") }; var ui, ci = ((ui = oi) && (hi.__proto__ = ui), ((hi.prototype = Object.create(ui && ui.prototype)).constructor = hi).prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer) }, hi.prototype.emplaceBack = function (t, e) { var n = this.length; this.resize(n + 1); var i = 2 * n; return this.int16[0 + i] = t, this.int16[1 + i] = e, n }, hi.prototype.emplace = function (t, e, n) { var i = 2 * t; return this.int16[0 + i] = e, this.int16[1 + i] = n, t }, hi); function hi() { ui.apply(this, arguments) } ci.prototype.bytesPerElement = 4, In("StructArrayLayout2i4", ci); var pi, fi = ((pi = oi) && (di.__proto__ = pi), ((di.prototype = Object.create(pi && pi.prototype)).constructor = di).prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer) }, di.prototype.emplaceBack = function (t, e, n, i) { var r = this.length; this.resize(r + 1); var o = 4 * r; return this.int16[0 + o] = t, this.int16[1 + o] = e, this.int16[2 + o] = n, this.int16[3 + o] = i, r }, di.prototype.emplace = function (t, e, n, i, r) { var o = 4 * t; return this.int16[0 + o] = e, this.int16[1 + o] = n, this.int16[2 + o] = i, this.int16[3 + o] = r, t }, di); function di() { pi.apply(this, arguments) } fi.prototype.bytesPerElement = 8, In("StructArrayLayout4i8", fi); var mi, yi = ((mi = oi) && (gi.__proto__ = mi), ((gi.prototype = Object.create(mi && mi.prototype)).constructor = gi).prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer) }, gi.prototype.emplaceBack = function (t, e, n, i, r, o) { var a = this.length; this.resize(a + 1); var s = 6 * a; return this.int16[0 + s] = t, this.int16[1 + s] = e, this.int16[2 + s] = n, this.int16[3 + s] = i, this.int16[4 + s] = r, this.int16[5 + s] = o, a }, gi.prototype.emplace = function (t, e, n, i, r, o, a) { var s = 6 * t; return this.int16[0 + s] = e, this.int16[1 + s] = n, this.int16[2 + s] = i, this.int16[3 + s] = r, this.int16[4 + s] = o, this.int16[5 + s] = a, t }, gi); function gi() { mi.apply(this, arguments) } yi.prototype.bytesPerElement = 12, In("StructArrayLayout2i4i12", yi); var vi, _i = ((vi = oi) && (xi.__proto__ = vi), ((xi.prototype = Object.create(vi && vi.prototype)).constructor = xi).prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer) }, xi.prototype.emplaceBack = function (t, e, n, i, r, o, a, s) { var l = this.length; this.resize(l + 1); var u = 6 * l, c = 12 * l; return this.int16[0 + u] = t, this.int16[1 + u] = e, this.int16[2 + u] = n, this.int16[3 + u] = i, this.uint8[8 + c] = r, this.uint8[9 + c] = o, this.uint8[10 + c] = a, this.uint8[11 + c] = s, l }, xi.prototype.emplace = function (t, e, n, i, r, o, a, s, l) { var u = 6 * t, c = 12 * t; return this.int16[0 + u] = e, this.int16[1 + u] = n, this.int16[2 + u] = i, this.int16[3 + u] = r, this.uint8[8 + c] = o, this.uint8[9 + c] = a, this.uint8[10 + c] = s, this.uint8[11 + c] = l, t }, xi); function xi() { vi.apply(this, arguments) } _i.prototype.bytesPerElement = 12, In("StructArrayLayout4i4ub12", _i); var bi, wi = ((bi = oi) && (Ei.__proto__ = bi), ((Ei.prototype = Object.create(bi && bi.prototype)).constructor = Ei).prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer) }, Ei.prototype.emplaceBack = function (t, e, n, i, r, o, a, s) { var l = this.length; this.resize(l + 1); var u = 8 * l; return this.int16[0 + u] = t, this.int16[1 + u] = e, this.int16[2 + u] = n, this.int16[3 + u] = i, this.uint16[4 + u] = r, this.uint16[5 + u] = o, this.uint16[6 + u] = a, this.uint16[7 + u] = s, l }, Ei.prototype.emplace = function (t, e, n, i, r, o, a, s, l) { var u = 8 * t; return this.int16[0 + u] = e, this.int16[1 + u] = n, this.int16[2 + u] = i, this.int16[3 + u] = r, this.uint16[4 + u] = o, this.uint16[5 + u] = a, this.uint16[6 + u] = s, this.uint16[7 + u] = l, t }, Ei); function Ei() { bi.apply(this, arguments) } wi.prototype.bytesPerElement = 16, In("StructArrayLayout4i4ui16", wi); var Si, Ti = ((Si = oi) && (Ai.__proto__ = Si), ((Ai.prototype = Object.create(Si && Si.prototype)).constructor = Ai).prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer) }, Ai.prototype.emplaceBack = function (t, e, n) { var i = this.length; this.resize(i + 1); var r = 3 * i; return this.float32[0 + r] = t, this.float32[1 + r] = e, this.float32[2 + r] = n, i }, Ai.prototype.emplace = function (t, e, n, i) { var r = 3 * t; return this.float32[0 + r] = e, this.float32[1 + r] = n, this.float32[2 + r] = i, t }, Ai); function Ai() { Si.apply(this, arguments) } Ti.prototype.bytesPerElement = 12, In("StructArrayLayout3f12", Ti); var zi, Ii = ((zi = oi) && (ki.__proto__ = zi), ((ki.prototype = Object.create(zi && zi.prototype)).constructor = ki).prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer) }, ki.prototype.emplaceBack = function (t) { var e = this.length; this.resize(e + 1); var n = +e; return this.uint32[0 + n] = t, e }, ki.prototype.emplace = function (t, e) { var n = +t; return this.uint32[0 + n] = e, t }, ki); function ki() { zi.apply(this, arguments) } Ii.prototype.bytesPerElement = 4, In("StructArrayLayout1ul4", Ii); var Ci, Ht = ((Ci = oi) && (Mi.__proto__ = Ci), ((Mi.prototype = Object.create(Ci && Ci.prototype)).constructor = Mi).prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer) }, Mi.prototype.emplaceBack = function (t, e, n, i, r, o, a, s, l, u, c) { var h = this.length; this.resize(h + 1); var p = 12 * h, f = 6 * h; return this.int16[0 + p] = t, this.int16[1 + p] = e, this.int16[2 + p] = n, this.int16[3 + p] = i, this.int16[4 + p] = r, this.int16[5 + p] = o, this.uint32[3 + f] = a, this.uint16[8 + p] = s, this.uint16[9 + p] = l, this.int16[10 + p] = u, this.int16[11 + p] = c, h }, Mi.prototype.emplace = function (t, e, n, i, r, o, a, s, l, u, c, h) { var p = 12 * t, f = 6 * t; return this.int16[0 + p] = e, this.int16[1 + p] = n, this.int16[2 + p] = i, this.int16[3 + p] = r, this.int16[4 + p] = o, this.int16[5 + p] = a, this.uint32[3 + f] = s, this.uint16[8 + p] = l, this.uint16[9 + p] = u, this.int16[10 + p] = c, this.int16[11 + p] = h, t }, Mi); function Mi() { Ci.apply(this, arguments) } Ht.prototype.bytesPerElement = 24, In("StructArrayLayout6i1ul2ui2i24", Ht); var Pi, Li = ((Pi = oi) && (Di.__proto__ = Pi), ((Di.prototype = Object.create(Pi && Pi.prototype)).constructor = Di).prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer) }, Di.prototype.emplaceBack = function (t, e, n, i, r, o) { var a = this.length; this.resize(a + 1); var s = 6 * a; return this.int16[0 + s] = t, this.int16[1 + s] = e, this.int16[2 + s] = n, this.int16[3 + s] = i, this.int16[4 + s] = r, this.int16[5 + s] = o, a }, Di.prototype.emplace = function (t, e, n, i, r, o, a) { var s = 6 * t; return this.int16[0 + s] = e, this.int16[1 + s] = n, this.int16[2 + s] = i, this.int16[3 + s] = r, this.int16[4 + s] = o, this.int16[5 + s] = a, t }, Di); function Di() { Pi.apply(this, arguments) } Li.prototype.bytesPerElement = 12, In("StructArrayLayout2i2i2i12", Li); var Ri, Bi = ((Ri = oi) && (Oi.__proto__ = Ri), ((Oi.prototype = Object.create(Ri && Ri.prototype)).constructor = Oi).prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer) }, Oi.prototype.emplaceBack = function (t, e) { var n = this.length; this.resize(n + 1); var i = 4 * n; return this.uint8[0 + i] = t, this.uint8[1 + i] = e, n }, Oi.prototype.emplace = function (t, e, n) { var i = 4 * t; return this.uint8[0 + i] = e, this.uint8[1 + i] = n, t }, Oi); function Oi() { Ri.apply(this, arguments) } Bi.prototype.bytesPerElement = 4, In("StructArrayLayout2ub4", Bi); var Fi, Kt = ((Fi = oi) && (Vi.__proto__ = Fi), ((Vi.prototype = Object.create(Fi && Fi.prototype)).constructor = Vi).prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer) }, Vi.prototype.emplaceBack = function (t, e, n, i, r, o, a, s, l, u, c, h, p, f) { var d = this.length; this.resize(d + 1); var m = 20 * d, y = 10 * d, g = 40 * d; return this.int16[0 + m] = t, this.int16[1 + m] = e, this.uint16[2 + m] = n, this.uint16[3 + m] = i, this.uint32[2 + y] = r, this.uint32[3 + y] = o, this.uint32[4 + y] = a, this.uint16[10 + m] = s, this.uint16[11 + m] = l, this.uint16[12 + m] = u, this.float32[7 + y] = c, this.float32[8 + y] = h, this.uint8[36 + g] = p, this.uint8[37 + g] = f, d }, Vi.prototype.emplace = function (t, e, n, i, r, o, a, s, l, u, c, h, p, f, d) { var m = 20 * t, y = 10 * t, g = 40 * t; return this.int16[0 + m] = e, this.int16[1 + m] = n, this.uint16[2 + m] = i, this.uint16[3 + m] = r, this.uint32[2 + y] = o, this.uint32[3 + y] = a, this.uint32[4 + y] = s, this.uint16[10 + m] = l, this.uint16[11 + m] = u, this.uint16[12 + m] = c, this.float32[7 + y] = h, this.float32[8 + y] = p, this.uint8[36 + g] = f, this.uint8[37 + g] = d, t }, Vi); function Vi() { Fi.apply(this, arguments) } Kt.prototype.bytesPerElement = 40, In("StructArrayLayout2i2ui3ul3ui2f2ub40", Kt); var Ni, ji = ((Ni = oi) && (Ui.__proto__ = Ni), ((Ui.prototype = Object.create(Ni && Ni.prototype)).constructor = Ui).prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer) }, Ui.prototype.emplaceBack = function (t) { var e = this.length; this.resize(e + 1); var n = +e; return this.float32[0 + n] = t, e }, Ui.prototype.emplace = function (t, e) { var n = +t; return this.float32[0 + n] = e, t }, Ui); function Ui() { Ni.apply(this, arguments) } ji.prototype.bytesPerElement = 4, In("StructArrayLayout1f4", ji); var qi, Yt = ((qi = oi) && (Zi.__proto__ = qi), ((Zi.prototype = Object.create(qi && qi.prototype)).constructor = Zi).prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer) }, Zi.prototype.emplaceBack = function (t, e, n) { var i = this.length; this.resize(i + 1); var r = 3 * i; return this.int16[0 + r] = t, this.int16[1 + r] = e, this.int16[2 + r] = n, i }, Zi.prototype.emplace = function (t, e, n, i) { var r = 3 * t; return this.int16[0 + r] = e, this.int16[1 + r] = n, this.int16[2 + r] = i, t }, Zi); function Zi() { qi.apply(this, arguments) } Yt.prototype.bytesPerElement = 6, In("StructArrayLayout3i6", Yt); var Gi, Jt = ((Gi = oi) && (Xi.__proto__ = Gi), ((Xi.prototype = Object.create(Gi && Gi.prototype)).constructor = Xi).prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer) }, Xi.prototype.emplaceBack = function (t, e, n) { var i = this.length; this.resize(i + 1); var r = 2 * i, o = 4 * i; return this.uint32[0 + r] = t, this.uint16[2 + o] = e, this.uint16[3 + o] = n, i }, Xi.prototype.emplace = function (t, e, n, i) { var r = 2 * t, o = 4 * t; return this.uint32[0 + r] = e, this.uint16[2 + o] = n, this.uint16[3 + o] = i, t }, Xi); function Xi() { Gi.apply(this, arguments) } Jt.prototype.bytesPerElement = 8, In("StructArrayLayout1ul2ui8", Jt); var Wi, Hi = ((Wi = oi) && (Ki.__proto__ = Wi), ((Ki.prototype = Object.create(Wi && Wi.prototype)).constructor = Ki).prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer) }, Ki.prototype.emplaceBack = function (t, e, n) { var i = this.length; this.resize(i + 1); var r = 3 * i; return this.uint16[0 + r] = t, this.uint16[1 + r] = e, this.uint16[2 + r] = n, i }, Ki.prototype.emplace = function (t, e, n, i) { var r = 3 * t; return this.uint16[0 + r] = e, this.uint16[1 + r] = n, this.uint16[2 + r] = i, t }, Ki); function Ki() { Wi.apply(this, arguments) } Hi.prototype.bytesPerElement = 6, In("StructArrayLayout3ui6", Hi); var Ji, Yi = ((Ji = oi) && ($i.__proto__ = Ji), (($i.prototype = Object.create(Ji && Ji.prototype)).constructor = $i).prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer) }, $i.prototype.emplaceBack = function (t, e) { var n = this.length; this.resize(n + 1); var i = 2 * n; return this.uint16[0 + i] = t, this.uint16[1 + i] = e, n }, $i.prototype.emplace = function (t, e, n) { var i = 2 * t; return this.uint16[0 + i] = e, this.uint16[1 + i] = n, t }, $i); function $i() { Ji.apply(this, arguments) } Yi.prototype.bytesPerElement = 4, In("StructArrayLayout2ui4", Yi); var Qi, tr = ((Qi = oi) && (er.__proto__ = Qi), ((er.prototype = Object.create(Qi && Qi.prototype)).constructor = er).prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer) }, er.prototype.emplaceBack = function (t, e) { var n = this.length; this.resize(n + 1); var i = 2 * n; return this.float32[0 + i] = t, this.float32[1 + i] = e, n }, er.prototype.emplace = function (t, e, n) { var i = 2 * t; return this.float32[0 + i] = e, this.float32[1 + i] = n, t }, er); function er() { Qi.apply(this, arguments) } tr.prototype.bytesPerElement = 8, In("StructArrayLayout2f8", tr); var nr, ir = ((nr = oi) && (rr.__proto__ = nr), ((rr.prototype = Object.create(nr && nr.prototype)).constructor = rr).prototype._refreshViews = function () { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer) }, rr.prototype.emplaceBack = function (t, e, n, i) { var r = this.length; this.resize(r + 1); var o = 4 * r; return this.float32[0 + o] = t, this.float32[1 + o] = e, this.float32[2 + o] = n, this.float32[3 + o] = i, r }, rr.prototype.emplace = function (t, e, n, i, r) { var o = 4 * t; return this.float32[0 + o] = e, this.float32[1 + o] = n, this.float32[2 + o] = i, this.float32[3 + o] = r, t }, rr); function rr() { nr.apply(this, arguments) } ir.prototype.bytesPerElement = 16, In("StructArrayLayout4f16", ir); var or = function (t) { function e() { t.apply(this, arguments) } t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e; var n = { anchorPointX: { configurable: !0 }, anchorPointY: { configurable: !0 }, x1: { configurable: !0 }, y1: { configurable: !0 }, x2: { configurable: !0 }, y2: { configurable: !0 }, featureIndex: { configurable: !0 }, sourceLayerIndex: { configurable: !0 }, bucketIndex: { configurable: !0 }, radius: { configurable: !0 }, signedDistanceFromAnchor: { configurable: !0 }, anchorPoint: { configurable: !0 } }; return n.anchorPointX.get = function () { return this._structArray.int16[this._pos2 + 0] }, n.anchorPointX.set = function (t) { this._structArray.int16[this._pos2 + 0] = t }, n.anchorPointY.get = function () { return this._structArray.int16[this._pos2 + 1] }, n.anchorPointY.set = function (t) { this._structArray.int16[this._pos2 + 1] = t }, n.x1.get = function () { return this._structArray.int16[this._pos2 + 2] }, n.x1.set = function (t) { this._structArray.int16[this._pos2 + 2] = t }, n.y1.get = function () { return this._structArray.int16[this._pos2 + 3] }, n.y1.set = function (t) { this._structArray.int16[this._pos2 + 3] = t }, n.x2.get = function () { return this._structArray.int16[this._pos2 + 4] }, n.x2.set = function (t) { this._structArray.int16[this._pos2 + 4] = t }, n.y2.get = function () { return this._structArray.int16[this._pos2 + 5] }, n.y2.set = function (t) { this._structArray.int16[this._pos2 + 5] = t }, n.featureIndex.get = function () { return this._structArray.uint32[this._pos4 + 3] }, n.featureIndex.set = function (t) { this._structArray.uint32[this._pos4 + 3] = t }, n.sourceLayerIndex.get = function () { return this._structArray.uint16[this._pos2 + 8] }, n.sourceLayerIndex.set = function (t) { this._structArray.uint16[this._pos2 + 8] = t }, n.bucketIndex.get = function () { return this._structArray.uint16[this._pos2 + 9] }, n.bucketIndex.set = function (t) { this._structArray.uint16[this._pos2 + 9] = t }, n.radius.get = function () { return this._structArray.int16[this._pos2 + 10] }, n.radius.set = function (t) { this._structArray.int16[this._pos2 + 10] = t }, n.signedDistanceFromAnchor.get = function () { return this._structArray.int16[this._pos2 + 11] }, n.signedDistanceFromAnchor.set = function (t) { this._structArray.int16[this._pos2 + 11] = t }, n.anchorPoint.get = function () { return new p(this.anchorPointX, this.anchorPointY) }, Object.defineProperties(e.prototype, n), e }(w); or.prototype.size = 24; var ar, sr = ((ar = Ht) && (lr.__proto__ = ar), ((lr.prototype = Object.create(ar && ar.prototype)).constructor = lr).prototype.get = function (t) { return new or(this, t) }, lr); function lr() { ar.apply(this, arguments) } In("CollisionBoxArray", sr); var ur = function (t) { function e() { t.apply(this, arguments) } t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e; var n = { anchorX: { configurable: !0 }, anchorY: { configurable: !0 }, glyphStartIndex: { configurable: !0 }, numGlyphs: { configurable: !0 }, vertexStartIndex: { configurable: !0 }, lineStartIndex: { configurable: !0 }, lineLength: { configurable: !0 }, segment: { configurable: !0 }, lowerSize: { configurable: !0 }, upperSize: { configurable: !0 }, lineOffsetX: { configurable: !0 }, lineOffsetY: { configurable: !0 }, writingMode: { configurable: !0 }, hidden: { configurable: !0 } }; return n.anchorX.get = function () { return this._structArray.int16[this._pos2 + 0] }, n.anchorX.set = function (t) { this._structArray.int16[this._pos2 + 0] = t }, n.anchorY.get = function () { return this._structArray.int16[this._pos2 + 1] }, n.anchorY.set = function (t) { this._structArray.int16[this._pos2 + 1] = t }, n.glyphStartIndex.get = function () { return this._structArray.uint16[this._pos2 + 2] }, n.glyphStartIndex.set = function (t) { this._structArray.uint16[this._pos2 + 2] = t }, n.numGlyphs.get = function () { return this._structArray.uint16[this._pos2 + 3] }, n.numGlyphs.set = function (t) { this._structArray.uint16[this._pos2 + 3] = t }, n.vertexStartIndex.get = function () { return this._structArray.uint32[this._pos4 + 2] }, n.vertexStartIndex.set = function (t) { this._structArray.uint32[this._pos4 + 2] = t }, n.lineStartIndex.get = function () { return this._structArray.uint32[this._pos4 + 3] }, n.lineStartIndex.set = function (t) { this._structArray.uint32[this._pos4 + 3] = t }, n.lineLength.get = function () { return this._structArray.uint32[this._pos4 + 4] }, n.lineLength.set = function (t) { this._structArray.uint32[this._pos4 + 4] = t }, n.segment.get = function () { return this._structArray.uint16[this._pos2 + 10] }, n.segment.set = function (t) { this._structArray.uint16[this._pos2 + 10] = t }, n.lowerSize.get = function () { return this._structArray.uint16[this._pos2 + 11] }, n.lowerSize.set = function (t) { this._structArray.uint16[this._pos2 + 11] = t }, n.upperSize.get = function () { return this._structArray.uint16[this._pos2 + 12] }, n.upperSize.set = function (t) { this._structArray.uint16[this._pos2 + 12] = t }, n.lineOffsetX.get = function () { return this._structArray.float32[this._pos4 + 7] }, n.lineOffsetX.set = function (t) { this._structArray.float32[this._pos4 + 7] = t }, n.lineOffsetY.get = function () { return this._structArray.float32[this._pos4 + 8] }, n.lineOffsetY.set = function (t) { this._structArray.float32[this._pos4 + 8] = t }, n.writingMode.get = function () { return this._structArray.uint8[this._pos1 + 36] }, n.writingMode.set = function (t) { this._structArray.uint8[this._pos1 + 36] = t }, n.hidden.get = function () { return this._structArray.uint8[this._pos1 + 37] }, n.hidden.set = function (t) { this._structArray.uint8[this._pos1 + 37] = t }, Object.defineProperties(e.prototype, n), e }(w); ur.prototype.size = 40; var cr, hr = ((cr = Kt) && (pr.__proto__ = cr), ((pr.prototype = Object.create(cr && cr.prototype)).constructor = pr).prototype.get = function (t) { return new ur(this, t) }, pr); function pr() { cr.apply(this, arguments) } In("PlacedSymbolArray", hr); var fr = function (t) { function e() { t.apply(this, arguments) } t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e; var n = { offsetX: { configurable: !0 } }; return n.offsetX.get = function () { return this._structArray.float32[this._pos4 + 0] }, n.offsetX.set = function (t) { this._structArray.float32[this._pos4 + 0] = t }, Object.defineProperties(e.prototype, n), e }(w); fr.prototype.size = 4; var dr, mr = ((dr = ji) && (yr.__proto__ = dr), ((yr.prototype = Object.create(dr && dr.prototype)).constructor = yr).prototype.getoffsetX = function (t) { return this.float32[+t + 0] }, yr.prototype.get = function (t) { return new fr(this, t) }, yr); function yr() { dr.apply(this, arguments) } In("GlyphOffsetArray", mr); var gr = function (t) { function e() { t.apply(this, arguments) } t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e; var n = { x: { configurable: !0 }, y: { configurable: !0 }, tileUnitDistanceFromAnchor: { configurable: !0 } }; return n.x.get = function () { return this._structArray.int16[this._pos2 + 0] }, n.x.set = function (t) { this._structArray.int16[this._pos2 + 0] = t }, n.y.get = function () { return this._structArray.int16[this._pos2 + 1] }, n.y.set = function (t) { this._structArray.int16[this._pos2 + 1] = t }, n.tileUnitDistanceFromAnchor.get = function () { return this._structArray.int16[this._pos2 + 2] }, n.tileUnitDistanceFromAnchor.set = function (t) { this._structArray.int16[this._pos2 + 2] = t }, Object.defineProperties(e.prototype, n), e }(w); gr.prototype.size = 6; var vr, _r = ((vr = Yt) && (xr.__proto__ = vr), ((xr.prototype = Object.create(vr && vr.prototype)).constructor = xr).prototype.getx = function (t) { return this.int16[3 * t + 0] }, xr.prototype.gety = function (t) { return this.int16[3 * t + 1] }, xr.prototype.gettileUnitDistanceFromAnchor = function (t) { return this.int16[3 * t + 2] }, xr.prototype.get = function (t) { return new gr(this, t) }, xr); function xr() { vr.apply(this, arguments) } In("SymbolLineVertexArray", _r); var br = function (t) { function e() { t.apply(this, arguments) } t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e; var n = { featureIndex: { configurable: !0 }, sourceLayerIndex: { configurable: !0 }, bucketIndex: { configurable: !0 } }; return n.featureIndex.get = function () { return this._structArray.uint32[this._pos4 + 0] }, n.featureIndex.set = function (t) { this._structArray.uint32[this._pos4 + 0] = t }, n.sourceLayerIndex.get = function () { return this._structArray.uint16[this._pos2 + 2] }, n.sourceLayerIndex.set = function (t) { this._structArray.uint16[this._pos2 + 2] = t }, n.bucketIndex.get = function () { return this._structArray.uint16[this._pos2 + 3] }, n.bucketIndex.set = function (t) { this._structArray.uint16[this._pos2 + 3] = t }, Object.defineProperties(e.prototype, n), e }(w); br.prototype.size = 8; var wr, Er = ((wr = Jt) && (Sr.__proto__ = wr), ((Sr.prototype = Object.create(wr && wr.prototype)).constructor = Sr).prototype.get = function (t) { return new br(this, t) }, Sr); function Sr() { wr.apply(this, arguments) } In("FeatureIndexArray", Er); var Qt = si([{ name: "a_pos", components: 2, type: "Int16" }], 4), Tr = Qt.members, Ar = (Qt.size, Qt.alignment, function (t) { void 0 === t && (t = []), this.segments = t }); Ar.prototype.prepareSegment = function (t, e, n) { var i = this.segments[this.segments.length - 1]; return t > Ar.MAX_VERTEX_ARRAY_LENGTH && x("Max vertices per segment is " + Ar.MAX_VERTEX_ARRAY_LENGTH + ": bucket requested " + t), (!i || i.vertexLength + t > Ar.MAX_VERTEX_ARRAY_LENGTH) && (i = { vertexOffset: e.length, primitiveOffset: n.length, vertexLength: 0, primitiveLength: 0 }, this.segments.push(i)), i }, Ar.prototype.get = function () { return this.segments }, Ar.prototype.destroy = function () { for (var t = 0, e = this.segments; t < e.length; t += 1) { var n, i = e[t]; for (n in i.vaos) i.vaos[n].destroy() } }, Ar.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, In("SegmentVector", Ar); function zr(t, e) { return 256 * (t = d(Math.floor(t), 0, 255)) + d(Math.floor(e), 0, 255) } function Ir(t) { return [zr(255 * t.r, 255 * t.g), zr(255 * t.b, 255 * t.a)] } function kr(t, e, n) { this.value = t, this.name = e, this.type = n, this.statistics = { max: -1 / 0 } } kr.prototype.defines = function () { return ["#define HAS_UNIFORM_u_" + this.name] }, kr.prototype.populatePaintArray = function () { }, kr.prototype.updatePaintArray = function () { }, kr.prototype.upload = function () { }, kr.prototype.destroy = function () { }, kr.prototype.setUniforms = function (t, e, n, i) { i = i.constantOr(this.value), t = t.gl; "color" === this.type ? t.uniform4f(e.uniforms["u_" + this.name], i.r, i.g, i.b, i.a) : t.uniform1f(e.uniforms["u_" + this.name], i) }; function Cr(t, e, n) { this.expression = t, this.name = e, this.type = n, this.statistics = { max: -1 / 0 }, t = "color" === n ? tr : ji, this.paintVertexAttributes = [{ name: "a_" + e, type: "Float32", components: "color" === n ? 2 : 1, offset: 0 }], this.paintVertexArray = new t } Cr.prototype.defines = function () { return [] }, Cr.prototype.populatePaintArray = function (t, e) { var n = this.paintVertexArray, i = n.length; n.reserve(t); var r = this.expression.evaluate(new Bn(0), e, {}); if ("color" === this.type) for (var o = Ir(r), a = i; a < t; a++)n.emplaceBack(o[0], o[1]); else { for (var s = i; s < t; s++)n.emplaceBack(r); this.statistics.max = Math.max(this.statistics.max, r) } }, Cr.prototype.updatePaintArray = function (t, e, n, i) { var r = this.paintVertexArray, o = this.expression.evaluate({ zoom: 0 }, n, i); if ("color" === this.type) for (var a = Ir(o), s = t; s < e; s++)r.emplace(s, a[0], a[1]); else { for (var l = t; l < e; l++)r.emplace(l, o); this.statistics.max = Math.max(this.statistics.max, o) } }, Cr.prototype.upload = function (t) { this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent)) }, Cr.prototype.destroy = function () { this.paintVertexBuffer && this.paintVertexBuffer.destroy() }, Cr.prototype.setUniforms = function (t, e) { t.gl.uniform1f(e.uniforms["a_" + this.name + "_t"], 0) }; function Mr(t, e, n, i, r) { this.expression = t, this.name = e, this.type = n, this.useIntegerZoom = i, this.zoom = r, this.statistics = { max: -1 / 0 }, r = "color" === n ? ir : tr, this.paintVertexAttributes = [{ name: "a_" + e, type: "Float32", components: "color" === n ? 4 : 2, offset: 0 }], this.paintVertexArray = new r } Mr.prototype.defines = function () { return [] }, Mr.prototype.populatePaintArray = function (t, e) { var n = this.paintVertexArray, i = n.length; n.reserve(t); var r = this.expression.evaluate(new Bn(this.zoom), e, {}), o = this.expression.evaluate(new Bn(this.zoom + 1), e, {}); if ("color" === this.type) for (var a = Ir(r), s = Ir(o), l = i; l < t; l++)n.emplaceBack(a[0], a[1], s[0], s[1]); else { for (var u = i; u < t; u++)n.emplaceBack(r, o); this.statistics.max = Math.max(this.statistics.max, r, o) } }, Mr.prototype.updatePaintArray = function (t, e, n, i) { var r = this.paintVertexArray, o = this.expression.evaluate({ zoom: this.zoom }, n, i), a = this.expression.evaluate({ zoom: this.zoom + 1 }, n, i); if ("color" === this.type) for (var s = Ir(o), l = Ir(a), u = t; u < e; u++)r.emplace(u, s[0], s[1], l[0], l[1]); else { for (var c = t; c < e; c++)r.emplace(c, o, a); this.statistics.max = Math.max(this.statistics.max, o, a) } }, Mr.prototype.upload = function (t) { this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent)) }, Mr.prototype.destroy = function () { this.paintVertexBuffer && this.paintVertexBuffer.destroy() }, Mr.prototype.interpolationFactor = function (t) { return this.useIntegerZoom ? this.expression.interpolationFactor(Math.floor(t), this.zoom, this.zoom + 1) : this.expression.interpolationFactor(t, this.zoom, this.zoom + 1) }, Mr.prototype.setUniforms = function (t, e, n) { t.gl.uniform1f(e.uniforms["a_" + this.name + "_t"], this.interpolationFactor(n.zoom)) }; function Pr() { this.binders = {}, this.cacheKey = "", this._buffers = [], this._idMap = {}, this._bufferOffset = 0 } Pr.createDynamic = function (t, e, n) { var i, r, o, a, s, l = new Pr, u = []; for (i in t.paint._values) { !n(i) || (r = t.paint.get(i)) instanceof Kn && ae(r.property.specification) && (a = i, s = t.type, o = { "text-opacity": "opacity", "icon-opacity": "opacity", "text-color": "fill_color", "icon-color": "fill_color", "text-halo-color": "halo_color", "icon-halo-color": "halo_color", "text-halo-blur": "halo_blur", "icon-halo-blur": "halo_blur", "text-halo-width": "halo_width", "icon-halo-width": "halo_width", "line-gap-width": "gapwidth" }[a] || a.replace(s + "-", "").replace(/-/g, "_"), a = r.property.specification.type, s = r.property.useIntegerZoom, "constant" === r.value.kind ? (l.binders[i] = new kr(r.value, o, a), u.push("/u_" + o)) : "source" === r.value.kind ? (l.binders[i] = new Cr(r.value, o, a), u.push("/a_" + o)) : (l.binders[i] = new Mr(r.value, o, a, s, e), u.push("/z_" + o))) } return l.cacheKey = u.sort().join(""), l }, Pr.prototype.populatePaintArrays = function (t, e, n) { for (var i in this.binders) this.binders[i].populatePaintArray(t, e); var r; e.id && (r = String(e.id), this._idMap[r] = this._idMap[r] || [], this._idMap[r].push({ index: n, start: this._bufferOffset, end: t })), this._bufferOffset = t }, Pr.prototype.updatePaintArrays = function (t, e, n) { var i, r = !1; for (i in t) { var o = this._idMap[i]; if (o) for (var a = t[i], s = 0, l = o; s < l.length; s += 1) { var u, c = l[s], h = e.feature(c.index); for (u in this.binders) { var p, f = this.binders[u]; f instanceof kr || !0 !== f.expression.isStateDependent || (p = n.paint.get(u), f.expression = p.value, f.updatePaintArray(c.start, c.end, h, a), r = !0) } } } return r }, Pr.prototype.defines = function () { var t, e = []; for (t in this.binders) e.push.apply(e, this.binders[t].defines()); return e }, Pr.prototype.setUniforms = function (t, e, n, i) { for (var r in this.binders) this.binders[r].setUniforms(t, e, i, n.get(r)) }, Pr.prototype.getPaintVertexBuffers = function () { return this._buffers }, Pr.prototype.upload = function (t) { for (var e in this.binders) this.binders[e].upload(t); var n, i = []; for (n in this.binders) { var r = this.binders[n]; (r instanceof Cr || r instanceof Mr) && r.paintVertexBuffer && i.push(r.paintVertexBuffer) } this._buffers = i }, Pr.prototype.destroy = function () { for (var t in this.binders) this.binders[t].destroy() }; function Lr(t, e, n, i) { void 0 === i && (i = function () { return !0 }), this.programConfigurations = {}; for (var r = 0, o = e; r < o.length; r += 1) { var a = o[r]; this.programConfigurations[a.id] = Pr.createDynamic(a, n, i), this.programConfigurations[a.id].layoutAttributes = t } this.needsUpload = !1 } Lr.prototype.populatePaintArrays = function (t, e, n) { for (var i in this.programConfigurations) this.programConfigurations[i].populatePaintArrays(t, e, n); this.needsUpload = !0 }, Lr.prototype.updatePaintArrays = function (t, e, n) { for (var i = 0, r = n; i < r.length; i += 1) { var o = r[i]; this.needsUpload = this.programConfigurations[o.id].updatePaintArrays(t, e, o) || this.needsUpload } }, Lr.prototype.get = function (t) { return this.programConfigurations[t] }, Lr.prototype.upload = function (t) { if (this.needsUpload) { for (var e in this.programConfigurations) this.programConfigurations[e].upload(t); this.needsUpload = !1 } }, Lr.prototype.destroy = function () { for (var t in this.programConfigurations) this.programConfigurations[t].destroy() }, In("ConstantBinder", kr), In("SourceExpressionBinder", Cr), In("CompositeExpressionBinder", Mr), In("ProgramConfiguration", Pr, { omit: ["_buffers"] }), In("ProgramConfigurationSet", Lr); var Dr = 8192, Rr = { min: -1 * Math.pow(2, 15), max: Math.pow(2, 15) - 1 }; function Br(t) { for (var e = Dr / t.extent, n = t.loadGeometry(), i = 0; i < n.length; i++)for (var r = n[i], o = 0; o < r.length; o++) { var a = r[o]; a.x = Math.round(a.x * e), a.y = Math.round(a.y * e), (a.x < Rr.min || a.x > Rr.max || a.y < Rr.min || a.y > Rr.max) && x("Geometry exceeds allowed extent, reduce your vector tile buffer size") } return n } function Or(t, e, n, i, r) { t.emplaceBack(2 * e + (i + 1) / 2, 2 * n + (r + 1) / 2) } function Fr(t) { this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(function (t) { return t.id }), this.index = t.index, this.layoutVertexArray = new ci, this.indexArray = new Hi, this.segments = new Ar, this.programConfigurations = new Lr(Tr, t.layers, t.zoom) } function Vr(t, e, n) { for (var i = 0; i < t.length; i++) { var r = t[i]; if (Xr(r, e)) return !0; if (qr(e, r, n)) return !0 } return !1 } function Nr(t, e) { if (1 === t.length && 1 === t[0].length) return Gr(e, t[0][0]); for (var n = 0; n < e.length; n++)for (var i = e[n], r = 0; r < i.length; r++)if (Gr(t, i[r])) return !0; for (var o = 0; o < t.length; o++) { for (var a = t[o], s = 0; s < a.length; s++)if (Gr(e, a[s])) return !0; for (var l = 0; l < e.length; l++)if (Ur(a, e[l])) return !0 } return !1 } function jr(t, e, n) { for (var i = 0; i < e.length; i++)for (var r = e[i], o = 0; o < t.length; o++) { var a = t[o]; if (3 <= a.length) for (var s = 0; s < r.length; s++)if (Xr(a, r[s])) return !0; if (function (t, e, n) { if (1 < t.length) { if (Ur(t, e)) return !0; for (var i = 0; i < e.length; i++)if (qr(e[i], t, n)) return !0 } for (var r = 0; r < t.length; r++)if (qr(t[r], e, n)) return !0; return !1 }(a, r, n)) return !0 } return !1 } function Ur(t, e) { if (0 !== t.length && 0 !== e.length) for (var n, i, r, o, a = 0; a < t.length - 1; a++)for (var s = t[a], l = t[a + 1], u = 0; u < e.length - 1; u++)if (n = s, i = l, r = e[u], o = e[u + 1], b(n, r, o) !== b(i, r, o) && b(n, i, r) !== b(n, i, o)) return 1 } function qr(t, e, n) { var i = n * n; if (1 === e.length) return t.distSqr(e[0]) < i; for (var r = 1; r < e.length; r++)if (Zr(t, e[r - 1], e[r]) < i) return 1 } function Zr(t, e, n) { var i = e.distSqr(n); if (0 === i) return t.distSqr(e); i = ((t.x - e.x) * (n.x - e.x) + (t.y - e.y) * (n.y - e.y)) / i; return i < 0 ? t.distSqr(e) : 1 < i ? t.distSqr(n) : t.distSqr(n.sub(e)._mult(i)._add(e)) } function Gr(t, e) { for (var n, i, r, o = !1, a = 0; a < t.length; a++)for (var s = 0, l = (n = t[a]).length - 1; s < n.length; l = s++)i = n[s], r = n[l], i.y > e.y != r.y > e.y && e.x < (r.x - i.x) * (e.y - i.y) / (r.y - i.y) + i.x && (o = !o); return o } function Xr(t, e) { for (var n = !1, i = 0, r = t.length - 1; i < t.length; r = i++) { var o = t[i], a = t[r]; o.y > e.y != a.y > e.y && e.x < (a.x - o.x) * (e.y - o.y) / (a.y - o.y) + o.x && (n = !n) } return n } function Wr(t, e, n) { var i = e.paint.get(t).value; return "constant" === i.kind ? i.value : n.programConfigurations.get(e.id).binders[t].statistics.max } function Hr(t) { return Math.sqrt(t[0] * t[0] + t[1] * t[1]) } function Kr(t, e, n, i, r) { if (!e[0] && !e[1]) return t; var o = p.convert(e); "viewport" === n && o._rotate(-i); for (var a = [], s = 0; s < t.length; s++) { for (var l = t[s], u = [], c = 0; c < l.length; c++)u.push(l[c].sub(o._mult(r))); a.push(u) } return a } Fr.prototype.populate = function (t, e) { for (var n = 0, i = t; n < i.length; n += 1) { var r = i[n], o = r.feature, a = r.index, s = r.sourceLayerIndex; this.layers[0]._featureFilter(new Bn(this.zoom), o) && (r = Br(o), this.addFeature(o, r, a), e.featureIndex.insert(o, r, a, s, this.index)) } }, Fr.prototype.update = function (t, e) { this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers) }, Fr.prototype.isEmpty = function () { return 0 === this.layoutVertexArray.length }, Fr.prototype.uploadPending = function () { return !this.uploaded || this.programConfigurations.needsUpload }, Fr.prototype.upload = function (t) { this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Tr), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0 }, Fr.prototype.destroy = function () { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy()) }, Fr.prototype.addFeature = function (t, e, n) { for (var i = 0, r = e; i < r.length; i += 1)for (var o = 0, a = r[i]; o < a.length; o += 1) { var s, l = a[o], u = l.x, c = l.y; u < 0 || Dr <= u || c < 0 || Dr <= c || (l = (s = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray)).vertexLength, Or(this.layoutVertexArray, u, c, -1, -1), Or(this.layoutVertexArray, u, c, 1, -1), Or(this.layoutVertexArray, u, c, 1, 1), Or(this.layoutVertexArray, u, c, -1, 1), this.indexArray.emplaceBack(l, l + 1, l + 2), this.indexArray.emplaceBack(l, l + 3, l + 2), s.vertexLength += 4, s.primitiveLength += 2) } this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, n) }, In("CircleBucket", Fr, { omit: ["layers"] }); var Jr = { paint: new ei({ "circle-radius": new $n(V.paint_circle["circle-radius"]), "circle-color": new $n(V.paint_circle["circle-color"]), "circle-blur": new $n(V.paint_circle["circle-blur"]), "circle-opacity": new $n(V.paint_circle["circle-opacity"]), "circle-translate": new Yn(V.paint_circle["circle-translate"]), "circle-translate-anchor": new Yn(V.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new Yn(V.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new Yn(V.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new $n(V.paint_circle["circle-stroke-width"]), "circle-stroke-color": new $n(V.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new $n(V.paint_circle["circle-stroke-opacity"]) }) }, Yr = "undefined" != typeof Float32Array ? Float32Array : Array; function $r() { var t = new Yr(9); return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t } function Qr() { var t = new Yr(3); return t[0] = 0, t[1] = 0, t[2] = 0, t } function to(t) { var e = t[0], n = t[1], t = t[2]; return Math.sqrt(e * e + n * n + t * t) } function eo(t, e, n) { var i = new Yr(3); return i[0] = t, i[1] = e, i[2] = n, i } Math.PI; var no, $t = to, be = (no = Qr(), function (t, e, n, i, r, o) { var a, s; for (e = e || 3, n = n || 0, s = i ? Math.min(i * e + n, t.length) : t.length, a = n; a < s; a += e)no[0] = t[a], no[1] = t[a + 1], no[2] = t[a + 2], r(no, no, o), t[a] = no[0], t[a + 1] = no[1], t[a + 2] = no[2]; return t }); function io() { var t = new Yr(4); return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0, t } function ro(t, e) { var n = e[0], i = e[1], r = e[2], o = e[3], e = n * n + i * i + r * r + o * o; return 0 < e && (e = 1 / Math.sqrt(e), t[0] = n * e, t[1] = i * e, t[2] = r * e, t[3] = o * e), t } function oo(t, e, n) { var i = e[0], r = e[1], o = e[2], e = e[3]; return t[0] = n[0] * i + n[4] * r + n[8] * o + n[12] * e, t[1] = n[1] * i + n[5] * r + n[9] * o + n[13] * e, t[2] = n[2] * i + n[6] * r + n[10] * o + n[14] * e, t[3] = n[3] * i + n[7] * r + n[11] * o + n[15] * e, t } var ao, we = (ao = io(), function (t, e, n, i, r, o) { var a, s; for (e = e || 4, n = n || 0, s = i ? Math.min(i * e + n, t.length) : t.length, a = n; a < s; a += e)ao[0] = t[a], ao[1] = t[a + 1], ao[2] = t[a + 2], ao[3] = t[a + 3], r(ao, ao, o), t[a] = ao[0], t[a + 1] = ao[1], t[a + 2] = ao[2], t[a + 3] = ao[3]; return t }); function so() { var t = new Yr(4); return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t } Qr(), eo(1, 0, 0), eo(0, 1, 0), so(), so(), $r(); (oi = new Yr(2))[0] = 0, oi[1] = 0; var lo, Ht = ((lo = ii) && (uo.__proto__ = lo), ((uo.prototype = Object.create(lo && lo.prototype)).constructor = uo).prototype.createBucket = function (t) { return new Fr(t) }, uo.prototype.queryRadius = function (t) { return Wr("circle-radius", this, t) + Wr("circle-stroke-width", this, t) + Hr(this.paint.get("circle-translate")) }, uo.prototype.queryIntersectsFeature = function (t, e, n, i, r, o, a, s) { for (var l, u, t = Kr(t, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), o.angle, a), n = this.paint.get("circle-radius").evaluate(e, n) + this.paint.get("circle-stroke-width").evaluate(e, n), c = "map" === this.paint.get("circle-pitch-alignment"), h = c ? t : (l = s, u = o, t.map(function (t) { return t.map(function (t) { return co(t, l, u) }) })), p = c ? n * a : n, f = 0, d = i; f < d.length; f += 1)for (var m = 0, y = d[f]; m < y.length; m += 1) { var g = y[m], v = c ? g : co(g, s, o), _ = p, g = oo([], [g.x, g.y, 0, 1], s); if ("viewport" === this.paint.get("circle-pitch-scale") && "map" === this.paint.get("circle-pitch-alignment") ? _ *= g[3] / o.cameraToCenterDistance : "map" === this.paint.get("circle-pitch-scale") && "viewport" === this.paint.get("circle-pitch-alignment") && (_ *= o.cameraToCenterDistance / g[3]), Vr(h, v, _)) return !0 } return !1 }, uo); function uo(t) { lo.call(this, t, Jr) } function co(t, e, n) { e = oo([], [t.x, t.y, 0, 1], e); return new p((e[0] / e[3] + 1) * n.width * .5, (e[1] / e[3] + 1) * n.height * .5) } var ho, po = ((ho = Fr) && (fo.__proto__ = ho), (fo.prototype = Object.create(ho && ho.prototype)).constructor = fo); function fo() { ho.apply(this, arguments) } function mo(t, e, n, i) { var r = e.width, e = e.height; if (i) { if (i.length !== r * e * n) throw new RangeError("mismatched image size") } else i = new Uint8Array(r * e * n); return t.width = r, t.height = e, t.data = i, t } function yo(t, e, n) { var i = e.width, r = e.height; i === t.width && r === t.height || (go(t, e = mo({}, { width: i, height: r }, n), { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(t.width, i), height: Math.min(t.height, r) }, n), t.width = i, t.height = r, t.data = e.data) } function go(t, e, n, i, r, o) { if (0 === r.width || 0 === r.height) return e; if (r.width > t.width || r.height > t.height || n.x > t.width - r.width || n.y > t.height - r.height) throw new RangeError("out of range source coordinates for image copy"); if (r.width > e.width || r.height > e.height || i.x > e.width - r.width || i.y > e.height - r.height) throw new RangeError("out of range destination coordinates for image copy"); for (var a = t.data, s = e.data, l = 0; l < r.height; l++)for (var u = ((n.y + l) * t.width + n.x) * o, c = ((i.y + l) * e.width + i.x) * o, h = 0; h < r.width * o; h++)s[c + h] = a[u + h]; return e } In("HeatmapBucket", po, { omit: ["layers"] }); var vo = function (t, e) { mo(this, t, 1, e) }; vo.prototype.resize = function (t) { yo(this, t, 1) }, vo.prototype.clone = function () { return new vo({ width: this.width, height: this.height }, new Uint8Array(this.data)) }, vo.copy = function (t, e, n, i, r) { go(t, e, n, i, r, 1) }; function _o(t, e) { mo(this, t, 4, e) } _o.prototype.resize = function (t) { yo(this, t, 4) }, _o.prototype.clone = function () { return new _o({ width: this.width, height: this.height }, new Uint8Array(this.data)) }, _o.copy = function (t, e, n, i, r) { go(t, e, n, i, r, 4) }, In("AlphaImage", vo), In("RGBAImage", _o); var xo = { paint: new ei({ "heatmap-radius": new $n(V.paint_heatmap["heatmap-radius"]), "heatmap-weight": new $n(V.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new Yn(V.paint_heatmap["heatmap-intensity"]), "heatmap-color": new ti(V.paint_heatmap["heatmap-color"]), "heatmap-opacity": new Yn(V.paint_heatmap["heatmap-opacity"]) }) }; function bo(t, e) { for (var n = new Uint8Array(1024), i = {}, r = 0, o = 0; r < 256; r++, o += 4) { i[e] = r / 255; var a = t.evaluate(i); n[o + 0] = Math.floor(255 * a.r / a.a), n[o + 1] = Math.floor(255 * a.g / a.a), n[o + 2] = Math.floor(255 * a.b / a.a), n[o + 3] = Math.floor(255 * a.a) } return new _o({ width: 256, height: 1 }, n) } var wo, Eo, Kt = ((Eo = ii) && (Io.__proto__ = Eo), ((Io.prototype = Object.create(Eo && Eo.prototype)).constructor = Io).prototype.createBucket = function (t) { return new po(t) }, Io.prototype._handleSpecialPaintPropertyUpdate = function (t) { "heatmap-color" === t && this._updateColorRamp() }, Io.prototype._updateColorRamp = function () { var t = this._transitionablePaint._values["heatmap-color"].value.expression; this.colorRamp = bo(t, "heatmapDensity"), this.colorRampTexture = null }, Io.prototype.resize = function () { this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null) }, Io.prototype.queryRadius = function () { return 0 }, Io.prototype.queryIntersectsFeature = function () { return !1 }, Io.prototype.hasOffscreenPass = function () { return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility }, Io), So = { paint: new ei({ "hillshade-illumination-direction": new Yn(V.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new Yn(V.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new Yn(V.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new Yn(V.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new Yn(V.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new Yn(V.paint_hillshade["hillshade-accent-color"]) }) }, Yt = ((wo = ii) && (zo.__proto__ = wo), ((zo.prototype = Object.create(wo && wo.prototype)).constructor = zo).prototype.hasOffscreenPass = function () { return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility }, zo), w = si([{ name: "a_pos", components: 2, type: "Int16" }], 4), To = w.members, Ao = (w.size, w.alignment, ko), Jt = ko; function zo(t) { wo.call(this, t, So) } function Io(t) { Eo.call(this, t, xo), this._updateColorRamp() } function ko(t, e, n) { n = n || 2; var i, r, o, a, s, l, u, c = e && e.length, h = c ? e[0] * n : t.length, p = Co(t, 0, h, n, !0), f = []; if (!p) return f; if (c && (p = function (t, e, n, i) { for (var r, o = [], a = 0, s = e.length; a < s; a++)(r = Co(t, e[a] * i, a < s - 1 ? e[a + 1] * i : t.length, i, !1)) === r.next && (r.steiner = !0), o.push(function (t) { var e = t, n = t; for (; e.x < n.x && (n = e), e = e.next, e !== t;); return n }(r)); for (o.sort(Lo), a = 0; a < o.length; a++)(function (t, e) { { (e = function (t, e) { var n, i = e, r = t.x, o = t.y, a = -1 / 0; do { if (o <= i.y && o >= i.next.y && i.next.y !== i.y) { var s = i.x + (o - i.y) * (i.next.x - i.x) / (i.next.y - i.y); if (s <= r && a < s) { if ((a = s) === r) { if (o === i.y) return i; if (o === i.next.y) return i.next } n = i.x < i.next.x ? i : i.next } } i = i.next } while (i !== e); if (!n) return null; if (r === a) return n.prev; for (var l, u = n, c = n.x, h = n.y, p = 1 / 0, i = n.next; i !== u;)r >= i.x && i.x >= c && r !== i.x && Ro(o < h ? r : a, o, c, h, o < h ? a : r, o, i.x, i.y) && ((l = Math.abs(o - i.y) / (r - i.x)) < p || l === p && i.x > n.x) && Vo(i, t) && (n = i, p = l), i = i.next; return n }(t, e)) && Mo(t = No(e, t), t.next) } })(o[a], n), n = Mo(n, n.next); return n }(t, e, p, n)), t.length > 80 * n) { i = o = t[0], r = a = t[1]; for (var d = n; d < h; d += n)(s = t[d]) < i && (i = s), (l = t[d + 1]) < r && (r = l), o < s && (o = s), a < l && (a = l); u = 0 !== (u = Math.max(o - i, a - r)) ? 1 / u : 0 } return Po(p, f, n, i, r, u), f } function Co(t, e, n, i, r) { var o, a; if (r === 0 < Zo(t, e, n, i)) for (o = e; o < n; o += i)a = jo(o, t[o], t[o + 1], a); else for (o = n - i; e <= o; o -= i)a = jo(o, t[o], t[o + 1], a); return a && Oo(a, a.next) && (Uo(a), a = a.next), a } function Mo(t, e) { if (!t) return t; e = e || t; var n, i = t; do { if (n = !1, i.steiner || !Oo(i, i.next) && 0 !== Bo(i.prev, i, i.next)) i = i.next; else { if (Uo(i), (i = e = i.prev) === i.next) break; n = !0 } } while (n || i !== e); return e } function Po(t, e, n, i, r, o, a) { if (t) { !a && o && function (t, e, n, i) { for (var r = t; null === r.z && (r.z = Do(r.x, r.y, e, n, i)), r.prevZ = r.prev, r.nextZ = r.next, (r = r.next) !== t;); r.prevZ.nextZ = null, r.prevZ = null, function (t) { var e, n, i, r, o, a, s, l, u = 1; do { for (n = t, o = t = null, a = 0; n;) { for (a++, i = n, e = s = 0; e < u && (s++, i = i.nextZ); e++); for (l = u; 0 < s || 0 < l && i;)0 !== s && (0 === l || !i || n.z <= i.z) ? (n = (r = n).nextZ, s--) : (i = (r = i).nextZ, l--), o ? o.nextZ = r : t = r, r.prevZ = o, o = r; n = i } o.nextZ = null, u *= 2 } while (1 < a) }(r) }(t, i, r, o); for (var s, l, u = t; t.prev !== t.next;)if (s = t.prev, l = t.next, o ? function (t, e, n, i) { var r = t.prev, o = t, a = t.next; if (0 <= Bo(r, o, a)) return !1; for (var s = (r.x < o.x ? r.x < a.x ? r : a : o.x < a.x ? o : a).x, l = (r.y < o.y ? r.y < a.y ? r : a : o.y < a.y ? o : a).y, u = (r.x > o.x ? r.x > a.x ? r : a : o.x > a.x ? o : a).x, c = (r.y > o.y ? r.y > a.y ? r : a : o.y > a.y ? o : a).y, h = Do(s, l, e, n, i), p = Do(u, c, e, n, i), f = t.prevZ, d = t.nextZ; f && f.z >= h && d && d.z <= p;) { if (f !== t.prev && f !== t.next && Ro(r.x, r.y, o.x, o.y, a.x, a.y, f.x, f.y) && 0 <= Bo(f.prev, f, f.next)) return !1; if (f = f.prevZ, d !== t.prev && d !== t.next && Ro(r.x, r.y, o.x, o.y, a.x, a.y, d.x, d.y) && 0 <= Bo(d.prev, d, d.next)) return !1; d = d.nextZ } for (; f && f.z >= h;) { if (f !== t.prev && f !== t.next && Ro(r.x, r.y, o.x, o.y, a.x, a.y, f.x, f.y) && 0 <= Bo(f.prev, f, f.next)) return !1; f = f.prevZ } for (; d && d.z <= p;) { if (d !== t.prev && d !== t.next && Ro(r.x, r.y, o.x, o.y, a.x, a.y, d.x, d.y) && 0 <= Bo(d.prev, d, d.next)) return !1; d = d.nextZ } return !0 }(t, i, r, o) : function (t) { var e = t.prev, n = t, i = t.next; if (0 <= Bo(e, n, i)) return !1; for (var r = t.next.next; r !== t.prev;) { if (Ro(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) && 0 <= Bo(r.prev, r, r.next)) return !1; r = r.next } return !0 }(t)) e.push(s.i / n), e.push(t.i / n), e.push(l.i / n), Uo(t), t = l.next, u = l.next; else if ((t = l) === u) { a ? 1 === a ? Po(t = function (t, e, n) { var i = t; do { var r = i.prev, o = i.next.next; !Oo(r, o) && Fo(r, i, i.next, o) && Vo(r, o) && Vo(o, r) && (e.push(r.i / n), e.push(i.i / n), e.push(o.i / n), Uo(i), Uo(i.next), i = t = o), i = i.next } while (i !== t); return i }(t, e, n), e, n, i, r, o, 2) : 2 === a && function (t, e, n, i, r, o) { var a = t; do { for (var s = a.next.next; s !== a.prev;) { if (a.i !== s.i && function (t, o) { return t.next.i !== o.i && t.prev.i !== o.i && !function (t, e) { var n = t; do { if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && Fo(n, n.next, t, e)) return 1; n = n.next } while (n !== t) }(t, o) && Vo(t, o) && Vo(o, t) && function (t) { for (var e = t, n = !1, i = (t.x + o.x) / 2, r = (t.y + o.y) / 2; e.y > r != e.next.y > r && e.next.y !== e.y && i < (e.next.x - e.x) * (r - e.y) / (e.next.y - e.y) + e.x && (n = !n), (e = e.next) !== t;); return n }(t) }(a, s)) { var l = No(a, s); return a = Mo(a, a.next), l = Mo(l, l.next), Po(a, e, n, i, r, o), Po(l, e, n, i, r, o) } s = s.next } a = a.next } while (a !== t) }(t, e, n, i, r, o) : Po(Mo(t), e, n, i, r, o, 1); break } } } function Lo(t, e) { return t.x - e.x } function Do(t, e, n, i, r) { return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1 } function Ro(t, e, n, i, r, o, a, s) { return 0 <= (r - a) * (e - s) - (t - a) * (o - s) && 0 <= (t - a) * (i - s) - (n - a) * (e - s) && 0 <= (n - a) * (o - s) - (r - a) * (i - s) } function Bo(t, e, n) { return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y) } function Oo(t, e) { return t.x === e.x && t.y === e.y } function Fo(t, e, n, i) { return Oo(t, e) && Oo(n, i) || Oo(t, i) && Oo(n, e) || 0 < Bo(t, e, n) != 0 < Bo(t, e, i) && 0 < Bo(n, i, t) != 0 < Bo(n, i, e) } function Vo(t, e) { return Bo(t.prev, t, t.next) < 0 ? 0 <= Bo(t, e, t.next) && 0 <= Bo(t, t.prev, e) : Bo(t, e, t.prev) < 0 || Bo(t, t.next, e) < 0 } function No(t, e) { var n = new qo(t.i, t.x, t.y), i = new qo(e.i, e.x, e.y), r = t.next, o = e.prev; return (t.next = e).prev = t, (n.next = r).prev = n, (i.next = n).prev = i, (o.next = i).prev = o, i } function jo(t, e, n, i) { n = new qo(t, e, n); return i ? (n.next = i.next, (n.prev = i).next.prev = n, i.next = n) : (n.prev = n).next = n, n } function Uo(t) { t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ) } function qo(t, e, n) { this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1 } function Zo(t, e, n, i) { for (var r = 0, o = e, a = n - i; o < n; o += i)r += (t[a] - t[o]) * (t[o + 1] + t[a + 1]), a = o; return r } ko.deviation = function (t, e, n, i) { var r = e && e.length, o = r ? e[0] * n : t.length, a = Math.abs(Zo(t, 0, o, n)); if (r) for (var s = 0, l = e.length; s < l; s++) { var u = e[s] * n, c = s < l - 1 ? e[s + 1] * n : t.length; a -= Math.abs(Zo(t, u, c, n)) } for (var h = 0, s = 0; s < i.length; s += 3) { var p = i[s] * n, f = i[s + 1] * n, d = i[s + 2] * n; h += Math.abs((t[p] - t[d]) * (t[1 + f] - t[1 + p]) - (t[p] - t[f]) * (t[1 + d] - t[1 + p])) } return 0 === a && 0 === h ? 0 : Math.abs((h - a) / a) }, ko.flatten = function (t) { for (var e = t[0][0].length, n = { vertices: [], holes: [], dimensions: e }, i = 0, r = 0; r < t.length; r++) { for (var o = 0; o < t[r].length; o++)for (var a = 0; a < e; a++)n.vertices.push(t[r][o][a]); 0 < r && (i += t[r - 1].length, n.holes.push(i)) } return n }, Ao.default = Jt; var Go = Xo; function Xo(t, e, n, i, r) { !function t(e, n, i, r, o) { for (; i < r;) { var a, s, l, u; 600 < r - i && (a = r - i + 1, s = n - i + 1, u = Math.log(a), l = .5 * Math.exp(2 * u / 3), u = .5 * Math.sqrt(u * l * (a - l) / a) * (s - a / 2 < 0 ? -1 : 1), t(e, n, Math.max(i, Math.floor(n - s * l / a + u)), Math.min(r, Math.floor(n + (a - s) * l / a + u)), o)); var c = e[n], h = i, p = r; for (Wo(e, i, n), 0 < o(e[r], c) && Wo(e, i, r); h < p;) { for (Wo(e, h, p), h++, p--; o(e[h], c) < 0;)h++; for (; 0 < o(e[p], c);)p-- } 0 === o(e[i], c) ? Wo(e, i, p) : Wo(e, ++p, r), p <= n && (i = p + 1), n <= p && (r = p - 1) } }(t, e, n || 0, i || t.length - 1, r || Ho) } function Wo(t, e, n) { var i = t[e]; t[e] = t[n], t[n] = i } function Ho(t, e) { return t < e ? -1 : e < t ? 1 : 0 } function Ko(t, e) { var n = t.length; if (n <= 1) return [t]; for (var i, r, o = [], a = 0; a < n; a++) { var s = function (t) { for (var e, n, i = 0, r = 0, o = t.length, a = o - 1; r < o; a = r++)e = t[r], i += ((n = t[a]).x - e.x) * (e.y + n.y); return i }(t[a]); 0 !== s && (t[a].area = Math.abs(s), void 0 === r && (r = s < 0), r === s < 0 ? (i && o.push(i), i = [t[a]]) : i.push(t[a])) } if (i && o.push(i), 1 < e) for (var l = 0; l < o.length; l++)o[l].length <= e || (Go(o[l], e, 1, o[l].length - 1, Jo), o[l] = o[l].slice(0, e)); return o } function Jo(t, e) { return e.area - t.area } Go.default = Xo; function Yo(t) { this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(function (t) { return t.id }), this.index = t.index, this.layoutVertexArray = new ci, this.indexArray = new Hi, this.indexArray2 = new Yi, this.programConfigurations = new Lr(To, t.layers, t.zoom), this.segments = new Ar, this.segments2 = new Ar } Yo.prototype.populate = function (t, e) { for (var n = 0, i = t; n < i.length; n += 1) { var r = i[n], o = r.feature, a = r.index, s = r.sourceLayerIndex; this.layers[0]._featureFilter(new Bn(this.zoom), o) && (r = Br(o), this.addFeature(o, r, a), e.featureIndex.insert(o, r, a, s, this.index)) } }, Yo.prototype.update = function (t, e) { this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers) }, Yo.prototype.isEmpty = function () { return 0 === this.layoutVertexArray.length }, Yo.prototype.uploadPending = function () { return !this.uploaded || this.programConfigurations.needsUpload }, Yo.prototype.upload = function (t) { this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, To), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.indexBuffer2 = t.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t), this.uploaded = !0 }, Yo.prototype.destroy = function () { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy()) }, Yo.prototype.addFeature = function (t, e, n) { for (var i = 0, r = Ko(e, 500); i < r.length; i += 1) { for (var o = r[i], a = 0, s = 0, l = o; s < l.length; s += 1)a += l[s].length; for (var u = this.segments.prepareSegment(a, this.layoutVertexArray, this.indexArray), c = u.vertexLength, h = [], p = [], f = 0, d = o; f < d.length; f += 1) { var m = d[f]; if (0 !== m.length) { m !== o[0] && p.push(h.length / 2); var y = this.segments2.prepareSegment(m.length, this.layoutVertexArray, this.indexArray2), g = y.vertexLength; this.layoutVertexArray.emplaceBack(m[0].x, m[0].y), this.indexArray2.emplaceBack(g + m.length - 1, g), h.push(m[0].x), h.push(m[0].y); for (var v = 1; v < m.length; v++)this.layoutVertexArray.emplaceBack(m[v].x, m[v].y), this.indexArray2.emplaceBack(g + v - 1, g + v), h.push(m[v].x), h.push(m[v].y); y.vertexLength += m.length, y.primitiveLength += m.length } } for (var _ = Ao(h, p), x = 0; x < _.length; x += 3)this.indexArray.emplaceBack(c + _[x], c + _[x + 1], c + _[x + 2]); u.vertexLength += a, u.primitiveLength += _.length / 3 } this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, n) }, In("FillBucket", Yo, { omit: ["layers"] }); var $o, Qo = { paint: new ei({ "fill-antialias": new Yn(V.paint_fill["fill-antialias"]), "fill-opacity": new $n(V.paint_fill["fill-opacity"]), "fill-color": new $n(V.paint_fill["fill-color"]), "fill-outline-color": new $n(V.paint_fill["fill-outline-color"]), "fill-translate": new Yn(V.paint_fill["fill-translate"]), "fill-translate-anchor": new Yn(V.paint_fill["fill-translate-anchor"]), "fill-pattern": new Qn(V.paint_fill["fill-pattern"]) }) }, Qt = (($o = ii) && (na.__proto__ = $o), ((na.prototype = Object.create($o && $o.prototype)).constructor = na).prototype.recalculate = function (t) { this.paint = this._transitioningPaint.possiblyEvaluate(t); t = this.paint._values["fill-outline-color"]; "constant" === t.value.kind && void 0 === t.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]) }, na.prototype.createBucket = function (t) { return new Yo(t) }, na.prototype.queryRadius = function () { return Hr(this.paint.get("fill-translate")) }, na.prototype.queryIntersectsFeature = function (t, e, n, i, r, o, a) { return Nr(Kr(t, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), o.angle, a), i) }, na), oi = si([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), ta = oi.members, ea = (oi.size, oi.alignment, Math.pow(2, 13)); function na(t) { $o.call(this, t, Qo) } function ia(t, e, n, i, r, o, a, s) { t.emplaceBack(e, n, 2 * Math.floor(i * ea) + a, r * ea * 2, o * ea * 2, Math.round(s)) } function ra(t) { this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(function (t) { return t.id }), this.index = t.index, this.layoutVertexArray = new yi, this.indexArray = new Hi, this.programConfigurations = new Lr(ta, t.layers, t.zoom), this.segments = new Ar } ra.prototype.populate = function (t, e) { for (var n = 0, i = t; n < i.length; n += 1) { var r = i[n], o = r.feature, a = r.index, s = r.sourceLayerIndex; this.layers[0]._featureFilter(new Bn(this.zoom), o) && (r = Br(o), this.addFeature(o, r, a), e.featureIndex.insert(o, r, a, s, this.index)) } }, ra.prototype.update = function (t, e) { this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers) }, ra.prototype.isEmpty = function () { return 0 === this.layoutVertexArray.length }, ra.prototype.uploadPending = function () { return !this.uploaded || this.programConfigurations.needsUpload }, ra.prototype.upload = function (t) { this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, ta), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0 }, ra.prototype.destroy = function () { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy()) }, ra.prototype.addFeature = function (t, e, n) { for (var i, r = 0, o = Ko(e, 500); r < o.length; r += 1) { for (var a = o[r], s = 0, l = 0, u = a; l < u.length; l += 1)s += u[l].length; for (var c = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray), h = 0, p = a; h < p.length; h += 1) { var f = p[h]; if (0 !== f.length && !((i = f).every(function (t) { return t.x < 0 }) || i.every(function (t) { return t.x > Dr }) || i.every(function (t) { return t.y < 0 }) || i.every(function (t) { return t.y > Dr }))) for (var d = 0, m = 0; m < f.length; m++) { var y, g, v, _ = f[m]; 1 <= m && (y = f[m - 1], v = y, (g = _).x === v.x && (g.x < 0 || g.x > Dr) || g.y === v.y && (g.y < 0 || g.y > Dr) || (c.vertexLength + 4 > Ar.MAX_VERTEX_ARRAY_LENGTH && (c = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray)), v = _.sub(y)._perp()._unit(), 32768 < d + (g = y.dist(_)) && (d = 0), ia(this.layoutVertexArray, _.x, _.y, v.x, v.y, 0, 0, d), ia(this.layoutVertexArray, _.x, _.y, v.x, v.y, 0, 1, d), d += g, ia(this.layoutVertexArray, y.x, y.y, v.x, v.y, 0, 0, d), ia(this.layoutVertexArray, y.x, y.y, v.x, v.y, 0, 1, d), v = c.vertexLength, this.indexArray.emplaceBack(v, v + 1, v + 2), this.indexArray.emplaceBack(v + 1, v + 2, v + 3), c.vertexLength += 4, c.primitiveLength += 2)) } } c.vertexLength + s > Ar.MAX_VERTEX_ARRAY_LENGTH && (c = this.segments.prepareSegment(s, this.layoutVertexArray, this.indexArray)); for (var x = [], b = [], w = c.vertexLength, E = 0, S = a; E < S.length; E += 1) { var T = S[E]; if (0 !== T.length) { T !== a[0] && b.push(x.length / 2); for (var A = 0; A < T.length; A++) { var z = T[A]; ia(this.layoutVertexArray, z.x, z.y, 0, 0, 1, 1, 0), x.push(z.x), x.push(z.y) } } } for (var I = Ao(x, b), k = 0; k < I.length; k += 3)this.indexArray.emplaceBack(w + I[k], w + I[k + 1], w + I[k + 2]); c.primitiveLength += I.length / 3, c.vertexLength += s } this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, n) }, In("FillExtrusionBucket", ra, { omit: ["layers"] }); var oa, aa = { paint: new ei({ "fill-extrusion-opacity": new Yn(V["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new $n(V["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new Yn(V["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new Yn(V["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new Qn(V["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new $n(V["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new $n(V["paint_fill-extrusion"]["fill-extrusion-base"]) }) }, w = ((oa = ii) && (ua.__proto__ = oa), ((ua.prototype = Object.create(oa && oa.prototype)).constructor = ua).prototype.createBucket = function (t) { return new ra(t) }, ua.prototype.queryRadius = function () { return Hr(this.paint.get("fill-extrusion-translate")) }, ua.prototype.queryIntersectsFeature = function (t, e, n, i, r, o, a) { return Nr(Kr(t, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), o.angle, a), i) }, ua.prototype.hasOffscreenPass = function () { return 0 !== this.paint.get("fill-extrusion-opacity") && "none" !== this.visibility }, ua.prototype.resize = function () { this.viewportFrame && (this.viewportFrame.destroy(), this.viewportFrame = null) }, ua), Jt = si([{ name: "a_pos_normal", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), sa = Jt.members, la = (Jt.size, Jt.alignment, ca); function ua(t) { oa.call(this, t, aa) } function ca(t, e, n, i, r) { this.properties = {}, this.extent = n, this.type = 0, this._pbf = t, this._geometry = -1, this._keys = i, this._values = r, t.readFields(ha, this, e) } function ha(t, e, n) { 1 == t ? e.id = n.readVarint() : 2 == t ? function (t, e) { for (var n = t.readVarint() + t.pos; t.pos < n;) { var i = e._keys[t.readVarint()], r = e._values[t.readVarint()]; e.properties[i] = r } }(n, e) : 3 == t ? e.type = n.readVarint() : 4 == t && (e._geometry = n.pos) } ca.types = ["Unknown", "Point", "LineString", "Polygon"], ca.prototype.loadGeometry = function () { var t = this._pbf; t.pos = this._geometry; for (var e, n, i = t.readVarint() + t.pos, r = 1, o = 0, a = 0, s = 0, l = []; t.pos < i;) { if (o <= 0 && (r = 7 & (n = t.readVarint()), o = n >> 3), o--, 1 === r || 2 === r) a += t.readSVarint(), s += t.readSVarint(), 1 === r && (e && l.push(e), e = []), e.push(new p(a, s)); else { if (7 !== r) throw new Error("unknown command " + r); e && e.push(e[0].clone()) } } return e && l.push(e), l }, ca.prototype.bbox = function () { var t = this._pbf; t.pos = this._geometry; for (var e, n = t.readVarint() + t.pos, i = 1, r = 0, o = 0, a = 0, s = 1 / 0, l = -1 / 0, u = 1 / 0, c = -1 / 0; t.pos < n;) { if (r <= 0 && (i = 7 & (e = t.readVarint()), r = e >> 3), r--, 1 === i || 2 === i) (o += t.readSVarint()) < s && (s = o), l < o && (l = o), (a += t.readSVarint()) < u && (u = a), c < a && (c = a); else if (7 !== i) throw new Error("unknown command " + i) } return [s, u, l, c] }, ca.prototype.toGeoJSON = function (t, e, n) { var i, r = this.extent * Math.pow(2, n), o = this.extent * t, a = this.extent * e, s = this.loadGeometry(), e = ca.types[this.type]; function l(t) { for (var e = 0; e < t.length; e++) { var n = t[e], i = 180 - 360 * (n.y + a) / r; t[e] = [360 * (n.x + o) / r - 180, 360 / Math.PI * Math.atan(Math.exp(i * Math.PI / 180)) - 90] } } switch (this.type) { case 1: for (var u = [], c = 0; c < s.length; c++)u[c] = s[c][0]; l(s = u); break; case 2: for (c = 0; c < s.length; c++)l(s[c]); break; case 3: for (s = function (t) { var e = t.length; if (e <= 1) return [t]; for (var n, i, r = [], o = 0; o < e; o++) { var a = function (t) { for (var e, n, i = 0, r = 0, o = t.length, a = o - 1; r < o; a = r++)e = t[r], i += ((n = t[a]).x - e.x) * (e.y + n.y); return i }(t[o]); 0 !== a && (void 0 === i && (i = a < 0), i === a < 0 ? (n && r.push(n), n = [t[o]]) : n.push(t[o])) } return n && r.push(n), r }(s), c = 0; c < s.length; c++)for (i = 0; i < s[c].length; i++)l(s[c][i]) }1 === s.length ? s = s[0] : e = "Multi" + e; e = { type: "Feature", geometry: { type: e, coordinates: s }, properties: this.properties }; return "id" in this && (e.id = this.id), e }; var pa = fa; function fa(t, e) { this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t, this._keys = [], this._values = [], this._features = [], t.readFields(da, this, e), this.length = this._features.length } function da(t, e, n) { 15 === t ? e.version = n.readVarint() : 1 === t ? e.name = n.readString() : 5 === t ? e.extent = n.readVarint() : 2 === t ? e._features.push(n.pos) : 3 === t ? e._keys.push(n.readString()) : 4 === t && e._values.push(function (t) { for (var e = null, n = t.readVarint() + t.pos; t.pos < n;)var i = t.readVarint() >> 3, e = 1 == i ? t.readString() : 2 == i ? t.readFloat() : 3 == i ? t.readDouble() : 4 == i ? t.readVarint64() : 5 == i ? t.readVarint() : 6 == i ? t.readSVarint() : 7 == i ? t.readBoolean() : null; return e }(n)) } function ma(t, e, n) { 3 !== t || (n = new pa(n, n.readVarint() + n.pos)).length && (e[n.name] = n) } fa.prototype.feature = function (t) { if (t < 0 || t >= this._features.length) throw new Error("feature index out of bounds"); this._pbf.pos = this._features[t]; t = this._pbf.readVarint() + this._pbf.pos; return new la(this._pbf, t, this.extent, this._keys, this._values) }; var ya = { VectorTile: function (t, e) { this.layers = t.readFields(ma, {}, e) }, VectorTileFeature: la, VectorTileLayer: pa }, ga = ya.VectorTileFeature.types, va = Math.cos(Math.PI / 180 * 37.5), _a = Math.pow(2, 14) / .5; function xa(t, e, n, i, r, o, a) { t.emplaceBack(e.x, e.y, i ? 1 : 0, r ? 1 : -1, Math.round(63 * n.x) + 128, Math.round(63 * n.y) + 128, 1 + (0 === o ? 0 : o < 0 ? -1 : 1) | (.5 * a & 63) << 2, .5 * a >> 6) } function ba(t) { this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(function (t) { return t.id }), this.index = t.index, this.layoutVertexArray = new _i, this.indexArray = new Hi, this.programConfigurations = new Lr(sa, t.layers, t.zoom), this.segments = new Ar } function wa(t, e) { return (t / e.tileTotal * (e.end - e.start) + e.start) * (_a - 1) } ba.prototype.populate = function (t, e) { for (var n = 0, i = t; n < i.length; n += 1) { var r = i[n], o = r.feature, a = r.index, s = r.sourceLayerIndex; this.layers[0]._featureFilter(new Bn(this.zoom), o) && (r = Br(o), this.addFeature(o, r, a), e.featureIndex.insert(o, r, a, s, this.index)) } }, ba.prototype.update = function (t, e) { this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers) }, ba.prototype.isEmpty = function () { return 0 === this.layoutVertexArray.length }, ba.prototype.uploadPending = function () { return !this.uploaded || this.programConfigurations.needsUpload }, ba.prototype.upload = function (t) { this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, sa), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0 }, ba.prototype.destroy = function () { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy()) }, ba.prototype.addFeature = function (t, e, n) { for (var i = this.layers[0].layout, r = i.get("line-join").evaluate(t, {}), o = i.get("line-cap"), a = i.get("line-miter-limit"), s = i.get("line-round-limit"), l = 0, u = e; l < u.length; l += 1) { var c = u[l]; this.addLine(c, t, r, o, a, s, n) } }, ba.prototype.addLine = function (t, e, n, i, r, o, a) { var s = null; e.properties && e.properties.hasOwnProperty("mapbox_clip_start") && e.properties.hasOwnProperty("mapbox_clip_end") && (s = { start: e.properties.mapbox_clip_start, end: e.properties.mapbox_clip_end, tileTotal: void 0 }); for (var l = "Polygon" === ga[e.type], u = t.length; 2 <= u && t[u - 1].equals(t[u - 2]);)u--; for (var c = 0; c < u - 1 && t[c].equals(t[c + 1]);)c++; if (!(u < (l ? 3 : 2))) { s && (s.tileTotal = function (t, e) { for (var n, i, r = 0, o = c; o < e - 1; o++)n = t[o], i = t[o + 1], r += n.dist(i); return r }(t, u)), "bevel" === n && (r = 1.05); var h, p, f, d = Dr / (512 * this.overscaling) * 15, m = t[c], y = this.segments.prepareSegment(10 * u, this.layoutVertexArray, this.indexArray), g = i, v = l ? "butt" : i, _ = !(this.distance = 0), x = void 0, b = void 0, w = void 0, E = void 0; this.e1 = this.e2 = this.e3 = -1, l && (h = t[u - 2], E = m.sub(h)._unit()._perp()); for (var S = c; S < u; S++)if (!(b = l && S === u - 1 ? t[c + 1] : t[S + 1]) || !t[S].equals(b)) { E && (w = E), h && (x = h), h = t[S], E = b ? b.sub(h)._unit()._perp() : w; var T = (w = w || E).add(E); 0 === T.x && 0 === T.y || T._unit(); var A = T.x * E.x + T.y * E.y, z = 0 != A ? 1 / A : 1 / 0, I = A < va && x && b; I && c < S && (2 * d < (M = h.dist(x)) && (k = h.sub(h.sub(x)._mult(d / M)._round()), this.distance += k.dist(x), this.addCurrentVertex(k, this.distance, w.mult(1), 0, 0, !1, y, s), x = k)); var k, C = x && b, M = C ? n : b ? g : v; if (C && "round" === M && (z < o ? M = "miter" : z <= 2 && (M = "fakeround")), "miter" === M && r < z && (M = "bevel"), "bevel" === M && (2 < z && (M = "flipbevel"), z < r && (M = "miter")), x && (this.distance += h.dist(x)), "miter" === M) T._mult(z), this.addCurrentVertex(h, this.distance, T, 0, 0, !1, y, s); else if ("flipbevel" === M) { 100 < z ? T = E.clone().mult(-1) : (k = 0 < w.x * E.y - w.y * E.x ? -1 : 1, C = z * w.add(E).mag() / w.sub(E).mag(), T._perp()._mult(C * k)), this.addCurrentVertex(h, this.distance, T, 0, 0, !1, y, s), this.addCurrentVertex(h, this.distance, T.mult(-1), 0, 0, !1, y, s) } else if ("bevel" === M || "fakeround" === M) { var P = 0 < w.x * E.y - w.y * E.x, z = -Math.sqrt(z * z - 1); if (P ? (f = 0, p = z) : (p = 0, f = z), _ || this.addCurrentVertex(h, this.distance, w, p, f, !1, y, s), "fakeround" === M) { for (var L = Math.floor(8 * (.5 - (A - .5))), D = void 0, R = 0; R < L; R++)D = E.mult((R + 1) / (L + 1))._add(w)._unit(), this.addPieSliceVertex(h, this.distance, D, P, y, s); this.addPieSliceVertex(h, this.distance, T, P, y, s); for (var B = L - 1; 0 <= B; B--)D = w.mult((B + 1) / (L + 1))._add(E)._unit(), this.addPieSliceVertex(h, this.distance, D, P, y, s) } b && this.addCurrentVertex(h, this.distance, E, -p, -f, !1, y, s) } else "butt" === M ? (_ || this.addCurrentVertex(h, this.distance, w, 0, 0, !1, y, s), b && this.addCurrentVertex(h, this.distance, E, 0, 0, !1, y, s)) : "square" === M ? (_ || (this.addCurrentVertex(h, this.distance, w, 1, 1, !1, y, s), this.e1 = this.e2 = -1), b && this.addCurrentVertex(h, this.distance, E, -1, -1, !1, y, s)) : "round" === M && (_ || (this.addCurrentVertex(h, this.distance, w, 0, 0, !1, y, s), this.addCurrentVertex(h, this.distance, w, 1, 1, !0, y, s), this.e1 = this.e2 = -1), b && (this.addCurrentVertex(h, this.distance, E, -1, -1, !0, y, s), this.addCurrentVertex(h, this.distance, E, 0, 0, !1, y, s))); I && S < u - 1 && (2 * d < (I = h.dist(b)) && (I = h.add(b.sub(h)._mult(d / I)._round()), this.distance += I.dist(h), this.addCurrentVertex(I, this.distance, E.mult(1), 0, 0, !1, y, s), h = I)), _ = !1 } this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, a) } }, ba.prototype.addCurrentVertex = function (t, e, n, i, r, o, a, s) { var l, u = this.layoutVertexArray, c = this.indexArray; s && (e = wa(e, s)), l = n.clone(), i && l._sub(n.perp()._mult(i)), xa(u, t, l, o, !1, i, e), this.e3 = a.vertexLength++, 0 <= this.e1 && 0 <= this.e2 && (c.emplaceBack(this.e1, this.e2, this.e3), a.primitiveLength++), this.e1 = this.e2, this.e2 = this.e3, l = n.mult(-1), r && l._sub(n.perp()._mult(r)), xa(u, t, l, o, !0, -r, e), this.e3 = a.vertexLength++, 0 <= this.e1 && 0 <= this.e2 && (c.emplaceBack(this.e1, this.e2, this.e3), a.primitiveLength++), this.e1 = this.e2, this.e2 = this.e3, _a / 2 < e && !s && (this.distance = 0, this.addCurrentVertex(t, this.distance, n, i, r, o, a)) }, ba.prototype.addPieSliceVertex = function (t, e, n, i, r, o) { n = n.mult(i ? -1 : 1); var a = this.layoutVertexArray, s = this.indexArray; o && (e = wa(e, o)), xa(a, t, n, !1, i, 0, e), this.e3 = r.vertexLength++, 0 <= this.e1 && 0 <= this.e2 && (s.emplaceBack(this.e1, this.e2, this.e3), r.primitiveLength++), i ? this.e2 = this.e3 : this.e1 = this.e3 }, In("LineBucket", ba, { omit: ["layers"] }); var Ea, oi = new ei({ "line-cap": new Yn(V.layout_line["line-cap"]), "line-join": new $n(V.layout_line["line-join"]), "line-miter-limit": new Yn(V.layout_line["line-miter-limit"]), "line-round-limit": new Yn(V.layout_line["line-round-limit"]) }), Sa = { paint: new ei({ "line-opacity": new $n(V.paint_line["line-opacity"]), "line-color": new $n(V.paint_line["line-color"]), "line-translate": new Yn(V.paint_line["line-translate"]), "line-translate-anchor": new Yn(V.paint_line["line-translate-anchor"]), "line-width": new $n(V.paint_line["line-width"]), "line-gap-width": new $n(V.paint_line["line-gap-width"]), "line-offset": new $n(V.paint_line["line-offset"]), "line-blur": new $n(V.paint_line["line-blur"]), "line-dasharray": new Qn(V.paint_line["line-dasharray"]), "line-pattern": new Qn(V.paint_line["line-pattern"]), "line-gradient": new ti(V.paint_line["line-gradient"]) }), layout: oi }, Ta = ((Ea = $n) && (Aa.__proto__ = Ea), ((Aa.prototype = Object.create(Ea && Ea.prototype)).constructor = Aa).prototype.possiblyEvaluate = function (t, e) { return e = new Bn(Math.floor(e.zoom), { now: e.now, fadeDuration: e.fadeDuration, zoomHistory: e.zoomHistory, transition: e.transition }), Ea.prototype.possiblyEvaluate.call(this, t, e) }, Aa.prototype.evaluate = function (t, e, n, i) { return e = c({}, e, { zoom: Math.floor(e.zoom) }), Ea.prototype.evaluate.call(this, t, e, n, i) }, new Aa(Sa.paint.properties["line-width"].specification)); function Aa() { Ea.apply(this, arguments) } Ta.useIntegerZoom = !0; var za, Jt = ((za = ii) && (Ia.__proto__ = za), ((Ia.prototype = Object.create(za && za.prototype)).constructor = Ia).prototype._handleSpecialPaintPropertyUpdate = function (t) { "line-gradient" === t && this._updateGradient() }, Ia.prototype._updateGradient = function () { var t = this._transitionablePaint._values["line-gradient"].value.expression; this.gradient = bo(t, "lineProgress"), this.gradientTexture = null }, Ia.prototype.recalculate = function (t) { za.prototype.recalculate.call(this, t), this.paint._values["line-floorwidth"] = Ta.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t) }, Ia.prototype.createBucket = function (t) { return new ba(t) }, Ia.prototype.queryRadius = function (t) { var e = t, t = ka(Wr("line-width", this, e), Wr("line-gap-width", this, e)), e = Wr("line-offset", this, e); return t / 2 + Math.abs(e) + Hr(this.paint.get("line-translate")) }, Ia.prototype.queryIntersectsFeature = function (t, e, n, i, r, o, a) { t = Kr(t, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), o.angle, a), o = a / 2 * ka(this.paint.get("line-width").evaluate(e, n), this.paint.get("line-gap-width").evaluate(e, n)), n = this.paint.get("line-offset").evaluate(e, n); return n && (i = function (t, e) { for (var n = [], i = new p(0, 0), r = 0; r < t.length; r++) { for (var o = t[r], a = [], s = 0; s < o.length; s++) { var l = o[s - 1], u = o[s], c = o[s + 1], l = 0 === s ? i : u.sub(l)._unit()._perp(), c = s === o.length - 1 ? i : c.sub(u)._unit()._perp(), l = l._add(c)._unit(), c = l.x * c.x + l.y * c.y; l._mult(1 / c), a.push(l._mult(e)._add(u)) } n.push(a) } return n }(i, n * a)), jr(t, i, o) }, Ia); function Ia(t) { za.call(this, t, Sa) } function ka(t, e) { return 0 < e ? e + 2 * t : t } var Ca = si([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }]), Ma = si([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4), Pa = (si([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4), si([{ name: "a_placed", components: 2, type: "Uint8" }], 4)), La = (si([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }, { type: "Int16", name: "radius" }, { type: "Int16", name: "signedDistanceFromAnchor" }]), si([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4)), Da = si([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4); function Ra(t, e, n) { n = e.layout.get("text-transform").evaluate(n, {}); return "uppercase" === n ? t = t.toLocaleUpperCase() : "lowercase" === n && (t = t.toLocaleLowerCase()), Un.applyArabicShaping && (t = Un.applyArabicShaping(t)), t } si([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "hidden" }]), si([{ type: "Float32", name: "offsetX" }]), si([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]); var Ba, Oa = { "!": "︕", "#": "＃", $: "＄", "%": "％", "&": "＆", "(": "︵", ")": "︶", "*": "＊", "+": "＋", ",": "︐", "-": "︲", ".": "・", "/": "／", ":": "︓", ";": "︔", "<": "︿", "=": "＝", ">": "﹀", "?": "︖", "@": "＠", "[": "﹇", "\\": "＼", "]": "﹈", "^": "＾", _: "︳", "`": "｀", "{": "︷", "|": "―", "}": "︸", "~": "～", "¢": "￠", "£": "￡", "¥": "￥", "¦": "￤", "¬": "￢", "¯": "￣", "–": "︲", "—": "︱", "‘": "﹃", "’": "﹄", "“": "﹁", "”": "﹂", "…": "︙", "‧": "・", "₩": "￦", "、": "︑", "。": "︒", "〈": "︿", "〉": "﹀", "《": "︽", "》": "︾", "「": "﹁", "」": "﹂", "『": "﹃", "』": "﹄", "【": "︻", "】": "︼", "〔": "︹", "〕": "︺", "〖": "︗", "〗": "︘", "！": "︕", "（": "︵", "）": "︶", "，": "︐", "－": "︲", "．": "・", "：": "︓", "；": "︔", "＜": "︿", "＞": "﹀", "？": "︖", "［": "﹇", "］": "﹈", "＿": "︳", "｛": "︷", "｜": "―", "｝": "︸", "｟": "︵", "｠": "︶", "｡": "︒", "｢": "﹁", "｣": "﹂" }, ti = ((Ba = p) && (Fa.__proto__ = Ba), ((Fa.prototype = Object.create(Ba && Ba.prototype)).constructor = Fa).prototype.clone = function () { return new Fa(this.x, this.y, this.angle, this.segment) }, Fa); function Fa(t, e, n, i) { Ba.call(this, t, e), this.angle = n, void 0 !== i && (this.segment = i) } function Va(t, e) { var n = e.expression; if ("constant" === n.kind) return { functionType: "constant", layoutSize: n.evaluate(new Bn(t + 1)) }; if ("source" === n.kind) return { functionType: "source" }; for (var i = n.zoomStops, r = 0; r < i.length && i[r] <= t;)r++; for (var o = r = Math.max(0, r - 1); o < i.length && i[o] < t + 1;)o++; o = Math.min(i.length - 1, o); var a = { min: i[r], max: i[o] }; return "composite" === n.kind ? { functionType: "composite", zoomRange: a, propertyValue: e.value } : { functionType: "camera", layoutSize: n.evaluate(new Bn(t + 1)), zoomRange: a, sizeRange: { min: n.evaluate(new Bn(a.min)), max: n.evaluate(new Bn(a.max)) }, propertyValue: e.value } } In("Anchor", ti); var Na = ya.VectorTileFeature.types, ja = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }]; function Ua(t, e, n, i, r, o, a, s) { t.emplaceBack(e, n, Math.round(32 * i), Math.round(32 * r), o, a, s ? s[0] : 0, s ? s[1] : 0) } function qa(t, e, n) { t.emplaceBack(e.x, e.y, n), t.emplaceBack(e.x, e.y, n), t.emplaceBack(e.x, e.y, n), t.emplaceBack(e.x, e.y, n) } function Za(t) { this.layoutVertexArray = new wi, this.indexArray = new Hi, this.programConfigurations = t, this.segments = new Ar, this.dynamicLayoutVertexArray = new Ti, this.opacityVertexArray = new Ii, this.placedSymbolArray = new hr } Za.prototype.upload = function (t, e, n, i) { n && (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Ca.members), this.indexBuffer = t.createIndexBuffer(this.indexArray, e), this.dynamicLayoutVertexBuffer = t.createVertexBuffer(this.dynamicLayoutVertexArray, Ma.members, !0), this.opacityVertexBuffer = t.createVertexBuffer(this.opacityVertexArray, ja, !0), this.opacityVertexBuffer.itemSize = 1), (n || i) && this.programConfigurations.upload(t) }, Za.prototype.destroy = function () { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy()) }, In("SymbolBuffers", Za); function Ga(t, e, n) { this.layoutVertexArray = new t, this.layoutAttributes = e, this.indexArray = new n, this.segments = new Ar, this.collisionVertexArray = new Bi } Ga.prototype.upload = function (t) { this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t.createVertexBuffer(this.collisionVertexArray, Pa.members, !0) }, Ga.prototype.destroy = function () { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy()) }, In("CollisionBuffers", Ga); function Xa(t) { this.collisionBoxArray = t.collisionBoxArray, this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(function (t) { return t.id }), this.index = t.index, this.pixelRatio = t.pixelRatio, this.sourceLayerIndex = t.sourceLayerIndex; var e = this.layers[0]._unevaluatedLayout._values; this.textSizeData = Va(this.zoom, e["text-size"]), this.iconSizeData = Va(this.zoom, e["icon-size"]), e = this.layers[0].layout, this.sortFeaturesByY = e.get("text-allow-overlap") || e.get("icon-allow-overlap") || e.get("text-ignore-placement") || e.get("icon-ignore-placement"), this.sourceID = t.sourceID } Xa.prototype.createArrays = function () { this.text = new Za(new Lr(Ca.members, this.layers, this.zoom, function (t) { return /^text/.test(t) })), this.icon = new Za(new Lr(Ca.members, this.layers, this.zoom, function (t) { return /^icon/.test(t) })), this.collisionBox = new Ga(Li, La.members, Yi), this.collisionCircle = new Ga(Li, Da.members, Hi), this.glyphOffsetArray = new mr, this.lineVertexArray = new _r }, Xa.prototype.calculateGlyphDependencies = function (t, e, n, i) { for (var r, o = 0; o < t.length; o++) { e[t.charCodeAt(o)] = !0, n && i && (r = Oa[t.charAt(o)]) && (e[r.charCodeAt(0)] = !0) } }, Xa.prototype.populate = function (t, e) { var n = this.layers[0], i = n.layout, r = i.get("text-font"), o = i.get("text-field"), a = i.get("icon-image"), s = ("constant" !== o.value.kind || 0 < o.value.value.toString().length) && ("constant" !== r.value.kind || 0 < r.value.value.length), l = "constant" !== a.value.kind || a.value.value && 0 < a.value.value.length; if (this.features = [], s || l) { for (var u = e.iconDependencies, c = e.glyphDependencies, h = new Bn(this.zoom), p = 0, f = t; p < f.length; p += 1) { var d = f[p], m = d.feature, y = d.index, g = d.sourceLayerIndex; if (n._featureFilter(h, m)) { var v = void 0; s && (v = function (t, e, n) { return t instanceof mt ? (t.sections.forEach(function (t) { t.text = Ra(t.text, e, n) }), t) : Ra(t, e, n) }(v = n.getValueAndResolveTokens("text-field", m), n, m)); d = void 0; if (l && (d = n.getValueAndResolveTokens("icon-image", m)), v || d) { g = { text: v, icon: d, index: y, sourceLayerIndex: g, geometry: Br(m), properties: m.properties, type: Na[m.type] }; if (void 0 !== m.id && (g.id = m.id), this.features.push(g), d && (u[d] = !0), v) { var _ = r.evaluate(m, {}).join(","), d = c[_] = c[_] || {}, x = "map" === i.get("text-rotation-alignment") && "point" !== i.get("symbol-placement"); if (v instanceof mt) for (var b = 0, w = v.sections; b < w.length; b += 1) { var E = w[b], S = Ln(v.toString()), T = E.fontStack || _, T = c[T] = c[T] || {}; this.calculateGlyphDependencies(E.text, T, x, S) } else { m = Ln(v); this.calculateGlyphDependencies(v, d, x, m) } } } } } "line" === i.get("symbol-placement") && (this.features = function (e) { var r = {}, o = {}, a = [], n = 0; function t(t) { a.push(e[t]), n++ } function i(t, e, n) { var i = o[t]; return delete o[t], o[e] = i, a[i].geometry[0].pop(), a[i].geometry[0] = a[i].geometry[0].concat(n[0]), i } function s(t, e, n) { var i = r[e]; return delete r[e], r[t] = i, a[i].geometry[0].shift(), a[i].geometry[0] = n[0].concat(a[i].geometry[0]), i } function l(t, e, n) { e = n ? e[0][e[0].length - 1] : e[0][0]; return t + ":" + e.x + ":" + e.y } for (var u = 0; u < e.length; u++) { var c, h, p, f = e[u], d = f.geometry, m = f.text instanceof mt ? f.text.toString() : f.text; m ? (c = l(m, d), h = l(m, d, !0), c in o && h in r && o[c] !== r[h] ? (p = s(c, h, d), f = i(c, h, a[p].geometry), delete r[c], delete o[h], o[l(m, a[f].geometry, !0)] = f, a[p].geometry = null) : c in o ? i(c, h, d) : h in r ? s(c, h, d) : (t(u), r[c] = n - 1, o[h] = n - 1)) : t(u) } return a.filter(function (t) { return t.geometry }) }(this.features)) } }, Xa.prototype.update = function (t, e) { this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t, e, this.layers), this.icon.programConfigurations.updatePaintArrays(t, e, this.layers)) }, Xa.prototype.isEmpty = function () { return 0 === this.symbolInstances.length }, Xa.prototype.uploadPending = function () { return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload }, Xa.prototype.upload = function (t) { this.uploaded || (this.collisionBox.upload(t), this.collisionCircle.upload(t)), this.text.upload(t, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0 }, Xa.prototype.destroy = function () { this.text.destroy(), this.icon.destroy(), this.collisionBox.destroy(), this.collisionCircle.destroy() }, Xa.prototype.addToLineVertexArray = function (t, e) { var n = this.lineVertexArray.length; if (void 0 !== t.segment) { for (var i = t.dist(e[t.segment + 1]), r = t.dist(e[t.segment]), o = {}, a = t.segment + 1; a < e.length; a++)o[a] = { x: e[a].x, y: e[a].y, tileUnitDistanceFromAnchor: i }, a < e.length - 1 && (i += e[a + 1].dist(e[a])); for (var s = t.segment || 0; 0 <= s; s--)o[s] = { x: e[s].x, y: e[s].y, tileUnitDistanceFromAnchor: r }, 0 < s && (r += e[s - 1].dist(e[s])); for (var l = 0; l < e.length; l++) { var u = o[l]; this.lineVertexArray.emplaceBack(u.x, u.y, u.tileUnitDistanceFromAnchor) } } return { lineStartIndex: n, lineLength: this.lineVertexArray.length - n } }, Xa.prototype.addSymbols = function (t, e, n, i, r, o, a, s, l, u) { for (var c = t.indexArray, h = t.layoutVertexArray, p = t.dynamicLayoutVertexArray, f = t.segments.prepareSegment(4 * e.length, t.layoutVertexArray, t.indexArray), d = this.glyphOffsetArray.length, m = f.vertexLength, y = 0, g = e; y < g.length; y += 1) { var v = g[y], _ = v.tl, x = v.tr, b = v.bl, w = v.br, E = v.tex, S = f.vertexLength, T = v.glyphOffset[1]; Ua(h, s.x, s.y, _.x, T + _.y, E.x, E.y, n), Ua(h, s.x, s.y, x.x, T + x.y, E.x + E.w, E.y, n), Ua(h, s.x, s.y, b.x, T + b.y, E.x, E.y + E.h, n), Ua(h, s.x, s.y, w.x, T + w.y, E.x + E.w, E.y + E.h, n), qa(p, s, 0), c.emplaceBack(S, S + 1, S + 2), c.emplaceBack(S + 1, S + 2, S + 3), f.vertexLength += 4, f.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(v.glyphOffset[0]) } t.placedSymbolArray.emplaceBack(s.x, s.y, d, this.glyphOffsetArray.length - d, m, l, u, s.segment, n ? n[0] : 0, n ? n[1] : 0, i[0], i[1], a, !1), t.programConfigurations.populatePaintArrays(t.layoutVertexArray.length, o, o.index) }, Xa.prototype._addCollisionDebugVertex = function (t, e, n, i, r) { return e.emplaceBack(0, 0), t.emplaceBack(n.x, n.y, i.x, i.y, Math.round(r.x), Math.round(r.y)) }, Xa.prototype.addCollisionDebugVertices = function (t, e, n, i, r, o, a, s) { var l = r.segments.prepareSegment(4, r.layoutVertexArray, r.indexArray), u = l.vertexLength, c = r.layoutVertexArray, h = r.collisionVertexArray; this._addCollisionDebugVertex(c, h, o, a.anchor, new p(t, e)), this._addCollisionDebugVertex(c, h, o, a.anchor, new p(n, e)), this._addCollisionDebugVertex(c, h, o, a.anchor, new p(n, i)), this._addCollisionDebugVertex(c, h, o, a.anchor, new p(t, i)), l.vertexLength += 4, s ? ((s = r.indexArray).emplaceBack(u, u + 1, u + 2), s.emplaceBack(u, u + 2, u + 3), l.primitiveLength += 2) : ((r = r.indexArray).emplaceBack(u, u + 1), r.emplaceBack(u + 1, u + 2), r.emplaceBack(u + 2, u + 3), r.emplaceBack(u + 3, u), l.primitiveLength += 4) }, Xa.prototype.generateCollisionDebugBuffers = function () { for (var t = 0, e = this.symbolInstances; t < e.length; t += 1) { var n = e[t]; n.textCollisionFeature = { boxStartIndex: n.textBoxStartIndex, boxEndIndex: n.textBoxEndIndex }, n.iconCollisionFeature = { boxStartIndex: n.iconBoxStartIndex, boxEndIndex: n.iconBoxEndIndex }; for (var i = 0; i < 2; i++) { var r = n[0 === i ? "textCollisionFeature" : "iconCollisionFeature"]; if (r) for (var o = r.boxStartIndex; o < r.boxEndIndex; o++) { var a = this.collisionBoxArray.get(o), s = a.x1, l = a.y1, u = a.x2, c = a.y2, h = 0 < a.radius; this.addCollisionDebugVertices(s, l, u, c, h ? this.collisionCircle : this.collisionBox, a.anchorPoint, n, h) } } } }, Xa.prototype.deserializeCollisionBoxes = function (t, e, n, i, r) { for (var o = {}, a = e; a < n; a++) { var s = t.get(a); if (0 === s.radius) { o.textBox = { x1: s.x1, y1: s.y1, x2: s.x2, y2: s.y2, anchorPointX: s.anchorPointX, anchorPointY: s.anchorPointY }, o.textFeatureIndex = s.featureIndex; break } o.textCircles || (o.textCircles = [], o.textFeatureIndex = s.featureIndex), o.textCircles.push(s.anchorPointX, s.anchorPointY, s.radius, s.signedDistanceFromAnchor, 1) } for (var l = i; l < r; l++) { var u = t.get(l); if (0 === u.radius) { o.iconBox = { x1: u.x1, y1: u.y1, x2: u.x2, y2: u.y2, anchorPointX: u.anchorPointX, anchorPointY: u.anchorPointY }, o.iconFeatureIndex = u.featureIndex; break } } return o }, Xa.prototype.hasTextData = function () { return 0 < this.text.segments.get().length }, Xa.prototype.hasIconData = function () { return 0 < this.icon.segments.get().length }, Xa.prototype.hasCollisionBoxData = function () { return 0 < this.collisionBox.segments.get().length }, Xa.prototype.hasCollisionCircleData = function () { return 0 < this.collisionCircle.segments.get().length }, Xa.prototype.sortFeatures = function (t) { var n = this; if (this.sortFeaturesByY && this.sortedAngle !== t && (this.sortedAngle = t, !(1 < this.text.segments.get().length || 1 < this.icon.segments.get().length))) { for (var e = [], i = 0; i < this.symbolInstances.length; i++)e.push(i); var r = Math.sin(t), o = Math.cos(t); e.sort(function (t, e) { t = n.symbolInstances[t], e = n.symbolInstances[e]; return (0 | Math.round(r * t.anchor.x + o * t.anchor.y)) - (0 | Math.round(r * e.anchor.x + o * e.anchor.y)) || e.featureIndex - t.featureIndex }), this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = []; for (var a = 0, s = e; a < s.length; a += 1) { var l = s[a], u = n.symbolInstances[l]; n.featureSortOrder.push(u.featureIndex); for (var c = 0, h = u.placedTextSymbolIndices; c < h.length; c += 1)for (var p = h[c], p = n.text.placedSymbolArray.get(p), f = p.vertexStartIndex + 4 * p.numGlyphs, d = p.vertexStartIndex; d < f; d += 4)n.text.indexArray.emplaceBack(d, d + 1, d + 2), n.text.indexArray.emplaceBack(d + 1, d + 2, d + 3); l = n.icon.placedSymbolArray.get(l); l.numGlyphs && (l = l.vertexStartIndex, n.icon.indexArray.emplaceBack(l, l + 1, l + 2), n.icon.indexArray.emplaceBack(l + 1, l + 2, l + 3)) } this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray) } }, In("SymbolBucket", Xa, { omit: ["layers", "collisionBoxArray", "features", "compareText"], shallow: ["symbolInstances"] }), Xa.MAX_GLYPHS = 65535, Xa.addDynamicAttributes = qa; var Wa, Ha, Ka, oi = new ei({ "symbol-placement": new Yn(V.layout_symbol["symbol-placement"]), "symbol-spacing": new Yn(V.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new Yn(V.layout_symbol["symbol-avoid-edges"]), "icon-allow-overlap": new Yn(V.layout_symbol["icon-allow-overlap"]), "icon-ignore-placement": new Yn(V.layout_symbol["icon-ignore-placement"]), "icon-optional": new Yn(V.layout_symbol["icon-optional"]), "icon-rotation-alignment": new Yn(V.layout_symbol["icon-rotation-alignment"]), "icon-size": new $n(V.layout_symbol["icon-size"]), "icon-text-fit": new Yn(V.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new Yn(V.layout_symbol["icon-text-fit-padding"]), "icon-image": new $n(V.layout_symbol["icon-image"]), "icon-rotate": new $n(V.layout_symbol["icon-rotate"]), "icon-padding": new Yn(V.layout_symbol["icon-padding"]), "icon-keep-upright": new Yn(V.layout_symbol["icon-keep-upright"]), "icon-offset": new $n(V.layout_symbol["icon-offset"]), "icon-anchor": new $n(V.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new Yn(V.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new Yn(V.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new Yn(V.layout_symbol["text-rotation-alignment"]), "text-field": new $n(V.layout_symbol["text-field"]), "text-font": new $n(V.layout_symbol["text-font"]), "text-size": new $n(V.layout_symbol["text-size"]), "text-max-width": new $n(V.layout_symbol["text-max-width"]), "text-line-height": new Yn(V.layout_symbol["text-line-height"]), "text-letter-spacing": new $n(V.layout_symbol["text-letter-spacing"]), "text-justify": new $n(V.layout_symbol["text-justify"]), "text-anchor": new $n(V.layout_symbol["text-anchor"]), "text-max-angle": new Yn(V.layout_symbol["text-max-angle"]), "text-rotate": new $n(V.layout_symbol["text-rotate"]), "text-padding": new Yn(V.layout_symbol["text-padding"]), "text-keep-upright": new Yn(V.layout_symbol["text-keep-upright"]), "text-transform": new $n(V.layout_symbol["text-transform"]), "text-offset": new $n(V.layout_symbol["text-offset"]), "text-allow-overlap": new Yn(V.layout_symbol["text-allow-overlap"]), "text-ignore-placement": new Yn(V.layout_symbol["text-ignore-placement"]), "text-optional": new Yn(V.layout_symbol["text-optional"]) }), Ja = { paint: new ei({ "icon-opacity": new $n(V.paint_symbol["icon-opacity"]), "icon-color": new $n(V.paint_symbol["icon-color"]), "icon-halo-color": new $n(V.paint_symbol["icon-halo-color"]), "icon-halo-width": new $n(V.paint_symbol["icon-halo-width"]), "icon-halo-blur": new $n(V.paint_symbol["icon-halo-blur"]), "icon-translate": new Yn(V.paint_symbol["icon-translate"]), "icon-translate-anchor": new Yn(V.paint_symbol["icon-translate-anchor"]), "text-opacity": new $n(V.paint_symbol["text-opacity"]), "text-color": new $n(V.paint_symbol["text-color"]), "text-halo-color": new $n(V.paint_symbol["text-halo-color"]), "text-halo-width": new $n(V.paint_symbol["text-halo-width"]), "text-halo-blur": new $n(V.paint_symbol["text-halo-blur"]), "text-translate": new Yn(V.paint_symbol["text-translate"]), "text-translate-anchor": new Yn(V.paint_symbol["text-translate-anchor"]) }), layout: oi }, oi = ((Ka = ii) && (ns.__proto__ = Ka), ((ns.prototype = Object.create(Ka && Ka.prototype)).constructor = ns).prototype.recalculate = function (t) { Ka.prototype.recalculate.call(this, t), "auto" === this.layout.get("icon-rotation-alignment") && ("point" !== this.layout.get("symbol-placement") ? this.layout._values["icon-rotation-alignment"] = "map" : this.layout._values["icon-rotation-alignment"] = "viewport"), "auto" === this.layout.get("text-rotation-alignment") && ("point" !== this.layout.get("symbol-placement") ? this.layout._values["text-rotation-alignment"] = "map" : this.layout._values["text-rotation-alignment"] = "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")) }, ns.prototype.getValueAndResolveTokens = function (t, e) { var n, i = this.layout.get(t).evaluate(e, {}), t = this._unevaluatedLayout._values[t]; return t.isDataDriven() || De(t.value) ? i : (n = e.properties, i.replace(/{([^{}]+)}/g, function (t, e) { return e in n ? String(n[e]) : "" })) }, ns.prototype.createBucket = function (t) { return new Xa(t) }, ns.prototype.queryRadius = function () { return 0 }, ns.prototype.queryIntersectsFeature = function () { return !1 }, ns), Ya = { paint: new ei({ "background-color": new Yn(V.paint_background["background-color"]), "background-pattern": new Qn(V.paint_background["background-pattern"]), "background-opacity": new Yn(V.paint_background["background-opacity"]) }) }, Qn = ((Ha = ii) && (es.__proto__ = Ha), (es.prototype = Object.create(Ha && Ha.prototype)).constructor = es), $a = { paint: new ei({ "raster-opacity": new Yn(V.paint_raster["raster-opacity"]), "raster-hue-rotate": new Yn(V.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new Yn(V.paint_raster["raster-brightness-min"]), "raster-brightness-max": new Yn(V.paint_raster["raster-brightness-max"]), "raster-saturation": new Yn(V.paint_raster["raster-saturation"]), "raster-contrast": new Yn(V.paint_raster["raster-contrast"]), "raster-resampling": new Yn(V.paint_raster["raster-resampling"]), "raster-fade-duration": new Yn(V.paint_raster["raster-fade-duration"]) }) }, Qa = { circle: Ht, heatmap: Kt, hillshade: Yt, fill: Qt, "fill-extrusion": w, line: Jt, symbol: oi, background: Qn, raster: ((Wa = ii) && (ts.__proto__ = Wa), (ts.prototype = Object.create(Wa && Wa.prototype)).constructor = ts) }; function ts(t) { Wa.call(this, t, $a) } function es(t) { Ha.call(this, t, Ya) } function ns(t) { Ka.call(this, t, Ja) } function is(t, e, n) { n = n || {}, this.w = t || 64, this.h = e || 64, this.autoResize = !!n.autoResize, this.shelves = [], this.freebins = [], this.stats = {}, this.bins = {}, this.maxId = 0 } function rs(t, e, n) { this.x = 0, this.y = t, this.w = this.free = e, this.h = n } is.prototype.pack = function (t, e) { t = [].concat(t), e = e || {}; for (var n, i, r, o = [], a = 0; a < t.length; a++)if (n = t[a].w || t[a].width, i = t[a].h || t[a].height, r = t[a].id, n && i) { if (!(r = this.packOne(n, i, r))) continue; e.inPlace && (t[a].x = r.x, t[a].y = r.y, t[a].id = r.id), o.push(r) } return this.shrink(), o }, is.prototype.packOne = function (t, e, n) { var i, r, o, a, s, l, u, c, h = { freebin: -1, shelf: -1, waste: 1 / 0 }, p = 0; if ("string" == typeof n || "number" == typeof n) { if (i = this.getBin(n)) return this.ref(i), i; "number" == typeof n && (this.maxId = Math.max(n, this.maxId)) } else n = ++this.maxId; for (a = 0; a < this.freebins.length; a++) { if (e === (i = this.freebins[a]).maxh && t === i.maxw) return this.allocFreebin(a, t, e, n); e > i.maxh || t > i.maxw || e <= i.maxh && t <= i.maxw && (o = i.maxw * i.maxh - t * e) < h.waste && (h.waste = o, h.freebin = a) } for (a = 0; a < this.shelves.length; a++)if (p += (r = this.shelves[a]).h, !(t > r.free)) { if (e === r.h) return this.allocShelf(a, t, e, n); e > r.h || e < r.h && (o = (r.h - e) * t) < h.waste && (h.freebin = -1, h.waste = o, h.shelf = a) } return -1 !== h.freebin ? this.allocFreebin(h.freebin, t, e, n) : -1 !== h.shelf ? this.allocShelf(h.shelf, t, e, n) : e <= this.h - p && t <= this.w ? (r = new rs(p, this.w, e), this.allocShelf(this.shelves.push(r) - 1, t, e, n)) : this.autoResize ? (s = l = this.h, ((u = c = this.w) <= s || u < t) && (c = 2 * Math.max(t, u)), (s < u || s < e) && (l = 2 * Math.max(e, s)), this.resize(c, l), this.packOne(t, e, n)) : null }, is.prototype.allocFreebin = function (t, e, n, i) { t = this.freebins.splice(t, 1)[0]; return t.id = i, t.w = e, t.h = n, t.refcount = 0, this.bins[i] = t, this.ref(t), t }, is.prototype.allocShelf = function (t, e, n, i) { n = this.shelves[t].alloc(e, n, i); return this.bins[i] = n, this.ref(n), n }, is.prototype.shrink = function () { if (0 < this.shelves.length) { for (var t = 0, e = 0, n = 0; n < this.shelves.length; n++) { var i = this.shelves[n]; e += i.h, t = Math.max(i.w - i.free, t) } this.resize(t, e) } }, is.prototype.getBin = function (t) { return this.bins[t] }, is.prototype.ref = function (t) { var e; return 1 == ++t.refcount && (e = t.h, this.stats[e] = 1 + (0 | this.stats[e])), t.refcount }, is.prototype.unref = function (t) { return 0 === t.refcount ? 0 : (0 == --t.refcount && (this.stats[t.h]--, delete this.bins[t.id], this.freebins.push(t)), t.refcount) }, is.prototype.clear = function () { this.shelves = [], this.freebins = [], this.stats = {}, this.bins = {}, this.maxId = 0 }, is.prototype.resize = function (t, e) { this.w = t, this.h = e; for (var n = 0; n < this.shelves.length; n++)this.shelves[n].resize(t); return !0 }, rs.prototype.alloc = function (t, e, s) { if (t > this.free || e > this.h) return null; var n = this.x; return this.x += t, this.free -= t, new function (t, e, n, i, r, o, a) { this.id = s, this.x = e, this.y = n, this.w = i, this.h = r, this.maxw = o || i, this.maxh = a || r, this.refcount = 0 }(0, n, this.y, t, e, t, this.h) }, rs.prototype.resize = function (t) { return this.free += t - this.w, this.w = t, !0 }; function os(t, e) { e = e.pixelRatio, this.paddedRect = t, this.pixelRatio = e } Kt = { tl: { configurable: !0 }, br: { configurable: !0 }, displaySize: { configurable: !0 } }; Kt.tl.get = function () { return [this.paddedRect.x + 1, this.paddedRect.y + 1] }, Kt.br.get = function () { return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1] }, Kt.displaySize.get = function () { return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio] }, Object.defineProperties(os.prototype, Kt); Yt = function (t) { var e, n = {}, i = new is(0, 0, { autoResize: !0 }), r = []; for (e in t) { var o = t[e], a = { x: 0, y: 0, w: o.data.width + 2, h: o.data.height + 2 }; r.push(a), n[e] = new os(a, o) } i.pack(r, { inPlace: !0 }); var s, l = new _o({ width: i.w, height: i.h }); for (s in t) { var u = t[s], c = n[s].paddedRect; _o.copy(u.data, l, { x: 0, y: 0 }, { x: c.x + 1, y: c.y + 1 }, u.data) } this.image = l, this.positions = n }; In("ImagePosition", os), In("ImageAtlas", Yt); function as(t, e, n, i) { this.context = t, this.format = n, this.texture = t.gl.createTexture(), this.update(e, i) } var ss = self.HTMLImageElement, ls = self.HTMLCanvasElement, us = self.HTMLVideoElement, cs = self.ImageData; as.prototype.update = function (t, e) { var n = t.width, i = t.height, r = !this.size || this.size[0] !== n || this.size[1] !== i, o = this.context, a = o.gl; this.useMipmap = Boolean(e && e.useMipmap), a.bindTexture(a.TEXTURE_2D, this.texture), r ? (this.size = [n, i], o.pixelStoreUnpack.set(1), this.format !== a.RGBA || e && !1 === e.premultiply || o.pixelStoreUnpackPremultiplyAlpha.set(!0), t instanceof ss || t instanceof ls || t instanceof us || t instanceof cs ? a.texImage2D(a.TEXTURE_2D, 0, this.format, this.format, a.UNSIGNED_BYTE, t) : a.texImage2D(a.TEXTURE_2D, 0, this.format, n, i, 0, this.format, a.UNSIGNED_BYTE, t.data)) : t instanceof ss || t instanceof ls || t instanceof us || t instanceof cs ? a.texSubImage2D(a.TEXTURE_2D, 0, 0, 0, a.RGBA, a.UNSIGNED_BYTE, t) : a.texSubImage2D(a.TEXTURE_2D, 0, 0, 0, n, i, a.RGBA, a.UNSIGNED_BYTE, t.data), this.useMipmap && this.isSizePowerOfTwo() && a.generateMipmap(a.TEXTURE_2D) }, as.prototype.bind = function (t, e, n) { var i = this.context.gl; i.bindTexture(i.TEXTURE_2D, this.texture), n !== i.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (n = i.LINEAR), t !== this.filter && (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, t), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, n || t), this.filter = t), e !== this.wrap && (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, e), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, e), this.wrap = e) }, as.prototype.isSizePowerOfTwo = function () { return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0 }, as.prototype.destroy = function () { this.context.gl.deleteTexture(this.texture), this.texture = null }; function hs(t, e, n, i, r) { var o, a, s = 8 * r - i - 1, l = (1 << s) - 1, u = l >> 1, c = -7, h = n ? r - 1 : 0, p = n ? -1 : 1, n = t[e + h]; for (h += p, o = n & (1 << -c) - 1, n >>= -c, c += s; 0 < c; o = 256 * o + t[e + h], h += p, c -= 8); for (a = o & (1 << -c) - 1, o >>= -c, c += i; 0 < c; a = 256 * a + t[e + h], h += p, c -= 8); if (0 === o) o = 1 - u; else { if (o === l) return a ? NaN : 1 / 0 * (n ? -1 : 1); a += Math.pow(2, i), o -= u } return (n ? -1 : 1) * a * Math.pow(2, o - i) } function ps(t, e, n, i, r, o) { var a, s, l = 8 * o - r - 1, u = (1 << l) - 1, c = u >> 1, h = 23 === r ? Math.pow(2, -24) - Math.pow(2, -77) : 0, p = i ? 0 : o - 1, f = i ? 1 : -1, o = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0; for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (s = isNaN(e) ? 1 : 0, a = u) : (a = Math.floor(Math.log(e) / Math.LN2), e * (i = Math.pow(2, -a)) < 1 && (a--, i *= 2), 2 <= (e += 1 <= a + c ? h / i : h * Math.pow(2, 1 - c)) * i && (a++, i /= 2), u <= a + c ? (s = 0, a = u) : 1 <= a + c ? (s = (e * i - 1) * Math.pow(2, r), a += c) : (s = e * Math.pow(2, c - 1) * Math.pow(2, r), a = 0)); 8 <= r; t[n + p] = 255 & s, p += f, s /= 256, r -= 8); for (a = a << r | s, l += r; 0 < l; t[n + p] = 255 & a, p += f, a /= 256, l -= 8); t[n + p - f] |= 128 * o } var fs = ds; function ds(t) { this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t) ? t : new Uint8Array(t || 0), this.pos = 0, this.type = 0, this.length = this.buf.length } function ms(t) { return t.type === ds.Bytes ? t.readVarint() + t.pos : t.pos + 1 } function ys(t, e, n) { return n ? 4294967296 * e + (t >>> 0) : 4294967296 * (e >>> 0) + (t >>> 0) } function gs(t, e, n) { var i = e <= 16383 ? 1 : e <= 2097151 ? 2 : e <= 268435455 ? 3 : Math.ceil(Math.log(e) / (7 * Math.LN2)); n.realloc(i); for (var r = n.pos - 1; t <= r; r--)n.buf[r + i] = n.buf[r] } function vs(t, e) { for (var n = 0; n < t.length; n++)e.writeVarint(t[n]) } function _s(t, e) { for (var n = 0; n < t.length; n++)e.writeSVarint(t[n]) } function xs(t, e) { for (var n = 0; n < t.length; n++)e.writeFloat(t[n]) } function bs(t, e) { for (var n = 0; n < t.length; n++)e.writeDouble(t[n]) } function ws(t, e) { for (var n = 0; n < t.length; n++)e.writeBoolean(t[n]) } function Es(t, e) { for (var n = 0; n < t.length; n++)e.writeFixed32(t[n]) } function Ss(t, e) { for (var n = 0; n < t.length; n++)e.writeSFixed32(t[n]) } function Ts(t, e) { for (var n = 0; n < t.length; n++)e.writeFixed64(t[n]) } function As(t, e) { for (var n = 0; n < t.length; n++)e.writeSFixed64(t[n]) } function zs(t, e) { return (t[e] | t[e + 1] << 8 | t[e + 2] << 16) + 16777216 * t[e + 3] } function Is(t, e, n) { t[n] = e, t[n + 1] = e >>> 8, t[n + 2] = e >>> 16, t[n + 3] = e >>> 24 } function ks(t, e) { return (t[e] | t[e + 1] << 8 | t[e + 2] << 16) + (t[e + 3] << 24) } ds.Varint = 0, ds.Fixed64 = 1, ds.Bytes = 2, ds.Fixed32 = 5, ds.prototype = { destroy: function () { this.buf = null }, readFields: function (t, e, n) { for (n = n || this.length; this.pos < n;) { var i = this.readVarint(), r = i >> 3, o = this.pos; this.type = 7 & i, t(r, e, this), this.pos === o && this.skip(i) } return e }, readMessage: function (t, e) { return this.readFields(t, e, this.readVarint() + this.pos) }, readFixed32: function () { var t = zs(this.buf, this.pos); return this.pos += 4, t }, readSFixed32: function () { var t = ks(this.buf, this.pos); return this.pos += 4, t }, readFixed64: function () { var t = zs(this.buf, this.pos) + 4294967296 * zs(this.buf, this.pos + 4); return this.pos += 8, t }, readSFixed64: function () { var t = zs(this.buf, this.pos) + 4294967296 * ks(this.buf, this.pos + 4); return this.pos += 8, t }, readFloat: function () { var t = hs(this.buf, this.pos, !0, 23, 4); return this.pos += 4, t }, readDouble: function () { var t = hs(this.buf, this.pos, !0, 52, 8); return this.pos += 8, t }, readVarint: function (t) { var e, n = this.buf, i = 127 & (e = n[this.pos++]); return e < 128 ? i : (i |= (127 & (e = n[this.pos++])) << 7, e < 128 ? i : (i |= (127 & (e = n[this.pos++])) << 14, e < 128 ? i : (i |= (127 & (e = n[this.pos++])) << 21, e < 128 ? i : function (t, e, n) { var i = n.buf, r = i[n.pos++], o = (112 & r) >> 4; if (r < 128) return ys(t, o, e); if (o |= (127 & (r = i[n.pos++])) << 3, r < 128) return ys(t, o, e); if (o |= (127 & (r = i[n.pos++])) << 10, r < 128) return ys(t, o, e); if (o |= (127 & (r = i[n.pos++])) << 17, r < 128) return ys(t, o, e); if (o |= (127 & (r = i[n.pos++])) << 24, r < 128) return ys(t, o, e); if (o |= (1 & (r = i[n.pos++])) << 31, r < 128) return ys(t, o, e); throw new Error("Expected varint not more than 10 bytes") }(i |= (15 & n[this.pos]) << 28, t, this)))) }, readVarint64: function () { return this.readVarint(!0) }, readSVarint: function () { var t = this.readVarint(); return t % 2 == 1 ? (t + 1) / -2 : t / 2 }, readBoolean: function () { return Boolean(this.readVarint()) }, readString: function () { var t = this.readVarint() + this.pos, e = function (t, e, n) { for (var i = "", r = e; r < n;) { var o, a, s, l = t[r], u = null, c = 239 < l ? 4 : 223 < l ? 3 : 191 < l ? 2 : 1; if (n < r + c) break; 1 === c ? l < 128 && (u = l) : 2 === c ? 128 == (192 & (o = t[r + 1])) && (u = (31 & l) << 6 | 63 & o) <= 127 && (u = null) : 3 === c ? (o = t[r + 1], a = t[r + 2], 128 == (192 & o) && 128 == (192 & a) && ((u = (15 & l) << 12 | (63 & o) << 6 | 63 & a) <= 2047 || 55296 <= u && u <= 57343) && (u = null)) : 4 === c && (o = t[r + 1], a = t[r + 2], s = t[r + 3], 128 == (192 & o) && 128 == (192 & a) && 128 == (192 & s) && ((u = (15 & l) << 18 | (63 & o) << 12 | (63 & a) << 6 | 63 & s) <= 65535 || 1114112 <= u) && (u = null)), null === u ? (u = 65533, c = 1) : 65535 < u && (u -= 65536, i += String.fromCharCode(u >>> 10 & 1023 | 55296), u = 56320 | 1023 & u), i += String.fromCharCode(u), r += c } return i }(this.buf, this.pos, t); return this.pos = t, e }, readBytes: function () { var t = this.readVarint() + this.pos, e = this.buf.subarray(this.pos, t); return this.pos = t, e }, readPackedVarint: function (t, e) { var n = ms(this); for (t = t || []; this.pos < n;)t.push(this.readVarint(e)); return t }, readPackedSVarint: function (t) { var e = ms(this); for (t = t || []; this.pos < e;)t.push(this.readSVarint()); return t }, readPackedBoolean: function (t) { var e = ms(this); for (t = t || []; this.pos < e;)t.push(this.readBoolean()); return t }, readPackedFloat: function (t) { var e = ms(this); for (t = t || []; this.pos < e;)t.push(this.readFloat()); return t }, readPackedDouble: function (t) { var e = ms(this); for (t = t || []; this.pos < e;)t.push(this.readDouble()); return t }, readPackedFixed32: function (t) { var e = ms(this); for (t = t || []; this.pos < e;)t.push(this.readFixed32()); return t }, readPackedSFixed32: function (t) { var e = ms(this); for (t = t || []; this.pos < e;)t.push(this.readSFixed32()); return t }, readPackedFixed64: function (t) { var e = ms(this); for (t = t || []; this.pos < e;)t.push(this.readFixed64()); return t }, readPackedSFixed64: function (t) { var e = ms(this); for (t = t || []; this.pos < e;)t.push(this.readSFixed64()); return t }, skip: function (t) { t &= 7; if (t === ds.Varint) for (; 127 < this.buf[this.pos++];); else if (t === ds.Bytes) this.pos = this.readVarint() + this.pos; else if (t === ds.Fixed32) this.pos += 4; else { if (t !== ds.Fixed64) throw new Error("Unimplemented type: " + t); this.pos += 8 } }, writeTag: function (t, e) { this.writeVarint(t << 3 | e) }, realloc: function (t) { for (var e, n = this.length || 16; n < this.pos + t;)n *= 2; n !== this.length && ((e = new Uint8Array(n)).set(this.buf), this.buf = e, this.length = n) }, finish: function () { return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length) }, writeFixed32: function (t) { this.realloc(4), Is(this.buf, t, this.pos), this.pos += 4 }, writeSFixed32: function (t) { this.realloc(4), Is(this.buf, t, this.pos), this.pos += 4 }, writeFixed64: function (t) { this.realloc(8), Is(this.buf, -1 & t, this.pos), Is(this.buf, Math.floor(t * (1 / 4294967296)), this.pos + 4), this.pos += 8 }, writeSFixed64: function (t) { this.realloc(8), Is(this.buf, -1 & t, this.pos), Is(this.buf, Math.floor(t * (1 / 4294967296)), this.pos + 4), this.pos += 8 }, writeVarint: function (r) { 268435455 < (r = +r || 0) || r < 0 ? function (t) { var e, n, i; if (0 <= r ? (i = r % 4294967296 | 0, e = r / 4294967296 | 0) : (e = ~(-r / 4294967296), 4294967295 ^ (i = ~(-r % 4294967296)) ? i = i + 1 | 0 : e = e + 1 | (i = 0)), 0x10000000000000000 <= r || r < -0x10000000000000000) throw new Error("Given varint doesn't fit into 10 bytes"); t.realloc(10), n = i, (i = t).buf[i.pos++] = 127 & n | 128, n >>>= 7, i.buf[i.pos++] = 127 & n | 128, n >>>= 7, i.buf[i.pos++] = 127 & n | 128, n >>>= 7, i.buf[i.pos++] = 127 & n | 128, n >>>= 7, i.buf[i.pos] = 127 & n, e = (7 & (n = e)) << 4, (t = t).buf[t.pos++] |= e | ((n >>>= 3) ? 128 : 0), n && (t.buf[t.pos++] = 127 & n | ((n >>>= 7) ? 128 : 0), n && (t.buf[t.pos++] = 127 & n | ((n >>>= 7) ? 128 : 0), n && (t.buf[t.pos++] = 127 & n | ((n >>>= 7) ? 128 : 0), n && (t.buf[t.pos++] = 127 & n | ((n >>>= 7) ? 128 : 0), n && (t.buf[t.pos++] = 127 & n))))) }(this) : (this.realloc(4), this.buf[this.pos++] = 127 & r | (127 < r ? 128 : 0), r <= 127 || (this.buf[this.pos++] = 127 & (r >>>= 7) | (127 < r ? 128 : 0), r <= 127 || (this.buf[this.pos++] = 127 & (r >>>= 7) | (127 < r ? 128 : 0), r <= 127 || (this.buf[this.pos++] = r >>> 7 & 127)))) }, writeSVarint: function (t) { this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t) }, writeBoolean: function (t) { this.writeVarint(Boolean(t)) }, writeString: function (t) { t = String(t), this.realloc(4 * t.length), this.pos++; var e = this.pos; this.pos = function (t, e, n) { for (var i, r, o = 0; o < e.length; o++) { if (55295 < (i = e.charCodeAt(o)) && i < 57344) { if (!r) { 56319 < i || o + 1 === e.length ? (t[n++] = 239, t[n++] = 191, t[n++] = 189) : r = i; continue } if (i < 56320) { t[n++] = 239, t[n++] = 191, t[n++] = 189, r = i; continue } i = r - 55296 << 10 | i - 56320 | 65536, r = null } else r && (t[n++] = 239, t[n++] = 191, t[n++] = 189, r = null); i < 128 ? t[n++] = i : (i < 2048 ? t[n++] = i >> 6 | 192 : (i < 65536 ? t[n++] = i >> 12 | 224 : (t[n++] = i >> 18 | 240, t[n++] = i >> 12 & 63 | 128), t[n++] = i >> 6 & 63 | 128), t[n++] = 63 & i | 128) } return n }(this.buf, t, this.pos); t = this.pos - e; 128 <= t && gs(e, t, this), this.pos = e - 1, this.writeVarint(t), this.pos += t }, writeFloat: function (t) { this.realloc(4), ps(this.buf, t, this.pos, !0, 23, 4), this.pos += 4 }, writeDouble: function (t) { this.realloc(8), ps(this.buf, t, this.pos, !0, 52, 8), this.pos += 8 }, writeBytes: function (t) { var e = t.length; this.writeVarint(e), this.realloc(e); for (var n = 0; n < e; n++)this.buf[this.pos++] = t[n] }, writeRawMessage: function (t, e) { this.pos++; var n = this.pos; t(e, this); e = this.pos - n; 128 <= e && gs(n, e, this), this.pos = n - 1, this.writeVarint(e), this.pos += e }, writeMessage: function (t, e, n) { this.writeTag(t, ds.Bytes), this.writeRawMessage(e, n) }, writePackedVarint: function (t, e) { this.writeMessage(t, vs, e) }, writePackedSVarint: function (t, e) { this.writeMessage(t, _s, e) }, writePackedBoolean: function (t, e) { this.writeMessage(t, ws, e) }, writePackedFloat: function (t, e) { this.writeMessage(t, xs, e) }, writePackedDouble: function (t, e) { this.writeMessage(t, bs, e) }, writePackedFixed32: function (t, e) { this.writeMessage(t, Es, e) }, writePackedSFixed32: function (t, e) { this.writeMessage(t, Ss, e) }, writePackedFixed64: function (t, e) { this.writeMessage(t, Ts, e) }, writePackedSFixed64: function (t, e) { this.writeMessage(t, As, e) }, writeBytesField: function (t, e) { this.writeTag(t, ds.Bytes), this.writeBytes(e) }, writeFixed32Field: function (t, e) { this.writeTag(t, ds.Fixed32), this.writeFixed32(e) }, writeSFixed32Field: function (t, e) { this.writeTag(t, ds.Fixed32), this.writeSFixed32(e) }, writeFixed64Field: function (t, e) { this.writeTag(t, ds.Fixed64), this.writeFixed64(e) }, writeSFixed64Field: function (t, e) { this.writeTag(t, ds.Fixed64), this.writeSFixed64(e) }, writeVarintField: function (t, e) { this.writeTag(t, ds.Varint), this.writeVarint(e) }, writeSVarintField: function (t, e) { this.writeTag(t, ds.Varint), this.writeSVarint(e) }, writeStringField: function (t, e) { this.writeTag(t, ds.Bytes), this.writeString(e) }, writeFloatField: function (t, e) { this.writeTag(t, ds.Fixed32), this.writeFloat(e) }, writeDoubleField: function (t, e) { this.writeTag(t, ds.Fixed64), this.writeDouble(e) }, writeBooleanField: function (t, e) { this.writeVarintField(t, Boolean(e)) } }; var Cs = 3; function Ms(t, e, n) { 1 === t && n.readMessage(Ps, e) } function Ps(t, e, n) { var i, r, o, a, s; 3 === t && (i = (s = n.readMessage(Ls, {})).id, r = s.bitmap, o = s.width, a = s.height, t = s.left, n = s.top, s = s.advance, e.push({ id: i, bitmap: new vo({ width: o + 2 * Cs, height: a + 2 * Cs }, r), metrics: { width: o, height: a, left: t, top: n, advance: s } })) } function Ls(t, e, n) { 1 === t ? e.id = n.readVarint() : 2 === t ? e.bitmap = n.readBytes() : 3 === t ? e.width = n.readVarint() : 4 === t ? e.height = n.readVarint() : 5 === t ? e.left = n.readSVarint() : 6 === t ? e.top = n.readSVarint() : 7 === t && (e.advance = n.readVarint()) } Qt = Cs, w = function (t, e, n) { this.target = t, this.parent = e, this.mapId = n, this.callbacks = {}, this.callbackID = 0, f(["receive"], this), this.target.addEventListener("message", this.receive, !1) }; function Ds(t, e, n) { n = 2 * Math.PI * 6378137 / 256 / Math.pow(2, n); return [t * n - 2 * Math.PI * 6378137 / 2, e * n - 2 * Math.PI * 6378137 / 2] } w.prototype.send = function (t, e, n, i) { var r = n ? this.mapId + ":" + this.callbackID++ : null; n && (this.callbacks[r] = n); n = []; this.target.postMessage({ targetMapId: i, sourceMapId: this.mapId, type: t, id: String(r), data: kn(e, n) }, n) }, w.prototype.receive = function (t) { var e, n, i = this, r = t.data, o = r.id; r.targetMapId && this.mapId !== r.targetMapId || (e = function (t, e) { var n = []; i.target.postMessage({ sourceMapId: i.mapId, type: "<response>", id: String(o), error: t ? kn(t) : null, data: kn(e, n) }, n) }, "<response>" === r.type ? (n = this.callbacks[r.id], delete this.callbacks[r.id], n && r.error ? n(Cn(r.error)) : n && n(null, Cn(r.data))) : void 0 !== r.id && this.parent[r.type] ? this.parent[r.type](r.sourceMapId, Cn(r.data), e) : void 0 !== r.id && this.parent.getWorkerSource ? (t = r.type.split("."), n = Cn(r.data), this.parent.getWorkerSource(r.sourceMapId, t[0], n.source)[t[1]](n, e)) : this.parent[r.type](Cn(r.data))) }, w.prototype.remove = function () { this.target.removeEventListener("message", this.receive, !1) }; function Rs(t, e, n) { this.z = t, this.x = e, this.y = n, this.key = Fs(0, t, e, n) } Rs.prototype.equals = function (t) { return this.z === t.z && this.x === t.x && this.y === t.y }, Rs.prototype.url = function (t, e) { var n, i, r = (n = this.x, i = this.y, o = this.z, r = Ds(256 * n, 256 * (i = Math.pow(2, o) - i - 1), o), o = Ds(256 * (n + 1), 256 * (1 + i), o), r[0] + "," + r[1] + "," + o[0] + "," + o[1]), o = function (t, e, n) { for (var i, r = "", o = t; 0 < o; o--)r += (e & (i = 1 << o - 1) ? 1 : 0) + (n & i ? 2 : 0); return r }(this.z, this.x, this.y); return t[(this.x + this.y) % t.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace("{z}", String(this.z)).replace("{x}", String(this.x)).replace("{y}", String("tms" === e ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", o).replace("{bbox-epsg-3857}", r) }; function Bs(t, e) { this.wrap = t, this.canonical = e, this.key = Fs(t, e.z, e.x, e.y) } function Os(t, e, n, i, r) { this.overscaledZ = t, this.wrap = e, this.canonical = new Rs(n, +i, +r), this.key = Fs(e, t, i, r) } function Fs(t, e, n, i) { (t *= 2) < 0 && (t = -1 * t - 1); var r = 1 << e; return 32 * (r * r * t + r * i + n) + e } Os.prototype.equals = function (t) { return this.overscaledZ === t.overscaledZ && this.wrap === t.wrap && this.canonical.equals(t.canonical) }, Os.prototype.scaledTo = function (t) { var e = this.canonical.z - t; return t > this.canonical.z ? new Os(t, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Os(t, this.wrap, t, this.canonical.x >> e, this.canonical.y >> e) }, Os.prototype.isChildOf = function (t) { var e = this.canonical.z - t.canonical.z; return 0 === t.overscaledZ || t.overscaledZ < this.overscaledZ && t.canonical.x === this.canonical.x >> e && t.canonical.y === this.canonical.y >> e }, Os.prototype.children = function (t) { if (this.overscaledZ >= t) return [new Os(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)]; var e = this.canonical.z + 1, n = 2 * this.canonical.x, t = 2 * this.canonical.y; return [new Os(e, this.wrap, e, n, t), new Os(e, this.wrap, e, 1 + n, t), new Os(e, this.wrap, e, n, 1 + t), new Os(e, this.wrap, e, 1 + n, 1 + t)] }, Os.prototype.isLessThan = function (t) { return this.wrap < t.wrap || !(this.wrap > t.wrap) && (this.overscaledZ < t.overscaledZ || !(this.overscaledZ > t.overscaledZ) && (this.canonical.x < t.canonical.x || !(this.canonical.x > t.canonical.x) && this.canonical.y < t.canonical.y)) }, Os.prototype.wrapped = function () { return new Os(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y) }, Os.prototype.unwrapTo = function (t) { return new Os(this.overscaledZ, t, this.canonical.z, this.canonical.x, this.canonical.y) }, Os.prototype.overscaleFactor = function () { return Math.pow(2, this.overscaledZ - this.canonical.z) }, Os.prototype.toUnwrapped = function () { return new Bs(this.wrap, this.canonical) }, Os.prototype.toString = function () { return this.overscaledZ + "/" + this.canonical.x + "/" + this.canonical.y }, Os.prototype.toCoordinate = function () { return new l(this.canonical.x + Math.pow(2, this.wrap), this.canonical.y, this.canonical.z) }, In("CanonicalTileID", Rs), In("OverscaledTileID", Os, { omit: ["posMatrix"] }); Jt = function (t, e, n) { if (this.uid = t, e.height !== e.width) throw new RangeError("DEM tiles must be square"); if (n && "mapbox" !== n && "terrarium" !== n) return x('"' + n + '" is not a valid encoding type. Valid types include "mapbox" and "terrarium".'); var i = this.dim = e.height; this.border = Math.max(Math.ceil(e.height / 2), 1), this.stride = this.dim + 2 * this.border, this.data = new Int32Array(this.stride * this.stride); for (var r = e.data, o = "terrarium" === n ? this._unpackTerrarium : this._unpackMapbox, a = 0; a < i; a++)for (var s = 0; s < i; s++) { var l = 4 * (a * i + s); this.set(s, a, o(r[l], r[1 + l], r[2 + l])) } for (var u = 0; u < i; u++)this.set(-1, u, this.get(0, u)), this.set(i, u, this.get(i - 1, u)), this.set(u, -1, this.get(u, 0)), this.set(u, i, this.get(u, i - 1)); this.set(-1, -1, this.get(0, 0)), this.set(i, -1, this.get(i - 1, 0)), this.set(-1, i, this.get(0, i - 1)), this.set(i, i, this.get(i - 1, i - 1)) }; Jt.prototype.set = function (t, e, n) { this.data[this._idx(t, e)] = n + 65536 }, Jt.prototype.get = function (t, e) { return this.data[this._idx(t, e)] - 65536 }, Jt.prototype._idx = function (t, e) { if (t < -this.border || t >= this.dim + this.border || e < -this.border || e >= this.dim + this.border) throw new RangeError("out of range source coordinates for DEM data"); return (e + this.border) * this.stride + (t + this.border) }, Jt.prototype._unpackMapbox = function (t, e, n) { return (256 * t * 256 + 256 * e + n) / 10 - 1e4 }, Jt.prototype._unpackTerrarium = function (t, e, n) { return 256 * t + e + n / 256 - 32768 }, Jt.prototype.getPixels = function () { return new _o({ width: this.dim + 2 * this.border, height: this.dim + 2 * this.border }, new Uint8Array(this.data.buffer)) }, Jt.prototype.backfillBorder = function (t, e, n) { if (this.dim !== t.dim) throw new Error("dem dimension mismatch"); var i = e * this.dim, r = e * this.dim + this.dim, o = n * this.dim, a = n * this.dim + this.dim; switch (e) { case -1: i = r - 1; break; case 1: r = i + 1 }switch (n) { case -1: o = a - 1; break; case 1: a = o + 1 }for (var s = d(i, -this.border, this.dim + this.border), l = d(r, -this.border, this.dim + this.border), o = d(o, -this.border, this.dim + this.border), u = d(a, -this.border, this.dim + this.border), c = -e * this.dim, h = -n * this.dim, p = o; p < u; p++)for (var f = s; f < l; f++)this.set(f, p, t.get(f + c, p + h)) }, In("DEMData", Jt); function Vs(t) { this._stringToNumber = {}, this._numberToString = []; for (var e = 0; e < t.length; e++) { var n = t[e]; this._stringToNumber[n] = e, this._numberToString[e] = n } } var Ns = si([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]); Vs.prototype.encode = function (t) { return this._stringToNumber[t] }, Vs.prototype.decode = function (t) { return this._numberToString[t] }; function js(t, e, n, i) { this.type = "Feature", (this._vectorTileFeature = t)._z = e, t._x = n, t._y = i, this.properties = t.properties, null != t.id && (this.id = t.id) } oi = { geometry: { configurable: !0 } }; oi.geometry.get = function () { return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry }, oi.geometry.set = function (t) { this._geometry = t }, js.prototype.toJSON = function () { var t, e = { geometry: this.geometry }; for (t in this) "_geometry" !== t && "_vectorTileFeature" !== t && (e[t] = this[t]); return e }, Object.defineProperties(js.prototype, oi); Qn = function () { this.state = {}, this.stateChanges = {} }; Qn.prototype.updateState = function (t, e, n) { e = String(e), this.stateChanges[t] = this.stateChanges[t] || {}, this.stateChanges[t][e] = this.stateChanges[t][e] || {}, c(this.stateChanges[t][e], n) }, Qn.prototype.getState = function (t, e) { e = String(e); var n = this.state[t] || {}, t = this.stateChanges[t] || {}; return c({}, n[e], t[e]) }, Qn.prototype.initializeTileState = function (t, e) { t.setFeatureState(this.state, e) }, Qn.prototype.coalesceChanges = function (t, e) { var n, i = {}; for (n in this.stateChanges) { this.state[n] = this.state[n] || {}; var r, o = {}; for (r in this.stateChanges[n]) this.state[n][r] || (this.state[n][r] = {}), c(this.state[n][r], this.stateChanges[n][r]), o[r] = this.state[n][r]; i[n] = o } if (this.stateChanges = {}, 0 !== Object.keys(i).length) for (var a in t) t[a].setFeatureState(i, e) }; Kt = function (t, e, n) { this.tileID = t, this.x = t.canonical.x, this.y = t.canonical.y, this.z = t.canonical.z, this.grid = e || new wn(Dr, 16, 0), this.featureIndexArray = n || new Er }; function Us(t, e) { return e - t } Kt.prototype.insert = function (t, e, n, i, r) { var o = this.featureIndexArray.length; this.featureIndexArray.emplaceBack(n, i, r); for (var a = 0; a < e.length; a++) { for (var s = e[a], l = [1 / 0, 1 / 0, -1 / 0, -1 / 0], u = 0; u < s.length; u++) { var c = s[u]; l[0] = Math.min(l[0], c.x), l[1] = Math.min(l[1], c.y), l[2] = Math.max(l[2], c.x), l[3] = Math.max(l[3], c.y) } l[0] < Dr && l[1] < Dr && 0 <= l[2] && 0 <= l[3] && this.grid.insert(o, l[0], l[1], l[2], l[3]) } }, Kt.prototype.loadVTLayers = function () { return this.vtLayers || (this.vtLayers = new ya.VectorTile(new fs(this.rawTileData)).layers, this.sourceLayerCoder = new Vs(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers }, Kt.prototype.query = function (r, e, o) { var a = this; this.loadVTLayers(); for (var n = r.params || {}, s = Dr / r.tileSize / r.scale, l = Ke(n.filter), u = r.queryGeometry, t = r.queryPadding * s, i = 1 / 0, c = 1 / 0, h = -1 / 0, p = -1 / 0, f = 0; f < u.length; f++)for (var d = u[f], m = 0; m < d.length; m++)var y = d[m], i = Math.min(i, y.x), c = Math.min(c, y.y), h = Math.max(h, y.x), p = Math.max(p, y.y); var g = this.grid.query(i - t, c - t, h + t, p + t); g.sort(Us); for (var v, _ = {}, x = 0; x < g.length; x++)!function (t) { var i, t = g[t]; t !== v && (v = t, t = a.featureIndexArray.get(t), i = null, a.loadMatchingFeature(_, t.bucketIndex, t.sourceLayerIndex, t.featureIndex, l, n.layers, e, function (t, e) { i = i || Br(t); var n = {}; return t.id && (n = o.getState(e.sourceLayer || "_geojsonTileLayer", String(t.id))), e.queryIntersectsFeature(u, t, n, i, a.z, r.transform, s, r.posMatrix) })) }(x); return _ }, Kt.prototype.loadMatchingFeature = function (t, e, n, i, r, o, a, s) { var l = this.bucketLayerIDs[e]; if (!o || function (t, e) { for (var n = 0; n < t.length; n++)if (0 <= e.indexOf(t[n])) return 1 }(o, l)) { var n = this.sourceLayerCoder.decode(n), u = this.vtLayers[n].feature(i); if (r(new Bn(this.tileID.overscaledZ), u)) for (var c = 0; c < l.length; c++) { var h, p, f = l[c]; o && o.indexOf(f) < 0 || (!(p = a[f]) || s && !s(u, p) || ((h = new js(u, this.z, this.x, this.y)).layer = p.serialize(), void 0 === (p = t[f]) && (p = t[f] = []), p.push({ featureIndex: i, feature: h }))) } } }, Kt.prototype.lookupSymbolFeatures = function (t, e, n, i, r, o) { var a = {}; this.loadVTLayers(); for (var s = Ke(i), l = 0, u = t; l < u.length; l += 1) { var c = u[l]; this.loadMatchingFeature(a, e, n, c, s, r, o) } return a }, Kt.prototype.hasLayer = function (t) { for (var e = 0, n = this.bucketLayerIDs; e < n.length; e += 1)for (var i = 0, r = n[e]; i < r.length; i += 1)if (t === r[i]) return !0; return !1 }, In("FeatureIndex", Kt, { omit: ["rawTileData", "sourceLayerCoder"] }); oi = function (t, e) { this.tileID = t, this.uid = h(), this.uses = 0, this.tileSize = e, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.expiredRequestCount = 0, this.state = "loading" }; oi.prototype.registerFadeDuration = function (t) { t += this.timeAdded; t < T.now() || this.fadeEndTime && t < this.fadeEndTime || (this.fadeEndTime = t) }, oi.prototype.wasRequested = function () { return "errored" === this.state || "loaded" === this.state || "reloading" === this.state }, oi.prototype.loadVectorData = function (t, e, n) { if (this.hasData() && this.unloadVectorData(), this.state = "loaded", t) { for (var i in t.featureIndex && (this.latestFeatureIndex = t.featureIndex, t.rawTileData ? (this.latestRawTileData = t.rawTileData, this.latestFeatureIndex.rawTileData = t.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t.collisionBoxArray, this.buckets = function (t, e) { var n = {}; if (!e) return n; for (var i = 0, r = t; i < r.length; i += 1) { var o = r[i], a = o.layerIds.map(function (t) { return e.getLayer(t) }).filter(Boolean); if (0 !== a.length) { o.layers = a, o.stateDependentLayers = a.filter(function (t) { return t.isStateDependent() }); for (var s = 0, l = a; s < l.length; s += 1)n[l[s].id] = o } } return n }(t.buckets, e.style), this.hasSymbolBuckets = !1, this.buckets) { var r = this.buckets[i]; if (r instanceof Xa) { if (this.hasSymbolBuckets = !0, !n) break; r.justReloaded = !0 } } for (var o in this.queryPadding = 0, this.buckets) { var a = this.buckets[o]; this.queryPadding = Math.max(this.queryPadding, e.style.getLayer(o).queryRadius(a)) } t.iconAtlasImage && (this.iconAtlasImage = t.iconAtlasImage), t.glyphAtlasImage && (this.glyphAtlasImage = t.glyphAtlasImage) } else this.collisionBoxArray = new sr }, oi.prototype.unloadVectorData = function () { for (var t in this.buckets) this.buckets[t].destroy(); this.buckets = {}, this.iconAtlasTexture && this.iconAtlasTexture.destroy(), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded" }, oi.prototype.unloadDEMData = function () { this.dem = null, this.neighboringTiles = null, this.state = "unloaded" }, oi.prototype.getBucket = function (t) { return this.buckets[t.id] }, oi.prototype.upload = function (t) { for (var e in this.buckets) { var n = this.buckets[e]; n.uploadPending() && n.upload(t) } var i = t.gl; this.iconAtlasImage && (this.iconAtlasTexture = new as(t, this.iconAtlasImage, i.RGBA), this.iconAtlasImage = null), this.glyphAtlasImage && (this.glyphAtlasTexture = new as(t, this.glyphAtlasImage, i.ALPHA), this.glyphAtlasImage = null) }, oi.prototype.queryRenderedFeatures = function (t, e, n, i, r, o, a, s) { return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: n, scale: i, tileSize: this.tileSize, posMatrix: s, transform: o, params: r, queryPadding: this.queryPadding * a }, t, e) : {} }, oi.prototype.querySourceFeatures = function (t, e) { if (this.latestFeatureIndex && this.latestFeatureIndex.rawTileData) { var n = this.latestFeatureIndex.loadVTLayers(), i = e ? e.sourceLayer : "", r = n._geojsonTileLayer || n[i]; if (r) for (var o = Ke(e && e.filter), e = this.tileID.canonical, a = e.z, s = e.x, l = e.y, u = { z: a, x: s, y: l }, c = 0; c < r.length; c++) { var h = r.feature(c); o(new Bn(this.tileID.overscaledZ), h) && ((h = new js(h, a, s, l)).tile = u, t.push(h)) } } }, oi.prototype.clearMask = function () { this.segments && (this.segments.destroy(), delete this.segments), this.maskedBoundsBuffer && (this.maskedBoundsBuffer.destroy(), delete this.maskedBoundsBuffer), this.maskedIndexBuffer && (this.maskedIndexBuffer.destroy(), delete this.maskedIndexBuffer) }, oi.prototype.setMask = function (t, e) { if (!u(this.mask, t) && (this.mask = t, this.clearMask(), !u(t, { 0: !0 }))) { var n = new fi, i = new Hi; this.segments = new Ar, this.segments.prepareSegment(0, n, i); for (var r = Object.keys(t), o = 0; o < r.length; o++) { var a = t[r[o]], s = Dr >> a.z, l = new p(a.x * s, a.y * s), a = new p(l.x + s, l.y + s), s = this.segments.prepareSegment(4, n, i); n.emplaceBack(l.x, l.y, l.x, l.y), n.emplaceBack(a.x, l.y, a.x, l.y), n.emplaceBack(l.x, a.y, l.x, a.y), n.emplaceBack(a.x, a.y, a.x, a.y); a = s.vertexLength; i.emplaceBack(a, a + 1, a + 2), i.emplaceBack(a + 1, a + 2, a + 3), s.vertexLength += 4, s.primitiveLength += 2 } this.maskedBoundsBuffer = e.createVertexBuffer(n, Ns.members), this.maskedIndexBuffer = e.createIndexBuffer(i) } }, oi.prototype.hasData = function () { return "loaded" === this.state || "reloading" === this.state || "expired" === this.state }, oi.prototype.setExpiryData = function (t) { var r, e, n, i = this.expirationTime; t.cacheControl ? (e = (e = t.cacheControl, r = {}, e.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, function (t, e, n, i) { i = n || i; return r[e] = !i || i.toLowerCase(), "" }), r["max-age"] && (e = parseInt(r["max-age"], 10), isNaN(e) ? delete r["max-age"] : r["max-age"] = e), r))["max-age"] && (this.expirationTime = Date.now() + 1e3 * e["max-age"]) : t.expires && (this.expirationTime = new Date(t.expires).getTime()), this.expirationTime && (e = Date.now(), t = !1, this.expirationTime > e ? t = !1 : i && !(this.expirationTime < i) && (n = this.expirationTime - i) ? this.expirationTime = e + Math.max(n, 3e4) : t = !0, t ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0) }, oi.prototype.getExpiryTimeout = function () { if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (new Date).getTime(), Math.pow(2, 31) - 1) }, oi.prototype.setFeatureState = function (t, e) { if (this.latestFeatureIndex && this.latestFeatureIndex.rawTileData && 0 !== Object.keys(t).length) { var n, i = this.latestFeatureIndex.loadVTLayers(); for (n in this.buckets) { var r = this.buckets[n], o = r.layers[0].sourceLayer || "_geojsonTileLayer", a = i[o], o = t[o]; a && o && 0 !== Object.keys(o).length && (r.update(o, a), e && e.style && (this.queryPadding = Math.max(this.queryPadding, e.style.getLayer(n).queryRadius(r)))) } } }, oi.prototype.holdingForFade = function () { return void 0 !== this.symbolFadeHoldUntil }, oi.prototype.symbolFadeFinished = function () { return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < T.now() }, oi.prototype.clearFadeHold = function () { this.symbolFadeHoldUntil = void 0 }, oi.prototype.setHoldDuration = function (t) { this.symbolFadeHoldUntil = T.now() + t }; function qs() { this.text = "", this.sectionIndex = [], this.sections = [] } var Zs = { horizontal: 1, vertical: 2, horizontalOnly: 3 }; qs.fromFeature = function (t, e) { var n = new qs; if (t instanceof mt) for (var i = 0; i < t.sections.length; i++) { var r = t.sections[i]; n.sections.push({ scale: r.scale || 1, fontStack: r.fontStack || e }), n.text += r.text; for (var o = 0; o < r.text.length; o++)n.sectionIndex.push(i) } else { n.text = t, n.sections.push({ scale: 1, fontStack: e }); for (var a = 0; a < t.length; a++)n.sectionIndex.push(0) } return n }, qs.prototype.length = function () { return this.text.length }, qs.prototype.getSection = function (t) { return this.sections[this.sectionIndex[t]] }, qs.prototype.getCharCode = function (t) { return this.text.charCodeAt(t) }, qs.prototype.verticalizePunctuation = function () { this.text = function (t) { for (var e = "", n = 0; n < t.length; n++) { var i = t.charCodeAt(n + 1) || null, r = t.charCodeAt(n - 1) || null; i && Rn(i) && !Oa[t[n + 1]] || r && Rn(r) && !Oa[t[n - 1]] || !Oa[t[n]] ? e += t[n] : e += Oa[t[n]] } return e }(this.text) }, qs.prototype.trim = function () { for (var t = 0, e = 0; e < this.text.length && Gs[this.text.charCodeAt(e)]; e++)t++; for (var n = this.text.length, i = this.text.length - 1; 0 <= i && t <= i && Gs[this.text.charCodeAt(i)]; i--)n--; this.text = this.text.substring(t, n), this.sectionIndex = this.sectionIndex.slice(t, n) }, qs.prototype.substring = function (t, e) { var n = new qs; return n.text = this.text.substring(t, e), n.sectionIndex = this.sectionIndex.slice(t, e), n.sections = this.sections, n }, qs.prototype.toString = function () { return this.text }, qs.prototype.getMaxScale = function () { var n = this; return this.sectionIndex.reduce(function (t, e) { return Math.max(t, n.sections[e].scale) }, 0) }; var Gs = { 9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0 }, Xs = {}; function Ws(t, e, n, i) { var r = Math.pow(t - e, 2); return i ? t < e ? r / 2 : 2 * r : r + Math.abs(n) * n } function Hs(t, e, n, i, r, o) { for (var a = null, s = Ws(e, n, r, o), l = 0, u = i; l < u.length; l += 1) { var c = u[l], h = Ws(e - c.x, n, r, o) + c.badness; h <= s && (a = c, s = h) } return { index: t, x: e, priorBreak: a, badness: s } } function Ks(t, e, n, i) { if (!n) return []; if (!t) return []; for (var r, o = [], a = function (t, e, n, i) { for (var r = 0, o = 0; o < t.length(); o++) { var a = t.getSection(o), s = i[a.fontStack], s = s && s[t.getCharCode(o)]; s && (r += s.metrics.advance * a.scale + e) } return r / Math.max(1, Math.ceil(r / n)) }(t, e, n, i), s = 0, l = 0; l < t.length(); l++) { var u = t.getSection(l), c = t.getCharCode(l), h = i[u.fontStack], h = h && h[c]; h && !Gs[c] && (s += h.metrics.advance * u.scale + e), l < t.length() - 1 && (Xs[c] || !((r = c) < 11904) && (Pn["Bopomofo Extended"](r) || Pn.Bopomofo(r) || Pn["CJK Compatibility Forms"](r) || Pn["CJK Compatibility Ideographs"](r) || Pn["CJK Compatibility"](r) || Pn["CJK Radicals Supplement"](r) || Pn["CJK Strokes"](r) || Pn["CJK Symbols and Punctuation"](r) || Pn["CJK Unified Ideographs Extension A"](r) || Pn["CJK Unified Ideographs"](r) || Pn["Enclosed CJK Letters and Months"](r) || Pn["Halfwidth and Fullwidth Forms"](r) || Pn.Hiragana(r) || Pn["Ideographic Description Characters"](r) || Pn["Kangxi Radicals"](r) || Pn["Katakana Phonetic Extensions"](r) || Pn.Katakana(r) || Pn["Vertical Forms"](r) || Pn["Yi Radicals"](r) || Pn["Yi Syllables"](r))) && o.push(Hs(l + 1, s, a, o, (u = c, r = t.getCharCode(l + 1), c = void 0, c = 0, 10 === u && (c -= 1e4), 40 !== u && 65288 !== u || (c += 50), 41 !== r && 65289 !== r || (c += 50), c), !1)) } return function t(e) { return e ? t(e.priorBreak).concat(e.index) : [] }(Hs(t.length(), s, a, o, 0, !0)) } function Js(t) { var e = .5, n = .5; switch (t) { case "right": case "top-right": case "bottom-right": e = 1; break; case "left": case "top-left": case "bottom-left": e = 0 }switch (t) { case "bottom": case "bottom-right": case "bottom-left": n = 1; break; case "top": case "top-right": case "top-left": n = 0 }return { horizontalAlign: e, verticalAlign: n } } Xs[10] = !0, Xs[32] = !0, Xs[38] = !0, Xs[40] = !0, Xs[41] = !0, Xs[43] = !0, Xs[45] = !0, Xs[47] = !0, Xs[173] = !0, Xs[183] = !0, Xs[8203] = !0, Xs[8208] = !0, Xs[8211] = !0, Xs[8231] = !0, t.createCommonjsModule = e, t.Point = p, t.window = self, t.browser = T, t.uuid = function () { return function t(e) { return e ? (e ^ 16 * Math.random() >> e / 4).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, t) }() }, t.validateUuid = function (t) { return !!t && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t) }, t.storageAvailable = function (t) { try { var e = self[t]; return e.setItem("_mapbox_test_", 1), e.removeItem("_mapbox_test_"), !0 } catch (t) { return !1 } }, t.warnOnce = x, t.postData = function (t, e, n) { var i = C(c(t, { method: "POST" })); return i.onerror = function () { n(new Error(i.statusText)) }, i.onload = function () { 200 <= i.status && i.status < 300 ? n(null, i.response) : n(new I(i.statusText, i.status, t.url)) }, i.send(e), { cancel: function () { return i.abort() } } }, t.getJSON = function (e, n) { var i = C(e); return i.setRequestHeader("Accept", "application/json"), i.onerror = function () { n(new Error(i.statusText)) }, i.onload = function () { if (200 <= i.status && i.status < 300 && i.response) { var t; try { t = JSON.parse(i.response) } catch (t) { return n(t) } n(null, t) } else 401 === i.status && e.url.match(/mapbox.com/) ? n(new I(i.statusText + ": you may have provided an invalid Mapbox access token. See https://www.mapbox.com/api-documentation/#access-tokens", i.status, e.url)) : n(new I(i.statusText, i.status, e.url)) }, i.send(), { cancel: function () { return i.abort() } } }, t.getImage = function (t, r) { return M(t, function (t, e) { var n, i; t ? r(t) : e && (n = new self.Image, i = self.URL || self.webkitURL, n.onload = function () { r(null, n), i.revokeObjectURL(n.src) }, t = new self.Blob([new Uint8Array(e.data)], { type: "image/png" }), n.cacheControl = e.cacheControl, n.expires = e.expires, n.src = e.data.byteLength ? i.createObjectURL(t) : "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=") }) }, t.ResourceType = A, t.RGBAImage = _o, t.ShelfPack = is, t.ImagePosition = os, t.Texture = as, t.getArrayBuffer = M, t.parseGlyphPBF = function (t) { return new fs(t).readFields(Ms, []) }, t.isChar = Pn, t.asyncAll = function (t, e, i) { if (!t.length) return i(null, []); var r = t.length, o = new Array(t.length), a = null; t.forEach(function (t, n) { e(t, function (t, e) { t && (a = t), o[n] = e, 0 == --r && i(a, o) }) }) }, t.AlphaImage = vo, t.styleSpec = V, t.endsWith = m, t.extend = c, t.sphericalToCartesian = function (t) { var e = t[0], n = t[1], t = t[2]; return n += 90, n *= Math.PI / 180, t *= Math.PI / 180, { x: e * Math.cos(n) * Math.sin(t), y: e * Math.sin(n) * Math.sin(t), z: e * Math.cos(t) } }, t.Evented = R, t.validateStyle = gn, t.validateLight = vn, t.emitValidationErrors = bn, t.Color = ut, t.number = Rt, t.Properties = ei, t.Transitionable = Gn, t.Transitioning = Wn, t.PossiblyEvaluated = Jn, t.DataConstantProperty = Yn, t.uniqueId = h, t.Actor = w, t.pick = function (t, e) { for (var n = {}, i = 0; i < e.length; i++) { var r = e[i]; r in t && (n[r] = t[r]) } return n }, t.wrap = function (t, e, n) { var i = n - e, i = ((t - e) % i + i) % i + e; return i === e ? n : i }, t.clamp = d, t.Event = D, t.ErrorEvent = O, t.OverscaledTileID = Os, t.EXTENT = Dr, t.getCoordinatesCenter = function (t) { for (var e = 1 / 0, n = 1 / 0, i = -1 / 0, r = -1 / 0, o = 0; o < t.length; o++)e = Math.min(e, t[o].column), n = Math.min(n, t[o].row), i = Math.max(i, t[o].column), r = Math.max(r, t[o].row); var a = i - e, s = r - n, s = Math.max(a, s), s = Math.max(0, Math.floor(-Math.log(s) / Math.LN2)); return new l((e + i) / 2, (n + r) / 2, 0).zoomTo(s) }, t.CanonicalTileID = Rs, t.StructArrayLayout4i8 = fi, t.rasterBoundsAttributes = Ns, t.getVideo = function (t, e) { var n = self.document.createElement("video"); n.muted = !0, n.onloadstart = function () { e(null, n) }; for (var i = 0; i < t.length; i++) { var r = self.document.createElement("source"), o = t[i], a = void 0; (a = self.document.createElement("a")).href = o, a.protocol === self.document.location.protocol && a.host === self.document.location.host || (n.crossOrigin = "Anonymous"), r.src = t[i], n.appendChild(r) } return { cancel: function () { } } }, t.ValidationError = N, t.bindAll = f, t.deepEqual = u, t.Tile = oi, t.Coordinate = l, t.keysDifference = function (t, e) { var n, i = []; for (n in t) n in e || i.push(n); return i }, t.SourceFeatureState = Qn, t.refProperties = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"], t.create = function () { var t = new Yr(16); return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t }, t.identity = function (t) { return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t }, t.invert = function (t, e) { var n = e[0], i = e[1], r = e[2], o = e[3], a = e[4], s = e[5], l = e[6], u = e[7], c = e[8], h = e[9], p = e[10], f = e[11], d = e[12], m = e[13], y = e[14], g = e[15], v = n * s - i * a, _ = n * l - r * a, x = n * u - o * a, b = i * l - r * s, w = i * u - o * s, E = r * u - o * l, S = c * m - h * d, T = c * y - p * d, A = c * g - f * d, z = h * y - p * m, I = h * g - f * m, k = p * g - f * y, e = v * k - _ * I + x * z + b * A - w * T + E * S; return e ? (e = 1 / e, t[0] = (s * k - l * I + u * z) * e, t[1] = (r * I - i * k - o * z) * e, t[2] = (m * E - y * w + g * b) * e, t[3] = (p * w - h * E - f * b) * e, t[4] = (l * A - a * k - u * T) * e, t[5] = (n * k - r * A + o * T) * e, t[6] = (y * x - d * E - g * _) * e, t[7] = (c * E - p * x + f * _) * e, t[8] = (a * I - s * A + u * S) * e, t[9] = (i * A - n * I - o * S) * e, t[10] = (d * w - m * x + g * v) * e, t[11] = (h * x - c * w - f * v) * e, t[12] = (s * T - a * z - l * S) * e, t[13] = (n * z - i * T + r * S) * e, t[14] = (m * _ - d * b - y * v) * e, t[15] = (c * b - h * _ + p * v) * e, t) : null }, t.multiply = function (t, e, n) { var i = e[0], r = e[1], o = e[2], a = e[3], s = e[4], l = e[5], u = e[6], c = e[7], h = e[8], p = e[9], f = e[10], d = e[11], m = e[12], y = e[13], g = e[14], v = e[15], _ = n[0], x = n[1], b = n[2], e = n[3]; return t[0] = _ * i + x * s + b * h + e * m, t[1] = _ * r + x * l + b * p + e * y, t[2] = _ * o + x * u + b * f + e * g, t[3] = _ * a + x * c + b * d + e * v, _ = n[4], x = n[5], b = n[6], e = n[7], t[4] = _ * i + x * s + b * h + e * m, t[5] = _ * r + x * l + b * p + e * y, t[6] = _ * o + x * u + b * f + e * g, t[7] = _ * a + x * c + b * d + e * v, _ = n[8], x = n[9], b = n[10], e = n[11], t[8] = _ * i + x * s + b * h + e * m, t[9] = _ * r + x * l + b * p + e * y, t[10] = _ * o + x * u + b * f + e * g, t[11] = _ * a + x * c + b * d + e * v, _ = n[12], x = n[13], b = n[14], e = n[15], t[12] = _ * i + x * s + b * h + e * m, t[13] = _ * r + x * l + b * p + e * y, t[14] = _ * o + x * u + b * f + e * g, t[15] = _ * a + x * c + b * d + e * v, t }, t.translate = function (t, e, n) { var i, r, o, a, s, l, u, c, h, p, f, d = n[0], m = n[1], y = n[2]; return e === t ? (t[12] = e[0] * d + e[4] * m + e[8] * y + e[12], t[13] = e[1] * d + e[5] * m + e[9] * y + e[13], t[14] = e[2] * d + e[6] * m + e[10] * y + e[14], t[15] = e[3] * d + e[7] * m + e[11] * y + e[15]) : (i = e[0], r = e[1], o = e[2], a = e[3], s = e[4], l = e[5], u = e[6], c = e[7], h = e[8], p = e[9], f = e[10], n = e[11], t[0] = i, t[1] = r, t[2] = o, t[3] = a, t[4] = s, t[5] = l, t[6] = u, t[7] = c, t[8] = h, t[9] = p, t[10] = f, t[11] = n, t[12] = i * d + s * m + h * y + e[12], t[13] = r * d + l * m + p * y + e[13], t[14] = o * d + u * m + f * y + e[14], t[15] = a * d + c * m + n * y + e[15]), t }, t.scale = function (t, e, n) { var i = n[0], r = n[1], n = n[2]; return t[0] = e[0] * i, t[1] = e[1] * i, t[2] = e[2] * i, t[3] = e[3] * i, t[4] = e[4] * r, t[5] = e[5] * r, t[6] = e[6] * r, t[7] = e[7] * r, t[8] = e[8] * n, t[9] = e[9] * n, t[10] = e[10] * n, t[11] = e[11] * n, t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t }, t.rotateX = function (t, e, n) { var i = Math.sin(n), r = Math.cos(n), o = e[4], a = e[5], s = e[6], l = e[7], u = e[8], c = e[9], h = e[10], n = e[11]; return e !== t && (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[4] = o * r + u * i, t[5] = a * r + c * i, t[6] = s * r + h * i, t[7] = l * r + n * i, t[8] = u * r - o * i, t[9] = c * r - a * i, t[10] = h * r - s * i, t[11] = n * r - l * i, t }, t.rotateZ = function (t, e, n) { var i = Math.sin(n), r = Math.cos(n), o = e[0], a = e[1], s = e[2], l = e[3], u = e[4], c = e[5], h = e[6], n = e[7]; return e !== t && (t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = o * r + u * i, t[1] = a * r + c * i, t[2] = s * r + h * i, t[3] = l * r + n * i, t[4] = u * r - o * i, t[5] = c * r - a * i, t[6] = h * r - s * i, t[7] = n * r - l * i, t }, t.perspective = function (t, e, n, i, r) { var o = 1 / Math.tan(e / 2), e = 1 / (i - r); return t[0] = o / n, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = o, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = (r + i) * e, t[11] = -1, t[12] = 0, t[13] = 0, t[14] = 2 * r * i * e, t[15] = 0, t }, t.ortho = function (t, e, n, i, r, o, a) { var s = 1 / (e - n), l = 1 / (i - r), u = 1 / (o - a); return t[0] = -2 * s, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * l, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 2 * u, t[11] = 0, t[12] = (e + n) * s, t[13] = (r + i) * l, t[14] = (a + o) * u, t[15] = 1, t }, t.create$1 = io, t.normalize = ro, t.transformMat4 = oo, t.forEach = we, t.getSizeData = Va, t.evaluateSizeForFeature = function (t, e, n) { return "source" === t.functionType ? n.lowerSize / 10 : "composite" === t.functionType ? Rt(n.lowerSize / 10, n.upperSize / 10, e.uSizeT) : e.uSize }, t.evaluateSizeForZoom = function (t, e, n) { if ("constant" === t.functionType) return { uSizeT: 0, uSize: t.layoutSize }; if ("source" === t.functionType) return { uSizeT: 0, uSize: 0 }; if ("camera" === t.functionType) { var i = t.propertyValue, r = t.zoomRange, o = t.sizeRange, r = d(Ne(i, n.specification).interpolationFactor(e, r.min, r.max), 0, 1); return { uSizeT: 0, uSize: o.min + r * (o.max - o.min) } } o = t.propertyValue, t = t.zoomRange; return { uSizeT: d(Ne(o, n.specification).interpolationFactor(e, t.min, t.max), 0, 1), uSize: 0 } }, t.addDynamicAttributes = qa, t.properties = Ja, t.WritingMode = Zs, t.multiPolygonIntersectsBufferedPoint = Vr, t.multiPolygonIntersectsMultiPolygon = Nr, t.multiPolygonIntersectsBufferedMultiLine = jr, t.polygonIntersectsPolygon = function (t, e) { for (var n = 0; n < t.length; n++)if (Xr(e, t[n])) return !0; for (var i = 0; i < e.length; i++)if (Xr(t, e[i])) return !0; return !!Ur(t, e) }, t.distToSegmentSquared = Zr, t.StyleLayer = ii, t.createStyleLayer = function (t) { return new Qa[t.type](t) }, t.clone = v, t.filterObject = g, t.mapObject = y, t.registerForPluginAvailability = function (t) { return Vn ? t({ pluginURL: Vn, completionCallback: On }) : jn.once("pluginAvailable", t), t }, t.evented = jn, t.ZoomHistory = Mn, t.createLayout = si, t.ProgramConfiguration = Pr, t.create$2 = $r, t.fromRotation = function (t, e) { var n = Math.sin(e), e = Math.cos(e); return t[0] = e, t[1] = n, t[2] = 0, t[3] = -n, t[4] = e, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t }, t.create$3 = Qr, t.length = to, t.fromValues = eo, t.normalize$1 = function (t, e) { var n = e[0], i = e[1], r = e[2]; return 0 < (r = n * n + i * i + r * r) && (r = 1 / Math.sqrt(r), t[0] = e[0] * r, t[1] = e[1] * r, t[2] = e[2] * r), t }, t.dot = function (t, e) { return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] }, t.cross = function (t, e, n) { var i = e[0], r = e[1], o = e[2], a = n[0], e = n[1], n = n[2]; return t[0] = r * n - o * e, t[1] = o * a - i * n, t[2] = i * e - r * a, t }, t.transformMat3 = function (t, e, n) { var i = e[0], r = e[1], e = e[2]; return t[0] = i * n[0] + r * n[3] + e * n[6], t[1] = i * n[1] + r * n[4] + e * n[7], t[2] = i * n[2] + r * n[5] + e * n[8], t }, t.len = $t, t.forEach$1 = be, t.StructArrayLayout2i4 = ci, t.UnwrappedTileID = Bs, t.create$4 = function () { var t = new Yr(4); return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t }, t.rotate = function (t, e, n) { var i = e[0], r = e[1], o = e[2], a = e[3], e = Math.sin(n), n = Math.cos(n); return t[0] = i * n + o * e, t[1] = r * n + a * e, t[2] = i * -e + o * n, t[3] = r * -e + a * n, t }, t.ease = a, t.bezier = r, t.EvaluationParameters = Bn, t.setRTLTextPlugin = function (t, e) { if (Fn) throw new Error("setRTLTextPlugin cannot be called multiple times."); Fn = !0, Vn = T.resolveURL(t), On = function (t) { t ? (Fn = !1, Vn = null, e && e(t)) : Nn = !0 }, jn.fire(new D("pluginAvailable", { pluginURL: Vn, completionCallback: On })) }, t.values = function (t) { var e, n = []; for (e in t) n.push(t[e]); return n }, t.featureFilter = Ke, t.Anchor = ti, t.register = In, t.GLYPH_PBF_BORDER = Qt, t.shapeText = function (t, e, n, i, r, o, A, a, s, l, u) { var c = qs.fromFeature(t, n); u === Zs.vertical && c.verticalizePunctuation(); var h, p = [], t = { positionedGlyphs: p, text: c, top: s[1], bottom: s[1], left: s[0], right: s[0], writingMode: u }, n = Un.processBidirectionalText, s = Un.processStyledBidirectionalText; if (n && 1 === c.sections.length) { h = []; for (var f = 0, d = n(c.toString(), Ks(c, a, i, e)); f < d.length; f += 1) { var m = d[f], y = new qs; y.text = m, y.sections = c.sections; for (var g = 0; g < m.length; g++)y.sectionIndex.push(0); h.push(y) } } else if (s) { h = []; for (var v = 0, _ = s(c.text, c.sectionIndex, Ks(c, a, i, e)); v < _.length; v += 1) { var x = _[v], b = new qs; b.text = x[0], b.sectionIndex = x[1], b.sections = c.sections, h.push(b) } } else h = function (t, e) { for (var n = [], i = t.text, r = 0, o = 0, a = e; o < a.length; o += 1) { var s = a[o]; n.push(t.substring(r, s)), r = s } return r < i.length && n.push(t.substring(r, i.length)), n }(c, Ks(c, a, i, e)); return function (t, e, r, o, n, i, a, s) { for (var l = 0, u = -17, c = 0, h = t.positionedGlyphs, p = "right" === A ? 1 : "left" === A ? 0 : .5, f = 0, d = r; f < d.length; f += 1) { var m = d[f]; m.trim(); var y = m.getMaxScale(); if (m.length()) { for (var g, v = h.length, _ = 0; _ < m.length(); _++) { var x = m.getSection(_), b = m.getCharCode(_), w = 24 * (y - x.scale), E = e[x.fontStack], E = E && E[b]; E && (Dn(b) && i !== Zs.horizontal ? (h.push({ glyph: b, x: l, y: w, vertical: !0, scale: x.scale, fontStack: x.fontStack }), l += s * x.scale + a) : (h.push({ glyph: b, x: l, y: u + w, vertical: !1, scale: x.scale, fontStack: x.fontStack }), l += E.metrics.advance * x.scale + a)) } h.length !== v && (g = l - a, c = Math.max(g, c), function (t, e, n, i, r) { if (r) { var o = t[i], e = e[o.fontStack], e = e && e[o.glyph]; if (e) for (var o = e.metrics.advance * o.scale, a = (t[i].x + o) * r, s = n; s <= i; s++)t[s].x -= a } }(h, e, v, h.length - 1, p)), l = 0, u += o * y } else u += o } var n = Js(n), S = n.horizontalAlign, T = n.verticalAlign; !function (t) { for (var e = (p - S) * c, n = (-T * r.length + .5) * o, i = 0; i < t.length; i++)t[i].x += e, t[i].y += n }(h); n = u - -17; t.top += -T * n, t.bottom = t.top + n, t.left += -S * c, t.right = t.left + c }(t, e, h, r, o, u, a, l), !!p.length && (t.text = t.text.toString(), t) }, t.shapeIcon = function (t, e, n) { var i = Js(n), r = i.horizontalAlign, n = i.verticalAlign, i = e[0], e = e[1], i = i - t.displaySize[0] * r, r = i + t.displaySize[0], n = e - t.displaySize[1] * n; return { image: t, top: n, bottom: n + t.displaySize[1], left: i, right: r } }, t.allowsVerticalWritingMode = Ln, t.allowsLetterSpacing = function (t) { for (var e, n = 0, i = t; n < i.length; n += 1)if (e = i[n].charCodeAt(0), Pn.Arabic(e) || Pn["Arabic Supplement"](e) || Pn["Arabic Extended-A"](e) || Pn["Arabic Presentation Forms-A"](e) || Pn["Arabic Presentation Forms-B"](e)) return !1; return !0 }, t.classifyRings = Ko, t.SymbolBucket = Xa, t.Formatted = mt, t.FeatureIndex = Kt, t.CollisionBoxArray = sr, t.DictionaryCoder = Vs, t.ImageAtlas = Yt, t.mvt = ya, t.Protobuf = fs, t.DEMData = Jt, t.vectorTile = ya, t.Point$1 = p, t.pbf = fs, t.plugin = Un }), t(0, function (X) { function m(t) { for (var e = "", n = 0, i = X.refProperties; n < i.length; n += 1)e += "/" + function t(e) { var n = typeof e; if ("number" == n || "boolean" == n || "string" == n || null == e) return JSON.stringify(e); if (Array.isArray(e)) { for (var i = "[", r = 0, o = e; r < o.length; r += 1)i += t(o[r]) + ","; return i + "]" } for (var a = Object.keys(e).sort(), s = "{", l = 0; l < a.length; l++)s += JSON.stringify(a[l]) + ":" + t(e[a[l]]) + ","; return s + "}" }(t[i[n]]); return e } function e(t) { t && this.replace(t) } function W(t, e, n, i, r) { if (void 0 === e.segment) return 1; for (var o = e, a = e.segment + 1, s = 0; -n / 2 < s;) { if (--a < 0) return; s -= t[a].dist(o), o = t[a] } s += t[a].dist(t[a + 1]), a++; for (var l = [], u = 0; s < n / 2;) { var c = t[a - 1], h = t[a], p = t[a + 1]; if (!p) return; c = c.angleTo(h) - h.angleTo(p), c = Math.abs((c + 3 * Math.PI) % (2 * Math.PI) - Math.PI); for (l.push({ distance: s, angleDelta: c }), u += c; s - l[0].distance > i;)u -= l.shift().angleDelta; if (r < u) return; a++, s += h.dist(p) } return 1 } function H(t) { for (var e = 0, n = 0; n < t.length - 1; n++)e += t[n].dist(t[n + 1]); return e } function K(t, e, n) { return t ? .6 * e * n : 0 } function J(t, e) { return Math.max(t ? t.right - t.left : 0, e ? e.right - e.left : 0) } e.prototype.replace = function (t) { this._layerConfigs = {}, this._layers = {}, this.update(t, []) }, e.prototype.update = function (t, e) { for (var n = this, i = 0, r = t; i < r.length; i += 1) { var o = r[i]; n._layerConfigs[o.id] = o; o = n._layers[o.id] = X.createStyleLayer(o); o._featureFilter = X.featureFilter(o.filter) } for (var a = 0, s = e; a < s.length; a += 1) { var l = s[a]; delete n._layerConfigs[l], delete n._layers[l] } this.familiesBySource = {}; for (var u = 0, c = function (t) { for (var e = {}, n = 0; n < t.length; n++) { var i = m(t[n]); (e[i] || (e[i] = [])).push(t[n]) } var r, o = []; for (r in e) o.push(e[r]); return o }(X.values(this._layerConfigs)); u < c.length; u += 1) { var h, p, f = c[u].map(function (t) { return n._layers[t.id] }), d = f[0]; "none" !== d.visibility && (h = d.source || "", ((p = (p = n.familiesBySource[h]) || (n.familiesBySource[h] = {}))[d = d.sourceLayer || "_geojsonTileLayer"] || (p[d] = [])).push(f)) } }; var Y = function () { this.opacity = 0, this.targetOpacity = 0, this.time = 0 }; Y.prototype.clone = function () { var t = new Y; return t.opacity = this.opacity, t.targetOpacity = this.targetOpacity, t.time = this.time, t }, X.register("OpacityState", Y); var $ = function (t, e, n, i, r, o, a, s, l, u, c, h) { var p, f, d = a.top * s - l, m = a.bottom * s + l, y = a.left * s - l, l = a.right * s + l; this.boxStartIndex = t.length, u ? (p = l - y, 0 < (f = m - d) && (f = Math.max(10 * s, f), this._addLineCollisionCircles(t, e, n, n.segment, p, f, i, r, o, c))) : (h && (e = new X.Point(y, d), p = new X.Point(l, d), f = new X.Point(y, m), c = new X.Point(l, m), h = h * Math.PI / 180, e._rotate(h), p._rotate(h), f._rotate(h), c._rotate(h), y = Math.min(e.x, p.x, f.x, c.x), l = Math.max(e.x, p.x, f.x, c.x), d = Math.min(e.y, p.y, f.y, c.y), m = Math.max(e.y, p.y, f.y, c.y)), t.emplaceBack(n.x, n.y, y, d, l, m, i, r, o, 0, 0)), this.boxEndIndex = t.length }; $.prototype._addLineCollisionCircles = function (t, e, n, i, r, o, a, s, l, u) { var c = o / 2, h = Math.floor(r / c) || 1, u = 1 + .4 * Math.log(u) / Math.LN2, p = Math.floor(h * u / 2), f = -o / 2, d = n, m = i + 1, y = f, g = -r / 2, v = g - r / 4; do { if (--m < 0) { if (g < y) return; m = 0; break } y -= e[m].dist(d), d = e[m] } while (v < y); for (var _ = e[m].dist(e[m + 1]), x = -p; x < h + p; x++) { var b = x * c, w = g + b; if (b < 0 && (w += b), r < b && (w += b - r), !(w < y)) { for (; y + _ < w;) { if (y += _, ++m + 1 >= e.length) return; _ = e[m].dist(e[m + 1]) } var E = w - y, b = e[m], E = e[m + 1].sub(b)._unit()._mult(E)._add(b)._round(), b = Math.abs(w - f) < c ? 0 : .8 * (w - f); t.emplaceBack(E.x, E.y, -o / 2, -o / 2, o / 2, o / 2, a, s, l, o / 2, b) } } }; var Q = i, t = i; function i(t, e) { if (!(this instanceof i)) return new i(t, e); if (this.data = t || [], this.length = this.data.length, this.compare = e || r, 0 < this.length) for (var n = (this.length >> 1) - 1; 0 <= n; n--)this._down(n) } function r(t, e) { return t < e ? -1 : e < t ? 1 : 0 } function tt(t, e) { return e.max - t.max } function et(t, e, n, i) { this.p = new X.Point(t, e), this.h = n, this.d = function (t, e) { for (var n = !1, i = 1 / 0, r = 0; r < e.length; r++)for (var o = e[r], a = 0, s = o.length, l = s - 1; a < s; l = a++) { var u = o[a], c = o[l]; u.y > t.y != c.y > t.y && t.x < (c.x - u.x) * (t.y - u.y) / (c.y - u.y) + u.x && (n = !n), i = Math.min(i, X.distToSegmentSquared(t, u, c)) } return (n ? 1 : -1) * Math.sqrt(i) }(this.p, i), this.max = this.d + this.h * Math.SQRT2 } function S(t, e, n, i, r, o) { t.createArrays(), t.symbolInstances = []; var a = 512 * t.overscaling; t.tilePixelRatio = X.EXTENT / a, t.compareText = {}, t.iconsNeedLinear = !1; var s, l, u = t.layers[0].layout, a = t.layers[0]._unevaluatedLayout._values, c = {}; "composite" === t.textSizeData.functionType && (l = (s = t.textSizeData.zoomRange).min, s = s.max, c.compositeTextSizes = [a["text-size"].possiblyEvaluate(new X.EvaluationParameters(l)), a["text-size"].possiblyEvaluate(new X.EvaluationParameters(s))]), "composite" === t.iconSizeData.functionType && (s = (l = t.iconSizeData.zoomRange).min, l = l.max, c.compositeIconSizes = [a["icon-size"].possiblyEvaluate(new X.EvaluationParameters(s)), a["icon-size"].possiblyEvaluate(new X.EvaluationParameters(l))]), c.layoutTextSize = a["text-size"].possiblyEvaluate(new X.EvaluationParameters(t.zoom + 1)), c.layoutIconSize = a["icon-size"].possiblyEvaluate(new X.EvaluationParameters(t.zoom + 1)), c.textMaxSize = a["text-size"].possiblyEvaluate(new X.EvaluationParameters(18)); for (var h = 24 * u.get("text-line-height"), p = "map" === u.get("text-rotation-alignment") && "point" !== u.get("symbol-placement"), f = u.get("text-keep-upright"), d = 0, m = t.features; d < m.length; d += 1) { var y, g, v, _, x = m[d], b = u.get("text-font").evaluate(x, {}).join(","), w = n, E = {}, S = x.text; S && (y = S instanceof X.Formatted ? S.toString() : S, T = u.get("text-offset").evaluate(x, {}).map(function (t) { return 24 * t }), _ = 24 * u.get("text-letter-spacing").evaluate(x, {}), A = X.allowsLetterSpacing(y) ? _ : 0, g = u.get("text-anchor").evaluate(x, {}), v = u.get("text-justify").evaluate(x, {}), _ = "point" === u.get("symbol-placement") ? 24 * u.get("text-max-width").evaluate(x, {}) : 0, E.horizontal = X.shapeText(S, e, b, _, h, g, v, A, T, 24, X.WritingMode.horizontal), X.allowsVerticalWritingMode(y) && p && f && (E.vertical = X.shapeText(S, e, b, _, h, g, v, A, T, 24, X.WritingMode.vertical))); var T, A = void 0; !x.icon || (T = i[x.icon]) && (A = X.shapeIcon(r[x.icon], u.get("icon-offset").evaluate(x, {}), u.get("icon-anchor").evaluate(x, {})), void 0 === t.sdfIcons ? t.sdfIcons = T.sdf : t.sdfIcons !== T.sdf && X.warnOnce("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), T.pixelRatio === t.pixelRatio && 0 === u.get("icon-rotate").constantOr(1) || (t.iconsNeedLinear = !0)), (E.horizontal || A) && function (n, i, r, o, a, s) { var t = s.layoutTextSize.evaluate(i, {}), e = s.layoutIconSize.evaluate(i, {}), l = s.textMaxSize.evaluate(i, {}); void 0 === l && (l = t); function u(t, e) { e.x < 0 || e.x >= X.EXTENT || e.y < 0 || e.y >= X.EXTENT || n.symbolInstances.push(function (t, e, n, i, x, r, o, a, s, l, u, c, h, p, f, d, m, y, g, v, _) { var b = t.addToLineVertexArray(e, n), w = 0, E = 0, S = 0, T = i.horizontal ? i.horizontal.text : "", A = []; i.horizontal && (z = r.layout.get("text-rotate").evaluate(g, {}), z = new $(o, n, e, a, s, l, i.horizontal, u, c, h, t.overscaling, z), E += nt(t, e, i.horizontal, r, h, g, p, b, i.vertical ? X.WritingMode.horizontal : X.WritingMode.horizontalOnly, A, v, _), i.vertical && (S += nt(t, e, i.vertical, r, h, g, p, b, X.WritingMode.vertical, A, v, _))); var z, h = z ? z.boxStartIndex : t.collisionBoxArray.length, v = z ? z.boxEndIndex : t.collisionBoxArray.length; x && (z = function (t, e, n) { var i, r, o, a, s, l, u, c, h, p, f, d = x.image, m = t.layout, y = x.top - 1 / d.pixelRatio, g = x.left - 1 / d.pixelRatio, v = x.bottom + 1 / d.pixelRatio, _ = x.right + 1 / d.pixelRatio; v = "none" !== m.get("icon-text-fit") && e ? (f = _ - g, h = v - y, u = m.get("text-size").evaluate(n, {}) / 24, i = e.left * u, l = e.right * u, r = e.top * u, o = l - i, c = e.bottom * u - r, p = m.get("icon-text-fit-padding")[0], a = m.get("icon-text-fit-padding")[1], s = m.get("icon-text-fit-padding")[2], l = m.get("icon-text-fit-padding")[3], e = "width" === m.get("icon-text-fit") ? .5 * (c - h) : 0, u = "height" === m.get("icon-text-fit") ? .5 * (o - f) : 0, f = "width" === m.get("icon-text-fit") || "both" === m.get("icon-text-fit") ? o : f, c = "height" === m.get("icon-text-fit") || "both" === m.get("icon-text-fit") ? c : h, h = new X.Point(i + u - l, r + e - p), p = new X.Point(i + u + a + f, r + e - p), f = new X.Point(i + u + a + f, r + e + s + c), new X.Point(i + u - l, r + e + s + c)) : (h = new X.Point(g, y), p = new X.Point(_, y), f = new X.Point(_, v), new X.Point(g, v)); t = t.layout.get("icon-rotate").evaluate(n, {}) * Math.PI / 180; return t && (n = Math.sin(t), t = [t = Math.cos(t), -n, n, t], h._matMult(t), p._matMult(t), v._matMult(t), f._matMult(t)), [{ tl: h, tr: p, bl: v, br: f, tex: d.paddedRect, writingMode: void 0, glyphOffset: [0, 0] }] }(r, i.horizontal, g), i = r.layout.get("icon-rotate").evaluate(g, {}), I = new $(o, n, e, a, s, l, x, f, d, !1, t.overscaling, i), w = 4 * z.length, d = null, "source" === (i = t.iconSizeData).functionType ? d = [10 * r.layout.get("icon-size").evaluate(g, {})] : "composite" === i.functionType && (d = [10 * _.compositeIconSizes[0].evaluate(g, {}), 10 * _.compositeIconSizes[1].evaluate(g, {})]), t.addSymbols(t.icon, z, d, y, m, g, !1, e, b.lineStartIndex, b.lineLength)); var b = I ? I.boxStartIndex : t.collisionBoxArray.length, I = I ? I.boxEndIndex : t.collisionBoxArray.length; return t.glyphOffsetArray.length >= X.SymbolBucket.MAX_GLYPHS && X.warnOnce("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), { key: T, textBoxStartIndex: h, textBoxEndIndex: v, iconBoxStartIndex: b, iconBoxEndIndex: I, textOffset: p, iconOffset: y, anchor: e, line: n, featureIndex: a, numGlyphVertices: E, numVerticalGlyphVertices: S, numIconVertices: w, textOpacityState: new Y, iconOpacityState: new Y, isDuplicate: !1, placedTextSymbolIndices: A, crossTileID: 0 } }(n, e, t, r, o, n.layers[0], n.collisionBoxArray, i.index, i.sourceLayerIndex, n.index, f, g, x, h, m, v, b, p, i, a, s)) } var c = n.layers[0].layout, h = c.get("text-offset").evaluate(i, {}), p = c.get("icon-offset").evaluate(i, {}), t = t / 24, f = n.tilePixelRatio * t, d = n.tilePixelRatio * l / 24, m = n.tilePixelRatio * e, y = n.tilePixelRatio * c.get("symbol-spacing"), g = c.get("text-padding") * n.tilePixelRatio, v = c.get("icon-padding") * n.tilePixelRatio, _ = c.get("text-max-angle") / 180 * Math.PI, x = "map" === c.get("text-rotation-alignment") && "point" !== c.get("symbol-placement"), b = "map" === c.get("icon-rotation-alignment") && "point" !== c.get("symbol-placement"), c = c.get("symbol-placement"), w = y / 2; if ("line" === c) for (var E = 0, S = function (t, e, n) { for (var i = [], r = 0; r < t.length; r++)for (var o = t[r], a = void 0, s = 0; s < o.length - 1; s++) { var l = o[s], u = o[s + 1]; l.x < 0 && u.x < 0 || (l.x < 0 ? l = new X.Point(0, l.y + (u.y - l.y) * ((0 - l.x) / (u.x - l.x)))._round() : u.x < 0 && (u = new X.Point(0, l.y + (u.y - l.y) * ((0 - l.x) / (u.x - l.x)))._round()), l.y < 0 && u.y < 0 || (l.y < 0 ? l = new X.Point(l.x + (u.x - l.x) * ((0 - l.y) / (u.y - l.y)), 0)._round() : u.y < 0 && (u = new X.Point(l.x + (u.x - l.x) * ((0 - l.y) / (u.y - l.y)), 0)._round()), l.x >= e && u.x >= e || (l.x >= e ? l = new X.Point(e, l.y + (u.y - l.y) * ((e - l.x) / (u.x - l.x)))._round() : u.x >= e && (u = new X.Point(e, l.y + (u.y - l.y) * ((e - l.x) / (u.x - l.x)))._round()), l.y >= n && u.y >= n || (l.y >= n ? l = new X.Point(l.x + (u.x - l.x) * ((n - l.y) / (u.y - l.y)), n)._round() : u.y >= n && (u = new X.Point(l.x + (u.x - l.x) * ((n - l.y) / (u.y - l.y)), n)._round()), a && l.equals(a[a.length - 1]) || (a = [l], i.push(a)), a.push(u))))) } return i }(i.geometry, X.EXTENT, X.EXTENT); E < S.length; E += 1)for (var T = S[E], A = 0, z = function (t, e, n, i, r, o, a, s, l) { var u = K(i, o, a), c = J(i, r), i = c * a, r = 0 === t[0].x || t[0].x === l || 0 === t[0].y || t[0].y === l; return e - i < e / 4 && (e = i + e / 4), function t(e, n, i, r, o, a, s, l, u) { for (var c = a / 2, h = H(e), p = 0, f = n - i, d = [], m = 0; m < e.length - 1; m++) { for (var y = e[m], g = e[m + 1], v = y.dist(g), _ = g.angleTo(y); f + i < p + v;) { var x = ((f += i) - p) / v, b = X.number(y.x, g.x, x), x = X.number(y.y, g.y, x); 0 <= b && b < u && 0 <= x && x < u && 0 <= f - c && f + c <= h && ((x = new X.Anchor(b, x, _, m))._round(), r && !W(e, x, a, r, o) || d.push(x)) } p += v } return l || d.length || s || (d = t(e, p / 2, i, r, o, a, s, !0, u)), d }(t, r ? e / 2 * s % e : (c / 2 + 2 * o) * a * s % e, e, u, n, i, r, !1, l) }(T, y, _, r.vertical || r.horizontal, o, 24, d, n.overscaling, X.EXTENT); A < z.length; A += 1) { var I = z[A], k = r.horizontal; k && function (t, e, n, i) { t = t.compareText; if (e in t) { for (var r = t[e], o = r.length - 1; 0 <= o; o--)if (i.dist(r[o]) < n) return !0 } else t[e] = []; return t[e].push(i), !1 }(n, k.text, w, I) || u(T, I) } else if ("line-center" === c) for (var C = 0, M = i.geometry; C < M.length; C += 1) { var P, L = M[C]; 1 < L.length && ((P = function (t, e, n, i, r, o) { for (var a = K(n, r, o), s = J(n, i) * o, l = 0, u = H(t) / 2, c = 0; c < t.length - 1; c++) { var h = t[c], p = t[c + 1], f = h.dist(p); if (u < l + f) { var d = (u - l) / f, m = X.number(h.x, p.x, d), d = X.number(h.y, p.y, d), h = new X.Anchor(m, d, p.angleTo(h), c); return h._round(), !a || W(t, h, s, a, e) ? h : void 0 } l += f } }(L, _, r.vertical || r.horizontal, o, 24, d)) && u(L, P)) } else if ("Polygon" === i.type) for (var D = 0, R = X.classifyRings(i.geometry, 0); D < R.length; D += 1) { var B = R[D], O = function (t, e, n) { void 0 === e && (e = 1), void 0 === n && (n = !1); for (var i = 1 / 0, r = 1 / 0, o = -1 / 0, a = -1 / 0, s = t[0], l = 0; l < s.length; l++) { var u = s[l]; (!l || u.x < i) && (i = u.x), (!l || u.y < r) && (r = u.y), (!l || u.x > o) && (o = u.x), (!l || u.y > a) && (a = u.y) } var c = o - i, h = a - r, p = Math.min(c, h), f = p / 2, d = new Q(null, tt); if (0 === p) return new X.Point(i, r); for (var m = i; m < o; m += p)for (var y = r; y < a; y += p)d.push(new et(m + f, y + f, f, t)); for (var g = function (t) { for (var e = 0, n = 0, i = 0, r = t[0], o = 0, a = r.length, s = a - 1; o < a; s = o++) { var l = r[o], u = r[s], c = l.x * u.y - u.x * l.y; n += (l.x + u.x) * c, i += (l.y + u.y) * c, e += 3 * c } return new et(n / e, i / e, 0, t) }(t), v = d.length; d.length;) { var _ = d.pop(); (_.d > g.d || !g.d) && (g = _, n && console.log("found best %d after %d probes", Math.round(1e4 * _.d) / 1e4, v)), _.max - g.d <= e || (f = _.h / 2, d.push(new et(_.p.x - f, _.p.y - f, f, t)), d.push(new et(_.p.x + f, _.p.y - f, f, t)), d.push(new et(_.p.x - f, _.p.y + f, f, t)), d.push(new et(_.p.x + f, _.p.y + f, f, t)), v += 4) } return n && (console.log("num probes: " + v), console.log("best distance: " + g.d)), g.p }(B, 16); u(B[0], new X.Anchor(O.x, O.y, 0)) } else if ("LineString" === i.type) for (var F = 0, V = i.geometry; F < V.length; F += 1) { var N = V[F]; u(N, new X.Anchor(N[0].x, N[0].y, 0)) } else if ("Point" === i.type) for (var j = 0, U = i.geometry; j < U.length; j += 1)for (var q = 0, Z = U[j]; q < Z.length; q += 1) { var G = Z[q]; u([G], new X.Anchor(G.x, G.y, 0)) } }(t, x, E, A, w, c) } o && t.generateCollisionDebugBuffers() } function nt(t, e, n, i, r, o, a, s, l, u, c, h) { var p = function (t, e, n, i, r) { for (var o = e.layout.get("text-rotate").evaluate(i, {}) * Math.PI / 180, a = e.layout.get("text-offset").evaluate(i, {}).map(function (t) { return 24 * t }), s = t.positionedGlyphs, l = [], u = 0; u < s.length; u++) { var c, h, p, f, d, m, y, g, v = s[u], _ = r[v.fontStack], x = _ && _[v.glyph]; !x || (c = x.rect) && (d = X.GLYPH_PBF_BORDER + 1, m = x.metrics.advance * v.scale / 2, h = n ? [v.x + m, v.y] : [0, 0], p = n ? [0, 0] : [v.x + m + a[0], v.y + a[1]], f = (x.metrics.left - d) * v.scale - m + p[0], _ = (-x.metrics.top - d) * v.scale + p[1], x = f + c.w * v.scale, d = _ + c.h * v.scale, p = new X.Point(f, _), _ = new X.Point(x, _), f = new X.Point(f, d), d = new X.Point(x, d), n && v.vertical && (y = new X.Point(-m, m), m = -Math.PI / 2, g = new X.Point(5, 0), p._rotateAround(m, y)._add(g), _._rotateAround(m, y)._add(g), f._rotateAround(m, y)._add(g), d._rotateAround(m, y)._add(g)), o && (y = Math.sin(o), g = [g = Math.cos(o), -y, y, g], p._matMult(g), _._matMult(g), f._matMult(g), d._matMult(g)), l.push({ tl: p, tr: _, bl: f, br: d, tex: c, writingMode: t.writingMode, glyphOffset: h })) } return l }(n, i, r, o, c), n = t.textSizeData, c = null; return "source" === n.functionType ? c = [10 * i.layout.get("text-size").evaluate(o, {})] : "composite" === n.functionType && (c = [10 * h.compositeTextSizes[0].evaluate(o, {}), 10 * h.compositeTextSizes[1].evaluate(o, {})]), t.addSymbols(t.text, p, c, a, r, o, l, e, s.lineStartIndex, s.lineLength), u.push(t.text.placedSymbolArray.length - 1), 4 * p.length } i.prototype = { push: function (t) { this.data.push(t), this.length++, this._up(this.length - 1) }, pop: function () { if (0 !== this.length) { var t = this.data[0]; return this.length--, 0 < this.length && (this.data[0] = this.data[this.length], this._down(0)), this.data.pop(), t } }, peek: function () { return this.data[0] }, _up: function (t) { for (var e = this.data, n = this.compare, i = e[t]; 0 < t;) { var r = t - 1 >> 1, o = e[r]; if (0 <= n(i, o)) break; e[t] = o, t = r } e[t] = i }, _down: function (t) { for (var e = this.data, n = this.compare, i = this.length >> 1, r = e[t]; t < i;) { var o = 1 + (t << 1), a = o + 1, s = e[o]; if (a < this.length && n(e[a], s) < 0 && (s = e[o = a]), 0 <= n(s, r)) break; e[t] = s, t = o } e[t] = r } }, Q.default = t; function T(t) { var e, n = {}, i = new X.ShelfPack(0, 0, { autoResize: !0 }), r = []; for (e in t) { var o, a = t[e], s = n[e] = {}; for (o in a) { var l, u = a[+o]; u && 0 !== u.bitmap.width && 0 !== u.bitmap.height && (l = { x: 0, y: 0, w: u.bitmap.width + 2, h: u.bitmap.height + 2 }, r.push(l), s[o] = { rect: l, metrics: u.metrics }) } } i.pack(r, { inPlace: !0 }); var c, h = new X.AlphaImage({ width: i.w, height: i.h }); for (c in t) { var p, f = t[c]; for (p in f) { var d, m = f[+p]; m && 0 !== m.bitmap.width && 0 !== m.bitmap.height && (d = n[c][p].rect, X.AlphaImage.copy(m.bitmap, h, { x: 0, y: 0 }, { x: d.x + 1, y: d.y + 1 }, m.bitmap)) } } this.image = h, this.positions = n } X.register("GlyphAtlas", T); function n(t) { this.tileID = new X.OverscaledTileID(t.tileID.overscaledZ, t.tileID.wrap, t.tileID.canonical.z, t.tileID.canonical.x, t.tileID.canonical.y), this.uid = t.uid, this.zoom = t.zoom, this.pixelRatio = t.pixelRatio, this.tileSize = t.tileSize, this.source = t.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t.showCollisionBoxes, this.collectResourceTiming = !!t.collectResourceTiming } function A(t, e) { for (var n = new X.EvaluationParameters(e), i = 0, r = t; i < r.length; i += 1)r[i].recalculate(n) } n.prototype.parse = function (t, e, n, r) { var i = this; this.status = "parsing", this.data = t, this.collisionBoxArray = new X.CollisionBoxArray; var o = new X.DictionaryCoder(Object.keys(t.layers).sort()), a = new X.FeatureIndex(this.tileID); a.bucketLayerIDs = []; var s, l, u, c, h = {}, p = { featureIndex: a, iconDependencies: {}, glyphDependencies: {} }, f = e.familiesBySource[this.source]; for (c in f) { var d = t.layers[c]; if (d) { 1 === d.version && X.warnOnce('Vector tile source "' + i.source + '" layer "' + c + '" does not use vector tile spec v2 and therefore may have some rendering errors.'); for (var m = o.encode(c), y = [], g = 0; g < d.length; g++) { var v = d.feature(g); y.push({ feature: v, index: g, sourceLayerIndex: m }) } for (var _ = 0, x = f[c]; _ < x.length; _ += 1) { var b = x[_], w = b[0]; w.minzoom && i.zoom < Math.floor(w.minzoom) || w.maxzoom && i.zoom >= w.maxzoom || "none" !== w.visibility && (A(b, i.zoom), (h[w.id] = w.createBucket({ index: a.bucketLayerIDs.length, layers: b, zoom: i.zoom, pixelRatio: i.pixelRatio, overscaling: i.overscaling, collisionBoxArray: i.collisionBoxArray, sourceLayerIndex: m, sourceID: i.source })).populate(y, p), a.bucketLayerIDs.push(b.map(function (t) { return t.id }))) } } } e = X.mapObject(p.glyphDependencies, function (t) { return Object.keys(t).map(Number) }); Object.keys(e).length ? n.send("getGlyphs", { uid: this.uid, stacks: e }, function (t, e) { s || (s = t, l = e, E.call(i)) }) : l = {}; e = Object.keys(p.iconDependencies); function E() { if (s) return r(s); if (l && u) { var t, e = new T(l), n = new X.ImageAtlas(u); for (t in h) { var i = h[t]; i instanceof X.SymbolBucket && (A(i.layers, this.zoom), S(i, l, e.positions, u, n.positions, this.showCollisionBoxes)) } this.status = "done", r(null, { buckets: X.values(h).filter(function (t) { return !t.isEmpty() }), featureIndex: a, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: e.image, iconAtlasImage: n.image }) } } e.length ? n.send("getImages", { icons: e }, function (t, e) { s || (s = t, u = e, E.call(i)) }) : u = {}, E.call(this) }; var o = "undefined" != typeof performance, c = { getEntriesByName: function (t) { return !!(o && performance && performance.getEntriesByName) && performance.getEntriesByName(t) }, mark: function (t) { return !!(o && performance && performance.mark) && performance.mark(t) }, measure: function (t, e, n) { return !!(o && performance && performance.measure) && performance.measure(t, e, n) }, clearMarks: function (t) { return !!(o && performance && performance.clearMarks) && performance.clearMarks(t) }, clearMeasures: function (t) { return !!(o && performance && performance.clearMeasures) && performance.clearMeasures(t) } }, t = function (t) { this._marks = { start: [t.url, "start"].join("#"), end: [t.url, "end"].join("#"), measure: t.url.toString() }, c.mark(this._marks.start) }; function a(t, n) { var e = X.getArrayBuffer(t.request, function (t, e) { t ? n(t) : e && n(null, { vectorTile: new X.mvt.VectorTile(new X.Protobuf(e.data)), rawData: e.data, cacheControl: e.cacheControl, expires: e.expires }) }); return function () { e.cancel(), n() } } t.prototype.finish = function () { c.mark(this._marks.end); var t = c.getEntriesByName(this._marks.measure); return 0 === t.length && (c.measure(this._marks.measure, this._marks.start, this._marks.end), t = c.getEntriesByName(this._marks.measure), c.clearMarks(this._marks.start), c.clearMarks(this._marks.end), c.clearMeasures(this._marks.measure)), t }, c.Performance = t; function s(t, e, n) { this.actor = t, this.layerIndex = e, this.loadVectorData = n || a, this.loading = {}, this.loaded = {} } s.prototype.loadTile = function (t, o) { var a = this, s = t.uid; this.loading || (this.loading = {}); var l = !!(t && t.request && t.request.collectResourceTiming) && new c.Performance(t.request), u = this.loading[s] = new n(t); u.abort = this.loadVectorData(t, function (t, e) { if (delete a.loading[s], t || !e) return o(t); var n = e.rawData, i = {}; e.expires && (i.expires = e.expires), e.cacheControl && (i.cacheControl = e.cacheControl); var r = {}; !l || (t = l.finish()) && (r.resourceTiming = JSON.parse(JSON.stringify(t))), u.vectorTile = e.vectorTile, u.parse(e.vectorTile, a.layerIndex, a.actor, function (t, e) { return t || !e ? o(t) : void o(null, X.extend({ rawTileData: n.slice(0) }, e, i, r)) }), a.loaded = a.loaded || {}, a.loaded[s] = u }) }, s.prototype.reloadTile = function (t, i) { var r, e = this.loaded, n = t.uid, o = this; e && e[n] && ((r = e[n]).showCollisionBoxes = t.showCollisionBoxes, t = function (t, e) { var n = r.reloadCallback; n && (delete r.reloadCallback, r.parse(r.vectorTile, o.layerIndex, o.actor, n)), i(t, e) }, "parsing" === r.status ? r.reloadCallback = t : "done" === r.status && r.parse(r.vectorTile, this.layerIndex, this.actor, t)) }, s.prototype.abortTile = function (t, e) { var n = this.loading, t = t.uid; n && n[t] && n[t].abort && (n[t].abort(), delete n[t]), e() }, s.prototype.removeTile = function (t, e) { var n = this.loaded, t = t.uid; n && n[t] && delete n[t], e() }; function l() { this.loaded = {} } l.prototype.loadTile = function (t, e) { var n = t.uid, i = t.encoding, t = t.rawImageData, i = new X.DEMData(n, t, i); this.loaded = this.loaded || {}, e(null, this.loaded[n] = i) }, l.prototype.removeTile = function (t) { var e = this.loaded, t = t.uid; e && e[t] && delete e[t] }; var u = { RADIUS: 6378137, FLATTENING: 1 / 298.257223563, POLAR_RADIUS: 6356752.3142 }; function h(t) { var e = 0; if (t && 0 < t.length) { e += Math.abs(p(t[0])); for (var n = 1; n < t.length; n++)e -= Math.abs(p(t[n])) } return e } function p(t) { var e, n, i, r, o, a, s = 0, l = t.length; if (2 < l) { for (a = 0; a < l; a++)o = a === l - 2 ? (i = l - 2, r = l - 1, 0) : a === l - 1 ? (i = l - 1, r = 0, 1) : (r = (i = a) + 1, a + 2), e = t[i], n = t[r], s += (f(t[o][0]) - f(e[0])) * Math.sin(f(n[1])); s = s * u.RADIUS * u.RADIUS / 2 } return s } function f(t) { return t * Math.PI / 180 } function d(t, e) { switch (t && t.type || null) { case "FeatureCollection": return t.features = t.features.map(g(d, e)), t; case "Feature": return t.geometry = d(t.geometry, e), t; case "Polygon": case "MultiPolygon": return n = e, "Polygon" === (e = t).type ? e.coordinates = v(e.coordinates, n) : "MultiPolygon" === e.type && (e.coordinates = e.coordinates.map(g(v, n))), e; default: return t }var n } var y = { geometry: function t(e) { var n, i = 0; switch (e.type) { case "Polygon": return h(e.coordinates); case "MultiPolygon": for (n = 0; n < e.coordinates.length; n++)i += h(e.coordinates[n]); return i; case "Point": case "MultiPoint": case "LineString": case "MultiLineString": return 0; case "GeometryCollection": for (n = 0; n < e.geometries.length; n++)i += t(e.geometries[n]); return i } }, ring: p }; function g(e, n) { return function (t) { return e(t, n) } } function v(t, e) { e = !!e, t[0] = _(t[0], e); for (var n = 1; n < t.length; n++)t[n] = _(t[n], !e); return t } function _(t, e) { return 0 <= y.ring(t) === e ? t : t.reverse() } function x(t) { this._feature = t, this.extent = X.EXTENT, this.type = t.type, this.properties = t.tags, "id" in t && !isNaN(t.id) && (this.id = parseInt(t.id, 10)) } var b = X.mvt.VectorTileFeature.prototype.toGeoJSON; x.prototype.loadGeometry = function () { if (1 === this._feature.type) { for (var t = [], e = 0, n = this._feature.geometry; e < n.length; e += 1) { var i = n[e]; t.push([new X.Point(i[0], i[1])]) } return t } for (var r = [], o = 0, a = this._feature.geometry; o < a.length; o += 1) { for (var s = [], l = 0, u = a[o]; l < u.length; l += 1) { var c = u[l]; s.push(new X.Point(c[0], c[1])) } r.push(s) } return r }, x.prototype.toGeoJSON = function (t, e, n) { return b.call(this, t, e, n) }; var w = function (t) { this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = X.EXTENT, this.length = t.length, this._features = t }; w.prototype.feature = function (t) { return new x(this._features[t]) }; var t = X.vectorTile.VectorTileFeature, E = z; function z(t, e) { this.options = e || {}, this.features = t, this.length = t.length } function I(t, e) { this.id = "number" == typeof t.id ? t.id : void 0, this.type = t.type, this.rawGeometry = 1 === t.type ? [t.geometry] : t.geometry, this.properties = t.tags, this.extent = e || 4096 } z.prototype.feature = function (t) { return new I(this.features[t], this.options.extent) }, I.prototype.loadGeometry = function () { var t = this.rawGeometry; this.geometry = []; for (var e = 0; e < t.length; e++) { for (var n = t[e], i = [], r = 0; r < n.length; r++)i.push(new X.Point$1(n[r][0], n[r][1])); this.geometry.push(i) } return this.geometry }, I.prototype.bbox = function () { this.geometry || this.loadGeometry(); for (var t = this.geometry, e = 1 / 0, n = -1 / 0, i = 1 / 0, r = -1 / 0, o = 0; o < t.length; o++)for (var a = t[o], s = 0; s < a.length; s++)var l = a[s], e = Math.min(e, l.x), n = Math.max(n, l.x), i = Math.min(i, l.y), r = Math.max(r, l.y); return [e, i, n, r] }, I.prototype.toGeoJSON = t.prototype.toGeoJSON; var k = C, t = E; function C(t) { var e = new X.pbf; return function (t, e) { for (var n in t.layers) e.writeMessage(3, M, t.layers[n]) }(t, e), e.finish() } function M(t, e) { e.writeVarintField(15, t.version || 1), e.writeStringField(1, t.name || ""), e.writeVarintField(5, t.extent || 4096); for (var n = { keys: [], values: [], keycache: {}, valuecache: {} }, i = 0; i < t.length; i++)n.feature = t.feature(i), e.writeMessage(2, P, n); var r = n.keys; for (i = 0; i < r.length; i++)e.writeStringField(3, r[i]); var o = n.values; for (i = 0; i < o.length; i++)e.writeMessage(4, O, o[i]) } function P(t, e) { var n = t.feature; void 0 !== n.id && e.writeVarintField(1, n.id), e.writeMessage(2, L, t), e.writeVarintField(3, n.type), e.writeMessage(4, B, n) } function L(t, e) { var n, i = t.feature, r = t.keys, o = t.values, a = t.keycache, s = t.valuecache; for (n in i.properties) { var l = a[n]; void 0 === l && (r.push(n), l = r.length - 1, a[n] = l), e.writeVarint(l); var u = i.properties[n], c = typeof u; "string" != c && "boolean" != c && "number" != c && (u = JSON.stringify(u)); l = c + ":" + u, c = s[l]; void 0 === c && (o.push(u), c = o.length - 1, s[l] = c), e.writeVarint(c) } } function D(t, e) { return (e << 3) + (7 & t) } function R(t) { return t << 1 ^ t >> 31 } function B(t, e) { for (var n = t.loadGeometry(), i = t.type, r = 0, o = 0, a = n.length, s = 0; s < a; s++) { var l = n[s], u = 1; 1 === i && (u = l.length), e.writeVarint(D(1, u)); for (var c = 3 === i ? l.length - 1 : l.length, h = 0; h < c; h++) { 1 === h && 1 !== i && e.writeVarint(D(2, c - 1)); var p = l[h].x - r, f = l[h].y - o; e.writeVarint(R(p)), e.writeVarint(R(f)), r += p, o += f } 3 === i && e.writeVarint(7) } } function O(t, e) { var n = typeof t; "string" == n ? e.writeStringField(1, t) : "boolean" == n ? e.writeBooleanField(7, t) : "number" == n && (t % 1 != 0 ? e.writeDoubleField(3, t) : t < 0 ? e.writeSVarintField(6, t) : e.writeVarintField(5, t)) } function F(t, e, n, i) { V(t, n, i), V(e, 2 * n, 2 * i), V(e, 2 * n + 1, 2 * i + 1) } function V(t, e, n) { var i = t[e]; t[e] = t[n], t[n] = i } function N(t, e, n, i) { n = t - n, i = e - i; return n * n + i * i } function j(t, e, n, i, r) { return new U(t, e, n, i, r) } function U(t, e, n, i, r) { e = e || q, n = n || Z, r = r || Array, this.nodeSize = i || 64, this.points = t, this.ids = new r(t.length), this.coords = new r(2 * t.length); for (var o = 0; o < t.length; o++)this.ids[o] = o, this.coords[2 * o] = e(t[o]), this.coords[2 * o + 1] = n(t[o]); !function t(e, n, i, r, o, a) { var s; o - r <= i || (function t(e, n, i, r, o, a) { for (; r < o;) { var s, l, u, c; 600 < o - r && (s = o - r + 1, l = i - r + 1, c = Math.log(s), u = .5 * Math.exp(2 * c / 3), c = .5 * Math.sqrt(c * u * (s - u) / s) * (l - s / 2 < 0 ? -1 : 1), t(e, n, i, Math.max(r, Math.floor(i - l * u / s + c)), Math.min(o, Math.floor(i + (s - l) * u / s + c)), a)); var h = n[2 * i + a], p = r, f = o; for (F(e, n, r, i), n[2 * o + a] > h && F(e, n, r, o); p < f;) { for (F(e, n, p, f), p++, f--; n[2 * p + a] < h;)p++; for (; n[2 * f + a] > h;)f-- } n[2 * r + a] === h ? F(e, n, r, f) : F(e, n, ++f, o), f <= i && (r = f + 1), i <= f && (o = f - 1) } }(e, n, s = Math.floor((r + o) / 2), r, o, a % 2), t(e, n, i, r, s - 1, a + 1), t(e, n, i, s + 1, o, a + 1)) }(this.ids, this.coords, this.nodeSize, 0, this.ids.length - 1, 0) } function q(t) { return t[0] } function Z(t) { return t[1] } function G(t) { this.options = st(Object.create(this.options), t), this.trees = new Array(this.options.maxZoom + 1) } function it(t) { return { type: "Feature", id: t.id, properties: rt(t), geometry: { type: "Point", coordinates: [360 * (t.x - .5), (t = (180 - 360 * t.y) * Math.PI / 180, 360 * Math.atan(Math.exp(t)) / Math.PI - 90)] } } } function rt(t) { var e = t.numPoints, n = 1e4 <= e ? Math.round(e / 1e3) + "k" : 1e3 <= e ? Math.round(e / 100) / 10 + "k" : e; return st(st({}, t.properties), { cluster: !0, cluster_id: t.id, point_count: e, point_count_abbreviated: n }) } function ot(t) { return t / 360 + .5 } function at(t) { t = Math.sin(t * Math.PI / 180), t = .5 - .25 * Math.log((1 + t) / (1 - t)) / Math.PI; return t < 0 ? 0 : 1 < t ? 1 : t } function st(t, e) { for (var n in e) t[n] = e[n]; return t } function lt(t) { return t.x } function ut(t) { return t.y } function ct(t, e, n, i) { i = { id: void 0 === t ? null : t, type: e, geometry: n, tags: i, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 }; return function (t) { var e = t.geometry, n = t.type; if ("Point" === n || "MultiPoint" === n || "LineString" === n) ht(t, e); else if ("Polygon" === n || "MultiLineString" === n) for (var i = 0; i < e.length; i++)ht(t, e[i]); else if ("MultiPolygon" === n) for (i = 0; i < e.length; i++)for (var r = 0; r < e[i].length; r++)ht(t, e[i][r]) }(i), i } function ht(t, e) { for (var n = 0; n < e.length; n += 3)t.minX = Math.min(t.minX, e[n]), t.minY = Math.min(t.minY, e[n + 1]), t.maxX = Math.max(t.maxX, e[n]), t.maxY = Math.max(t.maxY, e[n + 1]) } function pt(t, e, n, i) { if (e.geometry) { var r = e.geometry.coordinates, o = e.geometry.type, a = Math.pow(n.tolerance / ((1 << n.maxZoom) * n.extent), 2), s = [], l = e.id; if (n.promoteId ? l = e.properties[n.promoteId] : n.generateId && (l = i || 0), "Point" === o) ft(r, s); else if ("MultiPoint" === o) for (var u = 0; u < r.length; u++)ft(r[u], s); else if ("LineString" === o) dt(r, s, a, !1); else if ("MultiLineString" === o) { if (n.lineMetrics) { for (u = 0; u < r.length; u++)s = [], dt(r[u], s, a, !1), t.push(ct(l, "LineString", s, e.properties)); return } mt(r, s, a, !1) } else if ("Polygon" === o) mt(r, s, a, !0); else { if ("MultiPolygon" !== o) { if ("GeometryCollection" !== o) throw new Error("Input data is not a valid GeoJSON object."); for (u = 0; u < e.geometry.geometries.length; u++)pt(t, { id: l, geometry: e.geometry.geometries[u], properties: e.properties }, n, i); return } for (u = 0; u < r.length; u++) { var c = []; mt(r[u], c, a, !0), s.push(c) } } t.push(ct(l, o, s, e.properties)) } } function ft(t, e) { e.push(yt(t[0])), e.push(gt(t[1])), e.push(0) } function dt(t, e, n, i) { for (var r, o, a = 0, s = 0; s < t.length; s++) { var l = yt(t[s][0]), u = gt(t[s][1]); e.push(l), e.push(u), e.push(0), 0 < s && (a += i ? (r * u - l * o) / 2 : Math.sqrt(Math.pow(l - r, 2) + Math.pow(u - o, 2))), r = l, o = u } var c = e.length - 3; e[2] = 1, function t(e, n, i, r) { for (var o, a, s, l, u, c, h, p, f, d = r, m = i - n >> 1, y = i - n, g = e[n], v = e[n + 1], _ = e[i], x = e[i + 1], b = n + 3; b < i; b += 3) { var w = (a = e[b], s = e[b + 1], w = f = p = void 0, w = (h = x) - (u = v), 0 === (f = (c = _) - (l = g)) && 0 === w || (1 < (p = ((a - l) * f + (s - u) * w) / (f * f + w * w)) ? (l = c, u = h) : 0 < p && (l += f * p, u += w * p)), (f = a - l) * f + (w = s - u) * w); d < w ? (o = b, d = w) : w !== d || (w = Math.abs(b - m)) < y && (o = b, y = w) } r < d && (3 < o - n && t(e, n, o, r), e[o + 2] = d, 3 < i - o && t(e, o, i, r)) }(e, 0, c, n), e[2 + c] = 1, e.size = Math.abs(a), e.start = 0, e.end = e.size } function mt(t, e, n, i) { for (var r = 0; r < t.length; r++) { var o = []; dt(t[r], o, n, i), e.push(o) } } function yt(t) { return t / 360 + .5 } function gt(t) { t = Math.sin(t * Math.PI / 180), t = .5 - .25 * Math.log((1 + t) / (1 - t)) / Math.PI; return t < 0 ? 0 : 1 < t ? 1 : t } function vt(t, e, n, i, r, o, a, s) { if (i /= e, o >= (n /= e) && a < i) return t; if (a < n || i <= o) return null; for (var l = [], u = 0; u < t.length; u++) { var c = t[u], h = c.geometry, p = c.type, f = 0 === r ? c.minX : c.minY, d = 0 === r ? c.maxX : c.maxY; if (n <= f && d < i) l.push(c); else if (!(d < n || i <= f)) { var m = []; if ("Point" === p || "MultiPoint" === p) !function (t, e, n, i, r) { for (var o = 0; o < t.length; o += 3) { var a = t[o + r]; n <= a && a <= i && (e.push(t[o]), e.push(t[o + 1]), e.push(t[o + 2])) } }(h, m, n, i, r); else if ("LineString" === p) _t(h, m, n, i, r, !1, s.lineMetrics); else if ("MultiLineString" === p) bt(h, m, n, i, r, !1); else if ("Polygon" === p) bt(h, m, n, i, r, !0); else if ("MultiPolygon" === p) for (var y = 0; y < h.length; y++) { var g = []; bt(h[y], g, n, i, r, !0), g.length && m.push(g) } if (m.length) if (s.lineMetrics && "LineString" === p) for (y = 0; y < m.length; y++)l.push(ct(c.id, p, m[y], c.tags)); else "LineString" !== p && "MultiLineString" !== p || (1 === m.length ? (p = "LineString", m = m[0]) : p = "MultiLineString"), "Point" !== p && "MultiPoint" !== p || (p = 3 === m.length ? "Point" : "MultiPoint"), l.push(ct(c.id, p, m, c.tags)) } } return l.length ? l : null } function _t(t, e, n, i, r, o, a) { for (var s, l, u = xt(t), c = 0 === r ? Et : St, h = t.start, p = 0; p < t.length - 3; p += 3) { var f = t[p], d = t[p + 1], m = t[p + 2], y = t[p + 3], g = t[p + 4], v = 0 === r ? f : d, _ = 0 === r ? y : g, x = !1; a && (s = Math.sqrt(Math.pow(f - y, 2) + Math.pow(d - g, 2))), v < n ? n <= _ && (l = c(u, f, d, y, g, n), a && (u.start = h + s * l)) : i <= v ? _ < i && (l = c(u, f, d, y, g, i), a && (u.start = h + s * l)) : wt(u, f, d, m), _ < n && n <= v && (l = c(u, f, d, y, g, n), x = !0), i < _ && v <= i && (l = c(u, f, d, y, g, i), x = !0), !o && x && (a && (u.end = h + s * l), e.push(u), u = xt(t)), a && (h += s) } var b = t.length - 3, f = t[b], d = t[1 + b], m = t[2 + b]; (v = 0 === r ? f : d) >= n && v <= i && wt(u, f, d, m), b = u.length - 3, o && 3 <= b && (u[b] !== u[0] || u[1 + b] !== u[1]) && wt(u, u[0], u[1], u[2]), u.length && e.push(u) } function xt(t) { var e = []; return e.size = t.size, e.start = t.start, e.end = t.end, e } function bt(t, e, n, i, r, o) { for (var a = 0; a < t.length; a++)_t(t[a], e, n, i, r, o, !1) } function wt(t, e, n, i) { t.push(e), t.push(n), t.push(i) } function Et(t, e, n, i, r, o) { e = (o - e) / (i - e); return t.push(o), t.push(n + (r - n) * e), t.push(1), e } function St(t, e, n, i, r, o) { n = (o - n) / (r - n); return t.push(e + (i - e) * n), t.push(o), t.push(1), n } function Tt(t, e) { for (var n = [], i = 0; i < t.length; i++) { var r, o = t[i], a = o.type; if ("Point" === a || "MultiPoint" === a || "LineString" === a) r = At(o.geometry, e); else if ("MultiLineString" === a || "Polygon" === a) { r = []; for (var s = 0; s < o.geometry.length; s++)r.push(At(o.geometry[s], e)) } else if ("MultiPolygon" === a) for (r = [], s = 0; s < o.geometry.length; s++) { for (var l = [], u = 0; u < o.geometry[s].length; u++)l.push(At(o.geometry[s][u], e)); r.push(l) } n.push(ct(o.id, a, r, o.tags)) } return n } function At(t, e) { var n = []; n.size = t.size, void 0 !== t.start && (n.start = t.start, n.end = t.end); for (var i = 0; i < t.length; i += 3)n.push(t[i] + e, t[i + 1], t[i + 2]); return n } function zt(t, e) { if (t.transformed) return t; for (var n, i = 1 << t.z, r = t.x, o = t.y, a = 0; a < t.features.length; a++) { var s = t.features[a], l = s.geometry, u = s.type; if (s.geometry = [], 1 === u) for (n = 0; n < l.length; n += 2)s.geometry.push(It(l[n], l[n + 1], e, i, r, o)); else for (n = 0; n < l.length; n++) { for (var c = [], h = 0; h < l[n].length; h += 2)c.push(It(l[n][h], l[n][h + 1], e, i, r, o)); s.geometry.push(c) } } return t.transformed = !0, t } function It(t, e, n, i, r, o) { return [Math.round(n * (t * i - r)), Math.round(n * (e * i - o))] } function kt(t, e, n, i, r) { for (var o = e === r.maxZoom ? 0 : r.tolerance / ((1 << e) * r.extent), a = { features: [], numPoints: 0, numSimplified: 0, numFeatures: 0, source: null, x: n, y: i, z: e, transformed: !1, minX: 2, minY: 1, maxX: -1, maxY: 0 }, s = 0; s < t.length; s++) { a.numFeatures++, function (t, e, n, i) { var r = e.geometry, o = e.type, a = []; if ("Point" === o || "MultiPoint" === o) for (var s = 0; s < r.length; s += 3)a.push(r[s]), a.push(r[s + 1]), t.numPoints++, t.numSimplified++; else if ("LineString" === o) Ct(a, r, t, n, !1, !1); else if ("MultiLineString" === o || "Polygon" === o) for (s = 0; s < r.length; s++)Ct(a, r[s], t, n, "Polygon" === o, 0 === s); else if ("MultiPolygon" === o) for (var l = 0; l < r.length; l++) { var u = r[l]; for (s = 0; s < u.length; s++)Ct(a, u[s], t, n, !0, 0 === s) } if (a.length) { var c = e.tags || null; if ("LineString" === o && i.lineMetrics) { for (var h in c = {}, e.tags) c[h] = e.tags[h]; c.mapbox_clip_start = r.start / r.size, c.mapbox_clip_end = r.end / r.size } i = { geometry: a, type: "Polygon" === o || "MultiPolygon" === o ? 3 : "LineString" === o || "MultiLineString" === o ? 2 : 1, tags: c }; null !== e.id && (i.id = e.id), t.features.push(i) } }(a, t[s], o, r); var l = t[s].minX, u = t[s].minY, c = t[s].maxX, h = t[s].maxY; l < a.minX && (a.minX = l), u < a.minY && (a.minY = u), c > a.maxX && (a.maxX = c), h > a.maxY && (a.maxY = h) } return a } function Ct(t, e, n, i, r, o) { var a = i * i; if (0 < i && e.size < (r ? a : i)) n.numPoints += e.length / 3; else { for (var s = [], l = 0; l < e.length; l += 3)(0 === i || e[l + 2] > a) && (n.numSimplified++, s.push(e[l]), s.push(e[l + 1])), n.numPoints++; r && function (t, e) { for (var n = 0, i = 0, r = t.length, o = r - 2; i < r; o = i, i += 2)n += (t[i] - t[o]) * (t[i + 1] + t[o + 1]); if (0 < n === e) for (i = 0, r = t.length; i < r / 2; i += 2) { var a = t[i], s = t[i + 1]; t[i] = t[r - 2 - i], t[i + 1] = t[r - 1 - i], t[r - 2 - i] = a, t[r - 1 - i] = s } }(s, o), t.push(s) } } function Mt(t, e) { var n = (e = this.options = function (t, e) { for (var n in e) t[n] = e[n]; return t }(Object.create(this.options), e)).debug; if (n && console.time("preprocess data"), e.maxZoom < 0 || 24 < e.maxZoom) throw new Error("maxZoom should be in the 0-24 range"); if (e.promoteId && e.generateId) throw new Error("promoteId and generateId cannot be used together."); var i, r, o, a, s = function (t, e) { var n = []; if ("FeatureCollection" === t.type) for (var i = 0; i < t.features.length; i++)pt(n, t.features[i], e, i); else "Feature" === t.type ? pt(n, t, e) : pt(n, { geometry: t }, e); return n }(t, e); this.tiles = {}, this.tileCoords = [], n && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", e.indexMaxZoom, e.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), i = s, o = (r = e).buffer / r.extent, t = vt(a = i, 1, -1 - o, o, 0, -1, 2, r), e = vt(i, 1, 1 - o, 2 + o, 0, -1, 2, r), (t || e) && (a = vt(i, 1, -o, 1 + o, 0, -1, 2, r) || [], t && (a = Tt(t, 1).concat(a)), e && (a = a.concat(Tt(e, -1)))), (s = a).length && this.splitTile(s, 0, 0, 0), n && (s.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats))) } function Pt(t, e, n) { return 32 * ((1 << t) * n + e) + t } function Lt(t, e) { var n = t.tileID.canonical; if (!this._geoJSONIndex) return e(null, null); t = this._geoJSONIndex.getTile(n.z, n.x, n.y); if (!t) return e(null, null); n = new w(t.features), t = k(n); 0 === t.byteOffset && t.byteLength === t.buffer.byteLength || (t = new Uint8Array(t)), e(null, { vectorTile: n, rawData: t.buffer }) } k.fromVectorTileJs = C, k.fromGeojsonVt = function (t, e) { e = e || {}; var n, i = {}; for (n in t) i[n] = new E(t[n].features, e), i[n].name = n, i[n].version = e.version, i[n].extent = e.extent; return C({ layers: i }) }, k.GeoJSONWrapper = t, Mt.prototype.options = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: !(G.prototype = { options: { minZoom: 0, maxZoom: 16, radius: 40, extent: 512, nodeSize: 64, log: !(U.prototype = { range: function (t, e, n, i) { return function (t, e, n, i, r, o, a) { for (var s = [0, t.length - 1, 0], l = []; s.length;) { var u = s.pop(), c = s.pop(), h = s.pop(); if (c - h <= a) for (var p = h; p <= c; p++)d = e[2 * p], m = e[2 * p + 1], n <= d && d <= r && i <= m && m <= o && l.push(t[p]); else { var f = Math.floor((h + c) / 2), d = e[2 * f], m = e[2 * f + 1]; n <= d && d <= r && i <= m && m <= o && l.push(t[f]); var y = (u + 1) % 2; (0 === u ? n <= d : i <= m) && (s.push(h), s.push(f - 1), s.push(y)), (0 === u ? d <= r : m <= o) && (s.push(f + 1), s.push(c), s.push(y)) } } return l }(this.ids, this.coords, t, e, n, i, this.nodeSize) }, within: function (t, e, n) { return function (t, e, n, i, r, o) { for (var a = [0, t.length - 1, 0], s = [], l = r * r; a.length;) { var u = a.pop(), c = a.pop(), h = a.pop(); if (c - h <= o) for (var p = h; p <= c; p++)N(e[2 * p], e[2 * p + 1], n, i) <= l && s.push(t[p]); else { var f = Math.floor((h + c) / 2), d = e[2 * f], m = e[2 * f + 1]; N(d, m, n, i) <= l && s.push(t[f]); var y = (u + 1) % 2; (0 === u ? n - r <= d : i - r <= m) && (a.push(h), a.push(f - 1), a.push(y)), (0 === u ? d <= n + r : m <= i + r) && (a.push(f + 1), a.push(c), a.push(y)) } } return s }(this.ids, this.coords, t, e, n, this.nodeSize) } }), reduce: null, initial: function () { return {} }, map: function (t) { return t } }, load: function (t) { var e = this.options.log; e && console.time("total time"); var n = "prepare " + t.length + " points"; e && console.time(n), this.points = t; for (var i, r, o = [], a = 0; a < t.length; a++)t[a].geometry && o.push({ x: ot((r = t[i = a].geometry.coordinates)[0]), y: at(r[1]), zoom: 1 / 0, index: i, parentId: -1 }); this.trees[this.options.maxZoom + 1] = j(o, lt, ut, this.options.nodeSize, Float32Array), e && console.timeEnd(n); for (var s = this.options.maxZoom; s >= this.options.minZoom; s--) { var l = +Date.now(), o = this._cluster(o, s); this.trees[s] = j(o, lt, ut, this.options.nodeSize, Float32Array), e && console.log("z%d: %d clusters in %dms", s, o.length, +Date.now() - l) } return e && console.timeEnd("total time"), this }, getClusters: function (t, e) { var n = ((t[0] + 180) % 360 + 360) % 360 - 180, i = Math.max(-90, Math.min(90, t[1])), r = 180 === t[2] ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[3])); if (360 <= t[2] - t[0]) n = -180, r = 180; else if (r < n) { var a = this.getClusters([n, i, 180, o], e), t = this.getClusters([-180, i, r, o], e); return a.concat(t) } for (var s = this.trees[this._limitZoom(e)], l = s.range(ot(n), at(o), ot(r), at(i)), u = [], c = 0; c < l.length; c++) { var h = s.points[l[c]]; u.push(h.numPoints ? it(h) : this.points[h.index]) } return u }, getChildren: function (t) { var e = t >> 5, n = t % 32, i = "No cluster with the specified id.", r = this.trees[n]; if (!r) throw new Error(i); e = r.points[e]; if (!e) throw new Error(i); for (var n = this.options.radius / (this.options.extent * Math.pow(2, n - 1)), o = r.within(e.x, e.y, n), a = [], s = 0; s < o.length; s++) { var l = r.points[o[s]]; l.parentId === t && a.push(l.numPoints ? it(l) : this.points[l.index]) } if (0 === a.length) throw new Error(i); return a }, getLeaves: function (t, e, n) { e = e || 10, n = n || 0; var i = []; return this._appendLeaves(i, t, e, n, 0), i }, getTile: function (t, e, n) { var i = this.trees[this._limitZoom(t)], r = Math.pow(2, t), o = this.options.extent, a = this.options.radius / o, s = (n - a) / r, t = (n + 1 + a) / r, o = { features: [] }; return this._addTileFeatures(i.range((e - a) / r, s, (e + 1 + a) / r, t), i.points, e, n, r, o), 0 === e && this._addTileFeatures(i.range(1 - a / r, s, 1, t), i.points, r, n, r, o), e === r - 1 && this._addTileFeatures(i.range(0, s, a / r, t), i.points, -1, n, r, o), o.features.length ? o : null }, getClusterExpansionZoom: function (t) { for (var e = t % 32 - 1; e < this.options.maxZoom;) { var n = this.getChildren(t); if (e++, 1 !== n.length) break; t = n[0].properties.cluster_id } return e }, _appendLeaves: function (t, e, n, i, r) { for (var o = this.getChildren(e), a = 0; a < o.length; a++) { var s = o[a].properties; if (s && s.cluster ? r + s.point_count <= i ? r += s.point_count : r = this._appendLeaves(t, s.cluster_id, n, i, r) : r < i ? r++ : t.push(o[a]), t.length === n) break } return r }, _addTileFeatures: function (t, e, n, i, r, o) { for (var a = 0; a < t.length; a++) { var s = e[t[a]], l = { type: 1, geometry: [[Math.round(this.options.extent * (s.x * r - n)), Math.round(this.options.extent * (s.y * r - i))]], tags: s.numPoints ? rt(s) : this.points[s.index].properties }, s = (s.numPoints ? s : this.points[s.index]).id; void 0 !== s && (l.id = s), o.features.push(l) } }, _limitZoom: function (t) { return Math.max(this.options.minZoom, Math.min(t, this.options.maxZoom + 1)) }, _cluster: function (t, e) { for (var n = [], i = this.options.radius / (this.options.extent * Math.pow(2, e)), r = 0; r < t.length; r++) { var o = t[r]; if (!(o.zoom <= e)) { o.zoom = e; var a = this.trees[e + 1], s = a.within(o.x, o.y, i), l = o.numPoints || 1, u = o.x * l, c = o.y * l, h = null; this.options.reduce && (h = this.options.initial(), this._accumulate(h, o)); for (var p = (r << 5) + (e + 1), f = 0; f < s.length; f++) { var d, m = a.points[s[f]]; m.zoom <= e || (m.zoom = e, d = m.numPoints || 1, u += m.x * d, c += m.y * d, l += d, m.parentId = p, this.options.reduce && this._accumulate(h, m)) } 1 === l ? n.push(o) : (o.parentId = p, n.push({ x: u / l, y: c / l, zoom: 1 / 0, id: p, parentId: -1, numPoints: l, properties: h })) } } return n }, _accumulate: function (t, e) { e = e.numPoints ? e.properties : this.options.map(this.points[e.index].properties); this.options.reduce(t, e) } }), promoteId: null, generateId: !1, debug: 0 }, Mt.prototype.splitTile = function (t, e, n, i, r, o, a) { for (var s = [t, e, n, i], l = this.options, u = l.debug; s.length;) { i = s.pop(), n = s.pop(), e = s.pop(), t = s.pop(); var c, h, p, f, d, m, y, g, v = 1 << e, _ = Pt(e, n, i), x = this.tiles[_]; if (!x && (1 < u && console.time("creation"), x = this.tiles[_] = kt(t, e, n, i, l), this.tileCoords.push({ z: e, x: n, y: i }), u) && (1 < u && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", e, n, i, x.numFeatures, x.numPoints, x.numSimplified), console.timeEnd("creation")), g = "z" + e, this.stats[g] = (this.stats[g] || 0) + 1, this.total++), x.source = t, r) { if (e === l.maxZoom || e === r) continue; var b = 1 << r - e; if (n !== Math.floor(o / b) || i !== Math.floor(a / b)) continue } else if (e === l.indexMaxZoom || x.numPoints <= l.indexMaxPoints) continue; x.source = null, 0 !== t.length && (1 < u && console.time("clipping"), d = .5 - (f = .5 * l.buffer / l.extent), m = 1 + f, y = c = h = p = null, g = vt(t, v, n - f, n + (_ = .5 + f), 0, x.minX, x.maxX, l), b = vt(t, v, n + d, n + m, 0, x.minX, x.maxX, l), t = null, g && (y = vt(g, v, i - f, i + _, 1, x.minY, x.maxY, l), c = vt(g, v, i + d, i + m, 1, x.minY, x.maxY, l), g = null), b && (h = vt(b, v, i - f, i + _, 1, x.minY, x.maxY, l), p = vt(b, v, i + d, i + m, 1, x.minY, x.maxY, l), b = null), 1 < u && console.timeEnd("clipping"), s.push(y || [], e + 1, 2 * n, 2 * i), s.push(c || [], e + 1, 2 * n, 2 * i + 1), s.push(h || [], e + 1, 2 * n + 1, 2 * i), s.push(p || [], e + 1, 2 * n + 1, 2 * i + 1)) } }, Mt.prototype.getTile = function (t, e, n) { var i = this.options, r = i.extent, o = i.debug; if (t < 0 || 24 < t) return null; i = 1 << t, i = Pt(t, e = (e % i + i) % i, n); if (this.tiles[i]) return zt(this.tiles[i], r); 1 < o && console.log("drilling down to z%d-%d-%d", t, e, n); for (var a, s = t, l = e, u = n; !a && 0 < s;)s--, l = Math.floor(l / 2), u = Math.floor(u / 2), a = this.tiles[Pt(s, l, u)]; return a && a.source ? (1 < o && console.log("found parent tile z%d-%d-%d", s, l, u), 1 < o && console.time("drilling down"), this.splitTile(a.source, s, l, u, t, e, n), 1 < o && console.timeEnd("drilling down"), this.tiles[i] ? zt(this.tiles[i], r) : null) : null }; var Dt, Rt = ((Dt = s) && (Bt.__proto__ = Dt), ((Bt.prototype = Object.create(Dt && Dt.prototype)).constructor = Bt).prototype.loadData = function (t, e) { this._pendingCallback && this._pendingCallback(null, { abandoned: !0 }), this._pendingCallback = e, this._pendingLoadDataParams = t, this._state && "Idle" !== this._state ? this._state = "NeedsLoadData" : (this._state = "Coalescing", this._loadData()) }, Bt.prototype._loadData = function () { var r, o, a, s = this; this._pendingCallback && this._pendingLoadDataParams && (r = this._pendingCallback, o = this._pendingLoadDataParams, delete this._pendingCallback, delete this._pendingLoadDataParams, a = !!(o && o.request && o.request.collectResourceTiming) && new c.Performance(o.request), this.loadGeoJSON(o, function (t, e) { if (t || !e) return r(t); if ("object" != typeof e) return r(new Error("Input data is not a valid GeoJSON object.")); d(e, !0); try { s._geoJSONIndex = o.cluster ? new G(o.superclusterOptions).load(e.features) : new Mt(e, o.geojsonVtOptions) } catch (t) { return r(t) } s.loaded = {}; var n, i = {}; !a || (n = a.finish()) && (i.resourceTiming = {}, i.resourceTiming[o.source] = JSON.parse(JSON.stringify(n))), r(null, i) })) }, Bt.prototype.coalesce = function () { "Coalescing" === this._state ? this._state = "Idle" : "NeedsLoadData" === this._state && (this._state = "Coalescing", this._loadData()) }, Bt.prototype.reloadTile = function (t, e) { var n = this.loaded, i = t.uid; return n && n[i] ? Dt.prototype.reloadTile.call(this, t, e) : this.loadTile(t, e) }, Bt.prototype.loadGeoJSON = function (t, e) { if (t.request) X.getJSON(t.request, e); else { if ("string" != typeof t.data) return e(new Error("Input data is not a valid GeoJSON object.")); try { return e(null, JSON.parse(t.data)) } catch (t) { return e(new Error("Input data is not a valid GeoJSON object.")) } } }, Bt.prototype.removeSource = function (t, e) { this._pendingCallback && this._pendingCallback(null, { abandoned: !0 }), e() }, Bt.prototype.getClusterExpansionZoom = function (t, e) { e(null, this._geoJSONIndex.getClusterExpansionZoom(t.clusterId)) }, Bt.prototype.getClusterChildren = function (t, e) { e(null, this._geoJSONIndex.getChildren(t.clusterId)) }, Bt.prototype.getClusterLeaves = function (t, e) { e(null, this._geoJSONIndex.getLeaves(t.clusterId, t.limit, t.offset)) }, Bt), t = function (t) { var n = this; this.self = t, this.actor = new X.Actor(t, this), this.layerIndexes = {}, this.workerSourceTypes = { vector: s, geojson: Rt }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = function (t, e) { if (n.workerSourceTypes[t]) throw new Error('Worker source with name "' + t + '" already registered.'); n.workerSourceTypes[t] = e }, this.self.registerRTLTextPlugin = function (t) { if (X.plugin.isLoaded()) throw new Error("RTL text plugin already registered."); X.plugin.applyArabicShaping = t.applyArabicShaping, X.plugin.processBidirectionalText = t.processBidirectionalText, X.plugin.processStyledBidirectionalText = t.processStyledBidirectionalText } }; function Bt(t, e, n) { Dt.call(this, t, e, Lt), n && (this.loadGeoJSON = n) } return t.prototype.setLayers = function (t, e, n) { this.getLayerIndex(t).replace(e), n() }, t.prototype.updateLayers = function (t, e, n) { this.getLayerIndex(t).update(e.layers, e.removedIds), n() }, t.prototype.loadTile = function (t, e, n) { this.getWorkerSource(t, e.type, e.source).loadTile(e, n) }, t.prototype.loadDEMTile = function (t, e, n) { this.getDEMWorkerSource(t, e.source).loadTile(e, n) }, t.prototype.reloadTile = function (t, e, n) { this.getWorkerSource(t, e.type, e.source).reloadTile(e, n) }, t.prototype.abortTile = function (t, e, n) { this.getWorkerSource(t, e.type, e.source).abortTile(e, n) }, t.prototype.removeTile = function (t, e, n) { this.getWorkerSource(t, e.type, e.source).removeTile(e, n) }, t.prototype.removeDEMTile = function (t, e) { this.getDEMWorkerSource(t, e.source).removeTile(e) }, t.prototype.removeSource = function (t, e, n) { var i; this.workerSources[t] && this.workerSources[t][e.type] && this.workerSources[t][e.type][e.source] && (i = this.workerSources[t][e.type][e.source], delete this.workerSources[t][e.type][e.source], void 0 !== i.removeSource ? i.removeSource(e, n) : n()) }, t.prototype.loadWorkerSource = function (t, e, n) { try { this.self.importScripts(e.url), n() } catch (t) { n(t.toString()) } }, t.prototype.loadRTLTextPlugin = function (t, e, n) { try { X.plugin.isLoaded() || (this.self.importScripts(e), n(X.plugin.isLoaded() ? null : new Error("RTL Text Plugin failed to import scripts from " + e))) } catch (t) { n(t.toString()) } }, t.prototype.getLayerIndex = function (t) { return this.layerIndexes[t] || (this.layerIndexes[t] = new e) }, t.prototype.getWorkerSource = function (i, t, e) { var n, r = this; return this.workerSources[i] || (this.workerSources[i] = {}), this.workerSources[i][t] || (this.workerSources[i][t] = {}), this.workerSources[i][t][e] || (n = { send: function (t, e, n) { r.actor.send(t, e, n, i) } }, this.workerSources[i][t][e] = new this.workerSourceTypes[t](n, this.getLayerIndex(i))), this.workerSources[i][t][e] }, t.prototype.getDEMWorkerSource = function (t, e) { return this.demWorkerSources[t] || (this.demWorkerSources[t] = {}), this.demWorkerSources[t][e] || (this.demWorkerSources[t][e] = new l), this.demWorkerSources[t][e] }, "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope && new t(self), t }), t(0, function (D) { var n = D.createCommonjsModule(function (t) { function r(t) { return !!("undefined" != typeof window && "undefined" != typeof document && Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray && Function.prototype && Function.prototype.bind && Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions && "JSON" in window && "parse" in JSON && "stringify" in JSON && function () { if ("Worker" in window && "Blob" in window && "URL" in window) { var t, e, n = new Blob([""], { type: "text/javascript" }), i = URL.createObjectURL(n); try { e = new Worker(i), t = !0 } catch (e) { t = !1 } return e && e.terminate(), URL.revokeObjectURL(i), t } }() && "Uint8ClampedArray" in window && ArrayBuffer.isView && (e = t && t.failIfMajorPerformanceCaveat, void 0 === o[e] && (o[e] = (n = e, i = document.createElement("canvas"), (t = Object.create(r.webGLContextAttributes)).failIfMajorPerformanceCaveat = n, i.probablySupportsContext ? i.probablySupportsContext("webgl", t) || i.probablySupportsContext("experimental-webgl", t) : i.supportsContext ? i.supportsContext("webgl", t) || i.supportsContext("experimental-webgl", t) : i.getContext("webgl", t) || i.getContext("experimental-webgl", t))), o[e])); var e, n, i } t.exports ? t.exports = r : window && (window.mapboxgl = window.mapboxgl || {}, window.mapboxgl.supported = r); var o = {}; r.webGLContextAttributes = { antialias: !1, alpha: !0, stencil: !0, depth: !0 } }), d = { create: function (t, e, n) { t = D.window.document.createElement(t); return e && (t.className = e), n && n.appendChild(t), t }, createNS: function (t, e) { return D.window.document.createElementNS(t, e) } }, i = D.window.document ? D.window.document.documentElement.style : null; function t(t) { if (!i) return null; for (var e = 0; e < t.length; e++)if (t[e] in i) return t[e]; return t[0] } var e, r = t(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]); d.disableDrag = function () { i && r && (e = i[r], i[r] = "none") }, d.enableDrag = function () { i && r && (i[r] = e) }; var o = t(["transform", "WebkitTransform"]), a = !(d.setTransform = function (t, e) { t.style[o] = e }); try { var s = Object.defineProperty({}, "passive", { get: function () { a = !0 } }); D.window.addEventListener("test", s, s), D.window.removeEventListener("test", s, s) } catch (D) { a = !1 } d.addEventListener = function (t, e, n, i) { void 0 === i && (i = {}), "passive" in i && a ? t.addEventListener(e, n, i) : t.addEventListener(e, n, i.capture) }, d.removeEventListener = function (t, e, n, i) { void 0 === i && (i = {}), "passive" in i && a ? t.removeEventListener(e, n, i) : t.removeEventListener(e, n, i.capture) }; var l = function (t) { t.preventDefault(), t.stopPropagation(), D.window.removeEventListener("click", l, !0) }; d.suppressClick = function () { D.window.addEventListener("click", l, !0), D.window.setTimeout(function () { D.window.removeEventListener("click", l, !0) }, 0) }, d.mousePos = function (t, e) { var n = t.getBoundingClientRect(); return e = e.touches ? e.touches[0] : e, new D.Point(e.clientX - n.left - t.clientLeft, e.clientY - n.top - t.clientTop) }, d.touchPos = function (t, e) { for (var n = t.getBoundingClientRect(), i = [], r = "touchend" === e.type ? e.changedTouches : e.touches, o = 0; o < r.length; o++)i.push(new D.Point(r[o].clientX - n.left - t.clientLeft, r[o].clientY - n.top - t.clientTop)); return i }, d.mouseButton = function (t) { return void 0 !== D.window.InstallTrigger && 2 === t.button && t.ctrlKey && 0 <= D.window.navigator.platform.toUpperCase().indexOf("MAC") ? 0 : t.button }, d.remove = function (t) { t.parentNode && t.parentNode.removeChild(t) }; var u = { API_URL: "https://api.mapbox.com", EVENTS_URL: "https://events.mapbox.com/events/v2", REQUIRE_ACCESS_TOKEN: !0, ACCESS_TOKEN: null }, c = "See https://www.mapbox.com/api-documentation/#access-tokens"; function h(t, e) { var n = v(u.API_URL); if (t.protocol = n.protocol, t.authority = n.authority, "/" !== n.path && (t.path = "" + n.path + t.path), !u.REQUIRE_ACCESS_TOKEN) return _(t); if (!(e = e || u.ACCESS_TOKEN)) throw new Error("An API access token is required to use Mapbox GL. " + c); if ("s" === e[0]) throw new Error("Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). " + c); return t.params.push("access_token=" + e), _(t) } function p(t) { return 0 === t.indexOf("mapbox:") } function y(t, e, n, i) { var r = v(t); return p(t) ? (r.path = "/styles/v1" + r.path + "/sprite" + e + n, h(r, i)) : (r.path += "" + e + n, _(r)) } function f(t, e, n) { return e && p(e) ? (e = v(t), t = 2 <= D.browser.devicePixelRatio || 512 === n ? "@2x" : "", n = D.browser.supportsWebp ? ".webp" : "$1", e.path = e.path.replace(m, t + n), function (t) { for (var e = 0; e < t.length; e++)0 === t[e].indexOf("access_token=tk.") && (t[e] = "access_token=" + (u.ACCESS_TOKEN || "")) }(e.params), _(e)) : t } var m = /(\.(png|jpg)\d*)(?=$)/, g = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/; function v(t) { t = t.match(g); if (!t) throw new Error("Unable to parse URL object"); return { protocol: t[1], authority: t[2], path: t[3] || "/", params: t[4] ? t[4].split("&") : [] } } function _(t) { var e = t.params.length ? "?" + t.params.join("&") : ""; return t.protocol + "://" + t.authority + t.path + e } var x = function () { this.eventData = { anonId: null, lastSuccess: null, accessToken: u.ACCESS_TOKEN }, this.queue = [], this.pending = !1, this.pendingRequest = null }; x.prototype.postTurnstileEvent = function (t) { u.ACCESS_TOKEN && Array.isArray(t) && t.some(function (t) { return /(mapbox\.c)(n|om)/i.test(t) }) && this.queueRequest(D.browser.now()) }, x.prototype.queueRequest = function (t) { this.queue.push(t), this.processRequests() }, x.prototype.processRequests = function () { var e = this; if (!this.pendingRequest && 0 !== this.queue.length) { var n = "mapbox.turnstileEventData:" + (u.ACCESS_TOKEN || ""), i = D.storageAvailable("localStorage"), t = !!this.eventData.accessToken && this.eventData.accessToken !== u.ACCESS_TOKEN; if (t && (this.eventData.anonId = this.eventData.lastSuccess = null), (!this.eventData.anonId || !this.eventData.lastSuccess) && i) try { var r = D.window.localStorage.getItem(n); r && (this.eventData = JSON.parse(r)) } catch (e) { D.warnOnce("Unable to read from LocalStorage") } D.validateUuid(this.eventData.anonId) || (this.eventData.anonId = D.uuid(), t = !0); var o, a, s = this.queue.shift(); if (this.eventData.lastSuccess && (o = new Date(this.eventData.lastSuccess), l = new Date(s), a = (s - this.eventData.lastSuccess) / 864e5, t = t || 1 <= a || a < -1 || o.getDate() !== l.getDate()), !t) return this.processRequests(); var l = v(u.EVENTS_URL); l.params.push("access_token=" + (u.ACCESS_TOKEN || "")); t = { url: _(l), headers: { "Content-Type": "text/plain" } }, l = JSON.stringify([{ event: "appUserTurnstile", created: new Date(s).toISOString(), sdkIdentifier: "mapbox-gl-js", sdkVersion: "0.48.0", "enabled.telemetry": !1, userId: this.eventData.anonId }]); this.pendingRequest = D.postData(t, l, function (t) { if (e.pendingRequest = null, !t) { if (e.eventData.lastSuccess = s, e.eventData.accessToken = u.ACCESS_TOKEN, i) try { D.window.localStorage.setItem(n, JSON.stringify(e.eventData)) } catch (t) { D.warnOnce("Unable to write to LocalStorage") } e.processRequests() } }) } }; var b = new x, w = b.postTurnstileEvent.bind(b), E = function () { this.images = {}, this.loaded = !1, this.requestors = [], this.shelfPack = new D.ShelfPack(64, 64, { autoResize: !0 }), this.patterns = {}, this.atlasImage = new D.RGBAImage({ width: 64, height: 64 }), this.dirty = !0 }; E.prototype.isLoaded = function () { return this.loaded }, E.prototype.setLoaded = function (t) { if (this.loaded !== t && (this.loaded = t)) { for (var e = 0, n = this.requestors; e < n.length; e += 1) { var i = n[e], r = i.ids, i = i.callback; this._notify(r, i) } this.requestors = [] } }, E.prototype.getImage = function (t) { return this.images[t] }, E.prototype.addImage = function (t, e) { this.images[t] = e }, E.prototype.removeImage = function (t) { delete this.images[t]; var e = this.patterns[t]; e && (this.shelfPack.unref(e.bin), delete this.patterns[t]) }, E.prototype.listImages = function () { return Object.keys(this.images) }, E.prototype.getImages = function (t, e) { var n = !0; if (!this.isLoaded()) for (var i = 0, r = t; i < r.length; i += 1) { var o = r[i]; this.images[o] || (n = !1) } this.isLoaded() || n ? this._notify(t, e) : this.requestors.push({ ids: t, callback: e }) }, E.prototype._notify = function (t, e) { for (var n = {}, i = 0, r = t; i < r.length; i += 1) { var o = r[i], a = this.images[o]; a && (n[o] = { data: a.data.clone(), pixelRatio: a.pixelRatio, sdf: a.sdf }) } e(null, n) }, E.prototype.getPixelSize = function () { return { width: this.shelfPack.w, height: this.shelfPack.h } }, E.prototype.getPattern = function (t) { var e = this.patterns[t]; if (e) return e.position; var n = this.getImage(t); if (!n) return null; var i = n.data.width + 2, r = n.data.height + 2, o = this.shelfPack.packOne(i, r); if (!o) return null; this.atlasImage.resize(this.getPixelSize()); var a = n.data, s = this.atlasImage, l = o.x + 1, e = o.y + 1, i = a.width, r = a.height; D.RGBAImage.copy(a, s, { x: 0, y: 0 }, { x: l, y: e }, { width: i, height: r }), D.RGBAImage.copy(a, s, { x: 0, y: r - 1 }, { x: l, y: e - 1 }, { width: i, height: 1 }), D.RGBAImage.copy(a, s, { x: 0, y: 0 }, { x: l, y: e + r }, { width: i, height: 1 }), D.RGBAImage.copy(a, s, { x: i - 1, y: 0 }, { x: l - 1, y: e }, { width: 1, height: r }), D.RGBAImage.copy(a, s, { x: 0, y: 0 }, { x: l + i, y: e }, { width: 1, height: r }), this.dirty = !0; n = new D.ImagePosition(o, n); return this.patterns[t] = { bin: o, position: n }, n }, E.prototype.bind = function (t) { var e = t.gl; this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new D.Texture(t, this.atlasImage, e.RGBA), this.atlasTexture.bind(e.LINEAR, e.CLAMP_TO_EDGE) }; var S = A, T = 1e20; function A(t, e, n, i, r, o) { this.fontSize = t || 24, this.buffer = void 0 === e ? 3 : e, this.cutoff = i || .25, this.fontFamily = r || "sans-serif", this.fontWeight = o || "normal", this.radius = n || 8; n = this.size = this.fontSize + 2 * this.buffer; this.canvas = document.createElement("canvas"), this.canvas.width = this.canvas.height = n, this.ctx = this.canvas.getContext("2d"), this.ctx.font = this.fontWeight + " " + this.fontSize + "px " + this.fontFamily, this.ctx.textBaseline = "middle", this.ctx.fillStyle = "black", this.gridOuter = new Float64Array(n * n), this.gridInner = new Float64Array(n * n), this.f = new Float64Array(n), this.d = new Float64Array(n), this.z = new Float64Array(n + 1), this.v = new Int16Array(n), this.middle = Math.round(n / 2 * (0 <= navigator.userAgent.indexOf("Gecko/") ? 1.2 : 1)) } function z(t, e, n, i, r, o, a) { for (var s = 0; s < e; s++) { for (var l = 0; l < n; l++)i[l] = t[l * e + s]; for (I(i, r, o, a, n), l = 0; l < n; l++)t[l * e + s] = r[l] } for (l = 0; l < n; l++) { for (s = 0; s < e; s++)i[s] = t[l * e + s]; for (I(i, r, o, a, e), s = 0; s < e; s++)t[l * e + s] = Math.sqrt(r[s]) } } function I(t, e, n, i, r) { i[n[0] = 0] = -T, i[1] = +T; for (var o = 1, a = 0; o < r; o++) { for (var s = (t[o] + o * o - (t[n[a]] + n[a] * n[a])) / (2 * o - 2 * n[a]); s <= i[a];)a--, s = (t[o] + o * o - (t[n[a]] + n[a] * n[a])) / (2 * o - 2 * n[a]); n[++a] = o, i[a] = s, i[a + 1] = +T } for (a = o = 0; o < r; o++) { for (; i[a + 1] < o;)a++; e[o] = (o - n[a]) * (o - n[a]) + t[n[a]] } } A.prototype.draw = function (t) { this.ctx.clearRect(0, 0, this.size, this.size), this.ctx.fillText(t, this.buffer, this.middle); for (var e = this.ctx.getImageData(0, 0, this.size, this.size), n = new Uint8ClampedArray(this.size * this.size), i = 0; i < this.size * this.size; i++) { var r = e.data[4 * i + 3] / 255; this.gridOuter[i] = 1 == r ? 0 : 0 == r ? T : Math.pow(Math.max(0, .5 - r), 2), this.gridInner[i] = 1 == r ? T : 0 == r ? 0 : Math.pow(Math.max(0, r - .5), 2) } for (z(this.gridOuter, this.size, this.size, this.f, this.d, this.v, this.z), z(this.gridInner, this.size, this.size, this.f, this.d, this.v, this.z), i = 0; i < this.size * this.size; i++) { var o = this.gridOuter[i] - this.gridInner[i]; n[i] = Math.max(0, Math.min(255, Math.round(255 - 255 * (o / this.radius + this.cutoff)))) } return n }; var k = function (t, e) { this.requestTransform = t, this.localIdeographFontFamily = e, this.entries = {} }; k.prototype.setURL = function (t) { this.url = t }, k.prototype.getGlyphs = function (t, l) { var e, u = this, n = []; for (e in t) for (var i = 0, r = t[e]; i < r.length; i += 1) { var o = r[i]; n.push({ stack: e, id: o }) } D.asyncAll(n, function (t, n) { var o, a, i = t.stack, r = t.id, s = u.entries[i], t = (s = s || (u.entries[i] = { glyphs: {}, requests: {} })).glyphs[r]; void 0 !== t || (t = u._tinySDF(s, i, r)) ? n(null, { stack: i, id: r, glyph: t }) : 65535 < 256 * (o = Math.floor(r / 256)) ? n(new Error("glyphs > 65535 not supported")) : ((a = s.requests[o]) || (a = s.requests[o] = [], k.loadGlyphRange(i, o, u.url, u.requestTransform, function (t, e) { if (e) for (var n in e) s.glyphs[+n] = e[+n]; for (var i = 0, r = a; i < r.length; i += 1)(0, r[i])(t, e); delete s.requests[o] })), a.push(function (t, e) { t ? n(t) : e && n(null, { stack: i, id: r, glyph: e[r] || null }) })) }, function (t, e) { if (t) l(t); else if (e) { for (var n = {}, i = 0, r = e; i < r.length; i += 1) { var o = r[i], a = o.stack, s = o.id, o = o.glyph; (n[a] || (n[a] = {}))[s] = o && { id: o.id, bitmap: o.bitmap.clone(), metrics: o.metrics } } l(null, n) } }) }, k.prototype._tinySDF = function (t, e, n) { var i = this.localIdeographFontFamily; if (i && (D.isChar["CJK Unified Ideographs"](n) || D.isChar["Hangul Syllables"](n))) { var r, o = t.tinySDF; return o || (r = "400", /bold/i.test(e) ? r = "900" : /medium/i.test(e) ? r = "500" : /light/i.test(e) && (r = "200"), o = t.tinySDF = new k.TinySDF(24, 3, 8, .25, i, r)), { id: n, bitmap: new D.AlphaImage({ width: 30, height: 30 }, o.draw(String.fromCharCode(n))), metrics: { width: 24, height: 24, left: 0, top: -8, advance: 24 } } } }, k.loadGlyphRange = function (t, e, n, i, a) { var r = 256 * e, e = 255 + r, e = i(function (t, e) { if (!p(t)) return t; t = v(t); return t.path = "/fonts/v1" + t.path, h(t, e) }(n).replace("{fontstack}", t).replace("{range}", r + "-" + e), D.ResourceType.Glyphs); D.getArrayBuffer(e, function (t, e) { if (t) a(t); else if (e) { for (var n = {}, i = 0, r = D.parseGlyphPBF(e.data); i < r.length; i += 1) { var o = r[i]; n[o.id] = o } a(null, n) } }) }, k.TinySDF = S; var C = function () { this.specification = D.styleSpec.light.position }; C.prototype.possiblyEvaluate = function (t, e) { return D.sphericalToCartesian(t.expression.evaluate(e)) }, C.prototype.interpolate = function (t, e, n) { return { x: D.number(t.x, e.x, n), y: D.number(t.y, e.y, n), z: D.number(t.z, e.z, n) } }; var M, P = new D.Properties({ anchor: new D.DataConstantProperty(D.styleSpec.light.anchor), position: new C, color: new D.DataConstantProperty(D.styleSpec.light.color), intensity: new D.DataConstantProperty(D.styleSpec.light.intensity) }), L = ((M = D.Evented) && (B.__proto__ = M), ((B.prototype = Object.create(M && M.prototype)).constructor = B).prototype.getLight = function () { return this._transitionable.serialize() }, B.prototype.setLight = function (t) { if (!this._validate(D.validateLight, t)) for (var e in t) { var n = t[e]; D.endsWith(e, "-transition") ? this._transitionable.setTransition(e.slice(0, -"-transition".length), n) : this._transitionable.setValue(e, n) } }, B.prototype.updateTransitions = function (t) { this._transitioning = this._transitionable.transitioned(t, this._transitioning) }, B.prototype.hasTransition = function () { return this._transitioning.hasTransition() }, B.prototype.recalculate = function (t) { this.properties = this._transitioning.possiblyEvaluate(t) }, B.prototype._validate = function (t, e) { return D.emitValidationErrors(this, t.call(D.validateStyle, D.extend({ value: e, style: { glyphs: !0, sprite: !0 }, styleSpec: D.styleSpec }))) }, B), R = function (t, e) { this.width = t, this.height = e, this.nextRow = 0, this.bytes = 4, this.data = new Uint8Array(this.width * this.height * this.bytes), this.positions = {} }; function B(t) { M.call(this), this._transitionable = new D.Transitionable(P), this.setLight(t), this._transitioning = this._transitionable.untransitioned() } R.prototype.getDash = function (t, e) { var n = t.join(",") + String(e); return this.positions[n] || (this.positions[n] = this.addDash(t, e)), this.positions[n] }, R.prototype.addDash = function (t, e) { var n = e ? 7 : 0, i = 2 * n + 1; if (this.nextRow + i > this.height) return D.warnOnce("LineAtlas out of space"), null; for (var r = 0, o = 0; o < t.length; o++)r += t[o]; for (var a = this.width / r, s = a / 2, l = t.length % 2 == 1, u = -n; u <= n; u++)for (var c = this.nextRow + n + u, h = this.width * c, p = l ? -t[t.length - 1] : 0, f = t[0], d = 1, m = 0; m < this.width; m++) { for (; f < m / a;)p = f, f += t[d], l && d === t.length - 1 && (f += t[0]), d++; var y = Math.abs(m - p * a), g = Math.abs(m - f * a), v = Math.min(y, g), _ = d % 2 == 1, x = void 0; x = e ? (y = n ? u / n * (1 + s) : 0, _ ? (g = s - Math.abs(y), Math.sqrt(v * v + g * g)) : s - Math.sqrt(v * v + y * y)) : (_ ? 1 : -1) * v, this.data[3 + 4 * (h + m)] = Math.max(0, Math.min(255, x + 128)) } var b = { y: (this.nextRow + n + .5) / this.height, height: 2 * n / this.height, width: r }; return this.nextRow += i, this.dirty = !0, b }, R.prototype.bind = function (t) { t = t.gl; this.texture ? (t.bindTexture(t.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, this.width, this.height, t.RGBA, t.UNSIGNED_BYTE, this.data))) : (this.texture = t.createTexture(), t.bindTexture(t.TEXTURE_2D, this.texture), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.REPEAT), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.REPEAT), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.LINEAR), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, this.width, this.height, 0, t.RGBA, t.UNSIGNED_BYTE, this.data)) }; var O = function t(e, n) { this.workerPool = e, this.actors = [], this.currentActor = 0, this.id = D.uniqueId(); for (var i = this.workerPool.acquire(this.id), r = 0; r < i.length; r++) { var o = i[r], o = new t.Actor(o, n, this.id); o.name = "Worker " + r, this.actors.push(o) } }; function F(t, e, n) { function i(t, e) { if (t) return n(t); e && (t = D.pick(e, ["tiles", "minzoom", "maxzoom", "attribution", "mapbox_logo", "bounds"]), e.vector_layers && (t.vectorLayers = e.vector_layers, t.vectorLayerIds = t.vectorLayers.map(function (t) { return t.id })), n(null, t)) } return t.url ? D.getJSON(e(function (t, e) { if (!p(t)) return t; t = v(t); return t.path = "/v4/" + t.authority + ".json", t.params.push("secure"), h(t, e) }(t.url), D.ResourceType.Source), i) : D.browser.frame(function () { return i(null, t) }) } O.prototype.broadcast = function (n, i, t) { t = t || function () { }, D.asyncAll(this.actors, function (t, e) { t.send(n, i, e) }, t) }, O.prototype.send = function (t, e, n, i) { return "number" == typeof i && !isNaN(i) || (i = this.currentActor = (this.currentActor + 1) % this.actors.length), this.actors[i].send(t, e, n), i }, O.prototype.remove = function () { this.actors.forEach(function (t) { t.remove() }), this.actors = [], this.workerPool.release(this.id) }, O.Actor = D.Actor; function V(t, e) { if (isNaN(t) || isNaN(e)) throw new Error("Invalid LngLat object: (" + t + ", " + e + ")"); if (this.lng = +t, this.lat = +e, 90 < this.lat || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90") } V.prototype.wrap = function () { return new V(D.wrap(this.lng, -180, 180), this.lat) }, V.prototype.toArray = function () { return [this.lng, this.lat] }, V.prototype.toString = function () { return "LngLat(" + this.lng + ", " + this.lat + ")" }, V.prototype.toBounds = function (t) { var e = 360 * t / 40075017, t = e / Math.cos(Math.PI / 180 * this.lat); return new N(new V(this.lng - t, this.lat - e), new V(this.lng + t, this.lat + e)) }, V.convert = function (t) { if (t instanceof V) return t; if (Array.isArray(t) && (2 === t.length || 3 === t.length)) return new V(Number(t[0]), Number(t[1])); if (!Array.isArray(t) && "object" == typeof t && null !== t) return new V(Number(t.lng), Number(t.lat)); throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]") }; var N = function (t, e) { t && (e ? this.setSouthWest(t).setNorthEast(e) : 4 === t.length ? this.setSouthWest([t[0], t[1]]).setNorthEast([t[2], t[3]]) : this.setSouthWest(t[0]).setNorthEast(t[1])) }; N.prototype.setNorthEast = function (t) { return this._ne = t instanceof V ? new V(t.lng, t.lat) : V.convert(t), this }, N.prototype.setSouthWest = function (t) { return this._sw = t instanceof V ? new V(t.lng, t.lat) : V.convert(t), this }, N.prototype.extend = function (t) { var e, n, i = this._sw, r = this._ne; if (t instanceof V) n = e = t; else { if (!(t instanceof N)) return Array.isArray(t) ? t.every(Array.isArray) ? this.extend(N.convert(t)) : this.extend(V.convert(t)) : this; if (e = t._sw, n = t._ne, !e || !n) return this } return i || r ? (i.lng = Math.min(e.lng, i.lng), i.lat = Math.min(e.lat, i.lat), r.lng = Math.max(n.lng, r.lng), r.lat = Math.max(n.lat, r.lat)) : (this._sw = new V(e.lng, e.lat), this._ne = new V(n.lng, n.lat)), this }, N.prototype.getCenter = function () { return new V((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2) }, N.prototype.getSouthWest = function () { return this._sw }, N.prototype.getNorthEast = function () { return this._ne }, N.prototype.getNorthWest = function () { return new V(this.getWest(), this.getNorth()) }, N.prototype.getSouthEast = function () { return new V(this.getEast(), this.getSouth()) }, N.prototype.getWest = function () { return this._sw.lng }, N.prototype.getSouth = function () { return this._sw.lat }, N.prototype.getEast = function () { return this._ne.lng }, N.prototype.getNorth = function () { return this._ne.lat }, N.prototype.toArray = function () { return [this._sw.toArray(), this._ne.toArray()] }, N.prototype.toString = function () { return "LngLatBounds(" + this._sw.toString() + ", " + this._ne.toString() + ")" }, N.prototype.isEmpty = function () { return !(this._sw && this._ne) }, N.convert = function (t) { return !t || t instanceof N ? t : new N(t) }; function j(t, e, n) { this.bounds = N.convert(this.validateBounds(t)), this.minzoom = e || 0, this.maxzoom = n || 24 } j.prototype.validateBounds = function (t) { return Array.isArray(t) && 4 === t.length ? [Math.max(-180, t[0]), Math.max(-90, t[1]), Math.min(180, t[2]), Math.min(90, t[3])] : [-180, -90, 180, 90] }, j.prototype.contains = function (t) { var e = Math.floor(this.lngX(this.bounds.getWest(), t.z)), n = Math.floor(this.latY(this.bounds.getNorth(), t.z)), i = Math.ceil(this.lngX(this.bounds.getEast(), t.z)), r = Math.ceil(this.latY(this.bounds.getSouth(), t.z)); return t.x >= e && t.x < i && t.y >= n && t.y < r }, j.prototype.lngX = function (t, e) { return (t + 180) * (Math.pow(2, e) / 360) }, j.prototype.latY = function (t, e) { var n = D.clamp(Math.sin(Math.PI / 180 * t), -.9999, .9999), t = Math.pow(2, e) / (2 * Math.PI); return Math.pow(2, e - 1) + .5 * Math.log((1 + n) / (1 - n)) * -t }; var U, q, Z, G, X = ((G = D.Evented) && ($.__proto__ = G), (($.prototype = Object.create(G && G.prototype)).constructor = $).prototype.load = function () { var n = this; this.fire(new D.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = F(this._options, this.map._transformRequest, function (t, e) { n._tileJSONRequest = null, t ? n.fire(new D.ErrorEvent(t)) : e && (D.extend(n, e), e.bounds && (n.tileBounds = new j(e.bounds, n.minzoom, n.maxzoom)), w(e.tiles), n.fire(new D.Event("data", { dataType: "source", sourceDataType: "metadata" })), n.fire(new D.Event("data", { dataType: "source", sourceDataType: "content" }))) }) }, $.prototype.hasTile = function (t) { return !this.tileBounds || this.tileBounds.contains(t.canonical) }, $.prototype.onAdd = function (t) { this.map = t, this.load() }, $.prototype.onRemove = function () { this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null) }, $.prototype.serialize = function () { return D.extend({}, this._options) }, $.prototype.loadTile = function (n, i) { var t = f(n.tileID.canonical.url(this.tiles, this.scheme), this.url), t = { request: this.map._transformRequest(t, D.ResourceType.Tile), uid: n.uid, tileID: n.tileID, zoom: n.tileID.overscaledZ, tileSize: this.tileSize * n.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: D.browser.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes }; function e(t, e) { return n.aborted ? i(null) : t && 404 !== t.status ? i(t) : (e && e.resourceTiming && (n.resourceTiming = e.resourceTiming), this.map._refreshExpiredTiles && e && n.setExpiryData(e), n.loadVectorData(e, this.map.painter), i(null), void (n.reloadCallback && (this.loadTile(n, n.reloadCallback), n.reloadCallback = null))) } t.request.collectResourceTiming = this._collectResourceTiming, void 0 === n.workerID || "expired" === n.state ? n.workerID = this.dispatcher.send("loadTile", t, e.bind(this)) : "loading" === n.state ? n.reloadCallback = i : this.dispatcher.send("reloadTile", t, e.bind(this), n.workerID) }, $.prototype.abortTile = function (t) { this.dispatcher.send("abortTile", { uid: t.uid, type: this.type, source: this.id }, void 0, t.workerID) }, $.prototype.unloadTile = function (t) { t.unloadVectorData(), this.dispatcher.send("removeTile", { uid: t.uid, type: this.type, source: this.id }, void 0, t.workerID) }, $.prototype.hasTransition = function () { return !1 }, $), W = ((Z = D.Evented) && (Y.__proto__ = Z), ((Y.prototype = Object.create(Z && Z.prototype)).constructor = Y).prototype.load = function () { var n = this; this.fire(new D.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = F(this._options, this.map._transformRequest, function (t, e) { n._tileJSONRequest = null, t ? n.fire(new D.ErrorEvent(t)) : e && (D.extend(n, e), e.bounds && (n.tileBounds = new j(e.bounds, n.minzoom, n.maxzoom)), w(e.tiles), n.fire(new D.Event("data", { dataType: "source", sourceDataType: "metadata" })), n.fire(new D.Event("data", { dataType: "source", sourceDataType: "content" }))) }) }, Y.prototype.onAdd = function (t) { this.map = t, this.load() }, Y.prototype.onRemove = function () { this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null) }, Y.prototype.serialize = function () { return D.extend({}, this._options) }, Y.prototype.hasTile = function (t) { return !this.tileBounds || this.tileBounds.contains(t.canonical) }, Y.prototype.loadTile = function (i, r) { var o = this, t = f(i.tileID.canonical.url(this.tiles, this.scheme), this.url, this.tileSize); i.request = D.getImage(this.map._transformRequest(t, D.ResourceType.Tile), function (t, e) { var n; delete i.request, i.aborted ? (i.state = "unloaded", r(null)) : t ? (i.state = "errored", r(t)) : e && (o.map._refreshExpiredTiles && i.setExpiryData(e), delete e.cacheControl, delete e.expires, t = (n = o.map.painter.context).gl, i.texture = o.map.painter.getTileTexture(e.width), i.texture ? i.texture.update(e, { useMipmap: !0 }) : (i.texture = new D.Texture(n, e, t.RGBA, { useMipmap: !0 }), i.texture.bind(t.LINEAR, t.CLAMP_TO_EDGE, t.LINEAR_MIPMAP_NEAREST), n.extTextureFilterAnisotropic && t.texParameterf(t.TEXTURE_2D, n.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, n.extTextureFilterAnisotropicMax)), i.state = "loaded", r(null)) }) }, Y.prototype.abortTile = function (t, e) { t.request && (t.request.cancel(), delete t.request), e() }, Y.prototype.unloadTile = function (t, e) { t.texture && this.map.painter.saveTileTexture(t.texture), e() }, Y.prototype.hasTransition = function () { return !1 }, Y), x = ((q = W) && (J.__proto__ = q), ((J.prototype = Object.create(q && q.prototype)).constructor = J).prototype.serialize = function () { return { type: "raster-dem", url: this.url, tileSize: this.tileSize, tiles: this.tiles, bounds: this.bounds, encoding: this.encoding } }, J.prototype.loadTile = function (n, i) { var t = f(n.tileID.canonical.url(this.tiles, this.scheme), this.url, this.tileSize); n.request = D.getImage(this.map._transformRequest(t, D.ResourceType.Tile), function (t, e) { delete n.request, n.aborted ? (n.state = "unloaded", i(null)) : t ? (n.state = "errored", i(t)) : e && (this.map._refreshExpiredTiles && n.setExpiryData(e), delete e.cacheControl, delete e.expires, e = D.browser.getImageData(e), e = { uid: n.uid, coord: n.tileID, source: this.id, rawImageData: e, encoding: this.encoding }, n.workerID && "expired" !== n.state || (n.workerID = this.dispatcher.send("loadDEMTile", e, function (t, e) { t && (n.state = "errored", i(t)), e && (n.dem = e, n.needsHillshadePrepare = !0, n.state = "loaded", i(null)) }.bind(this)))) }.bind(this)), n.neighboringTiles = this._getNeighboringTiles(n.tileID) }, J.prototype._getNeighboringTiles = function (t) { var e = t.canonical, n = Math.pow(2, e.z), i = (e.x - 1 + n) % n, r = 0 === e.x ? t.wrap - 1 : t.wrap, o = (e.x + 1 + n) % n, a = e.x + 1 === n ? t.wrap + 1 : t.wrap, s = {}; return s[new D.OverscaledTileID(t.overscaledZ, r, e.z, i, e.y).key] = { backfilled: !1 }, s[new D.OverscaledTileID(t.overscaledZ, a, e.z, o, e.y).key] = { backfilled: !1 }, 0 < e.y && (s[new D.OverscaledTileID(t.overscaledZ, r, e.z, i, e.y - 1).key] = { backfilled: !1 }, s[new D.OverscaledTileID(t.overscaledZ, t.wrap, e.z, e.x, e.y - 1).key] = { backfilled: !1 }, s[new D.OverscaledTileID(t.overscaledZ, a, e.z, o, e.y - 1).key] = { backfilled: !1 }), e.y + 1 < n && (s[new D.OverscaledTileID(t.overscaledZ, r, e.z, i, e.y + 1).key] = { backfilled: !1 }, s[new D.OverscaledTileID(t.overscaledZ, t.wrap, e.z, e.x, e.y + 1).key] = { backfilled: !1 }, s[new D.OverscaledTileID(t.overscaledZ, a, e.z, o, e.y + 1).key] = { backfilled: !1 }), s }, J.prototype.unloadTile = function (t) { t.demTexture && this.map.painter.saveTileTexture(t.demTexture), t.fbo && (t.fbo.destroy(), delete t.fbo), t.dem && delete t.dem, delete t.neighboringTiles, t.state = "unloaded", this.dispatcher.send("removeDEMTile", { uid: t.uid, source: this.id }, void 0, t.workerID) }, J), b = ((U = D.Evented) && (K.__proto__ = U), ((K.prototype = Object.create(U && U.prototype)).constructor = K).prototype.load = function () { var e = this; this.fire(new D.Event("dataloading", { dataType: "source" })), this._updateWorkerData(function (t) { t ? e.fire(new D.ErrorEvent(t)) : (t = { dataType: "source", sourceDataType: "metadata" }, e._collectResourceTiming && e._resourceTiming && 0 < e._resourceTiming.length && (t.resourceTiming = e._resourceTiming, e._resourceTiming = []), e.fire(new D.Event("data", t))) }) }, K.prototype.onAdd = function (t) { this.map = t, this.load() }, K.prototype.setData = function (t) { var e = this; return this._data = t, this.fire(new D.Event("dataloading", { dataType: "source" })), this._updateWorkerData(function (t) { t ? e.fire(new D.ErrorEvent(t)) : (t = { dataType: "source", sourceDataType: "content" }, e._collectResourceTiming && e._resourceTiming && 0 < e._resourceTiming.length && (t.resourceTiming = e._resourceTiming, e._resourceTiming = []), e.fire(new D.Event("data", t))) }), this }, K.prototype.getClusterExpansionZoom = function (t, e) { return this.dispatcher.send("geojson.getClusterExpansionZoom", { clusterId: t, source: this.id }, e, this.workerID), this }, K.prototype.getClusterChildren = function (t, e) { return this.dispatcher.send("geojson.getClusterChildren", { clusterId: t, source: this.id }, e, this.workerID), this }, K.prototype.getClusterLeaves = function (t, e, n, i) { return this.dispatcher.send("geojson.getClusterLeaves", { source: this.id, clusterId: t, limit: e, offset: n }, i, this.workerID), this }, K.prototype._updateWorkerData = function (n) { var i = this, r = D.extend({}, this.workerOptions), t = this._data; "string" == typeof t ? (r.request = this.map._transformRequest(D.browser.resolveURL(t), D.ResourceType.Source), r.request.collectResourceTiming = this._collectResourceTiming) : r.data = JSON.stringify(t), this.workerID = this.dispatcher.send(this.type + ".loadData", r, function (t, e) { i._removed || e && e.abandoned || (i._loaded = !0, e && e.resourceTiming && e.resourceTiming[i.id] && (i._resourceTiming = e.resourceTiming[i.id].slice(0)), i.dispatcher.send(i.type + ".coalesce", { source: r.source }, null, i.workerID), n(t)) }, this.workerID) }, K.prototype.loadTile = function (n, i) { var r = this, o = void 0 === n.workerID ? "loadTile" : "reloadTile", t = { type: this.type, uid: n.uid, tileID: n.tileID, zoom: n.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: D.browser.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes }; n.workerID = this.dispatcher.send(o, t, function (t, e) { return n.unloadVectorData(), n.aborted ? i(null) : t ? i(t) : (n.loadVectorData(e, r.map.painter, "reloadTile" == o), i(null)) }, this.workerID) }, K.prototype.abortTile = function (t) { t.aborted = !0 }, K.prototype.unloadTile = function (t) { t.unloadVectorData(), this.dispatcher.send("removeTile", { uid: t.uid, type: this.type, source: this.id }, null, t.workerID) }, K.prototype.onRemove = function () { this._removed = !0, this.dispatcher.send("removeSource", { type: this.type, source: this.id }, null, this.workerID) }, K.prototype.serialize = function () { return D.extend({}, this._options, { type: this.type, data: this._data }) }, K.prototype.hasTransition = function () { return !1 }, K), H = function () { this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null }; function K(t, e, n, i) { U.call(this), this.id = t, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this.dispatcher = n, this.setEventedParent(i), this._data = e.data, this._options = D.extend({}, e), this._collectResourceTiming = e.collectResourceTiming, this._resourceTiming = [], void 0 !== e.maxzoom && (this.maxzoom = e.maxzoom), e.type && (this.type = e.type), e.attribution && (this.attribution = e.attribution); i = D.EXTENT / this.tileSize; this.workerOptions = D.extend({ source: this.id, cluster: e.cluster || !1, geojsonVtOptions: { buffer: (void 0 !== e.buffer ? e.buffer : 128) * i, tolerance: (void 0 !== e.tolerance ? e.tolerance : .375) * i, extent: D.EXTENT, maxZoom: this.maxzoom, lineMetrics: e.lineMetrics || !1, generateId: e.generateId || !1 }, superclusterOptions: { maxZoom: void 0 !== e.clusterMaxZoom ? Math.min(e.clusterMaxZoom, this.maxzoom - 1) : this.maxzoom - 1, extent: D.EXTENT, radius: (e.clusterRadius || 50) * i, log: !1 } }, e.workerOptions) } function J(t, e, n, i) { q.call(this, t, e, n, i), this.type = "raster-dem", this.maxzoom = 22, this._options = D.extend({}, e), this.encoding = e.encoding || "mapbox" } function Y(t, e, n, i) { Z.call(this), this.id = t, this.dispatcher = n, this.setEventedParent(i), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = D.extend({}, e), D.extend(this, D.pick(e, ["url", "scheme", "tileSize"])) } function $(t, e, n, i) { if (G.call(this), this.id = t, this.dispatcher = n, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, D.extend(this, D.pick(e, ["url", "scheme", "tileSize"])), this._options = D.extend({ type: "vector" }, e), this._collectResourceTiming = e.collectResourceTiming, 512 !== this.tileSize) throw new Error("vector tile sources must have a tileSize of 512"); this.setEventedParent(i) } H.prototype.bind = function (t, e, n, i, r, o, a, s) { this.context = t; for (var l = this.boundPaintVertexBuffers.length !== i.length, u = 0; !l && u < i.length; u++)this.boundPaintVertexBuffers[u] !== i[u] && (l = !0); var c = !this.vao || this.boundProgram !== e || this.boundLayoutVertexBuffer !== n || l || this.boundIndexBuffer !== r || this.boundVertexOffset !== o || this.boundDynamicVertexBuffer !== a || this.boundDynamicVertexBuffer2 !== s; !t.extVertexArrayObject || c ? this.freshBind(e, n, i, r, o, a, s) : (t.bindVertexArrayOES.set(this.vao), a && a.bind(), r && r.dynamicDraw && r.bind(), s && s.bind()) }, H.prototype.freshBind = function (t, e, n, i, r, o, a) { var s, l = t.numAttributes, u = this.context, c = u.gl; if (u.extVertexArrayObject) this.vao && this.destroy(), this.vao = u.extVertexArrayObject.createVertexArrayOES(), u.bindVertexArrayOES.set(this.vao), s = 0, this.boundProgram = t, this.boundLayoutVertexBuffer = e, this.boundPaintVertexBuffers = n, this.boundIndexBuffer = i, this.boundVertexOffset = r, this.boundDynamicVertexBuffer = o, this.boundDynamicVertexBuffer2 = a; else { s = u.currentNumAttributes || 0; for (var h = l; h < s; h++)c.disableVertexAttribArray(h) } e.enableAttributes(c, t); for (var p = 0, f = n; p < f.length; p += 1)f[p].enableAttributes(c, t); o && o.enableAttributes(c, t), a && a.enableAttributes(c, t), e.bind(), e.setVertexAttribPointers(c, t, r); for (var d = 0, m = n; d < m.length; d += 1) { var y = m[d]; y.bind(), y.setVertexAttribPointers(c, t, r) } o && (o.bind(), o.setVertexAttribPointers(c, t, r)), i && i.bind(), a && (a.bind(), a.setVertexAttribPointers(c, t, r)), u.currentNumAttributes = l }, H.prototype.destroy = function () { this.vao && (this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao), this.vao = null) }; var Q, tt, et, nt = ((et = D.Evented) && (at.__proto__ = et), ((at.prototype = Object.create(et && et.prototype)).constructor = at).prototype.load = function () { var n = this; this.fire(new D.Event("dataloading", { dataType: "source" })), this.url = this.options.url, D.getImage(this.map._transformRequest(this.url, D.ResourceType.Image), function (t, e) { t ? n.fire(new D.ErrorEvent(t)) : e && (n.image = D.browser.getImageData(e), n._finishLoading()) }) }, at.prototype._finishLoading = function () { this.map && (this.setCoordinates(this.coordinates), this.fire(new D.Event("data", { dataType: "source", sourceDataType: "metadata" }))) }, at.prototype.onAdd = function (t) { this.map = t, this.load() }, at.prototype.setCoordinates = function (t) { this.coordinates = t; var e = this.map, t = t.map(function (t) { return e.transform.locationCoordinate(V.convert(t)).zoomTo(0) }), n = this.centerCoord = D.getCoordinatesCenter(t); n.column = Math.floor(n.column), n.row = Math.floor(n.row), this.tileID = new D.CanonicalTileID(n.zoom, n.column, n.row), this.minzoom = this.maxzoom = n.zoom; t = t.map(function (t) { t = t.zoomTo(n.zoom); return new D.Point(Math.round((t.column - n.column) * D.EXTENT), Math.round((t.row - n.row) * D.EXTENT)) }); return this._boundsArray = new D.StructArrayLayout4i8, this._boundsArray.emplaceBack(t[0].x, t[0].y, 0, 0), this._boundsArray.emplaceBack(t[1].x, t[1].y, D.EXTENT, 0), this._boundsArray.emplaceBack(t[3].x, t[3].y, 0, D.EXTENT), this._boundsArray.emplaceBack(t[2].x, t[2].y, D.EXTENT, D.EXTENT), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this.fire(new D.Event("data", { dataType: "source", sourceDataType: "content" })), this }, at.prototype.prepare = function () { if (0 !== Object.keys(this.tiles).length && this.image) { var t, e = this.map.painter.context, n = e.gl; for (t in this.boundsBuffer || (this.boundsBuffer = e.createVertexBuffer(this._boundsArray, D.rasterBoundsAttributes.members)), this.boundsVAO || (this.boundsVAO = new H), this.texture || (this.texture = new D.Texture(e, this.image, n.RGBA), this.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE)), this.tiles) { var i = this.tiles[t]; "loaded" !== i.state && (i.state = "loaded", i.texture = this.texture) } } }, at.prototype.loadTile = function (t, e) { this.tileID && this.tileID.equals(t.tileID.canonical) ? (this.tiles[String(t.tileID.wrap)] = t).buckets = {} : t.state = "errored", e(null) }, at.prototype.serialize = function () { return { type: "image", url: this.options.url, coordinates: this.coordinates } }, at.prototype.hasTransition = function () { return !1 }, at), S = ((tt = nt) && (ot.__proto__ = tt), ((ot.prototype = Object.create(tt && tt.prototype)).constructor = ot).prototype.load = function () { var n = this, t = this.options; this.urls = []; for (var e = 0, i = t.urls; e < i.length; e += 1) { var r = i[e]; n.urls.push(n.map._transformRequest(r, D.ResourceType.Source).url) } D.getVideo(this.urls, function (t, e) { t ? n.fire(new D.ErrorEvent(t)) : e && (n.video = e, n.video.loop = !0, n.video.addEventListener("playing", function () { n.map._rerender() }), n.map && n.video.play(), n._finishLoading()) }) }, ot.prototype.getVideo = function () { return this.video }, ot.prototype.onAdd = function (t) { this.map || (this.map = t, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates))) }, ot.prototype.prepare = function () { if (!(0 === Object.keys(this.tiles).length || this.video.readyState < 2)) { var t, e = this.map.painter.context, n = e.gl; for (t in this.boundsBuffer || (this.boundsBuffer = e.createVertexBuffer(this._boundsArray, D.rasterBoundsAttributes.members)), this.boundsVAO || (this.boundsVAO = new H), this.texture ? this.video.paused || (this.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE), n.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, n.RGBA, n.UNSIGNED_BYTE, this.video)) : (this.texture = new D.Texture(e, this.video, n.RGBA), this.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE)), this.tiles) { var i = this.tiles[t]; "loaded" !== i.state && (i.state = "loaded", i.texture = this.texture) } } }, ot.prototype.serialize = function () { return { type: "video", urls: this.urls, coordinates: this.coordinates } }, ot.prototype.hasTransition = function () { return this.video && !this.video.paused }, ot), C = ((Q = nt) && (rt.__proto__ = Q), ((rt.prototype = Object.create(Q && Q.prototype)).constructor = rt).prototype.load = function () { this.canvas || (this.canvas = this.options.canvas instanceof D.window.HTMLCanvasElement ? this.options.canvas : D.window.document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new D.ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function () { this._playing = !0, this.map._rerender() }, this.pause = function () { this._playing = !1 }, this._finishLoading()) }, rt.prototype.getCanvas = function () { return this.canvas }, rt.prototype.onAdd = function (t) { this.map = t, this.load(), this.canvas && this.animate && this.play() }, rt.prototype.onRemove = function () { this.pause() }, rt.prototype.prepare = function () { var t = !1; if (this.canvas.width !== this.width && (this.width = this.canvas.width, t = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, t = !0), !this._hasInvalidDimensions() && 0 !== Object.keys(this.tiles).length) { var e, n = this.map.painter.context, i = n.gl; for (e in this.boundsBuffer || (this.boundsBuffer = n.createVertexBuffer(this._boundsArray, D.rasterBoundsAttributes.members)), this.boundsVAO || (this.boundsVAO = new H), this.texture ? t ? this.texture.update(this.canvas) : this._playing && (this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE), i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, i.RGBA, i.UNSIGNED_BYTE, this.canvas)) : (this.texture = new D.Texture(n, this.canvas, i.RGBA), this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE)), this.tiles) { var r = this.tiles[e]; "loaded" !== r.state && (r.state = "loaded", r.texture = this.texture) } } }, rt.prototype.serialize = function () { return { type: "canvas", coordinates: this.coordinates } }, rt.prototype.hasTransition = function () { return this._playing }, rt.prototype._hasInvalidDimensions = function () { for (var t = 0, e = [this.canvas.width, this.canvas.height]; t < e.length; t += 1) { var n = e[t]; if (isNaN(n) || n <= 0) return !0 } return !1 }, rt), it = { vector: X, raster: W, "raster-dem": x, geojson: b, video: S, image: nt, canvas: C }; function rt(t, e, n, i) { Q.call(this, t, e, n, i), e.coordinates ? Array.isArray(e.coordinates) && 4 === e.coordinates.length && !e.coordinates.some(function (t) { return !Array.isArray(t) || 2 !== t.length || t.some(function (t) { return "number" != typeof t }) }) || this.fire(new D.ErrorEvent(new D.ValidationError("sources." + t, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new D.ErrorEvent(new D.ValidationError("sources." + t, null, 'missing required property "coordinates"'))), e.animate && "boolean" != typeof e.animate && this.fire(new D.ErrorEvent(new D.ValidationError("sources." + t, null, 'optional "animate" property must be a boolean value'))), e.canvas ? "string" == typeof e.canvas || e.canvas instanceof D.window.HTMLCanvasElement || this.fire(new D.ErrorEvent(new D.ValidationError("sources." + t, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new D.ErrorEvent(new D.ValidationError("sources." + t, null, 'missing required property "canvas"'))), this.options = e, this.animate = void 0 === e.animate || e.animate } function ot(t, e, n, i) { tt.call(this, t, e, n, i), this.roundZoom = !0, this.type = "video", this.options = e } function at(t, e, n, i) { et.call(this), this.id = t, this.dispatcher = n, this.coordinates = e.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this.setEventedParent(i), this.options = e } function st(t, e) { t = t.tileID, e = e.tileID; return t.overscaledZ - e.overscaledZ || t.canonical.y - e.canonical.y || t.wrap - e.wrap || t.canonical.x - e.canonical.x } function lt(t, e) { this.max = t, this.onRemove = e, this.reset() } lt.prototype.reset = function () { for (var t in this.data) for (var e = 0, n = this.data[t]; e < n.length; e += 1) { var i = n[e]; i.timeout && clearTimeout(i.timeout), this.onRemove(i.value) } return this.data = {}, this.order = [], this }, lt.prototype.add = function (t, e, n) { var i = this, r = t.wrapped().key; void 0 === this.data[r] && (this.data[r] = []); var o, a = { value: e, timeout: void 0 }; return void 0 !== n && (a.timeout = setTimeout(function () { i.remove(t, a) }, n)), this.data[r].push(a), this.order.push(r), this.order.length > this.max && (o = this._getAndRemoveByKey(this.order[0])) && this.onRemove(o), this }, lt.prototype.has = function (t) { return t.wrapped().key in this.data }, lt.prototype.getAndRemove = function (t) { return this.has(t) ? this._getAndRemoveByKey(t.wrapped().key) : null }, lt.prototype._getAndRemoveByKey = function (t) { var e = this.data[t].shift(); return e.timeout && clearTimeout(e.timeout), 0 === this.data[t].length && delete this.data[t], this.order.splice(this.order.indexOf(t), 1), e.value }, lt.prototype.get = function (t) { return this.has(t) ? this.data[t.wrapped().key][0].value : null }, lt.prototype.remove = function (t, e) { if (!this.has(t)) return this; var n = t.wrapped().key, t = void 0 === e ? 0 : this.data[n].indexOf(e), e = this.data[n][t]; return this.data[n].splice(t, 1), e.timeout && clearTimeout(e.timeout), 0 === this.data[n].length && delete this.data[n], this.onRemove(e.value), this.order.splice(this.order.indexOf(n), 1), this }, lt.prototype.setMaxSize = function (t) { for (this.max = t; this.order.length > this.max;) { var e = this._getAndRemoveByKey(this.order[0]); e && this.onRemove(e) } return this }; function ut(t, e, n) { var i = (this.context = t).gl; this.buffer = i.createBuffer(), this.dynamicDraw = Boolean(n), this.unbindVAO(), t.bindElementBuffer.set(this.buffer), i.bufferData(i.ELEMENT_ARRAY_BUFFER, e.arrayBuffer, this.dynamicDraw ? i.DYNAMIC_DRAW : i.STATIC_DRAW), this.dynamicDraw || delete e.arrayBuffer } ut.prototype.unbindVAO = function () { this.context.extVertexArrayObject && this.context.bindVertexArrayOES.set(null) }, ut.prototype.bind = function () { this.context.bindElementBuffer.set(this.buffer) }, ut.prototype.updateData = function (t) { var e = this.context.gl; this.unbindVAO(), this.bind(), e.bufferSubData(e.ELEMENT_ARRAY_BUFFER, 0, t.arrayBuffer) }, ut.prototype.destroy = function () { var t = this.context.gl; this.buffer && (t.deleteBuffer(this.buffer), delete this.buffer) }; function ct(t, e, n, i) { this.length = e.length, this.attributes = n, this.itemSize = e.bytesPerElement, this.dynamicDraw = i, i = (this.context = t).gl, this.buffer = i.createBuffer(), t.bindVertexBuffer.set(this.buffer), i.bufferData(i.ARRAY_BUFFER, e.arrayBuffer, this.dynamicDraw ? i.DYNAMIC_DRAW : i.STATIC_DRAW), this.dynamicDraw || delete e.arrayBuffer } var ht = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" }; ct.prototype.bind = function () { this.context.bindVertexBuffer.set(this.buffer) }, ct.prototype.updateData = function (t) { var e = this.context.gl; this.bind(), e.bufferSubData(e.ARRAY_BUFFER, 0, t.arrayBuffer) }, ct.prototype.enableAttributes = function (t, e) { for (var n = 0; n < this.attributes.length; n++) { var i = this.attributes[n], i = e.attributes[i.name]; void 0 !== i && t.enableVertexAttribArray(i) } }, ct.prototype.setVertexAttribPointers = function (t, e, n) { for (var i = 0; i < this.attributes.length; i++) { var r = this.attributes[i], o = e.attributes[r.name]; void 0 !== o && t.vertexAttribPointer(o, r.components, t[ht[r.type]], !1, this.itemSize, r.offset + this.itemSize * (n || 0)) } }, ct.prototype.destroy = function () { var t = this.context.gl; this.buffer && (t.deleteBuffer(this.buffer), delete this.buffer) }; function pt(t) { this.context = t, this.current = D.Color.transparent } pt.prototype.get = function () { return this.current }, pt.prototype.set = function (t) { var e = this.current; t.r === e.r && t.g === e.g && t.b === e.b && t.a === e.a || (this.context.gl.clearColor(t.r, t.g, t.b, t.a), this.current = t) }; function ft(t) { this.context = t, this.current = 1 } ft.prototype.get = function () { return this.current }, ft.prototype.set = function (t) { this.current !== t && (this.context.gl.clearDepth(t), this.current = t) }; function dt(t) { this.context = t, this.current = 0 } dt.prototype.get = function () { return this.current }, dt.prototype.set = function (t) { this.current !== t && (this.context.gl.clearStencil(t), this.current = t) }; function mt(t) { this.context = t, this.current = [!0, !0, !0, !0] } mt.prototype.get = function () { return this.current }, mt.prototype.set = function (t) { var e = this.current; t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3] || (this.context.gl.colorMask(t[0], t[1], t[2], t[3]), this.current = t) }; function yt(t) { this.context = t, this.current = !0 } yt.prototype.get = function () { return this.current }, yt.prototype.set = function (t) { this.current !== t && (this.context.gl.depthMask(t), this.current = t) }; function gt(t) { this.context = t, this.current = 255 } gt.prototype.get = function () { return this.current }, gt.prototype.set = function (t) { this.current !== t && (this.context.gl.stencilMask(t), this.current = t) }; function vt(t) { this.context = t, this.current = { func: t.gl.ALWAYS, ref: 0, mask: 255 } } vt.prototype.get = function () { return this.current }, vt.prototype.set = function (t) { var e = this.current; t.func === e.func && t.ref === e.ref && t.mask === e.mask || (this.context.gl.stencilFunc(t.func, t.ref, t.mask), this.current = t) }; function _t(t) { this.context = t, t = this.context.gl, this.current = [t.KEEP, t.KEEP, t.KEEP] } _t.prototype.get = function () { return this.current }, _t.prototype.set = function (t) { var e = this.current; t[0] === e[0] && t[1] === e[1] && t[2] === e[2] || (this.context.gl.stencilOp(t[0], t[1], t[2]), this.current = t) }; function xt(t) { this.context = t, this.current = !1 } xt.prototype.get = function () { return this.current }, xt.prototype.set = function (t) { var e; this.current !== t && (e = this.context.gl, t ? e.enable(e.STENCIL_TEST) : e.disable(e.STENCIL_TEST), this.current = t) }; function bt(t) { this.context = t, this.current = [0, 1] } bt.prototype.get = function () { return this.current }, bt.prototype.set = function (t) { var e = this.current; t[0] === e[0] && t[1] === e[1] || (this.context.gl.depthRange(t[0], t[1]), this.current = t) }; function wt(t) { this.context = t, this.current = !1 } wt.prototype.get = function () { return this.current }, wt.prototype.set = function (t) { var e; this.current !== t && (e = this.context.gl, t ? e.enable(e.DEPTH_TEST) : e.disable(e.DEPTH_TEST), this.current = t) }; function Et(t) { this.context = t, this.current = t.gl.LESS } Et.prototype.get = function () { return this.current }, Et.prototype.set = function (t) { this.current !== t && (this.context.gl.depthFunc(t), this.current = t) }; function St(t) { this.context = t, this.current = !1 } St.prototype.get = function () { return this.current }, St.prototype.set = function (t) { var e; this.current !== t && (e = this.context.gl, t ? e.enable(e.BLEND) : e.disable(e.BLEND), this.current = t) }; function Tt(t) { this.context = t, t = this.context.gl, this.current = [t.ONE, t.ZERO] } Tt.prototype.get = function () { return this.current }, Tt.prototype.set = function (t) { var e = this.current; t[0] === e[0] && t[1] === e[1] || (this.context.gl.blendFunc(t[0], t[1]), this.current = t) }; function At(t) { this.context = t, this.current = D.Color.transparent } At.prototype.get = function () { return this.current }, At.prototype.set = function (t) { var e = this.current; t.r === e.r && t.g === e.g && t.b === e.b && t.a === e.a || (this.context.gl.blendColor(t.r, t.g, t.b, t.a), this.current = t) }; function zt(t) { this.context = t, this.current = null } zt.prototype.get = function () { return this.current }, zt.prototype.set = function (t) { this.current !== t && (this.context.gl.useProgram(t), this.current = t) }; function It(t) { this.context = t, this.current = t.gl.TEXTURE0 } It.prototype.get = function () { return this.current }, It.prototype.set = function (t) { this.current !== t && (this.context.gl.activeTexture(t), this.current = t) }; function kt(t) { this.context = t, t = this.context.gl, this.current = [0, 0, t.drawingBufferWidth, t.drawingBufferHeight] } kt.prototype.get = function () { return this.current }, kt.prototype.set = function (t) { var e = this.current; t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3] || (this.context.gl.viewport(t[0], t[1], t[2], t[3]), this.current = t) }; function Ct(t) { this.context = t, this.current = null } Ct.prototype.get = function () { return this.current }, Ct.prototype.set = function (t) { var e; this.current !== t && ((e = this.context.gl).bindFramebuffer(e.FRAMEBUFFER, t), this.current = t) }; function Mt(t) { this.context = t, this.current = null } Mt.prototype.get = function () { return this.current }, Mt.prototype.set = function (t) { var e; this.current !== t && ((e = this.context.gl).bindRenderbuffer(e.RENDERBUFFER, t), this.current = t) }; function Pt(t) { this.context = t, this.current = null } Pt.prototype.get = function () { return this.current }, Pt.prototype.set = function (t) { var e; this.current !== t && ((e = this.context.gl).bindTexture(e.TEXTURE_2D, t), this.current = t) }; function Lt(t) { this.context = t, this.current = null } Lt.prototype.get = function () { return this.current }, Lt.prototype.set = function (t) { var e; this.current !== t && ((e = this.context.gl).bindBuffer(e.ARRAY_BUFFER, t), this.current = t) }; function Dt(t) { this.context = t, this.current = null } Dt.prototype.get = function () { return this.current }, Dt.prototype.set = function (t) { var e = this.context.gl; e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, t), this.current = t }; function Rt(t) { this.context = t, this.current = null } Rt.prototype.get = function () { return this.current }, Rt.prototype.set = function (t) { this.current !== t && this.context.extVertexArrayObject && (this.context.extVertexArrayObject.bindVertexArrayOES(t), this.current = t) }; function Bt(t) { this.context = t, this.current = 4 } Bt.prototype.get = function () { return this.current }, Bt.prototype.set = function (t) { var e; this.current !== t && ((e = this.context.gl).pixelStorei(e.UNPACK_ALIGNMENT, t), this.current = t) }; function Ot(t) { this.context = t, this.current = !1 } Ot.prototype.get = function () { return this.current }, Ot.prototype.set = function (t) { var e; this.current !== t && ((e = this.context.gl).pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t), this.current = t) }; X = function (t, e) { this.context = t, this.current = null, this.parent = e }; X.prototype.get = function () { return this.current }; function Ft(t, e, n) { this.context = t, this.width = e, this.height = n, n = t.gl, n = this.framebuffer = n.createFramebuffer(), this.colorAttachment = new jt(t, n), this.depthAttachment = new Ut(t, n) } var Vt, Nt, jt = ((Nt = X) && (Zt.__proto__ = Nt), ((Zt.prototype = Object.create(Nt && Nt.prototype)).constructor = Zt).prototype.set = function (t) { var e; !this.dirty && this.current === t || (e = this.context.gl, this.context.bindFramebuffer.set(this.parent), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t, 0), this.current = t, this.dirty = !1) }, Zt.prototype.setDirty = function () { this.dirty = !0 }, Zt), Ut = ((Vt = X) && (qt.__proto__ = Vt), ((qt.prototype = Object.create(Vt && Vt.prototype)).constructor = qt).prototype.set = function (t) { var e; this.current !== t && (e = this.context.gl, this.context.bindFramebuffer.set(this.parent), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.RENDERBUFFER, t), this.current = t) }, qt); function qt() { Vt.apply(this, arguments) } function Zt(t, e) { Nt.call(this, t, e), this.dirty = !1 } Ft.prototype.destroy = function () { var t = this.context.gl, e = this.colorAttachment.get(); e && t.deleteTexture(e); e = this.depthAttachment.get(); e && t.deleteRenderbuffer(e), t.deleteFramebuffer(this.framebuffer) }; var Gt = function (t, e, n) { this.func = t, this.mask = e, this.range = n }; Gt.ReadOnly = !1, Gt.ReadWrite = !0, Gt.disabled = new Gt(519, Gt.ReadOnly, [0, 1]); var Xt = function (t, e, n, i, r, o) { this.test = t, this.ref = e, this.mask = n, this.fail = i, this.depthFail = r, this.pass = o }; Xt.disabled = new Xt({ func: 519, mask: 0 }, 0, 0, 7680, 7680, 7680); function Wt(t, e, n) { this.blendFunction = t, this.blendColor = e, this.mask = n } Wt.disabled = new Wt(Wt.Replace = [1, 0], D.Color.transparent, [!1, !1, !1, !1]), Wt.unblended = new Wt(Wt.Replace, D.Color.transparent, [!0, !0, !0, !0]), Wt.alphaBlended = new Wt([1, 771], D.Color.transparent, [!0, !0, !0, !0]); function Ht(t) { this.gl = t, this.extVertexArrayObject = this.gl.getExtension("OES_vertex_array_object"), this.clearColor = new pt(this), this.clearDepth = new ft(this), this.clearStencil = new dt(this), this.colorMask = new mt(this), this.depthMask = new yt(this), this.stencilMask = new gt(this), this.stencilFunc = new vt(this), this.stencilOp = new _t(this), this.stencilTest = new xt(this), this.depthRange = new bt(this), this.depthTest = new wt(this), this.depthFunc = new Et(this), this.blend = new St(this), this.blendFunc = new Tt(this), this.blendColor = new At(this), this.program = new zt(this), this.activeTexture = new It(this), this.viewport = new kt(this), this.bindFramebuffer = new Ct(this), this.bindRenderbuffer = new Mt(this), this.bindTexture = new Pt(this), this.bindVertexBuffer = new Lt(this), this.bindElementBuffer = new Dt(this), this.bindVertexArrayOES = this.extVertexArrayObject && new Rt(this), this.pixelStoreUnpack = new Bt(this), this.pixelStoreUnpackPremultiplyAlpha = new Ot(this), this.extTextureFilterAnisotropic = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = t.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.extTextureHalfFloat = t.getExtension("OES_texture_half_float"), this.extTextureHalfFloat && t.getExtension("OES_texture_half_float_linear") } Ht.prototype.createIndexBuffer = function (t, e) { return new ut(this, t, e) }, Ht.prototype.createVertexBuffer = function (t, e, n) { return new ct(this, t, e, n) }, Ht.prototype.createRenderbuffer = function (t, e, n) { var i = this.gl, r = i.createRenderbuffer(); return this.bindRenderbuffer.set(r), i.renderbufferStorage(i.RENDERBUFFER, t, e, n), this.bindRenderbuffer.set(null), r }, Ht.prototype.createFramebuffer = function (t, e) { return new Ft(this, t, e) }, Ht.prototype.clear = function (t) { var e = t.color, n = t.depth, i = this.gl, t = 0; e && (t |= i.COLOR_BUFFER_BIT, this.clearColor.set(e), this.colorMask.set([!0, !0, !0, !0])), void 0 !== n && (t |= i.DEPTH_BUFFER_BIT, this.clearDepth.set(n), this.depthMask.set(!0)), i.clear(t) }, Ht.prototype.setDepthMode = function (t) { t.func !== this.gl.ALWAYS || t.mask ? (this.depthTest.set(!0), this.depthFunc.set(t.func), this.depthMask.set(t.mask), this.depthRange.set(t.range)) : this.depthTest.set(!1) }, Ht.prototype.setStencilMode = function (t) { t.test.func !== this.gl.ALWAYS || t.mask ? (this.stencilTest.set(!0), this.stencilMask.set(t.mask), this.stencilOp.set([t.fail, t.depthFail, t.pass]), this.stencilFunc.set({ func: t.test.func, ref: t.ref, mask: t.test.mask })) : this.stencilTest.set(!1) }, Ht.prototype.setColorMode = function (t) { D.deepEqual(t.blendFunction, Wt.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(t.blendFunction), this.blendColor.set(t.blendColor)), this.colorMask.set(t.mask) }; var Kt, Jt = ((Kt = D.Evented) && (Yt.__proto__ = Kt), ((Yt.prototype = Object.create(Kt && Kt.prototype)).constructor = Yt).prototype.onAdd = function (t) { this.map = t, this._maxTileCacheSize = t ? t._maxTileCacheSize : null, this._source && this._source.onAdd && this._source.onAdd(t) }, Yt.prototype.onRemove = function (t) { this._source && this._source.onRemove && this._source.onRemove(t) }, Yt.prototype.loaded = function () { if (this._sourceErrored) return !0; if (!this._sourceLoaded) return !1; for (var t in this._tiles) { var e = this._tiles[t]; if ("loaded" !== e.state && "errored" !== e.state) return !1 } return !0 }, Yt.prototype.getSource = function () { return this._source }, Yt.prototype.pause = function () { this._paused = !0 }, Yt.prototype.resume = function () { var t; this._paused && (t = this._shouldReloadOnResume, this._paused = !1, this._shouldReloadOnResume = !1, t && this.reload(), this.transform && this.update(this.transform)) }, Yt.prototype._loadTile = function (t, e) { return this._source.loadTile(t, e) }, Yt.prototype._unloadTile = function (t) { if (this._source.unloadTile) return this._source.unloadTile(t, function () { }) }, Yt.prototype._abortTile = function (t) { if (this._source.abortTile) return this._source.abortTile(t, function () { }) }, Yt.prototype.serialize = function () { return this._source.serialize() }, Yt.prototype.prepare = function (t) { for (var e in this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null), this._tiles) this._tiles[e].upload(t) }, Yt.prototype.getIds = function () { return Object.keys(this._tiles).map(Number).sort(Qt) }, Yt.prototype.getRenderableIds = function (t) { var e, r = this, n = []; for (e in r._tiles) r._isIdRenderable(+e, t) && n.push(+e); return t ? n.sort(function (t, e) { var n = r._tiles[t].tileID, i = r._tiles[e].tileID, t = new D.Point(n.canonical.x, n.canonical.y)._rotate(r.transform.angle), e = new D.Point(i.canonical.x, i.canonical.y)._rotate(r.transform.angle); return n.overscaledZ - i.overscaledZ || e.y - t.y || e.x - t.x }) : n.sort(Qt) }, Yt.prototype.hasRenderableParent = function (t) { t = this.findLoadedParent(t, 0); return !!t && this._isIdRenderable(t.tileID.key) }, Yt.prototype._isIdRenderable = function (t, e) { return this._tiles[t] && this._tiles[t].hasData() && !this._coveredTiles[t] && (e || !this._tiles[t].holdingForFade()) }, Yt.prototype.reload = function () { if (this._paused) this._shouldReloadOnResume = !0; else for (var t in this._cache.reset(), this._tiles) "errored" !== this._tiles[t].state && this._reloadTile(t, "reloading") }, Yt.prototype._reloadTile = function (t, e) { var n = this._tiles[t]; n && ("loading" !== n.state && (n.state = e), this._loadTile(n, this._tileLoaded.bind(this, n, t, e))) }, Yt.prototype._tileLoaded = function (t, e, n, i) { if (i) return t.state = "errored", void (404 !== i.status ? this._source.fire(new D.ErrorEvent(i, { tile: t })) : this.update(this.transform)); t.timeAdded = D.browser.now(), "expired" === n && (t.refreshedUponExpiration = !0), this._setTileReloadTimer(e, t), "raster-dem" === this.getSource().type && t.dem && this._backfillDEM(t), this._state.initializeTileState(t, this.map ? this.map.painter : null), this._source.fire(new D.Event("data", { dataType: "source", tile: t, coord: t.tileID })), this.map && (this.map.painter.tileExtentVAO.vao = null) }, Yt.prototype._backfillDEM = function (t) { for (var e = this.getRenderableIds(), n = 0; n < e.length; n++) { var i = e[n]; t.neighboringTiles && t.neighboringTiles[i] && (r(t, i = this.getTileByID(i)), r(i, t)) } function r(t, e) { t.needsHillshadePrepare = !0; var n = e.tileID.canonical.x - t.tileID.canonical.x, i = e.tileID.canonical.y - t.tileID.canonical.y, r = Math.pow(2, t.tileID.canonical.z), o = e.tileID.key; 0 === n && 0 == i || 1 < Math.abs(i) || (1 < Math.abs(n) && (1 === Math.abs(n + r) ? n += r : 1 === Math.abs(n - r) && (n -= r)), e.dem && t.dem && (t.dem.backfillBorder(e.dem, n, i), t.neighboringTiles && t.neighboringTiles[o] && (t.neighboringTiles[o].backfilled = !0))) } }, Yt.prototype.getTile = function (t) { return this.getTileByID(t.key) }, Yt.prototype.getTileByID = function (t) { return this._tiles[t] }, Yt.prototype.getZoom = function (t) { return t.zoom + t.scaleZoom(t.tileSize / this._source.tileSize) }, Yt.prototype._retainLoadedChildren = function (t, e, n, i) { for (var r in this._tiles) { var o = this._tiles[r]; if (!(i[r] || !o.hasData() || o.tileID.overscaledZ <= e || o.tileID.overscaledZ > n)) { for (var a = o.tileID; o && o.tileID.overscaledZ > e + 1;) { var s = o.tileID.scaledTo(o.tileID.overscaledZ - 1); (o = this._tiles[s.key]) && o.hasData() && (a = s) } for (var l = a; l.overscaledZ > e;)if (t[(l = l.scaledTo(l.overscaledZ - 1)).key]) { i[a.key] = a; break } } } }, Yt.prototype.findLoadedParent = function (t, e) { for (var n = t.overscaledZ - 1; e <= n; n--) { var i = t.scaledTo(n); if (!i) return; var r = String(i.key), r = this._tiles[r]; if (r && r.hasData()) return r; if (this._cache.has(i)) return this._cache.get(i) } }, Yt.prototype.updateCacheSize = function (t) { t = (Math.ceil(t.width / this._source.tileSize) + 1) * (Math.ceil(t.height / this._source.tileSize) + 1), t = Math.floor(5 * t), t = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, t) : t; this._cache.setMaxSize(t) }, Yt.prototype.handleWrapJump = function (t) { var e = (t - (void 0 === this._prevLng ? t : this._prevLng)) / 360, n = Math.round(e); if (this._prevLng = t, n) { var i, r, o, a = {}; for (i in this._tiles) { var s = this._tiles[i]; s.tileID = s.tileID.unwrapTo(s.tileID.wrap + n), a[s.tileID.key] = s } for (r in this._tiles = a, this._timers) clearTimeout(this._timers[r]), delete this._timers[r]; for (o in this._tiles) { var l = this._tiles[o]; this._setTileReloadTimer(o, l) } } }, Yt.prototype.update = function (t) { var e, n = this; if (this.transform = t, this._sourceLoaded && !this._paused) { this.updateCacheSize(t), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used ? this._source.tileID ? e = t.getVisibleUnwrappedCoordinates(this._source.tileID).map(function (t) { return new D.OverscaledTileID(t.canonical.z, t.wrap, t.canonical.z, t.canonical.x, t.canonical.y) }) : (e = t.coveringTiles({ tileSize: this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled }), this._source.hasTile && (e = e.filter(function (t) { return n._source.hasTile(t) }))) : e = []; var i, r = (this._source.roundZoom ? Math.round : Math.floor)(this.getZoom(t)), o = Math.max(r - Yt.maxOverzooming, this._source.minzoom), t = Math.max(r + Yt.maxUnderzooming, this._source.minzoom), a = this._updateRetainedTiles(e, r); if (te(this._source.type)) { for (var s, l = {}, u = {}, c = 0, h = Object.keys(a); c < h.length; c += 1) { var p = h[c], f = a[p], d = n._tiles[p]; !d || d.fadeEndTime && d.fadeEndTime <= D.browser.now() || ((d = n.findLoadedParent(f, o)) && (n._addTile(d.tileID), l[d.tileID.key] = d.tileID), u[p] = f) } for (s in this._retainLoadedChildren(u, r, t, a), l) a[s] || (n._coveredTiles[s] = !0, a[s] = l[s]) } for (i in a) n._tiles[i].clearFadeHold(); for (var m = 0, y = D.keysDifference(this._tiles, a); m < y.length; m += 1) { var g = y[m], v = n._tiles[g]; v.hasSymbolBuckets && !v.holdingForFade() ? v.setHoldDuration(n.map._fadeDuration) : v.hasSymbolBuckets && !v.symbolFadeFinished() || n._removeTile(g) } } }, Yt.prototype.releaseSymbolFadeTiles = function () { for (var t in this._tiles) this._tiles[t].holdingForFade() && this._removeTile(t) }, Yt.prototype._updateRetainedTiles = function (t, e) { for (var n = {}, i = {}, r = Math.max(e - Yt.maxOverzooming, this._source.minzoom), o = Math.max(e + Yt.maxUnderzooming, this._source.minzoom), a = {}, s = 0, l = t; s < l.length; s += 1) { var u = l[s], c = this._addTile(u); n[u.key] = u, c.hasData() || e < this._source.maxzoom && (a[u.key] = u) } this._retainLoadedChildren(a, e, o, n); for (var h = 0, p = t; h < p.length; h += 1) { var f = p[h], d = this._tiles[f.key]; if (!d.hasData()) { if (e + 1 > this._source.maxzoom) { var m = f.children(this._source.maxzoom)[0], y = this.getTile(m); if (y && y.hasData()) { n[m.key] = m; continue } } else { m = f.children(this._source.maxzoom); if (n[m[0].key] && n[m[1].key] && n[m[2].key] && n[m[3].key]) continue } for (var g = d.wasRequested(), v = f.overscaledZ - 1; r <= v; --v) { var _ = f.scaledTo(v); if (i[_.key]) break; if (i[_.key] = !0, !(d = this.getTile(_)) && g && (d = this._addTile(_)), d && (n[_.key] = _, g = d.wasRequested(), d.hasData())) break } } } return n }, Yt.prototype._addTile = function (t) { var e = this._tiles[t.key]; if (e) return e; (e = this._cache.getAndRemove(t)) && (this._setTileReloadTimer(t.key, e), e.tileID = t, this._state.initializeTileState(e, this.map ? this.map.painter : null), this._cacheTimers[t.key] && (clearTimeout(this._cacheTimers[t.key]), delete this._cacheTimers[t.key], this._setTileReloadTimer(t.key, e))); var n = Boolean(e); return n || (e = new D.Tile(t, this._source.tileSize * t.overscaleFactor()), this._loadTile(e, this._tileLoaded.bind(this, e, t.key, e.state))), e ? (e.uses++, this._tiles[t.key] = e, n || this._source.fire(new D.Event("dataloading", { tile: e, coord: e.tileID, dataType: "source" })), e) : null }, Yt.prototype._setTileReloadTimer = function (t, e) { var n = this; t in this._timers && (clearTimeout(this._timers[t]), delete this._timers[t]); e = e.getExpiryTimeout(); e && (this._timers[t] = setTimeout(function () { n._reloadTile(t, "expired"), delete n._timers[t] }, e)) }, Yt.prototype._removeTile = function (t) { var e = this._tiles[t]; e && (e.uses--, delete this._tiles[t], this._timers[t] && (clearTimeout(this._timers[t]), delete this._timers[t]), 0 < e.uses || (e.hasData() ? this._cache.add(e.tileID, e, e.getExpiryTimeout()) : (e.aborted = !0, this._abortTile(e), this._unloadTile(e)))) }, Yt.prototype.clearTiles = function () { for (var t in this._shouldReloadOnResume = !1, this._paused = !1, this._tiles) this._removeTile(t); this._cache.reset() }, Yt.prototype.tilesIn = function (t, e) { for (var n = [], i = this.getIds(), r = 1 / 0, o = 1 / 0, a = -1 / 0, s = -1 / 0, l = t[0].zoom, u = 0; u < t.length; u++)var c = t[u], r = Math.min(r, c.column), o = Math.min(o, c.row), a = Math.max(a, c.column), s = Math.max(s, c.row); for (var h = 0; h < i.length; h++) { var p = this._tiles[i[h]]; if (!p.holdingForFade()) { var f = p.tileID, d = Math.pow(2, this.transform.zoom - p.tileID.overscaledZ), m = e * p.queryPadding * D.EXTENT / p.tileSize / d, y = [$t(f, new D.Coordinate(r, o, l)), $t(f, new D.Coordinate(a, s, l))]; if (y[0].x - m < D.EXTENT && y[0].y - m < D.EXTENT && 0 <= y[1].x + m && 0 <= y[1].y + m) { for (var g = [], v = 0; v < t.length; v++)g.push($t(f, t[v])); n.push({ tile: p, tileID: f, queryGeometry: [g], scale: d }) } } } return n }, Yt.prototype.getVisibleCoordinates = function (t) { for (var e = this, t = this.getRenderableIds(t).map(function (t) { return e._tiles[t].tileID }), n = 0, i = t; n < i.length; n += 1) { var r = i[n]; r.posMatrix = e.transform.calculatePosMatrix(r.toUnwrapped()) } return t }, Yt.prototype.hasTransition = function () { if (this._source.hasTransition()) return !0; if (te(this._source.type)) for (var t in this._tiles) { var e = this._tiles[t]; if (void 0 !== e.fadeEndTime && e.fadeEndTime >= D.browser.now()) return !0 } return !1 }, Yt.prototype.setFeatureState = function (t, e, n) { t = t || "_geojsonTileLayer", this._state.updateState(t, e, n) }, Yt.prototype.getFeatureState = function (t, e) { return t = t || "_geojsonTileLayer", this._state.getState(t, e) }, Yt); function Yt(t, e, n) { var i = this; Kt.call(this), this.id = t, this.dispatcher = n, this.on("data", function (t) { "source" === t.dataType && "metadata" === t.sourceDataType && (i._sourceLoaded = !0), i._sourceLoaded && !i._paused && "source" === t.dataType && "content" === t.sourceDataType && (i.reload(), i.transform && i.update(i.transform)) }), this.on("error", function () { i._sourceErrored = !0 }), this._source = function (t, e, n, i) { i = new it[e.type](t, e, n, i); if (i.id !== t) throw new Error("Expected Source id to be " + t + " instead of " + i.id); return D.bindAll(["load", "abort", "unload", "serialize", "prepare"], i), i }(t, e, n, this), this._tiles = {}, this._cache = new lt(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._coveredTiles = {}, this._state = new D.SourceFeatureState } function $t(t, e) { e = e.zoomTo(t.canonical.z); return new D.Point((e.column - (t.canonical.x + t.wrap * Math.pow(2, t.canonical.z))) * D.EXTENT, (e.row - t.canonical.y) * D.EXTENT) } function Qt(t, e) { return t % 32 - e % 32 || e - t } function te(t) { return "raster" === t || "image" === t || "video" === t } function ee() { return new D.window.Worker(ui.workerUrl) } Jt.maxOverzooming = 10, Jt.maxUnderzooming = 3; var ne, ie = function () { this.active = {} }; function re(t) { t = t.slice(); for (var e = Object.create(null), n = 0; n < t.length; n++)e[t[n].id] = t[n]; for (var i = 0; i < t.length; i++)"ref" in t[i] && (t[i] = function (t, e) { var n, i = {}; for (n in t) "ref" !== n && (i[n] = t[n]); return D.refProperties.forEach(function (t) { t in e && (i[t] = e[t]) }), i }(t[i], e[t[i].ref])); return t } ie.prototype.acquire = function (t) { if (!this.workers) for (this.workers = []; this.workers.length < ie.workerCount;)this.workers.push(new ee); return this.active[t] = !0, this.workers.slice() }, ie.prototype.release = function (t) { delete this.active[t], 0 === Object.keys(this.active).length && (this.workers.forEach(function (t) { t.terminate() }), this.workers = null) }, ie.workerCount = Math.max(Math.floor(D.browser.hardwareConcurrency / 2), 1); var oe = { setStyle: "setStyle", addLayer: "addLayer", removeLayer: "removeLayer", setPaintProperty: "setPaintProperty", setLayoutProperty: "setLayoutProperty", setFilter: "setFilter", addSource: "addSource", removeSource: "removeSource", setGeoJSONSourceData: "setGeoJSONSourceData", setLayerZoomRange: "setLayerZoomRange", setLayerProperty: "setLayerProperty", setCenter: "setCenter", setZoom: "setZoom", setBearing: "setBearing", setPitch: "setPitch", setSprite: "setSprite", setGlyphs: "setGlyphs", setTransition: "setTransition", setLight: "setLight" }; function ae(t, e, n) { n.push({ command: oe.addSource, args: [t, e[t]] }) } function se(t, e, n) { e.push({ command: oe.removeSource, args: [t] }), n[t] = !0 } function le(t, e, n, i, r, o) { for (var a in e = e || {}, t = t || {}) t.hasOwnProperty(a) && (D.deepEqual(t[a], e[a]) || n.push({ command: o, args: [i, a, e[a], r] })); for (a in e) e.hasOwnProperty(a) && !t.hasOwnProperty(a) && (D.deepEqual(t[a], e[a]) || n.push({ command: o, args: [i, a, e[a], r] })) } function ue(t) { return t.id } function ce(t, e) { return t[e.id] = e, t } function he(t, e) { if (!t) return [{ command: oe.setStyle, args: [e] }]; var n = []; try { if (!D.deepEqual(t.version, e.version)) return [{ command: oe.setStyle, args: [e] }]; D.deepEqual(t.center, e.center) || n.push({ command: oe.setCenter, args: [e.center] }), D.deepEqual(t.zoom, e.zoom) || n.push({ command: oe.setZoom, args: [e.zoom] }), D.deepEqual(t.bearing, e.bearing) || n.push({ command: oe.setBearing, args: [e.bearing] }), D.deepEqual(t.pitch, e.pitch) || n.push({ command: oe.setPitch, args: [e.pitch] }), D.deepEqual(t.sprite, e.sprite) || n.push({ command: oe.setSprite, args: [e.sprite] }), D.deepEqual(t.glyphs, e.glyphs) || n.push({ command: oe.setGlyphs, args: [e.glyphs] }), D.deepEqual(t.transition, e.transition) || n.push({ command: oe.setTransition, args: [e.transition] }), D.deepEqual(t.light, e.light) || n.push({ command: oe.setLight, args: [e.light] }); var i = {}, r = []; !function (t, e, n, i) { var r, o, a, s, l; for (r in e = e || {}, t = t || {}) t.hasOwnProperty(r) && (e.hasOwnProperty(r) || se(r, n, i)); for (r in e) e.hasOwnProperty(r) && (t.hasOwnProperty(r) ? D.deepEqual(t[r], e[r]) || ("geojson" === t[r].type && "geojson" === e[r].type && function (t, e, n) { for (var i in t[n]) if (t[n].hasOwnProperty(i) && "data" !== i && !D.deepEqual(t[n][i], e[n][i])) return; for (i in e[n]) if (e[n].hasOwnProperty(i) && "data" !== i && !D.deepEqual(t[n][i], e[n][i])) return; return 1 }(t, e, r) ? n.push({ command: oe.setGeoJSONSourceData, args: [r, e[r].data] }) : (o = r, a = e, s = n, l = i, se(o, s, l), ae(o, a, s))) : ae(r, e, n)) }(t.sources, e.sources, r, i); var o = []; t.layers && t.layers.forEach(function (t) { i[t.source] ? n.push({ command: oe.removeLayer, args: [t.id] }) : o.push(t) }), n = n.concat(r), function (t, e, n) { e = e || []; for (var i, r, o, a, s, l = (t = t || []).map(ue), u = e.map(ue), c = t.reduce(ce, {}), h = e.reduce(ce, {}), p = l.slice(), f = Object.create(null), d = 0, m = 0; d < l.length; d++)i = l[d], h.hasOwnProperty(i) ? m++ : (n.push({ command: oe.removeLayer, args: [i] }), p.splice(p.indexOf(i, m), 1)); for (m = d = 0; d < u.length; d++)i = u[u.length - 1 - d], p[p.length - 1 - d] !== i && (c.hasOwnProperty(i) ? (n.push({ command: oe.removeLayer, args: [i] }), p.splice(p.lastIndexOf(i, p.length - m), 1)) : m++, a = p[p.length - d], n.push({ command: oe.addLayer, args: [h[i], a] }), p.splice(p.length - d, 0, i), f[i] = !0); for (d = 0; d < u.length; d++)if (r = c[i = u[d]], o = h[i], !f[i] && !D.deepEqual(r, o)) if (D.deepEqual(r.source, o.source) && D.deepEqual(r["source-layer"], o["source-layer"]) && D.deepEqual(r.type, o.type)) { for (s in le(r.layout, o.layout, n, i, null, oe.setLayoutProperty), le(r.paint, o.paint, n, i, null, oe.setPaintProperty), D.deepEqual(r.filter, o.filter) || n.push({ command: oe.setFilter, args: [i, o.filter] }), D.deepEqual(r.minzoom, o.minzoom) && D.deepEqual(r.maxzoom, o.maxzoom) || n.push({ command: oe.setLayerZoomRange, args: [i, o.minzoom, o.maxzoom] }), r) r.hasOwnProperty(s) && "layout" !== s && "paint" !== s && "filter" !== s && "metadata" !== s && "minzoom" !== s && "maxzoom" !== s && (0 === s.indexOf("paint.") ? le(r[s], o[s], n, i, s.slice(6), oe.setPaintProperty) : D.deepEqual(r[s], o[s]) || n.push({ command: oe.setLayerProperty, args: [i, s, o[s]] })); for (s in o) o.hasOwnProperty(s) && !r.hasOwnProperty(s) && "layout" !== s && "paint" !== s && "filter" !== s && "metadata" !== s && "minzoom" !== s && "maxzoom" !== s && (0 === s.indexOf("paint.") ? le(r[s], o[s], n, i, s.slice(6), oe.setPaintProperty) : D.deepEqual(r[s], o[s]) || n.push({ command: oe.setLayerProperty, args: [i, s, o[s]] })) } else n.push({ command: oe.removeLayer, args: [i] }), a = p[p.lastIndexOf(i) + 1], n.push({ command: oe.addLayer, args: [o, a] }) }(o, e.layers, n) } catch (t) { console.warn("Unable to compute style diff:", t), n = [{ command: oe.setStyle, args: [e] }] } return n } function pe(t, e, n) { var i = this.boxCells = [], r = this.circleCells = []; this.xCellCount = Math.ceil(t / n), this.yCellCount = Math.ceil(e / n); for (var o = 0; o < this.xCellCount * this.yCellCount; o++)i.push([]), r.push([]); this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = t, this.height = e, this.xScale = this.xCellCount / t, this.yScale = this.yCellCount / e, this.boxUid = 0, this.circleUid = 0 } pe.prototype.keysLength = function () { return this.boxKeys.length + this.circleKeys.length }, pe.prototype.insert = function (t, e, n, i, r) { this._forEachCell(e, n, i, r, this._insertBoxCell, this.boxUid++), this.boxKeys.push(t), this.bboxes.push(e), this.bboxes.push(n), this.bboxes.push(i), this.bboxes.push(r) }, pe.prototype.insertCircle = function (t, e, n, i) { this._forEachCell(e - i, n - i, e + i, n + i, this._insertCircleCell, this.circleUid++), this.circleKeys.push(t), this.circles.push(e), this.circles.push(n), this.circles.push(i) }, pe.prototype._insertBoxCell = function (t, e, n, i, r, o) { this.boxCells[r].push(o) }, pe.prototype._insertCircleCell = function (t, e, n, i, r, o) { this.circleCells[r].push(o) }, pe.prototype._query = function (t, e, n, i, r, o) { if (n < 0 || t > this.width || i < 0 || e > this.height) return !r && []; var a = []; if (t <= 0 && e <= 0 && this.width <= n && this.height <= i) { if (r) return !0; for (var s = 0; s < this.boxKeys.length; s++)a.push({ key: this.boxKeys[s], x1: this.bboxes[4 * s], y1: this.bboxes[4 * s + 1], x2: this.bboxes[4 * s + 2], y2: this.bboxes[4 * s + 3] }); for (var l = 0; l < this.circleKeys.length; l++) { var u = this.circles[3 * l], c = this.circles[3 * l + 1], h = this.circles[3 * l + 2]; a.push({ key: this.circleKeys[l], x1: u - h, y1: c - h, x2: u + h, y2: c + h }) } return o ? a.filter(o) : a } var p = { hitTest: r, seenUids: { box: {}, circle: {} } }; return this._forEachCell(t, e, n, i, this._queryCell, a, p, o), r ? 0 < a.length : a }, pe.prototype._queryCircle = function (t, e, n, i, r) { var o = t - n, a = t + n, s = e - n, l = e + n; if (a < 0 || o > this.width || l < 0 || s > this.height) return !i && []; var u = [], n = { hitTest: i, circle: { x: t, y: e, radius: n }, seenUids: { box: {}, circle: {} } }; return this._forEachCell(o, s, a, l, this._queryCellCircle, u, n, r), i ? 0 < u.length : u }, pe.prototype.query = function (t, e, n, i, r) { return this._query(t, e, n, i, !1, r) }, pe.prototype.hitTest = function (t, e, n, i, r) { return this._query(t, e, n, i, !0, r) }, pe.prototype.hitTestCircle = function (t, e, n, i) { return this._queryCircle(t, e, n, !0, i) }, pe.prototype._queryCell = function (t, e, n, i, r, o, a, s) { var l = a.seenUids, u = this.boxCells[r]; if (null !== u) for (var c = this.bboxes, h = 0, p = u; h < p.length; h += 1) { var f = p[h]; if (!l.box[f]) { l.box[f] = !0; var d = 4 * f; if (t <= c[2 + d] && e <= c[3 + d] && n >= c[0 + d] && i >= c[1 + d] && (!s || s(this.boxKeys[f]))) { if (a.hitTest) return o.push(!0), !0; o.push({ key: this.boxKeys[f], x1: c[d], y1: c[1 + d], x2: c[2 + d], y2: c[3 + d] }) } } } r = this.circleCells[r]; if (null !== r) for (var m = this.circles, y = 0, g = r; y < g.length; y += 1) { var v = g[y]; if (!l.circle[v]) { l.circle[v] = !0; var _ = 3 * v; if (this._circleAndRectCollide(m[_], m[1 + _], m[2 + _], t, e, n, i) && (!s || s(this.circleKeys[v]))) { if (a.hitTest) return o.push(!0), !0; var x = m[_], b = m[1 + _], _ = m[2 + _]; o.push({ key: this.circleKeys[v], x1: x - _, y1: b - _, x2: x + _, y2: b + _ }) } } } }, pe.prototype._queryCellCircle = function (t, e, n, i, r, o, a, s) { var l = a.circle, u = a.seenUids, a = this.boxCells[r]; if (null !== a) for (var c = this.bboxes, h = 0, p = a; h < p.length; h += 1) { var f = p[h]; if (!u.box[f]) { u.box[f] = !0; var d = 4 * f; if (this._circleAndRectCollide(l.x, l.y, l.radius, c[0 + d], c[1 + d], c[2 + d], c[3 + d]) && (!s || s(this.boxKeys[f]))) return o.push(!0), !0 } } r = this.circleCells[r]; if (null !== r) for (var m = this.circles, y = 0, g = r; y < g.length; y += 1) { var v = g[y]; if (!u.circle[v]) { u.circle[v] = !0; var _ = 3 * v; if (this._circlesCollide(m[_], m[1 + _], m[2 + _], l.x, l.y, l.radius) && (!s || s(this.circleKeys[v]))) return o.push(!0), !0 } } }, pe.prototype._forEachCell = function (t, e, n, i, r, o, a, s) { for (var l = this._convertToXCellCoord(t), u = this._convertToYCellCoord(e), c = this._convertToXCellCoord(n), h = this._convertToYCellCoord(i), p = l; p <= c; p++)for (var f = u; f <= h; f++) { var d = this.xCellCount * f + p; if (r.call(this, t, e, n, i, d, o, a, s)) return } }, pe.prototype._convertToXCellCoord = function (t) { return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(t * this.xScale))) }, pe.prototype._convertToYCellCoord = function (t) { return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(t * this.yScale))) }, pe.prototype._circlesCollide = function (t, e, n, i, r, o) { t = i - t, e = r - e, o = n + o; return t * t + e * e < o * o }, pe.prototype._circleAndRectCollide = function (t, e, n, i, r, o, a) { o = (o - i) / 2, i = Math.abs(t - (i + o)); if (o + n < i) return !1; a = (a - r) / 2, r = Math.abs(e - (r + a)); if (a + n < r) return !1; if (i <= o || r <= a) return !0; o = i - o, a = r - a; return o * o + a * a <= n * n }; var fe = D.properties.layout; function de(t, e, n, i, r) { var o = D.identity(new Float32Array(16)); return e ? (D.identity(o), D.scale(o, o, [1 / r, 1 / r, 1]), n || D.rotateZ(o, o, i.angle)) : (D.scale(o, o, [i.width / 2, -i.height / 2, 1]), D.translate(o, o, [1, -1, 0]), D.multiply(o, o, t)), o } function me(t, e) { t = [t.x, t.y, 0, 1]; Ee(t, t, e); e = t[3]; return { point: new D.Point(t[0] / e, t[1] / e), signedDistanceFromCamera: e } } function ye(t, e, n, i, r, o, a, s, l, u, c, h) { var p = s.glyphStartIndex + s.numGlyphs, f = s.lineStartIndex, d = s.lineStartIndex + s.lineLength, m = e.getoffsetX(s.glyphStartIndex), p = e.getoffsetX(p - 1), m = xe(t * m, n, i, r, o, a, s.segment, f, d, l, u, c, h); if (!m) return null; h = xe(t * p, n, i, r, o, a, s.segment, f, d, l, u, c, h); return h ? { first: m, last: h } : null } function ge(t, e, n, i) { return t === D.WritingMode.horizontal && Math.abs(n.y - e.y) > Math.abs(n.x - e.x) * i ? { useVertical: !0 } : (t === D.WritingMode.vertical ? e.y < n.y : e.x > n.x) ? { needsFlipping: !0 } : null } function ve(t, e, n, i, r, o, a, s, l, u, c, h, p, f) { var d, m = e / 24, y = t.lineOffsetX * e, g = t.lineOffsetY * e; if (1 < t.numGlyphs) { var v = t.glyphStartIndex + t.numGlyphs, _ = t.lineStartIndex, x = t.lineStartIndex + t.lineLength, b = ye(m, s, y, g, n, c, h, t, l, o, p, !1); if (!b) return { notEnoughRoom: !0 }; e = me(b.first.point, a).point, a = me(b.last.point, a).point; if (i && !n) { a = ge(t.writingMode, e, a, f); if (a) return a } d = [b.first]; for (var w = t.glyphStartIndex + 1; w < v - 1; w++)d.push(xe(m * s.getoffsetX(w), y, g, n, c, h, t.segment, _, x, l, o, p, !1)); d.push(b.last) } else { if (i && !n) { var b = me(h, r).point, i = t.lineStartIndex + t.segment + 1, E = new D.Point(l.getx(i), l.gety(i)), i = me(E, r), E = 0 < i.signedDistanceFromCamera ? i.point : _e(h, E, b, 1, r), E = ge(t.writingMode, b, E, f); if (E) return E } E = xe(m * s.getoffsetX(t.glyphStartIndex), y, g, n, c, h, t.segment, t.lineStartIndex, t.lineStartIndex + t.lineLength, l, o, p, !1); if (!E) return { notEnoughRoom: !0 }; d = [E] } for (var S = 0, T = d; S < T.length; S += 1) { var A = T[S]; D.addDynamicAttributes(u, A.point, A.angle) } return {} } function _e(t, e, n, i, r) { r = me(t.add(t.sub(e)._unit()), r).point, r = n.sub(r); return n.add(r._mult(i / r.mag())) } function xe(t, e, n, i, r, o, a, s, l, u, c, h, p) { var t = i ? t - e : t + e, f = 0 < t ? 1 : -1, e = 0; i && (f *= -1, e = Math.PI), f < 0 && (e += Math.PI); for (var d = 0 < f ? s + a : s + a + 1, a = d, m = r, y = r, g = 0, v = 0, _ = Math.abs(t); g + v <= _;) { if ((d += f) < s || l <= d) return null; var x, b, y = m; void 0 === (m = h[d]) && (m = 0 < (b = me(x = new D.Point(u.getx(d), u.gety(d)), c)).signedDistanceFromCamera ? h[d] = b.point : (b = d - f, _e(0 === g ? o : new D.Point(u.getx(b), u.gety(b)), x, y, _ - g + 1, c))), g += v, v = y.dist(m) } r = (_ - g) / v, t = m.sub(y), r = t.mult(r)._add(y); return r._add(t._unit()._perp()._mult(n * f)), { point: r, angle: e + Math.atan2(m.y - y.y, m.x - y.x), tileDistance: p ? { prevTileDistance: d - f === a ? 0 : u.gettileUnitDistanceFromAnchor(d - f), lastSegmentViewportDistance: _ - g } : null } } var be = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]); function we(t, e) { for (var n = 0; n < t; n++) { var i = e.length; e.resize(i + 4), e.float32.set(be, 3 * i) } } function Ee(t, e, n) { var i = e[0], e = e[1]; return t[0] = n[0] * i + n[4] * e + n[12], t[1] = n[1] * i + n[5] * e + n[13], t[3] = n[3] * i + n[7] * e + n[15], t } function Se(t, e, n) { void 0 === e && (e = new pe(t.width + 200, t.height + 200, 25)), void 0 === n && (n = new pe(t.width + 200, t.height + 200, 25)), this.transform = t, this.grid = e, this.ignoredGrid = n, this.pitchfactor = Math.cos(t._pitch) * t.cameraToCenterDistance, this.screenRightBoundary = t.width + 100, this.screenBottomBoundary = t.height + 100, this.gridRightBoundary = t.width + 200, this.gridBottomBoundary = t.height + 200 } function Te(t, e, n) { t[e + 4] = n ? 1 : 0 } function Ae(t, e, n) { return e * (D.EXTENT / (t.tileSize * Math.pow(2, n - t.tileID.overscaledZ))) } Se.prototype.placeCollisionBox = function (t, e, n, i, r) { var o = this.projectAndGetPerspectiveRatio(i, t.anchorPointX, t.anchorPointY), a = n * o.perspectiveRatio, s = t.x1 * a + o.point.x, i = t.y1 * a + o.point.y, n = t.x2 * a + o.point.x, o = t.y2 * a + o.point.y; return !this.isInsideGrid(s, i, n, o) || !e && this.grid.hitTest(s, i, n, o, r) ? { box: [], offscreen: !1 } : { box: [s, i, n, o], offscreen: this.isOffscreen(s, i, n, o) } }, Se.prototype.approximateTileDistance = function (t, e, n, i, r) { i = r ? 1 : i / this.pitchfactor, n = t.lastSegmentViewportDistance * n; return t.prevTileDistance + n + (i - 1) * n * Math.abs(Math.sin(e)) }, Se.prototype.placeCollisionCircles = function (t, e, n, i, r, o, a, s, l, u, c, h, p, f) { var d = [], m = this.projectAnchor(u, o.anchorX, o.anchorY), y = l / 24, g = o.lineOffsetX * l, v = o.lineOffsetY * l, l = new D.Point(o.anchorX, o.anchorY), _ = ye(y, s, g, v, !1, me(l, c).point, l, o, a, c, {}, !0), x = !1, b = !1, w = !0, E = m.perspectiveRatio * i, n = 1 / (i * n), S = 0, T = 0; _ && (S = this.approximateTileDistance(_.first.tileDistance, _.first.angle, n, m.cameraDistance, p), T = this.approximateTileDistance(_.last.tileDistance, _.last.angle, n, m.cameraDistance, p)); for (var A = 0; A < t.length; A += 5) { var z = t[A], I = t[A + 1], k = t[A + 2], C = t[A + 3]; if (!_ || C < -S || T < C) Te(t, A, !1); else { z = this.projectPoint(u, z, I), I = k * E; if (0 < d.length) { var M = z.x - d[d.length - 4], P = z.y - d[d.length - 3]; if (M * M + P * P < I * I * 2 && A + 8 < t.length) { var L = t[A + 8]; if (-S < L && L < T) { Te(t, A, !1); continue } } } k = A / 5; d.push(z.x, z.y, I, k), Te(t, A, !0); M = z.x - I, P = z.y - I, L = z.x + I, k = z.y + I, w = w && this.isOffscreen(M, P, L, k), b = b || this.isInsideGrid(M, P, L, k); if (!e && this.grid.hitTestCircle(z.x, z.y, I, f)) { if (!h) return { circles: [], offscreen: !1 }; x = !0 } } } return { circles: x || !b ? [] : d, offscreen: w } }, Se.prototype.queryRenderedSymbols = function (t) { if (0 === t.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength()) return {}; for (var e = [], n = 1 / 0, i = 1 / 0, r = -1 / 0, o = -1 / 0, a = 0, s = t; a < s.length; a += 1) { var l = s[a], l = new D.Point(l.x + 100, l.y + 100), n = Math.min(n, l.x), i = Math.min(i, l.y), r = Math.max(r, l.x), o = Math.max(o, l.y); e.push(l) } for (var u = {}, c = {}, h = 0, p = this.grid.query(n, i, r, o).concat(this.ignoredGrid.query(n, i, r, o)); h < p.length; h += 1) { var f = p[h], d = f.key; void 0 === u[d.bucketInstanceId] && (u[d.bucketInstanceId] = {}), u[d.bucketInstanceId][d.featureIndex] || (f = [new D.Point(f.x1, f.y1), new D.Point(f.x2, f.y1), new D.Point(f.x2, f.y2), new D.Point(f.x1, f.y2)], D.polygonIntersectsPolygon(e, f) && (u[d.bucketInstanceId][d.featureIndex] = !0, void 0 === c[d.bucketInstanceId] && (c[d.bucketInstanceId] = []), c[d.bucketInstanceId].push(d.featureIndex))) } return c }, Se.prototype.insertCollisionBox = function (t, e, n, i, r) { r = { bucketInstanceId: n, featureIndex: i, collisionGroupID: r }; (e ? this.ignoredGrid : this.grid).insert(r, t[0], t[1], t[2], t[3]) }, Se.prototype.insertCollisionCircles = function (t, e, n, i, r) { for (var o = e ? this.ignoredGrid : this.grid, a = { bucketInstanceId: n, featureIndex: i, collisionGroupID: r }, s = 0; s < t.length; s += 4)o.insertCircle(a, t[s], t[s + 1], t[s + 2]) }, Se.prototype.projectAnchor = function (t, e, n) { n = [e, n, 0, 1]; return Ee(n, n, t), { perspectiveRatio: .5 + this.transform.cameraToCenterDistance / n[3] * .5, cameraDistance: n[3] } }, Se.prototype.projectPoint = function (t, e, n) { n = [e, n, 0, 1]; return Ee(n, n, t), new D.Point((n[0] / n[3] + 1) / 2 * this.transform.width + 100, (-n[1] / n[3] + 1) / 2 * this.transform.height + 100) }, Se.prototype.projectAndGetPerspectiveRatio = function (t, e, n) { n = [e, n, 0, 1]; return Ee(n, n, t), { point: new D.Point((n[0] / n[3] + 1) / 2 * this.transform.width + 100, (-n[1] / n[3] + 1) / 2 * this.transform.height + 100), perspectiveRatio: .5 + this.transform.cameraToCenterDistance / n[3] * .5 } }, Se.prototype.isOffscreen = function (t, e, n, i) { return n < 100 || t >= this.screenRightBoundary || i < 100 || e > this.screenBottomBoundary }, Se.prototype.isInsideGrid = function (t, e, n, i) { return 0 <= n && t < this.gridRightBoundary && 0 <= i && e < this.gridBottomBoundary }; function ze(t, e, n, i) { this.opacity = t ? Math.max(0, Math.min(1, t.opacity + (t.placed ? e : -e))) : i && n ? 1 : 0, this.placed = n } ze.prototype.isHidden = function () { return 0 === this.opacity && !this.placed }; function Ie(t, e, n, i, r) { this.text = new ze(t ? t.text : null, e, n, r), this.icon = new ze(t ? t.icon : null, e, i, r) } Ie.prototype.isHidden = function () { return this.text.isHidden() && this.icon.isHidden() }; function ke(t, e, n) { this.text = t, this.icon = e, this.skipFade = n } function Ce(t) { this.crossSourceCollisions = t, this.maxGroupID = 0, this.collisionGroups = {} } Ce.prototype.get = function (t) { return this.crossSourceCollisions ? { ID: 0, predicate: null } : (this.collisionGroups[t] || (e = ++this.maxGroupID, this.collisionGroups[t] = { ID: e, predicate: function (t) { return t.collisionGroupID === e } }), this.collisionGroups[t]); var e }; function Me(t, e, n) { this.transform = t.clone(), this.collisionIndex = new Se(this.transform), this.placements = {}, this.opacities = {}, this.stale = !1, this.fadeDuration = e, this.retainedQueryData = {}, this.collisionGroups = new Ce(n) } function Pe(t, e, n) { t.emplaceBack(e ? 1 : 0, n ? 1 : 0), t.emplaceBack(e ? 1 : 0, n ? 1 : 0), t.emplaceBack(e ? 1 : 0, n ? 1 : 0), t.emplaceBack(e ? 1 : 0, n ? 1 : 0) } Me.prototype.placeLayerTile = function (t, e, n, i) { var r, o, a, s, l, u = e.getBucket(t), c = e.latestFeatureIndex; u && c && t.id === u.layerIds[0] && (r = e.collisionBoxArray, l = u.layers[0].layout, o = Math.pow(2, this.transform.zoom - e.tileID.overscaledZ), a = e.tileSize / D.EXTENT, t = de(s = this.transform.calculatePosMatrix(e.tileID.toUnwrapped()), "map" === l.get("text-pitch-alignment"), "map" === l.get("text-rotation-alignment"), this.transform, Ae(e, 1, this.transform.zoom)), l = de(s, "map" === l.get("icon-pitch-alignment"), "map" === l.get("icon-rotation-alignment"), this.transform, Ae(e, 1, this.transform.zoom)), this.retainedQueryData[u.bucketInstanceId] = new function (t, e, n, i, r) { this.bucketInstanceId = t, this.featureIndex = e, this.sourceLayerIndex = n, this.bucketIndex = i, this.tileID = r }(u.bucketInstanceId, c, u.sourceLayerIndex, u.index, e.tileID), this.placeLayerBucket(u, s, t, l, o, a, n, e.holdingForFade(), i, r)) }, Me.prototype.placeLayerBucket = function (t, e, n, i, r, o, a, s, l, u) { for (var c = t.layers[0].layout, h = D.evaluateSizeForZoom(t.textSizeData, this.transform.zoom, D.properties.layout.properties["text-size"]), p = c.get("text-optional"), f = c.get("icon-optional"), d = this.collisionGroups.get(t.sourceID), m = 0, y = t.symbolInstances; m < y.length; m += 1) { var g, v, _, x, b, w, E, S, T, A, z, I = y[m]; l[I.crossTileID] || (s ? this.placements[I.crossTileID] = new ke(!1, !1, !1) : (T = !(g = S = !1), _ = E = v = null, b = x = 0, I.collisionArrays || (I.collisionArrays = t.deserializeCollisionBoxes(u, I.textBoxStartIndex, I.textBoxEndIndex, I.iconBoxStartIndex, I.iconBoxEndIndex)), I.collisionArrays.textFeatureIndex && (x = I.collisionArrays.textFeatureIndex), I.collisionArrays.textBox && (S = 0 < (v = this.collisionIndex.placeCollisionBox(I.collisionArrays.textBox, c.get("text-allow-overlap"), o, e, d.predicate)).box.length, T = T && v.offscreen), (w = I.collisionArrays.textCircles) && (A = t.text.placedSymbolArray.get(I.placedTextSymbolIndices[0]), z = D.evaluateSizeForFeature(t.textSizeData, h, A), E = this.collisionIndex.placeCollisionCircles(w, c.get("text-allow-overlap"), r, o, I.key, A, t.lineVertexArray, t.glyphOffsetArray, z, e, n, a, "map" === c.get("text-pitch-alignment"), d.predicate), S = c.get("text-allow-overlap") || 0 < E.circles.length, T = T && E.offscreen), I.collisionArrays.iconFeatureIndex && (b = I.collisionArrays.iconFeatureIndex), I.collisionArrays.iconBox && (g = 0 < (_ = this.collisionIndex.placeCollisionBox(I.collisionArrays.iconBox, c.get("icon-allow-overlap"), o, e, d.predicate)).box.length, T = T && _.offscreen), A = p || 0 === I.numGlyphVertices && 0 === I.numVerticalGlyphVertices, z = f || 0 === I.numIconVertices, A || z ? z ? A || (g = g && S) : S = g && S : g = S = g && S, S && v && this.collisionIndex.insertCollisionBox(v.box, c.get("text-ignore-placement"), t.bucketInstanceId, x, d.ID), g && _ && this.collisionIndex.insertCollisionBox(_.box, c.get("icon-ignore-placement"), t.bucketInstanceId, b, d.ID), S && E && this.collisionIndex.insertCollisionCircles(E.circles, c.get("text-ignore-placement"), t.bucketInstanceId, x, d.ID), this.placements[I.crossTileID] = new ke(S, g, T || t.justReloaded), l[I.crossTileID] = !0)) } t.justReloaded = !1 }, Me.prototype.commit = function (t, e) { this.commitTime = e; var n, i, r = !1, o = t && 0 !== this.fadeDuration ? (this.commitTime - t.commitTime) / this.fadeDuration : 1, a = t ? t.opacities : {}; for (n in this.placements) var s = this.placements[n], l = a[n], r = l ? (this.opacities[n] = new Ie(l, o, s.text, s.icon), r || s.text !== l.text.placed || s.icon !== l.icon.placed) : (this.opacities[n] = new Ie(null, o, s.text, s.icon, s.skipFade), r || s.text || s.icon); for (i in a) { var u, c = a[i]; this.opacities[i] || ((u = new Ie(c, o, !1, !1)).isHidden() || (this.opacities[i] = u, r = r || c.text.placed || c.icon.placed)) } r ? this.lastPlacementChangeTime = e : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = t ? t.lastPlacementChangeTime : e) }, Me.prototype.updateLayerOpacities = function (t, e) { for (var n = {}, i = 0, r = e; i < r.length; i += 1) { var o = r[i], a = o.getBucket(t); a && o.latestFeatureIndex && t.id === a.layerIds[0] && this.updateBucketOpacities(a, n, o.collisionBoxArray) } }, Me.prototype.updateBucketOpacities = function (t, e, n) { t.hasTextData() && t.text.opacityVertexArray.clear(), t.hasIconData() && t.icon.opacityVertexArray.clear(), t.hasCollisionBoxData() && t.collisionBox.collisionVertexArray.clear(), t.hasCollisionCircleData() && t.collisionCircle.collisionVertexArray.clear(); for (var i = t.layers[0].layout, r = new Ie(null, 0, !1, !1, !0), o = new Ie(null, 0, i.get("text-allow-overlap"), i.get("icon-allow-overlap"), !0), a = 0; a < t.symbolInstances.length; a++) { var s = t.symbolInstances[a], l = e[s.crossTileID], u = this.opacities[s.crossTileID]; l ? u = r : u || (u = o, this.opacities[s.crossTileID] = u), e[s.crossTileID] = !0; var c = 0 < s.numGlyphVertices || 0 < s.numVerticalGlyphVertices, h = 0 < s.numIconVertices; if (c) { for (var p = Ne(u.text), f = (s.numGlyphVertices + s.numVerticalGlyphVertices) / 4, d = 0; d < f; d++)t.text.opacityVertexArray.emplaceBack(p); for (var m = 0, y = s.placedTextSymbolIndices; m < y.length; m += 1) { var g = y[m]; t.text.placedSymbolArray.get(g).hidden = u.text.isHidden() } } if (h) { for (var v = Ne(u.icon), _ = 0; _ < s.numIconVertices / 4; _++)t.icon.opacityVertexArray.emplaceBack(v); t.icon.placedSymbolArray.get(a).hidden = u.icon.isHidden() } s.collisionArrays || (s.collisionArrays = t.deserializeCollisionBoxes(n, s.textBoxStartIndex, s.textBoxEndIndex, s.iconBoxStartIndex, s.iconBoxEndIndex)); h = s.collisionArrays; if (h) { h.textBox && t.hasCollisionBoxData() && Pe(t.collisionBox.collisionVertexArray, u.text.placed, !1), h.iconBox && t.hasCollisionBoxData() && Pe(t.collisionBox.collisionVertexArray, u.icon.placed, !1); var x = h.textCircles; if (x && t.hasCollisionCircleData()) for (var b = 0; b < x.length; b += 5) { var w = l || 0 === x[b + 4]; Pe(t.collisionCircle.collisionVertexArray, u.text.placed, w) } } } t.sortFeatures(this.transform.angle), this.retainedQueryData[t.bucketInstanceId] && (this.retainedQueryData[t.bucketInstanceId].featureSortOrder = t.featureSortOrder), t.hasTextData() && t.text.opacityVertexBuffer && t.text.opacityVertexBuffer.updateData(t.text.opacityVertexArray), t.hasIconData() && t.icon.opacityVertexBuffer && t.icon.opacityVertexBuffer.updateData(t.icon.opacityVertexArray), t.hasCollisionBoxData() && t.collisionBox.collisionVertexBuffer && t.collisionBox.collisionVertexBuffer.updateData(t.collisionBox.collisionVertexArray), t.hasCollisionCircleData() && t.collisionCircle.collisionVertexBuffer && t.collisionCircle.collisionVertexBuffer.updateData(t.collisionCircle.collisionVertexArray) }, Me.prototype.symbolFadeChange = function (t) { return 0 === this.fadeDuration ? 1 : (t - this.commitTime) / this.fadeDuration }, Me.prototype.hasTransitions = function (t) { return this.stale || t - this.lastPlacementChangeTime < this.fadeDuration }, Me.prototype.stillRecent = function (t) { return "undefined" !== this.commitTime && this.commitTime + this.fadeDuration > t }, Me.prototype.setStale = function () { this.stale = !0 }; var Le = Math.pow(2, 25), De = Math.pow(2, 24), Re = Math.pow(2, 17), Be = Math.pow(2, 16), Oe = Math.pow(2, 9), Fe = Math.pow(2, 8), Ve = Math.pow(2, 1); function Ne(t) { if (0 === t.opacity && !t.placed) return 0; if (1 === t.opacity && t.placed) return 4294967295; var e = t.placed ? 1 : 0, t = Math.floor(127 * t.opacity); return t * Le + e * De + t * Re + e * Be + t * Oe + e * Fe + t * Ve + e } function je() { this._currentTileIndex = 0, this._seenCrossTileIDs = {} } je.prototype.continuePlacement = function (t, e, n, i, r) { for (; this._currentTileIndex < t.length;) { var o = t[this._currentTileIndex]; if (e.placeLayerTile(i, o, n, this._seenCrossTileIDs), this._currentTileIndex++, r()) return !0 } }; function Ue(t, e, n, i, r, o) { this.placement = new Me(t, r, o), this._currentPlacementIndex = e.length - 1, this._forceFullPlacement = n, this._showCollisionBoxes = i, this._done = !1 } Ue.prototype.isDone = function () { return this._done }, Ue.prototype.continuePlacement = function (t, e, n) { for (var i = this, r = D.browser.now(), o = function () { var t = D.browser.now() - r; return !i._forceFullPlacement && 2 < t }; 0 <= this._currentPlacementIndex;) { var a = e[t[i._currentPlacementIndex]], s = i.placement.collisionIndex.transform.zoom; if ("symbol" === a.type && (!a.minzoom || a.minzoom <= s) && (!a.maxzoom || a.maxzoom > s)) { if (i._inProgressLayer || (i._inProgressLayer = new je), i._inProgressLayer.continuePlacement(n[a.source], i.placement, i._showCollisionBoxes, a, o)) return; delete i._inProgressLayer } i._currentPlacementIndex-- } this._done = !0 }, Ue.prototype.commit = function (t, e) { return this.placement.commit(t, e), this.placement }; function qe(t, e, n) { this.tileID = t, this.indexedSymbolInstances = {}, this.bucketInstanceId = n; for (var i = 0, r = e; i < r.length; i += 1) { var o = r[i], a = o.key; this.indexedSymbolInstances[a] || (this.indexedSymbolInstances[a] = []), this.indexedSymbolInstances[a].push({ crossTileID: o.crossTileID, coord: this.getScaledCoordinates(o, t) }) } } var Ze = 512 / D.EXTENT / 2; qe.prototype.getScaledCoordinates = function (t, e) { var n = e.canonical.z - this.tileID.canonical.z, n = Ze / Math.pow(2, n), t = t.anchor; return { x: Math.floor((e.canonical.x * D.EXTENT + t.x) * n), y: Math.floor((e.canonical.y * D.EXTENT + t.y) * n) } }, qe.prototype.findMatches = function (t, e, n) { for (var i = this.tileID.canonical.z < e.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - e.canonical.z), r = 0, o = t; r < o.length; r += 1) { var a = o[r]; if (!a.crossTileID) { var s = this.indexedSymbolInstances[a.key]; if (s) for (var l = this.getScaledCoordinates(a, e), u = 0, c = s; u < c.length; u += 1) { var h = c[u]; if (Math.abs(h.coord.x - l.x) <= i && Math.abs(h.coord.y - l.y) <= i && !n[h.crossTileID]) { n[h.crossTileID] = !0, a.crossTileID = h.crossTileID; break } } } } }; function Ge() { this.maxCrossTileID = 0 } Ge.prototype.generate = function () { return ++this.maxCrossTileID }; function Xe() { this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0 } Xe.prototype.handleWrapJump = function (t) { var e = Math.round((t - this.lng) / 360); if (0 !== e) for (var n in this.indexes) { var i, r = this.indexes[n], o = {}; for (i in r) { var a = r[i]; a.tileID = a.tileID.unwrapTo(a.tileID.wrap + e), o[a.tileID.key] = a } this.indexes[n] = o } this.lng = t }, Xe.prototype.addBucket = function (t, e, n) { if (this.indexes[t.overscaledZ] && this.indexes[t.overscaledZ][t.key]) { if (this.indexes[t.overscaledZ][t.key].bucketInstanceId === e.bucketInstanceId) return !1; this.removeBucketCrossTileIDs(t.overscaledZ, this.indexes[t.overscaledZ][t.key]) } for (var i = 0, r = e.symbolInstances; i < r.length; i += 1)r[i].crossTileID = 0; this.usedCrossTileIDs[t.overscaledZ] || (this.usedCrossTileIDs[t.overscaledZ] = {}); var o, a = this.usedCrossTileIDs[t.overscaledZ]; for (o in this.indexes) { var s = this.indexes[o]; if (Number(o) > t.overscaledZ) for (var l in s) { var u = s[l]; u.tileID.isChildOf(t) && u.findMatches(e.symbolInstances, t, a) } else { var c = s[t.scaledTo(Number(o)).key]; c && c.findMatches(e.symbolInstances, t, a) } } for (var h = 0, p = e.symbolInstances; h < p.length; h += 1) { var f = p[h]; f.crossTileID || (f.crossTileID = n.generate(), a[f.crossTileID] = !0) } return void 0 === this.indexes[t.overscaledZ] && (this.indexes[t.overscaledZ] = {}), this.indexes[t.overscaledZ][t.key] = new qe(t, e.symbolInstances, e.bucketInstanceId), !0 }, Xe.prototype.removeBucketCrossTileIDs = function (t, e) { for (var n in e.indexedSymbolInstances) for (var i = 0, r = e.indexedSymbolInstances[n]; i < r.length; i += 1) { var o = r[i]; delete this.usedCrossTileIDs[t][o.crossTileID] } }, Xe.prototype.removeStaleBuckets = function (t) { var e, n = !1; for (e in this.indexes) { var i, r = this.indexes[e]; for (i in r) t[r[i].bucketInstanceId] || (this.removeBucketCrossTileIDs(e, r[i]), delete r[i], n = !0) } return n }; var We = function () { this.layerIndexes = {}, this.crossTileIDs = new Ge, this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {} }; We.prototype.addLayer = function (t, e, n) { var i = this.layerIndexes[t.id]; void 0 === i && (i = this.layerIndexes[t.id] = new Xe); var r = !1, o = {}; i.handleWrapJump(n); for (var a = 0, s = e; a < s.length; a += 1) { var l = s[a], u = l.getBucket(t); u && t.id === u.layerIds[0] && (u.bucketInstanceId || (u.bucketInstanceId = ++this.maxBucketInstanceId), i.addBucket(l.tileID, u, this.crossTileIDs) && (r = !0), o[u.bucketInstanceId] = !0) } return i.removeStaleBuckets(o) && (r = !0), r }, We.prototype.pruneUnusedLayers = function (t) { var e, n = {}; for (e in t.forEach(function (t) { n[t] = !0 }), this.layerIndexes) n[e] || delete this.layerIndexes[e] }; function He(t, e) { return D.emitValidationErrors(t, e && e.filter(function (t) { return "source.canvas" !== t.identifier })) } var Ke, Je = D.pick(oe, ["addLayer", "removeLayer", "setPaintProperty", "setLayoutProperty", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData"]), Ye = D.pick(oe, ["setCenter", "setZoom", "setBearing", "setPitch"]), $e = ((Ke = D.Evented) && (Qe.__proto__ = Ke), Qe.prototype = Object.create(Ke && Ke.prototype), (Qe.prototype.constructor = Qe).prototype.loadURL = function (t, e) { var n = this; void 0 === e && (e = {}), this.fire(new D.Event("dataloading", { dataType: "style" })); var i = "boolean" == typeof e.validate ? e.validate : !p(t); t = function (t, e) { if (!p(t)) return t; t = v(t); return t.path = "/styles/v1" + t.path, h(t, e) }(t, e.accessToken); t = this.map._transformRequest(t, D.ResourceType.Style); this._request = D.getJSON(t, function (t, e) { n._request = null, t ? n.fire(new D.ErrorEvent(t)) : e && n._load(e, i) }) }, Qe.prototype.loadJSON = function (t, e) { var n = this; void 0 === e && (e = {}), this.fire(new D.Event("dataloading", { dataType: "style" })), this._request = D.browser.frame(function () { n._request = null, n._load(t, !1 !== e.validate) }) }, Qe.prototype._load = function (t, e) { var n, c, h, p, f, i, r, o = this; if (!e || !He(this, D.validateStyle(t))) { for (var a in this._loaded = !0, (this.stylesheet = t).sources) o.addSource(a, t.sources[a], { validate: !1 }); t.sprite ? this._spriteRequest = (n = t.sprite, e = this.map._transformRequest, c = function (t, e) { if (o._spriteRequest = null, t) o.fire(new D.ErrorEvent(t)); else if (e) for (var n in e) o.imageManager.addImage(n, e[n]); o.imageManager.setLoaded(!0), o.fire(new D.Event("data", { dataType: "style" })) }, s = 1 < D.browser.devicePixelRatio ? "@2x" : "", i = D.getJSON(e(y(n, s, ".json"), D.ResourceType.SpriteJSON), function (t, e) { i = null, f || (f = t, h = e, m()) }), r = D.getImage(e(y(n, s, ".png"), D.ResourceType.SpriteImage), function (t, e) { r = null, f || (f = t, p = e, m()) }), { cancel: function () { i && (i.cancel(), i = null), r && (r.cancel(), r = null) } }) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(t.glyphs); var s = re(this.stylesheet.layers); this._order = s.map(function (t) { return t.id }), this._layers = {}; for (var l = 0, u = s; l < u.length; l += 1) { var d = u[l]; (d = D.createStyleLayer(d)).setEventedParent(o, { layer: { id: d.id } }), o._layers[d.id] = d } this.dispatcher.broadcast("setLayers", this._serializeLayers(this._order)), this.light = new L(this.stylesheet.light), this.fire(new D.Event("data", { dataType: "style" })), this.fire(new D.Event("style.load")) } function m() { if (f) c(f); else if (h && p) { var t, e = D.browser.getImageData(p), n = {}; for (t in h) { var i = h[t], r = i.width, o = i.height, a = i.x, s = i.y, l = i.sdf, u = i.pixelRatio, i = new D.RGBAImage({ width: r, height: o }); D.RGBAImage.copy(e, i, { x: a, y: s }, { x: 0, y: 0 }, { width: r, height: o }), n[t] = { data: i, pixelRatio: u, sdf: l } } c(null, n) } } }, Qe.prototype._validateLayer = function (t) { var e, n = this.sourceCaches[t.source]; n && (!(e = t.sourceLayer) || ("geojson" === (n = n.getSource()).type || n.vectorLayerIds && -1 === n.vectorLayerIds.indexOf(e)) && this.fire(new D.ErrorEvent(new Error('Source layer "' + e + '" does not exist on source "' + n.id + '" as specified by style layer "' + t.id + '"')))) }, Qe.prototype.loaded = function () { if (!this._loaded) return !1; if (Object.keys(this._updatedSources).length) return !1; for (var t in this.sourceCaches) if (!this.sourceCaches[t].loaded()) return !1; return !!this.imageManager.isLoaded() }, Qe.prototype._serializeLayers = function (t) { var e = this; return t.map(function (t) { return e._layers[t].serialize() }) }, Qe.prototype.hasTransitions = function () { if (this.light && this.light.hasTransition()) return !0; for (var t in this.sourceCaches) if (this.sourceCaches[t].hasTransition()) return !0; for (var e in this._layers) if (this._layers[e].hasTransition()) return !0; return !1 }, Qe.prototype._checkLoaded = function () { if (!this._loaded) throw new Error("Style is not done loading") }, Qe.prototype.update = function (t) { if (this._loaded) { if (this._changed) { var e, n, i = Object.keys(this._updatedLayers), r = Object.keys(this._removedLayers); for (e in (i.length || r.length) && this._updateWorkerLayers(i, r), this._updatedSources) { var o = this._updatedSources[e]; "reload" === o ? this._reloadSource(e) : "clear" === o && this._clearSource(e) } for (n in this._updatedPaintProps) this._layers[n].updateTransitions(t); this.light.updateTransitions(t), this._resetUpdates(), this.fire(new D.Event("data", { dataType: "style" })) } for (var a in this.sourceCaches) this.sourceCaches[a].used = !1; for (var s = 0, l = this._order; s < l.length; s += 1) { var u = l[s], u = this._layers[u]; u.recalculate(t), !u.isHidden(t.zoom) && u.source && (this.sourceCaches[u.source].used = !0) } this.light.recalculate(t), this.z = t.zoom } }, Qe.prototype._updateWorkerLayers = function (t, e) { this.dispatcher.broadcast("updateLayers", { layers: this._serializeLayers(t), removedIds: e }) }, Qe.prototype._resetUpdates = function () { this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {} }, Qe.prototype.setState = function (t) { var e = this; if (this._checkLoaded(), He(this, D.validateStyle(t))) return !1; (t = D.clone(t)).layers = re(t.layers); var n = he(this.serialize(), t).filter(function (t) { return !(t.command in Ye) }); if (0 === n.length) return !1; var i = n.filter(function (t) { return !(t.command in Je) }); if (0 < i.length) throw new Error("Unimplemented: " + i.map(function (t) { return t.command }).join(", ") + "."); return n.forEach(function (t) { "setTransition" !== t.command && e[t.command].apply(e, t.args) }), this.stylesheet = t, !0 }, Qe.prototype.addImage = function (t, e) { if (this.getImage(t)) return this.fire(new D.ErrorEvent(new Error("An image with this name already exists."))); this.imageManager.addImage(t, e), this.fire(new D.Event("data", { dataType: "style" })) }, Qe.prototype.getImage = function (t) { return this.imageManager.getImage(t) }, Qe.prototype.removeImage = function (t) { if (!this.getImage(t)) return this.fire(new D.ErrorEvent(new Error("No image with this name exists."))); this.imageManager.removeImage(t), this.fire(new D.Event("data", { dataType: "style" })) }, Qe.prototype.listImages = function () { return this._checkLoaded(), this.imageManager.listImages() }, Qe.prototype.addSource = function (t, e, n) { var i, r = this; if (this._checkLoaded(), void 0 !== this.sourceCaches[t]) throw new Error("There is already a source with this ID"); if (!e.type) throw new Error("The type property must be defined, but the only the following properties were given: " + Object.keys(e).join(", ") + "."); 0 <= ["vector", "raster", "geojson", "video", "image"].indexOf(e.type) && this._validate(D.validateStyle.source, "sources." + t, e, null, n) || (this.map && this.map._collectResourceTiming && (e.collectResourceTiming = !0), (i = this.sourceCaches[t] = new Jt(t, e, this.dispatcher)).style = this, i.setEventedParent(this, function () { return { isSourceLoaded: r.loaded(), source: i.serialize(), sourceId: t } }), i.onAdd(this.map), this._changed = !0) }, Qe.prototype.removeSource = function (t) { if (this._checkLoaded(), void 0 === this.sourceCaches[t]) throw new Error("There is no source with this ID"); for (var e in this._layers) if (this._layers[e].source === t) return this.fire(new D.ErrorEvent(new Error('Source "' + t + '" cannot be removed while layer "' + e + '" is using it.'))); var n = this.sourceCaches[t]; delete this.sourceCaches[t], delete this._updatedSources[t], n.fire(new D.Event("data", { sourceDataType: "metadata", dataType: "source", sourceId: t })), n.setEventedParent(null), n.clearTiles(), n.onRemove && n.onRemove(this.map), this._changed = !0 }, Qe.prototype.setGeoJSONSourceData = function (t, e) { this._checkLoaded(), this.sourceCaches[t].getSource().setData(e), this._changed = !0 }, Qe.prototype.getSource = function (t) { return this.sourceCaches[t] && this.sourceCaches[t].getSource() }, Qe.prototype.addLayer = function (t, e, n) { this._checkLoaded(); var i = t.id; this.getLayer(i) ? this.fire(new D.ErrorEvent(new Error('Layer with id "' + i + '" already exists on this map'))) : ("object" == typeof t.source && (this.addSource(i, t.source), t = D.clone(t), t = D.extend(t, { source: i })), this._validate(D.validateStyle.layer, "layers." + i, t, { arrayIndex: -1 }, n) || (n = D.createStyleLayer(t), this._validateLayer(n), n.setEventedParent(this, { layer: { id: i } }), t = e ? this._order.indexOf(e) : this._order.length, e && -1 === t ? this.fire(new D.ErrorEvent(new Error('Layer with id "' + e + '" does not exist on this map.'))) : (this._order.splice(t, 0, i), this._layerOrderChanged = !0, this._layers[i] = n, this._removedLayers[i] && n.source && (t = this._removedLayers[i], delete this._removedLayers[i], t.type !== n.type ? this._updatedSources[n.source] = "clear" : (this._updatedSources[n.source] = "reload", this.sourceCaches[n.source].pause())), this._updateLayer(n)))) }, Qe.prototype.moveLayer = function (t, e) { var n; this._checkLoaded(), this._changed = !0, this._layers[t] ? t !== e && (n = this._order.indexOf(t), this._order.splice(n, 1), n = e ? this._order.indexOf(e) : this._order.length, e && -1 === n ? this.fire(new D.ErrorEvent(new Error('Layer with id "' + e + '" does not exist on this map.'))) : (this._order.splice(n, 0, t), this._layerOrderChanged = !0)) : this.fire(new D.ErrorEvent(new Error("The layer '" + t + "' does not exist in the map's style and cannot be moved."))) }, Qe.prototype.removeLayer = function (t) { this._checkLoaded(); var e, n = this._layers[t]; n ? (n.setEventedParent(null), e = this._order.indexOf(t), this._order.splice(e, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[t] = n, delete this._layers[t], delete this._updatedLayers[t], delete this._updatedPaintProps[t]) : this.fire(new D.ErrorEvent(new Error("The layer '" + t + "' does not exist in the map's style and cannot be removed."))) }, Qe.prototype.getLayer = function (t) { return this._layers[t] }, Qe.prototype.setLayerZoomRange = function (t, e, n) { this._checkLoaded(); var i = this.getLayer(t); i ? i.minzoom === e && i.maxzoom === n || (null != e && (i.minzoom = e), null != n && (i.maxzoom = n), this._updateLayer(i)) : this.fire(new D.ErrorEvent(new Error("The layer '" + t + "' does not exist in the map's style and cannot have zoom extent."))) }, Qe.prototype.setFilter = function (t, e) { this._checkLoaded(); var n = this.getLayer(t); if (n) { if (!D.deepEqual(n.filter, e)) return null == e ? (n.filter = void 0, void this._updateLayer(n)) : void (this._validate(D.validateStyle.filter, "layers." + n.id + ".filter", e) || (n.filter = D.clone(e), this._updateLayer(n))) } else this.fire(new D.ErrorEvent(new Error("The layer '" + t + "' does not exist in the map's style and cannot be filtered."))) }, Qe.prototype.getFilter = function (t) { return D.clone(this.getLayer(t).filter) }, Qe.prototype.setLayoutProperty = function (t, e, n) { this._checkLoaded(); var i = this.getLayer(t); i ? D.deepEqual(i.getLayoutProperty(e), n) || (i.setLayoutProperty(e, n), this._updateLayer(i)) : this.fire(new D.ErrorEvent(new Error("The layer '" + t + "' does not exist in the map's style and cannot be styled."))) }, Qe.prototype.getLayoutProperty = function (t, e) { return this.getLayer(t).getLayoutProperty(e) }, Qe.prototype.setPaintProperty = function (t, e, n) { this._checkLoaded(); var i = this.getLayer(t); i ? D.deepEqual(i.getPaintProperty(e), n) || (i.setPaintProperty(e, n) && this._updateLayer(i), this._changed = !0, this._updatedPaintProps[t] = !0) : this.fire(new D.ErrorEvent(new Error("The layer '" + t + "' does not exist in the map's style and cannot be styled."))) }, Qe.prototype.getPaintProperty = function (t, e) { return this.getLayer(t).getPaintProperty(e) }, Qe.prototype.setFeatureState = function (t, e) { this._checkLoaded(); var n = t.source, i = t.sourceLayer, r = this.sourceCaches[n]; void 0 !== r ? "vector" !== r.getSource().type || i ? null != t.id && "" !== t.id ? r.setFeatureState(i, t.id, e) : this.fire(new D.ErrorEvent(new Error("The feature id parameter must be provided."))) : this.fire(new D.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types."))) : this.fire(new D.ErrorEvent(new Error("The source '" + n + "' does not exist in the map's style."))) }, Qe.prototype.getFeatureState = function (t) { this._checkLoaded(); var e = t.source, n = t.sourceLayer, i = this.sourceCaches[e]; if (void 0 !== i) { if ("vector" !== i.getSource().type || n) return i.getFeatureState(n, t.id); this.fire(new D.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types."))) } else this.fire(new D.ErrorEvent(new Error("The source '" + e + "' does not exist in the map's style."))) }, Qe.prototype.getTransition = function () { return D.extend({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition) }, Qe.prototype.serialize = function () { var e = this; return D.filterObject({ version: this.stylesheet.version, name: this.stylesheet.name, metadata: this.stylesheet.metadata, light: this.stylesheet.light, center: this.stylesheet.center, zoom: this.stylesheet.zoom, bearing: this.stylesheet.bearing, pitch: this.stylesheet.pitch, sprite: this.stylesheet.sprite, glyphs: this.stylesheet.glyphs, transition: this.stylesheet.transition, sources: D.mapObject(this.sourceCaches, function (t) { return t.serialize() }), layers: this._order.map(function (t) { return e._layers[t].serialize() }) }, function (t) { return void 0 !== t }) }, Qe.prototype._updateLayer = function (t) { this._updatedLayers[t.id] = !0, t.source && !this._updatedSources[t.source] && (this._updatedSources[t.source] = "reload", this.sourceCaches[t.source].pause()), this._changed = !0 }, Qe.prototype._flattenRenderedFeatures = function (t) { for (var e = [], n = this._order.length - 1; 0 <= n; n--)for (var i = this._order[n], r = 0, o = t; r < o.length; r += 1) { var a = o[r][i]; if (a) for (var s = 0, l = a; s < l.length; s += 1) { var u = l[s]; e.push(u) } } return e }, Qe.prototype.queryRenderedFeatures = function (d, t, e) { t && t.filter && this._validate(D.validateStyle.filter, "queryRenderedFeatures.filter", t.filter); var n = {}; if (t && t.layers) { if (!Array.isArray(t.layers)) return this.fire(new D.ErrorEvent(new Error("parameters.layers must be an Array."))), []; for (var i = 0, r = t.layers; i < r.length; i += 1) { var o = r[i], a = this._layers[o]; if (!a) return this.fire(new D.ErrorEvent(new Error("The layer '" + o + "' does not exist in the map's style and cannot be queried for features."))), []; n[a.source] = !0 } } var s, l = [], u = d.map(function (t) { return e.pointCoordinate(t) }); for (s in this.sourceCaches) t.layers && !n[s] || l.push(function (n, t, e, i, r) { var o = r.maxPitchScaleFactor(); (e = n.tilesIn(e, o)).sort(st); for (var d = [], a = 0, s = e; a < s.length; a += 1) { var l = s[a]; d.push({ wrappedTileID: l.tileID.wrapped().key, queryResults: l.tile.queryRenderedFeatures(t, n._state, l.queryGeometry, l.scale, i, r, o, n.transform.calculatePosMatrix(l.tileID.toUnwrapped())) }) } var u, c = function () { for (var t = {}, e = {}, n = 0, i = d; n < i.length; n += 1) { var r, o = i[n], a = o.queryResults, o = o.wrappedTileID, s = e[o] = e[o] || {}; for (r in a) for (var l = a[r], u = s[r] = s[r] || {}, c = t[r] = t[r] || [], h = 0, p = l; h < p.length; h += 1) { var f = p[h]; u[f.featureIndex] || (u[f.featureIndex] = !0, c.push(f.feature)) } } return t }(); for (u in c) c[u].forEach(function (t) { var e = n.getFeatureState(t.layer["source-layer"], t.id); t.source = t.layer.source, t.layer["source-layer"] && (t.sourceLayer = t.layer["source-layer"]), t.state = e }); return c }(this.sourceCaches[s], this._layers, u, t, e)); return this.placement && l.push(function (l, i, u, t, e) { for (var c = {}, h = t.queryRenderedSymbols(d), n = [], r = 0, o = Object.keys(h).map(Number); r < o.length; r += 1) { var a = o[r]; n.push(e[a]) } n.sort(st); for (var p = 0, f = n; p < f.length; p += 1)!function () { var t, r = f[p], e = r.featureIndex.lookupSymbolFeatures(h[r.bucketInstanceId], r.bucketIndex, r.sourceLayerIndex, u.filter, u.layers, l); for (t in e) { var n = c[t] = c[t] || [], i = e[t]; i.sort(function (t, e) { var n = r.featureSortOrder; if (n) { var i = n.indexOf(t.featureIndex); return n.indexOf(e.featureIndex) - i } return e.featureIndex - t.featureIndex }); for (var o = 0, a = i; o < a.length; o += 1) { var s = a[o]; n.push(s.feature) } } }(); for (var s in c) !function (n) { c[n].forEach(function (t) { var e = l[n], e = i[e.source].getFeatureState(t.layer["source-layer"], t.id); t.source = t.layer.source, t.layer["source-layer"] && (t.sourceLayer = t.layer["source-layer"]), t.state = e }) }(s); return c }(this._layers, this.sourceCaches, t, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenRenderedFeatures(l) }, Qe.prototype.querySourceFeatures = function (t, e) { e && e.filter && this._validate(D.validateStyle.filter, "querySourceFeatures.filter", e.filter); t = this.sourceCaches[t]; return t ? function (e, t) { for (var n = e.getRenderableIds().map(function (t) { return e.getTileByID(t) }), i = [], r = {}, o = 0; o < n.length; o++) { var a = n[o], s = a.tileID.canonical.key; r[s] || (r[s] = !0, a.querySourceFeatures(i, t)) } return i }(t, e) : [] }, Qe.prototype.addSourceType = function (t, e, n) { return Qe.getSourceType(t) ? n(new Error('A source type called "' + t + '" already exists.')) : (Qe.setSourceType(t, e), e.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", { name: t, url: e.workerSourceURL }, n) : n(null, null)) }, Qe.prototype.getLight = function () { return this.light.getLight() }, Qe.prototype.setLight = function (t) { this._checkLoaded(); var e, n, i = this.light.getLight(), r = !1; for (e in t) if (!D.deepEqual(t[e], i[e])) { r = !0; break } r && (n = { now: D.browser.now(), transition: D.extend({ duration: 300, delay: 0 }, this.stylesheet.transition) }, this.light.setLight(t), this.light.updateTransitions(n)) }, Qe.prototype._validate = function (t, e, n, i, r) { return (!r || !1 !== r.validate) && He(this, t.call(D.validateStyle, D.extend({ key: e, style: this.serialize(), value: n, styleSpec: D.styleSpec }, i))) }, Qe.prototype._remove = function () { for (var t in this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), D.evented.off("pluginAvailable", this._rtlTextPluginCallback), this.sourceCaches) this.sourceCaches[t].clearTiles(); this.dispatcher.remove() }, Qe.prototype._clearSource = function (t) { this.sourceCaches[t].clearTiles() }, Qe.prototype._reloadSource = function (t) { this.sourceCaches[t].resume(), this.sourceCaches[t].reload() }, Qe.prototype._updateSources = function (t) { for (var e in this.sourceCaches) this.sourceCaches[e].update(t) }, Qe.prototype._generateCollisionBoxes = function () { for (var t in this.sourceCaches) this._reloadSource(t) }, Qe.prototype._updatePlacement = function (t, e, n, i) { for (var r = !1, o = !1, a = {}, s = 0, l = this._order; s < l.length; s += 1) { var u, c = l[s], c = this._layers[c]; "symbol" === c.type && (a[c.source] || (u = this.sourceCaches[c.source], a[c.source] = u.getRenderableIds(!0).map(function (t) { return u.getTileByID(t) }).sort(function (t, e) { return e.tileID.overscaledZ - t.tileID.overscaledZ || (t.tileID.isLessThan(e.tileID) ? -1 : 1) })), c = this.crossTileSymbolIndex.addLayer(c, a[c.source], t.center.lng), r = r || c) } this.crossTileSymbolIndex.pruneUnusedLayers(this._order); var h = this._layerOrderChanged; if ((h || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(D.browser.now())) && (this.pauseablePlacement = new Ue(t, this._order, h, e, n, i), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, a), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(this.placement, D.browser.now()), o = !0), r && this.pauseablePlacement.placement.setStale()), o || r) for (var p = 0, f = this._order; p < f.length; p += 1) { var d = f[p], d = this._layers[d]; "symbol" === d.type && this.placement.updateLayerOpacities(d, a[d.source]) } return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(D.browser.now()) }, Qe.prototype._releaseSymbolFadeTiles = function () { for (var t in this.sourceCaches) this.sourceCaches[t].releaseSymbolFadeTiles() }, Qe.prototype.getImages = function (t, e, n) { this.imageManager.getImages(e.icons, n) }, Qe.prototype.getGlyphs = function (t, e, n) { this.glyphManager.getGlyphs(e.stacks, n) }, Qe); function Qe(t, e) { var r = this; void 0 === e && (e = {}), Ke.call(this), this.map = t, this.dispatcher = new O(ne = ne || new ie, this), this.imageManager = new E, this.glyphManager = new k(t._transformRequest, e.localIdeographFontFamily), this.lineAtlas = new R(256, 512), this.crossTileSymbolIndex = new We, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new D.ZoomHistory, this._loaded = !1, this._resetUpdates(); var n = this; this._rtlTextPluginCallback = Qe.registerForPluginAvailability(function (t) { for (var e in n.dispatcher.broadcast("loadRTLTextPlugin", t.pluginURL, t.completionCallback), n.sourceCaches) n.sourceCaches[e].reload() }), this.on("data", function (t) { if ("source" === t.dataType && "metadata" === t.sourceDataType) { t = r.sourceCaches[t.sourceId]; if (t) { var e = t.getSource(); if (e && e.vectorLayerIds) for (var n in r._layers) { var i = r._layers[n]; i.source === e.id && r._validateLayer(i) } } } }) } $e.getSourceType = function (t) { return it[t] }, $e.setSourceType = function (t, e) { it[t] = e }, $e.registerForPluginAvailability = D.registerForPluginAvailability; var tn, en = D.createLayout([{ name: "a_pos", type: "Int16", components: 2 }]), nn = { prelude: { fragmentSource: "#ifdef GL_ES\nprecision mediump float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif\n", vertexSource: "#ifdef GL_ES\nprecision highp float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif\n\n// Unpack a pair of values that have been packed into a single float.\n// The packed values are assumed to be 8-bit unsigned integers, and are\n// packed like so:\n// packedValue = floor(input[0]) * 256 + input[1],\nvec2 unpack_float(const float packedValue) {\n    int packedIntValue = int(packedValue);\n    int v0 = packedIntValue / 256;\n    return vec2(v0, packedIntValue - v0 * 256);\n}\n\nvec2 unpack_opacity(const float packedOpacity) {\n    int intOpacity = int(packedOpacity) / 2;\n    return vec2(float(intOpacity) / 127.0, mod(packedOpacity, 2.0));\n}\n\n// To minimize the number of attributes needed, we encode a 4-component\n// color into a pair of floats (i.e. a vec2) as follows:\n// [ floor(color.r * 255) * 256 + color.g * 255,\n//   floor(color.b * 255) * 256 + color.g * 255 ]\nvec4 decode_color(const vec2 encodedColor) {\n    return vec4(\n        unpack_float(encodedColor[0]) / 255.0,\n        unpack_float(encodedColor[1]) / 255.0\n    );\n}\n\n// Unpack a pair of paint values and interpolate between them.\nfloat unpack_mix_vec2(const vec2 packedValue, const float t) {\n    return mix(packedValue[0], packedValue[1], t);\n}\n\n// Unpack a pair of paint values and interpolate between them.\nvec4 unpack_mix_vec4(const vec4 packedColors, const float t) {\n    vec4 minColor = decode_color(vec2(packedColors[0], packedColors[1]));\n    vec4 maxColor = decode_color(vec2(packedColors[2], packedColors[3]));\n    return mix(minColor, maxColor, t);\n}\n\n// The offset depends on how many pixels are between the world origin and the edge of the tile:\n// vec2 offset = mod(pixel_coord, size)\n//\n// At high zoom levels there are a ton of pixels between the world origin and the edge of the tile.\n// The glsl spec only guarantees 16 bits of precision for highp floats. We need more than that.\n//\n// The pixel_coord is passed in as two 16 bit values:\n// pixel_coord_upper = floor(pixel_coord / 2^16)\n// pixel_coord_lower = mod(pixel_coord, 2^16)\n//\n// The offset is calculated in a series of steps that should preserve this precision:\nvec2 get_pattern_pos(const vec2 pixel_coord_upper, const vec2 pixel_coord_lower,\n    const vec2 pattern_size, const float tile_units_to_pixels, const vec2 pos) {\n\n    vec2 offset = mod(mod(mod(pixel_coord_upper, pattern_size) * 256.0, pattern_size) * 256.0 + pixel_coord_lower, pattern_size);\n    return (tile_units_to_pixels * pos + offset) / pattern_size;\n}\n" }, background: { fragmentSource: "uniform vec4 u_color;\nuniform float u_opacity;\n\nvoid main() {\n    gl_FragColor = u_color * u_opacity;\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n", vertexSource: "attribute vec2 a_pos;\n\nuniform mat4 u_matrix;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n}\n" }, backgroundPattern: { fragmentSource: "uniform vec2 u_pattern_tl_a;\nuniform vec2 u_pattern_br_a;\nuniform vec2 u_pattern_tl_b;\nuniform vec2 u_pattern_br_b;\nuniform vec2 u_texsize;\nuniform float u_mix;\nuniform float u_opacity;\n\nuniform sampler2D u_image;\n\nvarying vec2 v_pos_a;\nvarying vec2 v_pos_b;\n\nvoid main() {\n    vec2 imagecoord = mod(v_pos_a, 1.0);\n    vec2 pos = mix(u_pattern_tl_a / u_texsize, u_pattern_br_a / u_texsize, imagecoord);\n    vec4 color1 = texture2D(u_image, pos);\n\n    vec2 imagecoord_b = mod(v_pos_b, 1.0);\n    vec2 pos2 = mix(u_pattern_tl_b / u_texsize, u_pattern_br_b / u_texsize, imagecoord_b);\n    vec4 color2 = texture2D(u_image, pos2);\n\n    gl_FragColor = mix(color1, color2, u_mix) * u_opacity;\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n", vertexSource: "uniform mat4 u_matrix;\nuniform vec2 u_pattern_size_a;\nuniform vec2 u_pattern_size_b;\nuniform vec2 u_pixel_coord_upper;\nuniform vec2 u_pixel_coord_lower;\nuniform float u_scale_a;\nuniform float u_scale_b;\nuniform float u_tile_units_to_pixels;\n\nattribute vec2 a_pos;\n\nvarying vec2 v_pos_a;\nvarying vec2 v_pos_b;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n\n    v_pos_a = get_pattern_pos(u_pixel_coord_upper, u_pixel_coord_lower, u_scale_a * u_pattern_size_a, u_tile_units_to_pixels, a_pos);\n    v_pos_b = get_pattern_pos(u_pixel_coord_upper, u_pixel_coord_lower, u_scale_b * u_pattern_size_b, u_tile_units_to_pixels, a_pos);\n}\n" }, circle: { fragmentSource: "#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\n\nvarying vec3 v_data;\n\nvoid main() {\n    #pragma mapbox: initialize highp vec4 color\n    #pragma mapbox: initialize mediump float radius\n    #pragma mapbox: initialize lowp float blur\n    #pragma mapbox: initialize lowp float opacity\n    #pragma mapbox: initialize highp vec4 stroke_color\n    #pragma mapbox: initialize mediump float stroke_width\n    #pragma mapbox: initialize lowp float stroke_opacity\n\n    vec2 extrude = v_data.xy;\n    float extrude_length = length(extrude);\n\n    lowp float antialiasblur = v_data.z;\n    float antialiased_blur = -max(blur, antialiasblur);\n\n    float opacity_t = smoothstep(0.0, antialiased_blur, extrude_length - 1.0);\n\n    float color_t = stroke_width < 0.01 ? 0.0 : smoothstep(\n        antialiased_blur,\n        0.0,\n        extrude_length - radius / (radius + stroke_width)\n    );\n\n    gl_FragColor = opacity_t * mix(color * opacity, stroke_color * stroke_opacity, color_t);\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n", vertexSource: "uniform mat4 u_matrix;\nuniform bool u_scale_with_map;\nuniform bool u_pitch_with_map;\nuniform vec2 u_extrude_scale;\nuniform highp float u_camera_to_center_distance;\n\nattribute vec2 a_pos;\n\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\n\nvarying vec3 v_data;\n\nvoid main(void) {\n    #pragma mapbox: initialize highp vec4 color\n    #pragma mapbox: initialize mediump float radius\n    #pragma mapbox: initialize lowp float blur\n    #pragma mapbox: initialize lowp float opacity\n    #pragma mapbox: initialize highp vec4 stroke_color\n    #pragma mapbox: initialize mediump float stroke_width\n    #pragma mapbox: initialize lowp float stroke_opacity\n\n    // unencode the extrusion vector that we snuck into the a_pos vector\n    vec2 extrude = vec2(mod(a_pos, 2.0) * 2.0 - 1.0);\n\n    // multiply a_pos by 0.5, since we had it * 2 in order to sneak\n    // in extrusion data\n    vec2 circle_center = floor(a_pos * 0.5);\n    if (u_pitch_with_map) {\n        vec2 corner_position = circle_center;\n        if (u_scale_with_map) {\n            corner_position += extrude * (radius + stroke_width) * u_extrude_scale;\n        } else {\n            // Pitching the circle with the map effectively scales it with the map\n            // To counteract the effect for pitch-scale: viewport, we rescale the\n            // whole circle based on the pitch scaling effect at its central point\n            vec4 projected_center = u_matrix * vec4(circle_center, 0, 1);\n            corner_position += extrude * (radius + stroke_width) * u_extrude_scale * (projected_center.w / u_camera_to_center_distance);\n        }\n\n        gl_Position = u_matrix * vec4(corner_position, 0, 1);\n    } else {\n        gl_Position = u_matrix * vec4(circle_center, 0, 1);\n\n        if (u_scale_with_map) {\n            gl_Position.xy += extrude * (radius + stroke_width) * u_extrude_scale * u_camera_to_center_distance;\n        } else {\n            gl_Position.xy += extrude * (radius + stroke_width) * u_extrude_scale * gl_Position.w;\n        }\n    }\n\n    // This is a minimum blur distance that serves as a faux-antialiasing for\n    // the circle. since blur is a ratio of the circle's size and the intent is\n    // to keep the blur at roughly 1px, the two are inversely related.\n    lowp float antialiasblur = 1.0 / DEVICE_PIXEL_RATIO / (radius + stroke_width);\n\n    v_data = vec3(extrude.x, extrude.y, antialiasblur);\n}\n" }, clippingMask: { fragmentSource: "void main() {\n    gl_FragColor = vec4(1.0);\n}\n", vertexSource: "attribute vec2 a_pos;\n\nuniform mat4 u_matrix;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n}\n" }, heatmap: { fragmentSource: "#pragma mapbox: define highp float weight\n\nuniform highp float u_intensity;\nvarying vec2 v_extrude;\n\n// Gaussian kernel coefficient: 1 / sqrt(2 * PI)\n#define GAUSS_COEF 0.3989422804014327\n\nvoid main() {\n    #pragma mapbox: initialize highp float weight\n\n    // Kernel density estimation with a Gaussian kernel of size 5x5\n    float d = -0.5 * 3.0 * 3.0 * dot(v_extrude, v_extrude);\n    float val = weight * u_intensity * GAUSS_COEF * exp(d);\n\n    gl_FragColor = vec4(val, 1.0, 1.0, 1.0);\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n", vertexSource: "#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\n\nuniform mat4 u_matrix;\nuniform float u_extrude_scale;\nuniform float u_opacity;\nuniform float u_intensity;\n\nattribute vec2 a_pos;\n\nvarying vec2 v_extrude;\n\n// Effective \"0\" in the kernel density texture to adjust the kernel size to;\n// this empirically chosen number minimizes artifacts on overlapping kernels\n// for typical heatmap cases (assuming clustered source)\nconst highp float ZERO = 1.0 / 255.0 / 16.0;\n\n// Gaussian kernel coefficient: 1 / sqrt(2 * PI)\n#define GAUSS_COEF 0.3989422804014327\n\nvoid main(void) {\n    #pragma mapbox: initialize highp float weight\n    #pragma mapbox: initialize mediump float radius\n\n    // unencode the extrusion vector that we snuck into the a_pos vector\n    vec2 unscaled_extrude = vec2(mod(a_pos, 2.0) * 2.0 - 1.0);\n\n    // This 'extrude' comes in ranging from [-1, -1], to [1, 1].  We'll use\n    // it to produce the vertices of a square mesh framing the point feature\n    // we're adding to the kernel density texture.  We'll also pass it as\n    // a varying, so that the fragment shader can determine the distance of\n    // each fragment from the point feature.\n    // Before we do so, we need to scale it up sufficiently so that the\n    // kernel falls effectively to zero at the edge of the mesh.\n    // That is, we want to know S such that\n    // weight * u_intensity * GAUSS_COEF * exp(-0.5 * 3.0^2 * S^2) == ZERO\n    // Which solves to:\n    // S = sqrt(-2.0 * log(ZERO / (weight * u_intensity * GAUSS_COEF))) / 3.0\n    float S = sqrt(-2.0 * log(ZERO / weight / u_intensity / GAUSS_COEF)) / 3.0;\n\n    // Pass the varying in units of radius\n    v_extrude = S * unscaled_extrude;\n\n    // Scale by radius and the zoom-based scale factor to produce actual\n    // mesh position\n    vec2 extrude = v_extrude * radius * u_extrude_scale;\n\n    // multiply a_pos by 0.5, since we had it * 2 in order to sneak\n    // in extrusion data\n    vec4 pos = vec4(floor(a_pos * 0.5) + extrude, 0, 1);\n\n    gl_Position = u_matrix * pos;\n}\n" }, heatmapTexture: { fragmentSource: "uniform sampler2D u_image;\nuniform sampler2D u_color_ramp;\nuniform float u_opacity;\nvarying vec2 v_pos;\n\nvoid main() {\n    float t = texture2D(u_image, v_pos).r;\n    vec4 color = texture2D(u_color_ramp, vec2(t, 0.5));\n    gl_FragColor = color * u_opacity;\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(0.0);\n#endif\n}\n", vertexSource: "uniform mat4 u_matrix;\nuniform vec2 u_world;\nattribute vec2 a_pos;\nvarying vec2 v_pos;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos * u_world, 0, 1);\n\n    v_pos.x = a_pos.x;\n    v_pos.y = 1.0 - a_pos.y;\n}\n" }, collisionBox: { fragmentSource: "\nvarying float v_placed;\nvarying float v_notUsed;\n\nvoid main() {\n\n    float alpha = 0.5;\n\n    // Red = collision, hide label\n    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0) * alpha;\n\n    // Blue = no collision, label is showing\n    if (v_placed > 0.5) {\n        gl_FragColor = vec4(0.0, 0.0, 1.0, 0.5) * alpha;\n    }\n\n    if (v_notUsed > 0.5) {\n        // This box not used, fade it out\n        gl_FragColor *= .1;\n    }\n}", vertexSource: "attribute vec2 a_pos;\nattribute vec2 a_anchor_pos;\nattribute vec2 a_extrude;\nattribute vec2 a_placed;\n\nuniform mat4 u_matrix;\nuniform vec2 u_extrude_scale;\nuniform float u_camera_to_center_distance;\n\nvarying float v_placed;\nvarying float v_notUsed;\n\nvoid main() {\n    vec4 projectedPoint = u_matrix * vec4(a_anchor_pos, 0, 1);\n    highp float camera_to_anchor_distance = projectedPoint.w;\n    highp float collision_perspective_ratio = clamp(\n        0.5 + 0.5 * (u_camera_to_center_distance / camera_to_anchor_distance),\n        0.0, // Prevents oversized near-field boxes in pitched/overzoomed tiles\n        4.0);\n\n    gl_Position = u_matrix * vec4(a_pos, 0.0, 1.0);\n    gl_Position.xy += a_extrude * u_extrude_scale * gl_Position.w * collision_perspective_ratio;\n\n    v_placed = a_placed.x;\n    v_notUsed = a_placed.y;\n}\n" }, collisionCircle: { fragmentSource: "uniform float u_overscale_factor;\n\nvarying float v_placed;\nvarying float v_notUsed;\nvarying float v_radius;\nvarying vec2 v_extrude;\nvarying vec2 v_extrude_scale;\n\nvoid main() {\n    float alpha = 0.5;\n\n    // Red = collision, hide label\n    vec4 color = vec4(1.0, 0.0, 0.0, 1.0) * alpha;\n\n    // Blue = no collision, label is showing\n    if (v_placed > 0.5) {\n        color = vec4(0.0, 0.0, 1.0, 0.5) * alpha;\n    }\n\n    if (v_notUsed > 0.5) {\n        // This box not used, fade it out\n        color *= .2;\n    }\n\n    float extrude_scale_length = length(v_extrude_scale);\n    float extrude_length = length(v_extrude) * extrude_scale_length;\n    float stroke_width = 15.0 * extrude_scale_length / u_overscale_factor;\n    float radius = v_radius * extrude_scale_length;\n\n    float distance_to_edge = abs(extrude_length - radius);\n    float opacity_t = smoothstep(-stroke_width, 0.0, -distance_to_edge);\n\n    gl_FragColor = opacity_t * color;\n}\n", vertexSource: "attribute vec2 a_pos;\nattribute vec2 a_anchor_pos;\nattribute vec2 a_extrude;\nattribute vec2 a_placed;\n\nuniform mat4 u_matrix;\nuniform vec2 u_extrude_scale;\nuniform float u_camera_to_center_distance;\n\nvarying float v_placed;\nvarying float v_notUsed;\nvarying float v_radius;\n\nvarying vec2 v_extrude;\nvarying vec2 v_extrude_scale;\n\nvoid main() {\n    vec4 projectedPoint = u_matrix * vec4(a_anchor_pos, 0, 1);\n    highp float camera_to_anchor_distance = projectedPoint.w;\n    highp float collision_perspective_ratio = clamp(\n        0.5 + 0.5 * (u_camera_to_center_distance / camera_to_anchor_distance),\n        0.0, // Prevents oversized near-field circles in pitched/overzoomed tiles\n        4.0);\n\n    gl_Position = u_matrix * vec4(a_pos, 0.0, 1.0);\n\n    highp float padding_factor = 1.2; // Pad the vertices slightly to make room for anti-alias blur\n    gl_Position.xy += a_extrude * u_extrude_scale * padding_factor * gl_Position.w * collision_perspective_ratio;\n\n    v_placed = a_placed.x;\n    v_notUsed = a_placed.y;\n    v_radius = abs(a_extrude.y); // We don't pitch the circles, so both units of the extrusion vector are equal in magnitude to the radius\n\n    v_extrude = a_extrude * padding_factor;\n    v_extrude_scale = u_extrude_scale * u_camera_to_center_distance * collision_perspective_ratio;\n}\n" }, debug: { fragmentSource: "uniform highp vec4 u_color;\n\nvoid main() {\n    gl_FragColor = u_color;\n}\n", vertexSource: "attribute vec2 a_pos;\n\nuniform mat4 u_matrix;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n}\n" }, fill: { fragmentSource: "#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\n\nvoid main() {\n    #pragma mapbox: initialize highp vec4 color\n    #pragma mapbox: initialize lowp float opacity\n\n    gl_FragColor = color * opacity;\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n", vertexSource: "attribute vec2 a_pos;\n\nuniform mat4 u_matrix;\n\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\n\nvoid main() {\n    #pragma mapbox: initialize highp vec4 color\n    #pragma mapbox: initialize lowp float opacity\n\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n}\n" }, fillOutline: { fragmentSource: "#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\n\nvarying vec2 v_pos;\n\nvoid main() {\n    #pragma mapbox: initialize highp vec4 outline_color\n    #pragma mapbox: initialize lowp float opacity\n\n    float dist = length(v_pos - gl_FragCoord.xy);\n    float alpha = 1.0 - smoothstep(0.0, 1.0, dist);\n    gl_FragColor = outline_color * (alpha * opacity);\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n", vertexSource: "attribute vec2 a_pos;\n\nuniform mat4 u_matrix;\nuniform vec2 u_world;\n\nvarying vec2 v_pos;\n\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\n\nvoid main() {\n    #pragma mapbox: initialize highp vec4 outline_color\n    #pragma mapbox: initialize lowp float opacity\n\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n    v_pos = (gl_Position.xy / gl_Position.w + 1.0) / 2.0 * u_world;\n}\n" }, fillOutlinePattern: { fragmentSource: "uniform vec2 u_pattern_tl_a;\nuniform vec2 u_pattern_br_a;\nuniform vec2 u_pattern_tl_b;\nuniform vec2 u_pattern_br_b;\nuniform vec2 u_texsize;\nuniform float u_mix;\n\nuniform sampler2D u_image;\n\nvarying vec2 v_pos_a;\nvarying vec2 v_pos_b;\nvarying vec2 v_pos;\n\n#pragma mapbox: define lowp float opacity\n\nvoid main() {\n    #pragma mapbox: initialize lowp float opacity\n\n    vec2 imagecoord = mod(v_pos_a, 1.0);\n    vec2 pos = mix(u_pattern_tl_a / u_texsize, u_pattern_br_a / u_texsize, imagecoord);\n    vec4 color1 = texture2D(u_image, pos);\n\n    vec2 imagecoord_b = mod(v_pos_b, 1.0);\n    vec2 pos2 = mix(u_pattern_tl_b / u_texsize, u_pattern_br_b / u_texsize, imagecoord_b);\n    vec4 color2 = texture2D(u_image, pos2);\n\n    // find distance to outline for alpha interpolation\n\n    float dist = length(v_pos - gl_FragCoord.xy);\n    float alpha = 1.0 - smoothstep(0.0, 1.0, dist);\n\n\n    gl_FragColor = mix(color1, color2, u_mix) * alpha * opacity;\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n", vertexSource: "uniform mat4 u_matrix;\nuniform vec2 u_world;\nuniform vec2 u_pattern_size_a;\nuniform vec2 u_pattern_size_b;\nuniform vec2 u_pixel_coord_upper;\nuniform vec2 u_pixel_coord_lower;\nuniform float u_scale_a;\nuniform float u_scale_b;\nuniform float u_tile_units_to_pixels;\n\nattribute vec2 a_pos;\n\nvarying vec2 v_pos_a;\nvarying vec2 v_pos_b;\nvarying vec2 v_pos;\n\n#pragma mapbox: define lowp float opacity\n\nvoid main() {\n    #pragma mapbox: initialize lowp float opacity\n\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n\n    v_pos_a = get_pattern_pos(u_pixel_coord_upper, u_pixel_coord_lower, u_scale_a * u_pattern_size_a, u_tile_units_to_pixels, a_pos);\n    v_pos_b = get_pattern_pos(u_pixel_coord_upper, u_pixel_coord_lower, u_scale_b * u_pattern_size_b, u_tile_units_to_pixels, a_pos);\n\n    v_pos = (gl_Position.xy / gl_Position.w + 1.0) / 2.0 * u_world;\n}\n" }, fillPattern: { fragmentSource: "uniform vec2 u_pattern_tl_a;\nuniform vec2 u_pattern_br_a;\nuniform vec2 u_pattern_tl_b;\nuniform vec2 u_pattern_br_b;\nuniform vec2 u_texsize;\nuniform float u_mix;\n\nuniform sampler2D u_image;\n\nvarying vec2 v_pos_a;\nvarying vec2 v_pos_b;\n\n#pragma mapbox: define lowp float opacity\n\nvoid main() {\n    #pragma mapbox: initialize lowp float opacity\n\n    vec2 imagecoord = mod(v_pos_a, 1.0);\n    vec2 pos = mix(u_pattern_tl_a / u_texsize, u_pattern_br_a / u_texsize, imagecoord);\n    vec4 color1 = texture2D(u_image, pos);\n\n    vec2 imagecoord_b = mod(v_pos_b, 1.0);\n    vec2 pos2 = mix(u_pattern_tl_b / u_texsize, u_pattern_br_b / u_texsize, imagecoord_b);\n    vec4 color2 = texture2D(u_image, pos2);\n\n    gl_FragColor = mix(color1, color2, u_mix) * opacity;\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n", vertexSource: "uniform mat4 u_matrix;\nuniform vec2 u_pattern_size_a;\nuniform vec2 u_pattern_size_b;\nuniform vec2 u_pixel_coord_upper;\nuniform vec2 u_pixel_coord_lower;\nuniform float u_scale_a;\nuniform float u_scale_b;\nuniform float u_tile_units_to_pixels;\n\nattribute vec2 a_pos;\n\nvarying vec2 v_pos_a;\nvarying vec2 v_pos_b;\n\n#pragma mapbox: define lowp float opacity\n\nvoid main() {\n    #pragma mapbox: initialize lowp float opacity\n\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n\n    v_pos_a = get_pattern_pos(u_pixel_coord_upper, u_pixel_coord_lower, u_scale_a * u_pattern_size_a, u_tile_units_to_pixels, a_pos);\n    v_pos_b = get_pattern_pos(u_pixel_coord_upper, u_pixel_coord_lower, u_scale_b * u_pattern_size_b, u_tile_units_to_pixels, a_pos);\n}\n" }, fillExtrusion: { fragmentSource: "varying vec4 v_color;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define highp vec4 color\n\nvoid main() {\n    #pragma mapbox: initialize lowp float base\n    #pragma mapbox: initialize lowp float height\n    #pragma mapbox: initialize highp vec4 color\n\n    gl_FragColor = v_color;\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n", vertexSource: "uniform mat4 u_matrix;\nuniform vec3 u_lightcolor;\nuniform lowp vec3 u_lightpos;\nuniform lowp float u_lightintensity;\n\nattribute vec2 a_pos;\nattribute vec4 a_normal_ed;\n\nvarying vec4 v_color;\n\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n\n#pragma mapbox: define highp vec4 color\n\nvoid main() {\n    #pragma mapbox: initialize lowp float base\n    #pragma mapbox: initialize lowp float height\n    #pragma mapbox: initialize highp vec4 color\n\n    vec3 normal = a_normal_ed.xyz;\n\n    base = max(0.0, base);\n    height = max(0.0, height);\n\n    float t = mod(normal.x, 2.0);\n\n    gl_Position = u_matrix * vec4(a_pos, t > 0.0 ? height : base, 1);\n\n    // Relative luminance (how dark/bright is the surface color?)\n    float colorvalue = color.r * 0.2126 + color.g * 0.7152 + color.b * 0.0722;\n\n    v_color = vec4(0.0, 0.0, 0.0, 1.0);\n\n    // Add slight ambient lighting so no extrusions are totally black\n    vec4 ambientlight = vec4(0.03, 0.03, 0.03, 1.0);\n    color += ambientlight;\n\n    // Calculate cos(theta), where theta is the angle between surface normal and diffuse light ray\n    float directional = clamp(dot(normal / 16384.0, u_lightpos), 0.0, 1.0);\n\n    // Adjust directional so that\n    // the range of values for highlight/shading is narrower\n    // with lower light intensity\n    // and with lighter/brighter surface colors\n    directional = mix((1.0 - u_lightintensity), max((1.0 - colorvalue + u_lightintensity), 1.0), directional);\n\n    // Add gradient along z axis of side surfaces\n    if (normal.y != 0.0) {\n        directional *= clamp((t + base) * pow(height / 150.0, 0.5), mix(0.7, 0.98, 1.0 - u_lightintensity), 1.0);\n    }\n\n    // Assign final color based on surface + ambient light color, diffuse light directional, and light color\n    // with lower bounds adjusted to hue of light\n    // so that shading is tinted with the complementary (opposite) color to the light color\n    v_color.r += clamp(color.r * directional * u_lightcolor.r, mix(0.0, 0.3, 1.0 - u_lightcolor.r), 1.0);\n    v_color.g += clamp(color.g * directional * u_lightcolor.g, mix(0.0, 0.3, 1.0 - u_lightcolor.g), 1.0);\n    v_color.b += clamp(color.b * directional * u_lightcolor.b, mix(0.0, 0.3, 1.0 - u_lightcolor.b), 1.0);\n}\n" }, fillExtrusionPattern: { fragmentSource: "uniform vec2 u_pattern_tl_a;\nuniform vec2 u_pattern_br_a;\nuniform vec2 u_pattern_tl_b;\nuniform vec2 u_pattern_br_b;\nuniform vec2 u_texsize;\nuniform float u_mix;\n\nuniform sampler2D u_image;\n\nvarying vec2 v_pos_a;\nvarying vec2 v_pos_b;\nvarying vec4 v_lighting;\n\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n\nvoid main() {\n    #pragma mapbox: initialize lowp float base\n    #pragma mapbox: initialize lowp float height\n\n    vec2 imagecoord = mod(v_pos_a, 1.0);\n    vec2 pos = mix(u_pattern_tl_a / u_texsize, u_pattern_br_a / u_texsize, imagecoord);\n    vec4 color1 = texture2D(u_image, pos);\n\n    vec2 imagecoord_b = mod(v_pos_b, 1.0);\n    vec2 pos2 = mix(u_pattern_tl_b / u_texsize, u_pattern_br_b / u_texsize, imagecoord_b);\n    vec4 color2 = texture2D(u_image, pos2);\n\n    vec4 mixedColor = mix(color1, color2, u_mix);\n\n    gl_FragColor = mixedColor * v_lighting;\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n", vertexSource: "uniform mat4 u_matrix;\nuniform vec2 u_pattern_size_a;\nuniform vec2 u_pattern_size_b;\nuniform vec2 u_pixel_coord_upper;\nuniform vec2 u_pixel_coord_lower;\nuniform float u_scale_a;\nuniform float u_scale_b;\nuniform float u_tile_units_to_pixels;\nuniform float u_height_factor;\n\nuniform vec3 u_lightcolor;\nuniform lowp vec3 u_lightpos;\nuniform lowp float u_lightintensity;\n\nattribute vec2 a_pos;\nattribute vec4 a_normal_ed;\n\nvarying vec2 v_pos_a;\nvarying vec2 v_pos_b;\nvarying vec4 v_lighting;\nvarying float v_directional;\n\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n\nvoid main() {\n    #pragma mapbox: initialize lowp float base\n    #pragma mapbox: initialize lowp float height\n\n    vec3 normal = a_normal_ed.xyz;\n    float edgedistance = a_normal_ed.w;\n\n    base = max(0.0, base);\n    height = max(0.0, height);\n\n    float t = mod(normal.x, 2.0);\n    float z = t > 0.0 ? height : base;\n\n    gl_Position = u_matrix * vec4(a_pos, z, 1);\n\n    vec2 pos = normal.x == 1.0 && normal.y == 0.0 && normal.z == 16384.0\n        ? a_pos // extrusion top\n        : vec2(edgedistance, z * u_height_factor); // extrusion side\n\n    v_pos_a = get_pattern_pos(u_pixel_coord_upper, u_pixel_coord_lower, u_scale_a * u_pattern_size_a, u_tile_units_to_pixels, pos);\n    v_pos_b = get_pattern_pos(u_pixel_coord_upper, u_pixel_coord_lower, u_scale_b * u_pattern_size_b, u_tile_units_to_pixels, pos);\n\n    v_lighting = vec4(0.0, 0.0, 0.0, 1.0);\n    float directional = clamp(dot(normal / 16383.0, u_lightpos), 0.0, 1.0);\n    directional = mix((1.0 - u_lightintensity), max((0.5 + u_lightintensity), 1.0), directional);\n\n    if (normal.y != 0.0) {\n        directional *= clamp((t + base) * pow(height / 150.0, 0.5), mix(0.7, 0.98, 1.0 - u_lightintensity), 1.0);\n    }\n\n    v_lighting.rgb += clamp(directional * u_lightcolor, mix(vec3(0.0), vec3(0.3), 1.0 - u_lightcolor), vec3(1.0));\n}\n" }, extrusionTexture: { fragmentSource: "uniform sampler2D u_image;\nuniform float u_opacity;\nvarying vec2 v_pos;\n\nvoid main() {\n    gl_FragColor = texture2D(u_image, v_pos) * u_opacity;\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(0.0);\n#endif\n}\n", vertexSource: "uniform mat4 u_matrix;\nuniform vec2 u_world;\nattribute vec2 a_pos;\nvarying vec2 v_pos;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos * u_world, 0, 1);\n\n    v_pos.x = a_pos.x;\n    v_pos.y = 1.0 - a_pos.y;\n}\n" }, hillshadePrepare: { fragmentSource: "#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform sampler2D u_image;\nvarying vec2 v_pos;\nuniform vec2 u_dimension;\nuniform float u_zoom;\nuniform float u_maxzoom;\n\nfloat getElevation(vec2 coord, float bias) {\n    // Convert encoded elevation value to meters\n    vec4 data = texture2D(u_image, coord) * 255.0;\n    return (data.r + data.g * 256.0 + data.b * 256.0 * 256.0) / 4.0;\n}\n\nvoid main() {\n    vec2 epsilon = 1.0 / u_dimension;\n\n    // queried pixels:\n    // +-----------+\n    // |   |   |   |\n    // | a | b | c |\n    // |   |   |   |\n    // +-----------+\n    // |   |   |   |\n    // | d | e | f |\n    // |   |   |   |\n    // +-----------+\n    // |   |   |   |\n    // | g | h | i |\n    // |   |   |   |\n    // +-----------+\n\n    float a = getElevation(v_pos + vec2(-epsilon.x, -epsilon.y), 0.0);\n    float b = getElevation(v_pos + vec2(0, -epsilon.y), 0.0);\n    float c = getElevation(v_pos + vec2(epsilon.x, -epsilon.y), 0.0);\n    float d = getElevation(v_pos + vec2(-epsilon.x, 0), 0.0);\n    float e = getElevation(v_pos, 0.0);\n    float f = getElevation(v_pos + vec2(epsilon.x, 0), 0.0);\n    float g = getElevation(v_pos + vec2(-epsilon.x, epsilon.y), 0.0);\n    float h = getElevation(v_pos + vec2(0, epsilon.y), 0.0);\n    float i = getElevation(v_pos + vec2(epsilon.x, epsilon.y), 0.0);\n\n    // here we divide the x and y slopes by 8 * pixel size\n    // where pixel size (aka meters/pixel) is:\n    // circumference of the world / (pixels per tile * number of tiles)\n    // which is equivalent to: 8 * 40075016.6855785 / (512 * pow(2, u_zoom))\n    // which can be reduced to: pow(2, 19.25619978527 - u_zoom)\n    // we want to vertically exaggerate the hillshading though, because otherwise\n    // it is barely noticeable at low zooms. to do this, we multiply this by some\n    // scale factor pow(2, (u_zoom - u_maxzoom) * a) where a is an arbitrary value\n    // Here we use a=0.3 which works out to the expression below. see \n    // nickidlugash's awesome breakdown for more info\n    // https://github.com/mapbox/mapbox-gl-js/pull/5286#discussion_r148419556\n    float exaggeration = u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;\n\n    vec2 deriv = vec2(\n        (c + f + f + i) - (a + d + d + g),\n        (g + h + h + i) - (a + b + b + c)\n    ) /  pow(2.0, (u_zoom - u_maxzoom) * exaggeration + 19.2562 - u_zoom);\n\n    gl_FragColor = clamp(vec4(\n        deriv.x / 2.0 + 0.5,\n        deriv.y / 2.0 + 0.5,\n        1.0,\n        1.0), 0.0, 1.0);\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n", vertexSource: "uniform mat4 u_matrix;\n\nattribute vec2 a_pos;\nattribute vec2 a_texture_pos;\n\nvarying vec2 v_pos;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n    v_pos = (a_texture_pos / 8192.0) / 2.0 + 0.25;\n}\n" }, hillshade: { fragmentSource: "uniform sampler2D u_image;\nvarying vec2 v_pos;\n\nuniform vec2 u_latrange;\nuniform vec2 u_light;\nuniform vec4 u_shadow;\nuniform vec4 u_highlight;\nuniform vec4 u_accent;\n\n#define PI 3.141592653589793\n\nvoid main() {\n    vec4 pixel = texture2D(u_image, v_pos);\n\n    vec2 deriv = ((pixel.rg * 2.0) - 1.0);\n\n    // We divide the slope by a scale factor based on the cosin of the pixel's approximate latitude\n    // to account for mercator projection distortion. see #4807 for details\n    float scaleFactor = cos(radians((u_latrange[0] - u_latrange[1]) * (1.0 - v_pos.y) + u_latrange[1]));\n    // We also multiply the slope by an arbitrary z-factor of 1.25\n    float slope = atan(1.25 * length(deriv) / scaleFactor);\n    float aspect = deriv.x != 0.0 ? atan(deriv.y, -deriv.x) : PI / 2.0 * (deriv.y > 0.0 ? 1.0 : -1.0);\n\n    float intensity = u_light.x;\n    // We add PI to make this property match the global light object, which adds PI/2 to the light's azimuthal\n    // position property to account for 0deg corresponding to north/the top of the viewport in the style spec\n    // and the original shader was written to accept (-illuminationDirection - 90) as the azimuthal.\n    float azimuth = u_light.y + PI;\n\n    // We scale the slope exponentially based on intensity, using a calculation similar to\n    // the exponential interpolation function in the style spec:\n    // https://github.com/mapbox/mapbox-gl-js/blob/master/src/style-spec/expression/definitions/interpolate.js#L217-L228\n    // so that higher intensity values create more opaque hillshading.\n    float base = 1.875 - intensity * 1.75;\n    float maxValue = 0.5 * PI;\n    float scaledSlope = intensity != 0.5 ? ((pow(base, slope) - 1.0) / (pow(base, maxValue) - 1.0)) * maxValue : slope;\n\n    // The accent color is calculated with the cosine of the slope while the shade color is calculated with the sine\n    // so that the accent color's rate of change eases in while the shade color's eases out.\n    float accent = cos(scaledSlope);\n    // We multiply both the accent and shade color by a clamped intensity value\n    // so that intensities >= 0.5 do not additionally affect the color values\n    // while intensity values < 0.5 make the overall color more transparent.\n    vec4 accent_color = (1.0 - accent) * u_accent * clamp(intensity * 2.0, 0.0, 1.0);\n    float shade = abs(mod((aspect + azimuth) / PI + 0.5, 2.0) - 1.0);\n    vec4 shade_color = mix(u_shadow, u_highlight, shade) * sin(scaledSlope) * clamp(intensity * 2.0, 0.0, 1.0);\n    gl_FragColor = accent_color * (1.0 - shade_color.a) + shade_color;\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n", vertexSource: "uniform mat4 u_matrix;\n\nattribute vec2 a_pos;\nattribute vec2 a_texture_pos;\n\nvarying vec2 v_pos;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n    v_pos = a_texture_pos / 8192.0;\n}\n" }, line: { fragmentSource: "#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n\nvarying vec2 v_width2;\nvarying vec2 v_normal;\nvarying float v_gamma_scale;\n\nvoid main() {\n    #pragma mapbox: initialize highp vec4 color\n    #pragma mapbox: initialize lowp float blur\n    #pragma mapbox: initialize lowp float opacity\n\n    // Calculate the distance of the pixel from the line in pixels.\n    float dist = length(v_normal) * v_width2.s;\n\n    // Calculate the antialiasing fade factor. This is either when fading in\n    // the line in case of an offset line (v_width2.t) or when fading out\n    // (v_width2.s)\n    float blur2 = (blur + 1.0 / DEVICE_PIXEL_RATIO) * v_gamma_scale;\n    float alpha = clamp(min(dist - (v_width2.t - blur2), v_width2.s - dist) / blur2, 0.0, 1.0);\n\n    gl_FragColor = color * (alpha * opacity);\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n", vertexSource: "\n\n// the distance over which the line edge fades out.\n// Retina devices need a smaller distance to avoid aliasing.\n#define ANTIALIASING 1.0 / DEVICE_PIXEL_RATIO / 2.0\n\n// floor(127 / 2) == 63.0\n// the maximum allowed miter limit is 2.0 at the moment. the extrude normal is\n// stored in a byte (-128..127). we scale regular normals up to length 63, but\n// there are also \"special\" normals that have a bigger length (of up to 126 in\n// this case).\n// #define scale 63.0\n#define scale 0.015873016\n\nattribute vec4 a_pos_normal;\nattribute vec4 a_data;\n\nuniform mat4 u_matrix;\nuniform mediump float u_ratio;\nuniform vec2 u_gl_units_to_pixels;\n\nvarying vec2 v_normal;\nvarying vec2 v_width2;\nvarying float v_gamma_scale;\nvarying highp float v_linesofar;\n\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n\nvoid main() {\n    #pragma mapbox: initialize highp vec4 color\n    #pragma mapbox: initialize lowp float blur\n    #pragma mapbox: initialize lowp float opacity\n    #pragma mapbox: initialize mediump float gapwidth\n    #pragma mapbox: initialize lowp float offset\n    #pragma mapbox: initialize mediump float width\n\n    vec2 a_extrude = a_data.xy - 128.0;\n    float a_direction = mod(a_data.z, 4.0) - 1.0;\n\n    v_linesofar = (floor(a_data.z / 4.0) + a_data.w * 64.0) * 2.0;\n\n    vec2 pos = a_pos_normal.xy;\n\n    // x is 1 if it's a round cap, 0 otherwise\n    // y is 1 if the normal points up, and -1 if it points down\n    mediump vec2 normal = a_pos_normal.zw;\n    v_normal = normal;\n\n    // these transformations used to be applied in the JS and native code bases.\n    // moved them into the shader for clarity and simplicity.\n    gapwidth = gapwidth / 2.0;\n    float halfwidth = width / 2.0;\n    offset = -1.0 * offset;\n\n    float inset = gapwidth + (gapwidth > 0.0 ? ANTIALIASING : 0.0);\n    float outset = gapwidth + halfwidth * (gapwidth > 0.0 ? 2.0 : 1.0) + (halfwidth == 0.0 ? 0.0 : ANTIALIASING);\n\n    // Scale the extrusion vector down to a normal and then up by the line width\n    // of this vertex.\n    mediump vec2 dist = outset * a_extrude * scale;\n\n    // Calculate the offset when drawing a line that is to the side of the actual line.\n    // We do this by creating a vector that points towards the extrude, but rotate\n    // it when we're drawing round end points (a_direction = -1 or 1) since their\n    // extrude vector points in another direction.\n    mediump float u = 0.5 * a_direction;\n    mediump float t = 1.0 - abs(u);\n    mediump vec2 offset2 = offset * a_extrude * scale * normal.y * mat2(t, -u, u, t);\n\n    vec4 projected_extrude = u_matrix * vec4(dist / u_ratio, 0.0, 0.0);\n    gl_Position = u_matrix * vec4(pos + offset2 / u_ratio, 0.0, 1.0) + projected_extrude;\n\n    // calculate how much the perspective view squishes or stretches the extrude\n    float extrude_length_without_perspective = length(dist);\n    float extrude_length_with_perspective = length(projected_extrude.xy / gl_Position.w * u_gl_units_to_pixels);\n    v_gamma_scale = extrude_length_without_perspective / extrude_length_with_perspective;\n\n    v_width2 = vec2(outset, inset);\n}\n" }, lineGradient: { fragmentSource: "\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n\nuniform sampler2D u_image;\n\nvarying vec2 v_width2;\nvarying vec2 v_normal;\nvarying float v_gamma_scale;\nvarying highp float v_lineprogress;\n\nvoid main() {\n    #pragma mapbox: initialize lowp float blur\n    #pragma mapbox: initialize lowp float opacity\n\n    // Calculate the distance of the pixel from the line in pixels.\n    float dist = length(v_normal) * v_width2.s;\n\n    // Calculate the antialiasing fade factor. This is either when fading in\n    // the line in case of an offset line (v_width2.t) or when fading out\n    // (v_width2.s)\n    float blur2 = (blur + 1.0 / DEVICE_PIXEL_RATIO) * v_gamma_scale;\n    float alpha = clamp(min(dist - (v_width2.t - blur2), v_width2.s - dist) / blur2, 0.0, 1.0);\n\n    // For gradient lines, v_lineprogress is the ratio along the entire line,\n    // scaled to [0, 2^15), and the gradient ramp is stored in a texture.\n    vec4 color = texture2D(u_image, vec2(v_lineprogress, 0.5));\n\n    gl_FragColor = color * (alpha * opacity);\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n", vertexSource: "\n// the attribute conveying progress along a line is scaled to [0, 2^15)\n#define MAX_LINE_DISTANCE 32767.0\n\n// the distance over which the line edge fades out.\n// Retina devices need a smaller distance to avoid aliasing.\n#define ANTIALIASING 1.0 / DEVICE_PIXEL_RATIO / 2.0\n\n// floor(127 / 2) == 63.0\n// the maximum allowed miter limit is 2.0 at the moment. the extrude normal is\n// stored in a byte (-128..127). we scale regular normals up to length 63, but\n// there are also \"special\" normals that have a bigger length (of up to 126 in\n// this case).\n// #define scale 63.0\n#define scale 0.015873016\n\nattribute vec4 a_pos_normal;\nattribute vec4 a_data;\n\nuniform mat4 u_matrix;\nuniform mediump float u_ratio;\nuniform vec2 u_gl_units_to_pixels;\n\nvarying vec2 v_normal;\nvarying vec2 v_width2;\nvarying float v_gamma_scale;\nvarying highp float v_lineprogress;\n\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n\nvoid main() {\n    #pragma mapbox: initialize lowp float blur\n    #pragma mapbox: initialize lowp float opacity\n    #pragma mapbox: initialize mediump float gapwidth\n    #pragma mapbox: initialize lowp float offset\n    #pragma mapbox: initialize mediump float width\n\n    vec2 a_extrude = a_data.xy - 128.0;\n    float a_direction = mod(a_data.z, 4.0) - 1.0;\n\n    v_lineprogress = (floor(a_data.z / 4.0) + a_data.w * 64.0) * 2.0 / MAX_LINE_DISTANCE;\n\n    vec2 pos = a_pos_normal.xy;\n\n    // x is 1 if it's a round cap, 0 otherwise\n    // y is 1 if the normal points up, and -1 if it points down\n    mediump vec2 normal = a_pos_normal.zw;\n    v_normal = normal;\n\n    // these transformations used to be applied in the JS and native code bases.\n    // moved them into the shader for clarity and simplicity.\n    gapwidth = gapwidth / 2.0;\n    float halfwidth = width / 2.0;\n    offset = -1.0 * offset;\n\n    float inset = gapwidth + (gapwidth > 0.0 ? ANTIALIASING : 0.0);\n    float outset = gapwidth + halfwidth * (gapwidth > 0.0 ? 2.0 : 1.0) + (halfwidth == 0.0 ? 0.0 : ANTIALIASING);\n\n    // Scale the extrusion vector down to a normal and then up by the line width\n    // of this vertex.\n    mediump vec2 dist = outset * a_extrude * scale;\n\n    // Calculate the offset when drawing a line that is to the side of the actual line.\n    // We do this by creating a vector that points towards the extrude, but rotate\n    // it when we're drawing round end points (a_direction = -1 or 1) since their\n    // extrude vector points in another direction.\n    mediump float u = 0.5 * a_direction;\n    mediump float t = 1.0 - abs(u);\n    mediump vec2 offset2 = offset * a_extrude * scale * normal.y * mat2(t, -u, u, t);\n\n    vec4 projected_extrude = u_matrix * vec4(dist / u_ratio, 0.0, 0.0);\n    gl_Position = u_matrix * vec4(pos + offset2 / u_ratio, 0.0, 1.0) + projected_extrude;\n\n    // calculate how much the perspective view squishes or stretches the extrude\n    float extrude_length_without_perspective = length(dist);\n    float extrude_length_with_perspective = length(projected_extrude.xy / gl_Position.w * u_gl_units_to_pixels);\n    v_gamma_scale = extrude_length_without_perspective / extrude_length_with_perspective;\n\n    v_width2 = vec2(outset, inset);\n}\n" }, linePattern: { fragmentSource: "uniform vec2 u_pattern_size_a;\nuniform vec2 u_pattern_size_b;\nuniform vec2 u_pattern_tl_a;\nuniform vec2 u_pattern_br_a;\nuniform vec2 u_pattern_tl_b;\nuniform vec2 u_pattern_br_b;\nuniform vec2 u_texsize;\nuniform float u_fade;\n\nuniform sampler2D u_image;\n\nvarying vec2 v_normal;\nvarying vec2 v_width2;\nvarying float v_linesofar;\nvarying float v_gamma_scale;\n\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n\nvoid main() {\n    #pragma mapbox: initialize lowp float blur\n    #pragma mapbox: initialize lowp float opacity\n\n    // Calculate the distance of the pixel from the line in pixels.\n    float dist = length(v_normal) * v_width2.s;\n\n    // Calculate the antialiasing fade factor. This is either when fading in\n    // the line in case of an offset line (v_width2.t) or when fading out\n    // (v_width2.s)\n    float blur2 = (blur + 1.0 / DEVICE_PIXEL_RATIO) * v_gamma_scale;\n    float alpha = clamp(min(dist - (v_width2.t - blur2), v_width2.s - dist) / blur2, 0.0, 1.0);\n\n    float x_a = mod(v_linesofar / u_pattern_size_a.x, 1.0);\n    float x_b = mod(v_linesofar / u_pattern_size_b.x, 1.0);\n\n    // v_normal.y is 0 at the midpoint of the line, -1 at the lower edge, 1 at the upper edge\n    // we clamp the line width outset to be between 0 and half the pattern height plus padding (2.0)\n    // to ensure we don't sample outside the designated symbol on the sprite sheet.\n    // 0.5 is added to shift the component to be bounded between 0 and 1 for interpolation of\n    // the texture coordinate\n    float y_a = 0.5 + (v_normal.y * clamp(v_width2.s, 0.0, (u_pattern_size_a.y + 2.0) / 2.0) / u_pattern_size_a.y);\n    float y_b = 0.5 + (v_normal.y * clamp(v_width2.s, 0.0, (u_pattern_size_b.y + 2.0) / 2.0) / u_pattern_size_b.y);\n    vec2 pos_a = mix(u_pattern_tl_a / u_texsize, u_pattern_br_a / u_texsize, vec2(x_a, y_a));\n    vec2 pos_b = mix(u_pattern_tl_b / u_texsize, u_pattern_br_b / u_texsize, vec2(x_b, y_b));\n\n    vec4 color = mix(texture2D(u_image, pos_a), texture2D(u_image, pos_b), u_fade);\n\n    gl_FragColor = color * alpha * opacity;\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n", vertexSource: "// floor(127 / 2) == 63.0\n// the maximum allowed miter limit is 2.0 at the moment. the extrude normal is\n// stored in a byte (-128..127). we scale regular normals up to length 63, but\n// there are also \"special\" normals that have a bigger length (of up to 126 in\n// this case).\n// #define scale 63.0\n#define scale 0.015873016\n\n// We scale the distance before adding it to the buffers so that we can store\n// long distances for long segments. Use this value to unscale the distance.\n#define LINE_DISTANCE_SCALE 2.0\n\n// the distance over which the line edge fades out.\n// Retina devices need a smaller distance to avoid aliasing.\n#define ANTIALIASING 1.0 / DEVICE_PIXEL_RATIO / 2.0\n\nattribute vec4 a_pos_normal;\nattribute vec4 a_data;\n\nuniform mat4 u_matrix;\nuniform mediump float u_ratio;\nuniform vec2 u_gl_units_to_pixels;\n\nvarying vec2 v_normal;\nvarying vec2 v_width2;\nvarying float v_linesofar;\nvarying float v_gamma_scale;\n\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n\nvoid main() {\n    #pragma mapbox: initialize lowp float blur\n    #pragma mapbox: initialize lowp float opacity\n    #pragma mapbox: initialize lowp float offset\n    #pragma mapbox: initialize mediump float gapwidth\n    #pragma mapbox: initialize mediump float width\n\n    vec2 a_extrude = a_data.xy - 128.0;\n    float a_direction = mod(a_data.z, 4.0) - 1.0;\n    float a_linesofar = (floor(a_data.z / 4.0) + a_data.w * 64.0) * LINE_DISTANCE_SCALE;\n\n    vec2 pos = a_pos_normal.xy;\n\n    // x is 1 if it's a round cap, 0 otherwise\n    // y is 1 if the normal points up, and -1 if it points down\n    mediump vec2 normal = a_pos_normal.zw;\n    v_normal = normal;\n\n    // these transformations used to be applied in the JS and native code bases.\n    // moved them into the shader for clarity and simplicity.\n    gapwidth = gapwidth / 2.0;\n    float halfwidth = width / 2.0;\n    offset = -1.0 * offset;\n\n    float inset = gapwidth + (gapwidth > 0.0 ? ANTIALIASING : 0.0);\n    float outset = gapwidth + halfwidth * (gapwidth > 0.0 ? 2.0 : 1.0) + (halfwidth == 0.0 ? 0.0 : ANTIALIASING);\n\n    // Scale the extrusion vector down to a normal and then up by the line width\n    // of this vertex.\n    mediump vec2 dist = outset * a_extrude * scale;\n\n    // Calculate the offset when drawing a line that is to the side of the actual line.\n    // We do this by creating a vector that points towards the extrude, but rotate\n    // it when we're drawing round end points (a_direction = -1 or 1) since their\n    // extrude vector points in another direction.\n    mediump float u = 0.5 * a_direction;\n    mediump float t = 1.0 - abs(u);\n    mediump vec2 offset2 = offset * a_extrude * scale * normal.y * mat2(t, -u, u, t);\n\n    vec4 projected_extrude = u_matrix * vec4(dist / u_ratio, 0.0, 0.0);\n    gl_Position = u_matrix * vec4(pos + offset2 / u_ratio, 0.0, 1.0) + projected_extrude;\n\n    // calculate how much the perspective view squishes or stretches the extrude\n    float extrude_length_without_perspective = length(dist);\n    float extrude_length_with_perspective = length(projected_extrude.xy / gl_Position.w * u_gl_units_to_pixels);\n    v_gamma_scale = extrude_length_without_perspective / extrude_length_with_perspective;\n\n    v_linesofar = a_linesofar;\n    v_width2 = vec2(outset, inset);\n}\n" }, lineSDF: { fragmentSource: "\nuniform sampler2D u_image;\nuniform float u_sdfgamma;\nuniform float u_mix;\n\nvarying vec2 v_normal;\nvarying vec2 v_width2;\nvarying vec2 v_tex_a;\nvarying vec2 v_tex_b;\nvarying float v_gamma_scale;\n\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n\nvoid main() {\n    #pragma mapbox: initialize highp vec4 color\n    #pragma mapbox: initialize lowp float blur\n    #pragma mapbox: initialize lowp float opacity\n    #pragma mapbox: initialize mediump float width\n    #pragma mapbox: initialize lowp float floorwidth\n\n    // Calculate the distance of the pixel from the line in pixels.\n    float dist = length(v_normal) * v_width2.s;\n\n    // Calculate the antialiasing fade factor. This is either when fading in\n    // the line in case of an offset line (v_width2.t) or when fading out\n    // (v_width2.s)\n    float blur2 = (blur + 1.0 / DEVICE_PIXEL_RATIO) * v_gamma_scale;\n    float alpha = clamp(min(dist - (v_width2.t - blur2), v_width2.s - dist) / blur2, 0.0, 1.0);\n\n    float sdfdist_a = texture2D(u_image, v_tex_a).a;\n    float sdfdist_b = texture2D(u_image, v_tex_b).a;\n    float sdfdist = mix(sdfdist_a, sdfdist_b, u_mix);\n    alpha *= smoothstep(0.5 - u_sdfgamma / floorwidth, 0.5 + u_sdfgamma / floorwidth, sdfdist);\n\n    gl_FragColor = color * (alpha * opacity);\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n", vertexSource: "// floor(127 / 2) == 63.0\n// the maximum allowed miter limit is 2.0 at the moment. the extrude normal is\n// stored in a byte (-128..127). we scale regular normals up to length 63, but\n// there are also \"special\" normals that have a bigger length (of up to 126 in\n// this case).\n// #define scale 63.0\n#define scale 0.015873016\n\n// We scale the distance before adding it to the buffers so that we can store\n// long distances for long segments. Use this value to unscale the distance.\n#define LINE_DISTANCE_SCALE 2.0\n\n// the distance over which the line edge fades out.\n// Retina devices need a smaller distance to avoid aliasing.\n#define ANTIALIASING 1.0 / DEVICE_PIXEL_RATIO / 2.0\n\nattribute vec4 a_pos_normal;\nattribute vec4 a_data;\n\nuniform mat4 u_matrix;\nuniform mediump float u_ratio;\nuniform vec2 u_patternscale_a;\nuniform float u_tex_y_a;\nuniform vec2 u_patternscale_b;\nuniform float u_tex_y_b;\nuniform vec2 u_gl_units_to_pixels;\n\nvarying vec2 v_normal;\nvarying vec2 v_width2;\nvarying vec2 v_tex_a;\nvarying vec2 v_tex_b;\nvarying float v_gamma_scale;\n\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n\nvoid main() {\n    #pragma mapbox: initialize highp vec4 color\n    #pragma mapbox: initialize lowp float blur\n    #pragma mapbox: initialize lowp float opacity\n    #pragma mapbox: initialize mediump float gapwidth\n    #pragma mapbox: initialize lowp float offset\n    #pragma mapbox: initialize mediump float width\n    #pragma mapbox: initialize lowp float floorwidth\n\n    vec2 a_extrude = a_data.xy - 128.0;\n    float a_direction = mod(a_data.z, 4.0) - 1.0;\n    float a_linesofar = (floor(a_data.z / 4.0) + a_data.w * 64.0) * LINE_DISTANCE_SCALE;\n\n    vec2 pos = a_pos_normal.xy;\n\n    // x is 1 if it's a round cap, 0 otherwise\n    // y is 1 if the normal points up, and -1 if it points down\n    mediump vec2 normal = a_pos_normal.zw;\n    v_normal = normal;\n\n    // these transformations used to be applied in the JS and native code bases.\n    // moved them into the shader for clarity and simplicity.\n    gapwidth = gapwidth / 2.0;\n    float halfwidth = width / 2.0;\n    offset = -1.0 * offset;\n\n    float inset = gapwidth + (gapwidth > 0.0 ? ANTIALIASING : 0.0);\n    float outset = gapwidth + halfwidth * (gapwidth > 0.0 ? 2.0 : 1.0) + (halfwidth == 0.0 ? 0.0 : ANTIALIASING);\n\n    // Scale the extrusion vector down to a normal and then up by the line width\n    // of this vertex.\n    mediump vec2 dist =outset * a_extrude * scale;\n\n    // Calculate the offset when drawing a line that is to the side of the actual line.\n    // We do this by creating a vector that points towards the extrude, but rotate\n    // it when we're drawing round end points (a_direction = -1 or 1) since their\n    // extrude vector points in another direction.\n    mediump float u = 0.5 * a_direction;\n    mediump float t = 1.0 - abs(u);\n    mediump vec2 offset2 = offset * a_extrude * scale * normal.y * mat2(t, -u, u, t);\n\n    vec4 projected_extrude = u_matrix * vec4(dist / u_ratio, 0.0, 0.0);\n    gl_Position = u_matrix * vec4(pos + offset2 / u_ratio, 0.0, 1.0) + projected_extrude;\n\n    // calculate how much the perspective view squishes or stretches the extrude\n    float extrude_length_without_perspective = length(dist);\n    float extrude_length_with_perspective = length(projected_extrude.xy / gl_Position.w * u_gl_units_to_pixels);\n    v_gamma_scale = extrude_length_without_perspective / extrude_length_with_perspective;\n\n    v_tex_a = vec2(a_linesofar * u_patternscale_a.x / floorwidth, normal.y * u_patternscale_a.y + u_tex_y_a);\n    v_tex_b = vec2(a_linesofar * u_patternscale_b.x / floorwidth, normal.y * u_patternscale_b.y + u_tex_y_b);\n\n    v_width2 = vec2(outset, inset);\n}\n" }, raster: { fragmentSource: "uniform float u_fade_t;\nuniform float u_opacity;\nuniform sampler2D u_image0;\nuniform sampler2D u_image1;\nvarying vec2 v_pos0;\nvarying vec2 v_pos1;\n\nuniform float u_brightness_low;\nuniform float u_brightness_high;\n\nuniform float u_saturation_factor;\nuniform float u_contrast_factor;\nuniform vec3 u_spin_weights;\n\nvoid main() {\n\n    // read and cross-fade colors from the main and parent tiles\n    vec4 color0 = texture2D(u_image0, v_pos0);\n    vec4 color1 = texture2D(u_image1, v_pos1);\n    if (color0.a > 0.0) {\n        color0.rgb = color0.rgb / color0.a;\n    }\n    if (color1.a > 0.0) {\n        color1.rgb = color1.rgb / color1.a;\n    }\n    vec4 color = mix(color0, color1, u_fade_t);\n    color.a *= u_opacity;\n    vec3 rgb = color.rgb;\n\n    // spin\n    rgb = vec3(\n        dot(rgb, u_spin_weights.xyz),\n        dot(rgb, u_spin_weights.zxy),\n        dot(rgb, u_spin_weights.yzx));\n\n    // saturation\n    float average = (color.r + color.g + color.b) / 3.0;\n    rgb += (average - rgb) * u_saturation_factor;\n\n    // contrast\n    rgb = (rgb - 0.5) * u_contrast_factor + 0.5;\n\n    // brightness\n    vec3 u_high_vec = vec3(u_brightness_low, u_brightness_low, u_brightness_low);\n    vec3 u_low_vec = vec3(u_brightness_high, u_brightness_high, u_brightness_high);\n\n    gl_FragColor = vec4(mix(u_high_vec, u_low_vec, rgb) * color.a, color.a);\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n", vertexSource: "uniform mat4 u_matrix;\nuniform vec2 u_tl_parent;\nuniform float u_scale_parent;\nuniform float u_buffer_scale;\n\nattribute vec2 a_pos;\nattribute vec2 a_texture_pos;\n\nvarying vec2 v_pos0;\nvarying vec2 v_pos1;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n    // We are using Int16 for texture position coordinates to give us enough precision for\n    // fractional coordinates. We use 8192 to scale the texture coordinates in the buffer\n    // as an arbitrarily high number to preserve adequate precision when rendering.\n    // This is also the same value as the EXTENT we are using for our tile buffer pos coordinates,\n    // so math for modifying either is consistent.\n    v_pos0 = (((a_texture_pos / 8192.0) - 0.5) / u_buffer_scale ) + 0.5;\n    v_pos1 = (v_pos0 * u_scale_parent) + u_tl_parent;\n}\n" }, symbolIcon: { fragmentSource: "uniform sampler2D u_texture;\n\n#pragma mapbox: define lowp float opacity\n\nvarying vec2 v_tex;\nvarying float v_fade_opacity;\n\nvoid main() {\n    #pragma mapbox: initialize lowp float opacity\n\n    lowp float alpha = opacity * v_fade_opacity;\n    gl_FragColor = texture2D(u_texture, v_tex) * alpha;\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n", vertexSource: "const float PI = 3.141592653589793;\n\nattribute vec4 a_pos_offset;\nattribute vec4 a_data;\nattribute vec3 a_projected_pos;\nattribute float a_fade_opacity;\n\nuniform bool u_is_size_zoom_constant;\nuniform bool u_is_size_feature_constant;\nuniform highp float u_size_t; // used to interpolate between zoom stops when size is a composite function\nuniform highp float u_size; // used when size is both zoom and feature constant\nuniform highp float u_camera_to_center_distance;\nuniform highp float u_pitch;\nuniform bool u_rotate_symbol;\nuniform highp float u_aspect_ratio;\nuniform float u_fade_change;\n\n#pragma mapbox: define lowp float opacity\n\nuniform mat4 u_matrix;\nuniform mat4 u_label_plane_matrix;\nuniform mat4 u_gl_coord_matrix;\n\nuniform bool u_is_text;\nuniform bool u_pitch_with_map;\n\nuniform vec2 u_texsize;\n\nvarying vec2 v_tex;\nvarying float v_fade_opacity;\n\nvoid main() {\n    #pragma mapbox: initialize lowp float opacity\n\n    vec2 a_pos = a_pos_offset.xy;\n    vec2 a_offset = a_pos_offset.zw;\n\n    vec2 a_tex = a_data.xy;\n    vec2 a_size = a_data.zw;\n\n    highp float segment_angle = -a_projected_pos[2];\n\n    float size;\n    if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {\n        size = mix(a_size[0], a_size[1], u_size_t) / 10.0;\n    } else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {\n        size = a_size[0] / 10.0;\n    } else if (!u_is_size_zoom_constant && u_is_size_feature_constant) {\n        size = u_size;\n    } else {\n        size = u_size;\n    }\n\n    vec4 projectedPoint = u_matrix * vec4(a_pos, 0, 1);\n    highp float camera_to_anchor_distance = projectedPoint.w;\n    // See comments in symbol_sdf.vertex\n    highp float distance_ratio = u_pitch_with_map ?\n        camera_to_anchor_distance / u_camera_to_center_distance :\n        u_camera_to_center_distance / camera_to_anchor_distance;\n    highp float perspective_ratio = clamp(\n            0.5 + 0.5 * distance_ratio,\n            0.0, // Prevents oversized near-field symbols in pitched/overzoomed tiles\n            4.0);\n\n    size *= perspective_ratio;\n\n    float fontScale = u_is_text ? size / 24.0 : size;\n\n    highp float symbol_rotation = 0.0;\n    if (u_rotate_symbol) {\n        // See comments in symbol_sdf.vertex\n        vec4 offsetProjectedPoint = u_matrix * vec4(a_pos + vec2(1, 0), 0, 1);\n\n        vec2 a = projectedPoint.xy / projectedPoint.w;\n        vec2 b = offsetProjectedPoint.xy / offsetProjectedPoint.w;\n\n        symbol_rotation = atan((b.y - a.y) / u_aspect_ratio, b.x - a.x);\n    }\n\n    highp float angle_sin = sin(segment_angle + symbol_rotation);\n    highp float angle_cos = cos(segment_angle + symbol_rotation);\n    mat2 rotation_matrix = mat2(angle_cos, -1.0 * angle_sin, angle_sin, angle_cos);\n\n    vec4 projected_pos = u_label_plane_matrix * vec4(a_projected_pos.xy, 0.0, 1.0);\n    gl_Position = u_gl_coord_matrix * vec4(projected_pos.xy / projected_pos.w + rotation_matrix * (a_offset / 32.0 * fontScale), 0.0, 1.0);\n\n    v_tex = a_tex / u_texsize;\n    vec2 fade_opacity = unpack_opacity(a_fade_opacity);\n    float fade_change = fade_opacity[1] > 0.5 ? u_fade_change : -u_fade_change;\n    v_fade_opacity = max(0.0, min(1.0, fade_opacity[0] + fade_change));\n}\n" }, symbolSDF: { fragmentSource: "#define SDF_PX 8.0\n#define EDGE_GAMMA 0.105/DEVICE_PIXEL_RATIO\n\nuniform bool u_is_halo;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n\nuniform sampler2D u_texture;\nuniform highp float u_gamma_scale;\nuniform bool u_is_text;\n\nvarying vec2 v_data0;\nvarying vec3 v_data1;\n\nvoid main() {\n    #pragma mapbox: initialize highp vec4 fill_color\n    #pragma mapbox: initialize highp vec4 halo_color\n    #pragma mapbox: initialize lowp float opacity\n    #pragma mapbox: initialize lowp float halo_width\n    #pragma mapbox: initialize lowp float halo_blur\n\n    vec2 tex = v_data0.xy;\n    float gamma_scale = v_data1.x;\n    float size = v_data1.y;\n    float fade_opacity = v_data1[2];\n\n    float fontScale = u_is_text ? size / 24.0 : size;\n\n    lowp vec4 color = fill_color;\n    highp float gamma = EDGE_GAMMA / (fontScale * u_gamma_scale);\n    lowp float buff = (256.0 - 64.0) / 256.0;\n    if (u_is_halo) {\n        color = halo_color;\n        gamma = (halo_blur * 1.19 / SDF_PX + EDGE_GAMMA) / (fontScale * u_gamma_scale);\n        buff = (6.0 - halo_width / fontScale) / SDF_PX;\n    }\n\n    lowp float dist = texture2D(u_texture, tex).a;\n    highp float gamma_scaled = gamma * gamma_scale;\n    highp float alpha = smoothstep(buff - gamma_scaled, buff + gamma_scaled, dist);\n\n    gl_FragColor = color * (alpha * opacity * fade_opacity);\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n", vertexSource: "const float PI = 3.141592653589793;\n\nattribute vec4 a_pos_offset;\nattribute vec4 a_data;\nattribute vec3 a_projected_pos;\nattribute float a_fade_opacity;\n\n// contents of a_size vary based on the type of property value\n// used for {text,icon}-size.\n// For constants, a_size is disabled.\n// For source functions, we bind only one value per vertex: the value of {text,icon}-size evaluated for the current feature.\n// For composite functions:\n// [ text-size(lowerZoomStop, feature),\n//   text-size(upperZoomStop, feature) ]\nuniform bool u_is_size_zoom_constant;\nuniform bool u_is_size_feature_constant;\nuniform highp float u_size_t; // used to interpolate between zoom stops when size is a composite function\nuniform highp float u_size; // used when size is both zoom and feature constant\n\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n\nuniform mat4 u_matrix;\nuniform mat4 u_label_plane_matrix;\nuniform mat4 u_gl_coord_matrix;\n\nuniform bool u_is_text;\nuniform bool u_pitch_with_map;\nuniform highp float u_pitch;\nuniform bool u_rotate_symbol;\nuniform highp float u_aspect_ratio;\nuniform highp float u_camera_to_center_distance;\nuniform float u_fade_change;\n\nuniform vec2 u_texsize;\n\nvarying vec2 v_data0;\nvarying vec3 v_data1;\n\nvoid main() {\n    #pragma mapbox: initialize highp vec4 fill_color\n    #pragma mapbox: initialize highp vec4 halo_color\n    #pragma mapbox: initialize lowp float opacity\n    #pragma mapbox: initialize lowp float halo_width\n    #pragma mapbox: initialize lowp float halo_blur\n\n    vec2 a_pos = a_pos_offset.xy;\n    vec2 a_offset = a_pos_offset.zw;\n\n    vec2 a_tex = a_data.xy;\n    vec2 a_size = a_data.zw;\n\n    highp float segment_angle = -a_projected_pos[2];\n    float size;\n\n    if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {\n        size = mix(a_size[0], a_size[1], u_size_t) / 10.0;\n    } else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {\n        size = a_size[0] / 10.0;\n    } else if (!u_is_size_zoom_constant && u_is_size_feature_constant) {\n        size = u_size;\n    } else {\n        size = u_size;\n    }\n\n    vec4 projectedPoint = u_matrix * vec4(a_pos, 0, 1);\n    highp float camera_to_anchor_distance = projectedPoint.w;\n    // If the label is pitched with the map, layout is done in pitched space,\n    // which makes labels in the distance smaller relative to viewport space.\n    // We counteract part of that effect by multiplying by the perspective ratio.\n    // If the label isn't pitched with the map, we do layout in viewport space,\n    // which makes labels in the distance larger relative to the features around\n    // them. We counteract part of that effect by dividing by the perspective ratio.\n    highp float distance_ratio = u_pitch_with_map ?\n        camera_to_anchor_distance / u_camera_to_center_distance :\n        u_camera_to_center_distance / camera_to_anchor_distance;\n    highp float perspective_ratio = clamp(\n        0.5 + 0.5 * distance_ratio,\n        0.0, // Prevents oversized near-field symbols in pitched/overzoomed tiles\n        4.0);\n\n    size *= perspective_ratio;\n\n    float fontScale = u_is_text ? size / 24.0 : size;\n\n    highp float symbol_rotation = 0.0;\n    if (u_rotate_symbol) {\n        // Point labels with 'rotation-alignment: map' are horizontal with respect to tile units\n        // To figure out that angle in projected space, we draw a short horizontal line in tile\n        // space, project it, and measure its angle in projected space.\n        vec4 offsetProjectedPoint = u_matrix * vec4(a_pos + vec2(1, 0), 0, 1);\n\n        vec2 a = projectedPoint.xy / projectedPoint.w;\n        vec2 b = offsetProjectedPoint.xy / offsetProjectedPoint.w;\n\n        symbol_rotation = atan((b.y - a.y) / u_aspect_ratio, b.x - a.x);\n    }\n\n    highp float angle_sin = sin(segment_angle + symbol_rotation);\n    highp float angle_cos = cos(segment_angle + symbol_rotation);\n    mat2 rotation_matrix = mat2(angle_cos, -1.0 * angle_sin, angle_sin, angle_cos);\n\n    vec4 projected_pos = u_label_plane_matrix * vec4(a_projected_pos.xy, 0.0, 1.0);\n    gl_Position = u_gl_coord_matrix * vec4(projected_pos.xy / projected_pos.w + rotation_matrix * (a_offset / 32.0 * fontScale), 0.0, 1.0);\n    float gamma_scale = gl_Position.w;\n\n    vec2 tex = a_tex / u_texsize;\n    vec2 fade_opacity = unpack_opacity(a_fade_opacity);\n    float fade_change = fade_opacity[1] > 0.5 ? u_fade_change : -u_fade_change;\n    float interpolated_fade_opacity = max(0.0, min(1.0, fade_opacity[0] + fade_change));\n\n    v_data0 = vec2(tex.x, tex.y);\n    v_data1 = vec3(gamma_scale, size, interpolated_fade_opacity);\n}\n" } }, rn = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g; for (tn in nn) !function (t) { var t = nn[t], a = {}; t.fragmentSource = t.fragmentSource.replace(rn, function (t, e, n, i, r) { return a[r] = !0, "define" === e ? "\n#ifndef HAS_UNIFORM_u_" + r + "\nvarying " + n + " " + i + " " + r + ";\n#else\nuniform " + n + " " + i + " u_" + r + ";\n#endif\n" : "\n#ifdef HAS_UNIFORM_u_" + r + "\n    " + n + " " + i + " " + r + " = u_" + r + ";\n#endif\n" }), t.vertexSource = t.vertexSource.replace(rn, function (t, e, n, i, r) { var o = "float" === i ? "vec2" : "vec4"; return a[r] ? "define" === e ? "\n#ifndef HAS_UNIFORM_u_" + r + "\nuniform lowp float a_" + r + "_t;\nattribute " + n + " " + o + " a_" + r + ";\nvarying " + n + " " + i + " " + r + ";\n#else\nuniform " + n + " " + i + " u_" + r + ";\n#endif\n" : "\n#ifndef HAS_UNIFORM_u_" + r + "\n    " + r + " = unpack_mix_" + o + "(a_" + r + ", a_" + r + "_t);\n#else\n    " + n + " " + i + " " + r + " = u_" + r + ";\n#endif\n" : "define" === e ? "\n#ifndef HAS_UNIFORM_u_" + r + "\nuniform lowp float a_" + r + "_t;\nattribute " + n + " " + o + " a_" + r + ";\n#else\nuniform " + n + " " + i + " u_" + r + ";\n#endif\n" : "\n#ifndef HAS_UNIFORM_u_" + r + "\n    " + n + " " + i + " " + r + " = unpack_mix_" + o + "(a_" + r + ", a_" + r + "_t);\n#else\n    " + n + " " + i + " " + r + " = u_" + r + ";\n#endif\n" }) }(tn); function on(t, e, n, i) { var r = t.gl; this.program = r.createProgram(), t = n.defines().concat("#define DEVICE_PIXEL_RATIO " + D.browser.devicePixelRatio.toFixed(1)), i && t.push("#define OVERDRAW_INSPECTOR;"), i = t.concat(an.prelude.fragmentSource, e.fragmentSource).join("\n"), t = t.concat(an.prelude.vertexSource, e.vertexSource).join("\n"), e = r.createShader(r.FRAGMENT_SHADER), r.shaderSource(e, i), r.compileShader(e), r.attachShader(this.program, e), e = r.createShader(r.VERTEX_SHADER), r.shaderSource(e, t), r.compileShader(e), r.attachShader(this.program, e); for (var o = n.layoutAttributes || [], a = 0; a < o.length; a++)r.bindAttribLocation(this.program, a, o[a].name); r.linkProgram(this.program), this.numAttributes = r.getProgramParameter(this.program, r.ACTIVE_ATTRIBUTES), this.attributes = {}, this.uniforms = {}; for (var s = 0; s < this.numAttributes; s++) { var l = r.getActiveAttrib(this.program, s); l && (this.attributes[l.name] = r.getAttribLocation(this.program, l.name)) } for (var u = r.getProgramParameter(this.program, r.ACTIVE_UNIFORMS), c = 0; c < u; c++) { var h = r.getActiveUniform(this.program, c); h && (this.uniforms[h.name] = r.getUniformLocation(this.program, h.name)) } } var an = nn; function sn(t, e) { for (var n = t.sort(function (t, e) { return t.tileID.isLessThan(e.tileID) ? -1 : e.tileID.isLessThan(t.tileID) ? 1 : 0 }), i = 0; i < n.length; i++) { var r = {}, o = n[i], a = n.slice(i + 1); (function t(e, n, i, r, o) { for (var a = 0; a < i.length; a++) { var s = i[a]; if (r.isLessThan(s.tileID)) break; if (n.key === s.tileID.key) return; if (s.tileID.isChildOf(n)) { for (var l = n.children(1 / 0), u = 0; u < l.length; u++)t(e, l[u], i.slice(a), r, o); return } } var c = n.overscaledZ - e.overscaledZ, c = new D.CanonicalTileID(c, n.canonical.x - (e.canonical.x << c), n.canonical.y - (e.canonical.y << c)); o[c.key] = o[c.key] || c })(o.tileID.wrapped(), o.tileID, a, new D.OverscaledTileID(0, o.tileID.wrap + 1, 0, 0, 0), r), o.setMask(r, e) } } function ln(t, e, n, i, r) { var o = t.context, a = o.gl, s = r ? t.useProgram("collisionCircle") : t.useProgram("collisionBox"); o.setDepthMode(Gt.disabled), o.setStencilMode(Xt.disabled), o.setColorMode(t.colorModeForRenderPass()); for (var l = 0; l < i.length; l++) { var u, c = i[l], h = e.getTile(c), p = h.getBucket(n); !p || (u = r ? p.collisionCircle : p.collisionBox) && (a.uniformMatrix4fv(s.uniforms.u_matrix, !1, c.posMatrix), a.uniform1f(s.uniforms.u_camera_to_center_distance, t.transform.cameraToCenterDistance), p = Ae(h, 1, t.transform.zoom), c = Math.pow(2, t.transform.zoom - h.tileID.overscaledZ), a.uniform1f(s.uniforms.u_pixels_to_tile_units, p), a.uniform2f(s.uniforms.u_extrude_scale, t.transform.pixelsToGLUnits[0] / (p * c), t.transform.pixelsToGLUnits[1] / (p * c)), a.uniform1f(s.uniforms.u_overscale_factor, h.tileID.overscaleFactor()), s.draw(o, r ? a.TRIANGLES : a.LINES, n.id, u.layoutVertexBuffer, u.indexBuffer, u.segments, null, u.collisionVertexBuffer, null)) } } on.prototype.draw = function (t, e, n, i, r, o, a, s, l) { for (var u, c = t.gl, h = ((u = {})[c.LINES] = 2, u[c.TRIANGLES] = 3, u[e]), p = 0, f = o.get(); p < f.length; p += 1) { var d = f[p], m = d.vaos || (d.vaos = {}); (m[n] || (m[n] = new H)).bind(t, this, i, a ? a.getPaintVertexBuffers() : [], r, d.vertexOffset, s, l), c.drawElements(e, d.primitiveLength * h, c.UNSIGNED_SHORT, d.primitiveOffset * h * 2) } }; var un = D.identity(new Float32Array(16)), cn = D.properties.layout; function hn(t, e, n, i, r, o, a, s, l, u) { var c, h = t.context, p = h.gl, f = t.transform, d = "map" === s, m = "map" === l, y = d && "point" !== n.layout.get("symbol-placement"), g = d && !m && !y; h.setDepthMode(m ? t.depthModeForSublayer(0, Gt.ReadOnly) : Gt.disabled); for (var v, _ = 0, x = i; _ < x.length; _ += 1) { var b, w, E, S, T, A, z, I, k = x[_], C = e.getTile(k), M = C.getBucket(n); M && (b = r ? M.text : M.icon) && b.segments.get().length && (w = b.programConfigurations.get(n.id), E = r || M.sdfIcons, S = r ? M.textSizeData : M.iconSizeData, c || (c = t.useProgram(E ? "symbolSDF" : "symbolIcon", w), w.setUniforms(t.context, c, n.paint, { zoom: t.transform.zoom }), function (t, e, n, i, r, o) { var a = e.context.gl, s = e.transform; a.uniform1i(t.uniforms.u_pitch_with_map, r ? 1 : 0), a.uniform1f(t.uniforms.u_is_text, n ? 1 : 0), a.uniform1f(t.uniforms.u_pitch, s.pitch / 360 * 2 * Math.PI); e = "constant" === o.functionType || "source" === o.functionType, r = "constant" === o.functionType || "camera" === o.functionType; a.uniform1i(t.uniforms.u_is_size_zoom_constant, e ? 1 : 0), a.uniform1i(t.uniforms.u_is_size_feature_constant, r ? 1 : 0), a.uniform1f(t.uniforms.u_camera_to_center_distance, s.cameraToCenterDistance); n = D.evaluateSizeForZoom(o, s.zoom, cn.properties[n ? "text-size" : "icon-size"]); void 0 !== n.uSizeT && a.uniform1f(t.uniforms.u_size_t, n.uSizeT), void 0 !== n.uSize && a.uniform1f(t.uniforms.u_size, n.uSize), a.uniform1f(t.uniforms.u_aspect_ratio, s.width / s.height), a.uniform1i(t.uniforms.u_rotate_symbol, i ? 1 : 0) }(c, t, r, g, m, S)), h.activeTexture.set(p.TEXTURE0), p.uniform1i(c.uniforms.u_texture, 0), r ? (C.glyphAtlasTexture.bind(p.LINEAR, p.CLAMP_TO_EDGE), p.uniform2fv(c.uniforms.u_texsize, C.glyphAtlasTexture.size)) : (T = 1 !== n.layout.get("icon-size").constantOr(0) || M.iconsNeedLinear, A = m || 0 !== f.pitch, C.iconAtlasTexture.bind(E || t.options.rotating || t.options.zooming || T || A ? p.LINEAR : p.NEAREST, p.CLAMP_TO_EDGE), p.uniform2fv(c.uniforms.u_texsize, C.iconAtlasTexture.size)), p.uniformMatrix4fv(c.uniforms.u_matrix, !1, t.translatePosMatrix(k.posMatrix, C, o, a)), I = Ae(C, 1, t.transform.zoom), z = de(k.posMatrix, m, d, t.transform, I), v = k.posMatrix, w = m, S = d, T = t.transform, A = I, I = void 0, I = D.identity(new Float32Array(16)), w ? (D.multiply(I, I, v), D.scale(I, I, [A, A, 1]), S || D.rotateZ(I, I, -T.angle)) : (D.scale(I, I, [1, -1, 1]), D.translate(I, I, [-1, -1, 0]), D.scale(I, I, [2 / T.width, 2 / T.height, 1])), I = I, p.uniformMatrix4fv(c.uniforms.u_gl_coord_matrix, !1, t.translatePosMatrix(I, C, o, a, !0)), y ? (p.uniformMatrix4fv(c.uniforms.u_label_plane_matrix, !1, un), function (t, e, n, i, r, o, a, s) { var l = i ? t.textSizeData : t.iconSizeData, u = D.evaluateSizeForZoom(l, n.transform.zoom, fe.properties[i ? "text-size" : "icon-size"]), c = [256 / n.width * 2 + 1, 256 / n.height * 2 + 1], h = (i ? t.text : t.icon).dynamicLayoutVertexArray; h.clear(); for (var p = t.lineVertexArray, f = (i ? t.text : t.icon).placedSymbolArray, d = n.transform.width / n.transform.height, m = !1, y = 0; y < f.length; y++) { var g, v, _, x, b, w = f.get(y); w.hidden || w.writingMode === D.WritingMode.vertical && !m ? we(w.numGlyphs, h) : (m = !1, _ = [w.anchorX, w.anchorY, 0, 1], D.transformMat4(_, _, e), v = c, x = void 0, x = (g = _)[0] / g[3], g = g[1] / g[3], x >= -v[0] && x <= v[0] && g >= -v[1] && g <= v[1] ? (b = .5 + _[3] / n.transform.cameraToCenterDistance * .5, x = D.evaluateSizeForFeature(l, u, w), g = a ? x * b : x / b, _ = me(v = new D.Point(w.anchorX, w.anchorY), r).point, m = (b = ve(w, g, !(x = {}), s, e, r, o, t.glyphOffsetArray, p, h, _, v, x, d)).useVertical, (b.notEnoughRoom || m || b.needsFlipping && ve(w, g, !0, s, e, r, o, t.glyphOffsetArray, p, h, _, v, x, d).notEnoughRoom) && we(w.numGlyphs, h)) : we(w.numGlyphs, h)) } (i ? t.text : t.icon).dynamicLayoutVertexBuffer.updateData(h) }(M, k.posMatrix, t, r, z, I, m, u)) : p.uniformMatrix4fv(c.uniforms.u_label_plane_matrix, !1, z), p.uniform1f(c.uniforms.u_fade_change, t.options.fadeDuration ? t.symbolFadeChange : 1), function (t, e, n, i, r, o, a) { var s = e.context, l = s.gl, e = e.transform; { o && (r = 0 !== n.paint.get(r ? "text-halo-width" : "icon-halo-width").constantOr(1), e = a ? Math.cos(e._pitch) * e.cameraToCenterDistance : 1, l.uniform1f(t.uniforms.u_gamma_scale, e), r && (l.uniform1f(t.uniforms.u_is_halo, 1), pn(i, n, s, t)), l.uniform1f(t.uniforms.u_is_halo, 0)) } pn(i, n, s, t) }(c, t, n, b, r, E, m)) } } function pn(t, e, n, i) { i.draw(n, n.gl.TRIANGLES, e.id, t.layoutVertexBuffer, t.indexBuffer, t.segments, t.programConfigurations.get(e.id), t.dynamicLayoutVertexBuffer, t.opacityVertexBuffer) } var fn = function (t, e) { if (!t) return !1; var n = e.imageManager.getPattern(t.from), t = e.imageManager.getPattern(t.to); return !n || !t }, dn = function (t, e, n) { var i = e.context, r = i.gl, o = e.imageManager.getPattern(t.from), a = e.imageManager.getPattern(t.to); r.uniform1i(n.uniforms.u_image, 0), r.uniform2fv(n.uniforms.u_pattern_tl_a, o.tl), r.uniform2fv(n.uniforms.u_pattern_br_a, o.br), r.uniform2fv(n.uniforms.u_pattern_tl_b, a.tl), r.uniform2fv(n.uniforms.u_pattern_br_b, a.br); var s = e.imageManager.getPixelSize(), l = s.width, s = s.height; r.uniform2fv(n.uniforms.u_texsize, [l, s]), r.uniform1f(n.uniforms.u_mix, t.t), r.uniform2fv(n.uniforms.u_pattern_size_a, o.displaySize), r.uniform2fv(n.uniforms.u_pattern_size_b, a.displaySize), r.uniform1f(n.uniforms.u_scale_a, t.fromScale), r.uniform1f(n.uniforms.u_scale_b, t.toScale), i.activeTexture.set(r.TEXTURE0), e.imageManager.bind(e.context) }, mn = function (t, e, n) { var i = e.context.gl; i.uniform1f(n.uniforms.u_tile_units_to_pixels, 1 / Ae(t, 1, e.transform.tileZoom)); var r = Math.pow(2, t.tileID.overscaledZ), e = t.tileSize * Math.pow(2, e.transform.tileZoom) / r, r = e * (t.tileID.canonical.x + t.tileID.wrap * r), t = e * t.tileID.canonical.y; i.uniform2f(n.uniforms.u_pixel_coord_upper, r >> 16, t >> 16), i.uniform2f(n.uniforms.u_pixel_coord_lower, 65535 & r, 65535 & t) }; function yn(t, e, n, i, r) { if (!fn(n.paint.get("fill-pattern"), t)) for (var o = !0, a = 0, s = i; a < s.length; a += 1) { var l = s[a], u = e.getTile(l), c = u.getBucket(n); c && (t.context.setStencilMode(t.stencilModeForClipping(l)), r(t, e, n, u, l, c, o), o = !1) } } function gn(t, e, n, i, r, o, a) { var s = t.context.gl, l = o.programConfigurations.get(n.id); _n("fill", n.paint.get("fill-pattern"), t, l, n, i, r, a).draw(t.context, s.TRIANGLES, n.id, o.layoutVertexBuffer, o.indexBuffer, o.segments, l) } function vn(t, e, n, i, r, o, a) { var s = t.context.gl, l = o.programConfigurations.get(n.id), a = _n("fillOutline", n.getPaintProperty("fill-outline-color") ? null : n.paint.get("fill-pattern"), t, l, n, i, r, a); s.uniform2f(a.uniforms.u_world, s.drawingBufferWidth, s.drawingBufferHeight), a.draw(t.context, s.LINES, n.id, o.layoutVertexBuffer, o.indexBuffer2, o.segments2, l) } function _n(t, e, n, i, r, o, a, s) { var l, u = n.context.program.get(); return e ? (l = n.useProgram(t + "Pattern", i), !s && l.program === u || (i.setUniforms(n.context, l, r.paint, { zoom: n.transform.zoom }), dn(e, n, l)), mn(o, n, l)) : (l = n.useProgram(t, i), !s && l.program === u || i.setUniforms(n.context, l, r.paint, { zoom: n.transform.zoom })), n.context.gl.uniformMatrix4fv(l.uniforms.u_matrix, !1, n.translatePosMatrix(a.posMatrix, o, r.paint.get("fill-translate"), r.paint.get("fill-translate-anchor"))), l } function xn(t, e) { this.context = new Ht(t), this.transform = e, this._tileTextures = {}, this.setup(), this.numSublayers = Jt.maxUnderzooming + Jt.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.depthRboNeedsClear = !0, this.emptyProgramConfiguration = new D.ProgramConfiguration, this.crossTileSymbolIndex = new We } var bn = { " ": [16, []], "!": [10, [5, 21, 5, 7, -1, -1, 5, 2, 4, 1, 5, 0, 6, 1, 5, 2]], '"': [16, [4, 21, 4, 14, -1, -1, 12, 21, 12, 14]], "#": [21, [11, 25, 4, -7, -1, -1, 17, 25, 10, -7, -1, -1, 4, 12, 18, 12, -1, -1, 3, 6, 17, 6]], $: [20, [8, 25, 8, -4, -1, -1, 12, 25, 12, -4, -1, -1, 17, 18, 15, 20, 12, 21, 8, 21, 5, 20, 3, 18, 3, 16, 4, 14, 5, 13, 7, 12, 13, 10, 15, 9, 16, 8, 17, 6, 17, 3, 15, 1, 12, 0, 8, 0, 5, 1, 3, 3]], "%": [24, [21, 21, 3, 0, -1, -1, 8, 21, 10, 19, 10, 17, 9, 15, 7, 14, 5, 14, 3, 16, 3, 18, 4, 20, 6, 21, 8, 21, 10, 20, 13, 19, 16, 19, 19, 20, 21, 21, -1, -1, 17, 7, 15, 6, 14, 4, 14, 2, 16, 0, 18, 0, 20, 1, 21, 3, 21, 5, 19, 7, 17, 7]], "&": [26, [23, 12, 23, 13, 22, 14, 21, 14, 20, 13, 19, 11, 17, 6, 15, 3, 13, 1, 11, 0, 7, 0, 5, 1, 4, 2, 3, 4, 3, 6, 4, 8, 5, 9, 12, 13, 13, 14, 14, 16, 14, 18, 13, 20, 11, 21, 9, 20, 8, 18, 8, 16, 9, 13, 11, 10, 16, 3, 18, 1, 20, 0, 22, 0, 23, 1, 23, 2]], "'": [10, [5, 19, 4, 20, 5, 21, 6, 20, 6, 18, 5, 16, 4, 15]], "(": [14, [11, 25, 9, 23, 7, 20, 5, 16, 4, 11, 4, 7, 5, 2, 7, -2, 9, -5, 11, -7]], ")": [14, [3, 25, 5, 23, 7, 20, 9, 16, 10, 11, 10, 7, 9, 2, 7, -2, 5, -5, 3, -7]], "*": [16, [8, 21, 8, 9, -1, -1, 3, 18, 13, 12, -1, -1, 13, 18, 3, 12]], "+": [26, [13, 18, 13, 0, -1, -1, 4, 9, 22, 9]], ",": [10, [6, 1, 5, 0, 4, 1, 5, 2, 6, 1, 6, -1, 5, -3, 4, -4]], "-": [26, [4, 9, 22, 9]], ".": [10, [5, 2, 4, 1, 5, 0, 6, 1, 5, 2]], "/": [22, [20, 25, 2, -7]], 0: [20, [9, 21, 6, 20, 4, 17, 3, 12, 3, 9, 4, 4, 6, 1, 9, 0, 11, 0, 14, 1, 16, 4, 17, 9, 17, 12, 16, 17, 14, 20, 11, 21, 9, 21]], 1: [20, [6, 17, 8, 18, 11, 21, 11, 0]], 2: [20, [4, 16, 4, 17, 5, 19, 6, 20, 8, 21, 12, 21, 14, 20, 15, 19, 16, 17, 16, 15, 15, 13, 13, 10, 3, 0, 17, 0]], 3: [20, [5, 21, 16, 21, 10, 13, 13, 13, 15, 12, 16, 11, 17, 8, 17, 6, 16, 3, 14, 1, 11, 0, 8, 0, 5, 1, 4, 2, 3, 4]], 4: [20, [13, 21, 3, 7, 18, 7, -1, -1, 13, 21, 13, 0]], 5: [20, [15, 21, 5, 21, 4, 12, 5, 13, 8, 14, 11, 14, 14, 13, 16, 11, 17, 8, 17, 6, 16, 3, 14, 1, 11, 0, 8, 0, 5, 1, 4, 2, 3, 4]], 6: [20, [16, 18, 15, 20, 12, 21, 10, 21, 7, 20, 5, 17, 4, 12, 4, 7, 5, 3, 7, 1, 10, 0, 11, 0, 14, 1, 16, 3, 17, 6, 17, 7, 16, 10, 14, 12, 11, 13, 10, 13, 7, 12, 5, 10, 4, 7]], 7: [20, [17, 21, 7, 0, -1, -1, 3, 21, 17, 21]], 8: [20, [8, 21, 5, 20, 4, 18, 4, 16, 5, 14, 7, 13, 11, 12, 14, 11, 16, 9, 17, 7, 17, 4, 16, 2, 15, 1, 12, 0, 8, 0, 5, 1, 4, 2, 3, 4, 3, 7, 4, 9, 6, 11, 9, 12, 13, 13, 15, 14, 16, 16, 16, 18, 15, 20, 12, 21, 8, 21]], 9: [20, [16, 14, 15, 11, 13, 9, 10, 8, 9, 8, 6, 9, 4, 11, 3, 14, 3, 15, 4, 18, 6, 20, 9, 21, 10, 21, 13, 20, 15, 18, 16, 14, 16, 9, 15, 4, 13, 1, 10, 0, 8, 0, 5, 1, 4, 3]], ":": [10, [5, 14, 4, 13, 5, 12, 6, 13, 5, 14, -1, -1, 5, 2, 4, 1, 5, 0, 6, 1, 5, 2]], ";": [10, [5, 14, 4, 13, 5, 12, 6, 13, 5, 14, -1, -1, 6, 1, 5, 0, 4, 1, 5, 2, 6, 1, 6, -1, 5, -3, 4, -4]], "<": [24, [20, 18, 4, 9, 20, 0]], "=": [26, [4, 12, 22, 12, -1, -1, 4, 6, 22, 6]], ">": [24, [4, 18, 20, 9, 4, 0]], "?": [18, [3, 16, 3, 17, 4, 19, 5, 20, 7, 21, 11, 21, 13, 20, 14, 19, 15, 17, 15, 15, 14, 13, 13, 12, 9, 10, 9, 7, -1, -1, 9, 2, 8, 1, 9, 0, 10, 1, 9, 2]], "@": [27, [18, 13, 17, 15, 15, 16, 12, 16, 10, 15, 9, 14, 8, 11, 8, 8, 9, 6, 11, 5, 14, 5, 16, 6, 17, 8, -1, -1, 12, 16, 10, 14, 9, 11, 9, 8, 10, 6, 11, 5, -1, -1, 18, 16, 17, 8, 17, 6, 19, 5, 21, 5, 23, 7, 24, 10, 24, 12, 23, 15, 22, 17, 20, 19, 18, 20, 15, 21, 12, 21, 9, 20, 7, 19, 5, 17, 4, 15, 3, 12, 3, 9, 4, 6, 5, 4, 7, 2, 9, 1, 12, 0, 15, 0, 18, 1, 20, 2, 21, 3, -1, -1, 19, 16, 18, 8, 18, 6, 19, 5]], A: [18, [9, 21, 1, 0, -1, -1, 9, 21, 17, 0, -1, -1, 4, 7, 14, 7]], B: [21, [4, 21, 4, 0, -1, -1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 15, 17, 13, 16, 12, 13, 11, -1, -1, 4, 11, 13, 11, 16, 10, 17, 9, 18, 7, 18, 4, 17, 2, 16, 1, 13, 0, 4, 0]], C: [21, [18, 16, 17, 18, 15, 20, 13, 21, 9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5]], D: [21, [4, 21, 4, 0, -1, -1, 4, 21, 11, 21, 14, 20, 16, 18, 17, 16, 18, 13, 18, 8, 17, 5, 16, 3, 14, 1, 11, 0, 4, 0]], E: [19, [4, 21, 4, 0, -1, -1, 4, 21, 17, 21, -1, -1, 4, 11, 12, 11, -1, -1, 4, 0, 17, 0]], F: [18, [4, 21, 4, 0, -1, -1, 4, 21, 17, 21, -1, -1, 4, 11, 12, 11]], G: [21, [18, 16, 17, 18, 15, 20, 13, 21, 9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 18, 8, -1, -1, 13, 8, 18, 8]], H: [22, [4, 21, 4, 0, -1, -1, 18, 21, 18, 0, -1, -1, 4, 11, 18, 11]], I: [8, [4, 21, 4, 0]], J: [16, [12, 21, 12, 5, 11, 2, 10, 1, 8, 0, 6, 0, 4, 1, 3, 2, 2, 5, 2, 7]], K: [21, [4, 21, 4, 0, -1, -1, 18, 21, 4, 7, -1, -1, 9, 12, 18, 0]], L: [17, [4, 21, 4, 0, -1, -1, 4, 0, 16, 0]], M: [24, [4, 21, 4, 0, -1, -1, 4, 21, 12, 0, -1, -1, 20, 21, 12, 0, -1, -1, 20, 21, 20, 0]], N: [22, [4, 21, 4, 0, -1, -1, 4, 21, 18, 0, -1, -1, 18, 21, 18, 0]], O: [22, [9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 19, 8, 19, 13, 18, 16, 17, 18, 15, 20, 13, 21, 9, 21]], P: [21, [4, 21, 4, 0, -1, -1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 14, 17, 12, 16, 11, 13, 10, 4, 10]], Q: [22, [9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 19, 8, 19, 13, 18, 16, 17, 18, 15, 20, 13, 21, 9, 21, -1, -1, 12, 4, 18, -2]], R: [21, [4, 21, 4, 0, -1, -1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 15, 17, 13, 16, 12, 13, 11, 4, 11, -1, -1, 11, 11, 18, 0]], S: [20, [17, 18, 15, 20, 12, 21, 8, 21, 5, 20, 3, 18, 3, 16, 4, 14, 5, 13, 7, 12, 13, 10, 15, 9, 16, 8, 17, 6, 17, 3, 15, 1, 12, 0, 8, 0, 5, 1, 3, 3]], T: [16, [8, 21, 8, 0, -1, -1, 1, 21, 15, 21]], U: [22, [4, 21, 4, 6, 5, 3, 7, 1, 10, 0, 12, 0, 15, 1, 17, 3, 18, 6, 18, 21]], V: [18, [1, 21, 9, 0, -1, -1, 17, 21, 9, 0]], W: [24, [2, 21, 7, 0, -1, -1, 12, 21, 7, 0, -1, -1, 12, 21, 17, 0, -1, -1, 22, 21, 17, 0]], X: [20, [3, 21, 17, 0, -1, -1, 17, 21, 3, 0]], Y: [18, [1, 21, 9, 11, 9, 0, -1, -1, 17, 21, 9, 11]], Z: [20, [17, 21, 3, 0, -1, -1, 3, 21, 17, 21, -1, -1, 3, 0, 17, 0]], "[": [14, [4, 25, 4, -7, -1, -1, 5, 25, 5, -7, -1, -1, 4, 25, 11, 25, -1, -1, 4, -7, 11, -7]], "\\": [14, [0, 21, 14, -3]], "]": [14, [9, 25, 9, -7, -1, -1, 10, 25, 10, -7, -1, -1, 3, 25, 10, 25, -1, -1, 3, -7, 10, -7]], "^": [16, [6, 15, 8, 18, 10, 15, -1, -1, 3, 12, 8, 17, 13, 12, -1, -1, 8, 17, 8, 0]], _: [16, [0, -2, 16, -2]], "`": [10, [6, 21, 5, 20, 4, 18, 4, 16, 5, 15, 6, 16, 5, 17]], a: [19, [15, 14, 15, 0, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]], b: [19, [4, 21, 4, 0, -1, -1, 4, 11, 6, 13, 8, 14, 11, 14, 13, 13, 15, 11, 16, 8, 16, 6, 15, 3, 13, 1, 11, 0, 8, 0, 6, 1, 4, 3]], c: [18, [15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]], d: [19, [15, 21, 15, 0, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]], e: [18, [3, 8, 15, 8, 15, 10, 14, 12, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]], f: [12, [10, 21, 8, 21, 6, 20, 5, 17, 5, 0, -1, -1, 2, 14, 9, 14]], g: [19, [15, 14, 15, -2, 14, -5, 13, -6, 11, -7, 8, -7, 6, -6, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]], h: [19, [4, 21, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0]], i: [8, [3, 21, 4, 20, 5, 21, 4, 22, 3, 21, -1, -1, 4, 14, 4, 0]], j: [10, [5, 21, 6, 20, 7, 21, 6, 22, 5, 21, -1, -1, 6, 14, 6, -3, 5, -6, 3, -7, 1, -7]], k: [17, [4, 21, 4, 0, -1, -1, 14, 14, 4, 4, -1, -1, 8, 8, 15, 0]], l: [8, [4, 21, 4, 0]], m: [30, [4, 14, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0, -1, -1, 15, 10, 18, 13, 20, 14, 23, 14, 25, 13, 26, 10, 26, 0]], n: [19, [4, 14, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0]], o: [19, [8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3, 16, 6, 16, 8, 15, 11, 13, 13, 11, 14, 8, 14]], p: [19, [4, 14, 4, -7, -1, -1, 4, 11, 6, 13, 8, 14, 11, 14, 13, 13, 15, 11, 16, 8, 16, 6, 15, 3, 13, 1, 11, 0, 8, 0, 6, 1, 4, 3]], q: [19, [15, 14, 15, -7, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]], r: [13, [4, 14, 4, 0, -1, -1, 4, 8, 5, 11, 7, 13, 9, 14, 12, 14]], s: [17, [14, 11, 13, 13, 10, 14, 7, 14, 4, 13, 3, 11, 4, 9, 6, 8, 11, 7, 13, 6, 14, 4, 14, 3, 13, 1, 10, 0, 7, 0, 4, 1, 3, 3]], t: [12, [5, 21, 5, 4, 6, 1, 8, 0, 10, 0, -1, -1, 2, 14, 9, 14]], u: [19, [4, 14, 4, 4, 5, 1, 7, 0, 10, 0, 12, 1, 15, 4, -1, -1, 15, 14, 15, 0]], v: [16, [2, 14, 8, 0, -1, -1, 14, 14, 8, 0]], w: [22, [3, 14, 7, 0, -1, -1, 11, 14, 7, 0, -1, -1, 11, 14, 15, 0, -1, -1, 19, 14, 15, 0]], x: [17, [3, 14, 14, 0, -1, -1, 14, 14, 3, 0]], y: [16, [2, 14, 8, 0, -1, -1, 14, 14, 8, 0, 6, -4, 4, -6, 2, -7, 1, -7]], z: [17, [14, 14, 3, 0, -1, -1, 3, 14, 14, 14, -1, -1, 3, 0, 14, 0]], "{": [14, [9, 25, 7, 24, 6, 23, 5, 21, 5, 19, 6, 17, 7, 16, 8, 14, 8, 12, 6, 10, -1, -1, 7, 24, 6, 22, 6, 20, 7, 18, 8, 17, 9, 15, 9, 13, 8, 11, 4, 9, 8, 7, 9, 5, 9, 3, 8, 1, 7, 0, 6, -2, 6, -4, 7, -6, -1, -1, 6, 8, 8, 6, 8, 4, 7, 2, 6, 1, 5, -1, 5, -3, 6, -5, 7, -6, 9, -7]], "|": [8, [4, 25, 4, -7]], "}": [14, [5, 25, 7, 24, 8, 23, 9, 21, 9, 19, 8, 17, 7, 16, 6, 14, 6, 12, 8, 10, -1, -1, 7, 24, 8, 22, 8, 20, 7, 18, 6, 17, 5, 15, 5, 13, 6, 11, 10, 9, 6, 7, 5, 5, 5, 3, 6, 1, 7, 0, 8, -2, 8, -4, 7, -6, -1, -1, 8, 8, 6, 6, 6, 4, 7, 2, 8, 1, 9, -1, 9, -3, 8, -5, 7, -6, 5, -7]], "~": [24, [3, 6, 3, 8, 4, 11, 6, 12, 8, 12, 10, 11, 14, 8, 16, 7, 18, 7, 20, 8, 21, 10, -1, -1, 3, 8, 4, 10, 6, 11, 8, 11, 10, 10, 14, 7, 16, 6, 18, 6, 20, 7, 21, 10, 21, 12]] }, wn = { symbol: function (t, e, n, i) { var r; "translucent" === t.renderPass && ((r = t.context).setStencilMode(Xt.disabled), r.setColorMode(t.colorModeForRenderPass()), 0 !== n.paint.get("icon-opacity").constantOr(1) && hn(t, e, n, i, !1, n.paint.get("icon-translate"), n.paint.get("icon-translate-anchor"), n.layout.get("icon-rotation-alignment"), n.layout.get("icon-pitch-alignment"), n.layout.get("icon-keep-upright")), 0 !== n.paint.get("text-opacity").constantOr(1) && hn(t, e, n, i, !0, n.paint.get("text-translate"), n.paint.get("text-translate-anchor"), n.layout.get("text-rotation-alignment"), n.layout.get("text-pitch-alignment"), n.layout.get("text-keep-upright")), e.map.showCollisionBoxes && (ln(t = t, e = e, n = n, i = i, !1), ln(t, e, n, i, !0))) }, circle: function (t, e, n, i) { if ("translucent" === t.renderPass) { var r = n.paint.get("circle-opacity"), o = n.paint.get("circle-stroke-width"), a = n.paint.get("circle-stroke-opacity"); if (0 !== r.constantOr(1) || 0 !== o.constantOr(1) && 0 !== a.constantOr(1)) { var s = t.context, l = s.gl; s.setDepthMode(t.depthModeForSublayer(0, Gt.ReadOnly)), s.setStencilMode(Xt.disabled), s.setColorMode(t.colorModeForRenderPass()); for (var u = !0, c = 0; c < i.length; c++) { var h, p, f, d = i[c], m = e.getTile(d), y = m.getBucket(n); y && (f = t.context.program.get(), h = y.programConfigurations.get(n.id), p = t.useProgram("circle", h), !u && p.program === f || (h.setUniforms(s, p, n.paint, { zoom: t.transform.zoom }), u = !1), l.uniform1f(p.uniforms.u_camera_to_center_distance, t.transform.cameraToCenterDistance), l.uniform1i(p.uniforms.u_scale_with_map, "map" === n.paint.get("circle-pitch-scale") ? 1 : 0), "map" === n.paint.get("circle-pitch-alignment") ? (l.uniform1i(p.uniforms.u_pitch_with_map, 1), f = Ae(m, 1, t.transform.zoom), l.uniform2f(p.uniforms.u_extrude_scale, f, f)) : (l.uniform1i(p.uniforms.u_pitch_with_map, 0), l.uniform2fv(p.uniforms.u_extrude_scale, t.transform.pixelsToGLUnits)), l.uniformMatrix4fv(p.uniforms.u_matrix, !1, t.translatePosMatrix(d.posMatrix, m, n.paint.get("circle-translate"), n.paint.get("circle-translate-anchor"))), p.draw(s, l.TRIANGLES, n.id, y.layoutVertexBuffer, y.indexBuffer, y.segments, h)) } } } }, heatmap: function (t, e, n, i) { if (0 !== n.paint.get("heatmap-opacity")) if ("offscreen" === t.renderPass) { var r = t.context, o = r.gl; r.setDepthMode(t.depthModeForSublayer(0, Gt.ReadOnly)), r.setStencilMode(Xt.disabled), function (t, e, n) { var i = t.gl; t.activeTexture.set(i.TEXTURE1), t.viewport.set([0, 0, e.width / 4, e.height / 4]); var r, o = n.heatmapFbo; o ? (i.bindTexture(i.TEXTURE_2D, o.colorAttachment.get()), t.bindFramebuffer.set(o.framebuffer)) : (r = i.createTexture(), i.bindTexture(i.TEXTURE_2D, r), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.LINEAR), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, i.LINEAR), o = n.heatmapFbo = t.createFramebuffer(e.width / 4, e.height / 4), function t(e, n, i, r) { var o = e.gl; o.texImage2D(o.TEXTURE_2D, 0, o.RGBA, n.width / 4, n.height / 4, 0, o.RGBA, e.extTextureHalfFloat ? e.extTextureHalfFloat.HALF_FLOAT_OES : o.UNSIGNED_BYTE, null), r.colorAttachment.set(i), e.extTextureHalfFloat && o.checkFramebufferStatus(o.FRAMEBUFFER) !== o.FRAMEBUFFER_COMPLETE && (e.extTextureHalfFloat = null, r.colorAttachment.setDirty(), t(e, n, i, r)) }(t, e, r, o)) }(r, t, n), r.clear({ color: D.Color.transparent }), r.setColorMode(new Wt([o.ONE, o.ONE], D.Color.transparent, [!0, !0, !0, !0])); for (var a = !0, s = 0; s < i.length; s++) { var l, u, c, h, p, f, d = i[s]; e.hasRenderableParent(d) || (u = (l = e.getTile(d)).getBucket(n)) && (c = t.context.program.get(), h = u.programConfigurations.get(n.id), p = t.useProgram("heatmap", h), f = t.transform.zoom, !a && p.program === c || (h.setUniforms(t.context, p, n.paint, { zoom: f }), a = !1), o.uniform1f(p.uniforms.u_extrude_scale, Ae(l, 1, f)), o.uniform1f(p.uniforms.u_intensity, n.paint.get("heatmap-intensity")), o.uniformMatrix4fv(p.uniforms.u_matrix, !1, d.posMatrix), p.draw(r, o.TRIANGLES, n.id, u.layoutVertexBuffer, u.indexBuffer, u.segments, h)) } r.viewport.set([0, 0, t.width, t.height]) } else "translucent" === t.renderPass && (t.context.setColorMode(t.colorModeForRenderPass()), y = n, g = (m = t).context, v = g.gl, (_ = y.heatmapFbo) && (g.activeTexture.set(v.TEXTURE0), v.bindTexture(v.TEXTURE_2D, _.colorAttachment.get()), g.activeTexture.set(v.TEXTURE1), (y.colorRampTexture || (y.colorRampTexture = new D.Texture(g, y.colorRamp, v.RGBA))).bind(v.LINEAR, v.CLAMP_TO_EDGE), g.setDepthMode(Gt.disabled), g.setStencilMode(Xt.disabled), g = m.useProgram("heatmapTexture"), y = y.paint.get("heatmap-opacity"), v.uniform1f(g.uniforms.u_opacity, y), v.uniform1i(g.uniforms.u_image, 0), v.uniform1i(g.uniforms.u_color_ramp, 1), y = D.create(), D.ortho(y, 0, m.width, m.height, 0, 0, 1), v.uniformMatrix4fv(g.uniforms.u_matrix, !1, y), v.uniform2f(g.uniforms.u_world, v.drawingBufferWidth, v.drawingBufferHeight), m.viewportVAO.bind(m.context, g, m.viewportBuffer, []), v.drawArrays(v.TRIANGLE_STRIP, 0, 4))); var m, y, g, v, _ }, line: function (t, e, n, i) { if ("translucent" === t.renderPass) { var r = n.paint.get("line-opacity"), o = n.paint.get("line-width"); if (0 !== r.constantOr(1) && 0 !== o.constantOr(1)) { o = t.context; o.setDepthMode(t.depthModeForSublayer(0, Gt.ReadOnly)), o.setColorMode(t.colorModeForRenderPass()); for (var a, s = n.paint.get("line-dasharray") ? "lineSDF" : n.paint.get("line-pattern") ? "linePattern" : n.paint.get("line-gradient") ? "lineGradient" : "line", l = !0, u = 0, c = i; u < c.length; u += 1) { var h, p, f, d, m = c[u], y = e.getTile(m), g = y.getBucket(n); g && (h = g.programConfigurations.get(n.id), d = t.context.program.get(), p = t.useProgram(s, h), f = l || p.program !== d, d = a !== y.tileID.overscaledZ, f && h.setUniforms(t.context, p, n.paint, { zoom: t.transform.zoom }), function (t, e, n, i, r, o, a, s, l) { var u, c, h, p, f = e.context, d = f.gl, m = r.paint.get("line-dasharray"), y = r.paint.get("line-pattern"); if (s || l) { var g = 1 / Ae(n, 1, e.transform.tileZoom); if (m) { u = e.lineAtlas.getDash(m.from, "round" === r.layout.get("line-cap")), c = e.lineAtlas.getDash(m.to, "round" === r.layout.get("line-cap")); var l = u.width * m.fromScale, v = c.width * m.toScale; d.uniform2f(t.uniforms.u_patternscale_a, g / l, -u.height / 2), d.uniform2f(t.uniforms.u_patternscale_b, g / v, -c.height / 2), d.uniform1f(t.uniforms.u_sdfgamma, e.lineAtlas.width / (256 * Math.min(l, v) * D.browser.devicePixelRatio) / 2) } else if (y) { if (h = e.imageManager.getPattern(y.from), p = e.imageManager.getPattern(y.to), !h || !p) return; d.uniform2f(t.uniforms.u_pattern_size_a, h.displaySize[0] * y.fromScale / g, h.displaySize[1]), d.uniform2f(t.uniforms.u_pattern_size_b, p.displaySize[0] * y.toScale / g, p.displaySize[1]); v = e.imageManager.getPixelSize(), g = v.width, v = v.height; d.uniform2fv(t.uniforms.u_texsize, [g, v]) } d.uniform2f(t.uniforms.u_gl_units_to_pixels, 1 / e.transform.pixelsToGLUnits[0], 1 / e.transform.pixelsToGLUnits[1]) } if (s && (m ? (d.uniform1i(t.uniforms.u_image, 0), f.activeTexture.set(d.TEXTURE0), e.lineAtlas.bind(f), d.uniform1f(t.uniforms.u_tex_y_a, u.y), d.uniform1f(t.uniforms.u_tex_y_b, c.y), d.uniform1f(t.uniforms.u_mix, m.t)) : y && (d.uniform1i(t.uniforms.u_image, 0), f.activeTexture.set(d.TEXTURE0), e.imageManager.bind(f), d.uniform2fv(t.uniforms.u_pattern_tl_a, h.tl), d.uniform2fv(t.uniforms.u_pattern_br_a, h.br), d.uniform2fv(t.uniforms.u_pattern_tl_b, p.tl), d.uniform2fv(t.uniforms.u_pattern_br_b, p.br), d.uniform1f(t.uniforms.u_fade, y.t))), f.setStencilMode(e.stencilModeForClipping(o)), o = e.translatePosMatrix(o.posMatrix, n, r.paint.get("line-translate"), r.paint.get("line-translate-anchor")), d.uniformMatrix4fv(t.uniforms.u_matrix, !1, o), d.uniform1f(t.uniforms.u_ratio, 1 / Ae(n, 1, e.transform.zoom)), r.paint.get("line-gradient")) { f.activeTexture.set(d.TEXTURE0); e = r.gradientTexture; if (!r.gradient) return; (e = e || (r.gradientTexture = new D.Texture(f, r.gradient, d.RGBA))).bind(d.LINEAR, d.CLAMP_TO_EDGE), d.uniform1i(t.uniforms.u_image, 0) } t.draw(f, d.TRIANGLES, r.id, i.layoutVertexBuffer, i.indexBuffer, i.segments, a) }(p, t, y, g, n, m, h, f, d), a = y.tileID.overscaledZ, l = !1) } } } }, fill: function (t, e, n, i) { var r, o = n.paint.get("fill-color"), a = n.paint.get("fill-opacity"); 0 !== a.constantOr(1) && ((r = t.context).setColorMode(t.colorModeForRenderPass()), a = n.paint.get("fill-pattern") || 1 !== o.constantOr(D.Color.transparent).a || 1 !== a.constantOr(0) ? "translucent" : "opaque", t.renderPass === a && (r.setDepthMode(t.depthModeForSublayer(1, "opaque" === t.renderPass ? Gt.ReadWrite : Gt.ReadOnly)), yn(t, e, n, i, gn)), "translucent" === t.renderPass && n.paint.get("fill-antialias") && (r.setDepthMode(t.depthModeForSublayer(n.getPaintProperty("fill-outline-color") ? 2 : 0, Gt.ReadOnly)), yn(t, e, n, i, vn))) }, "fill-extrusion": function (t, e, n, i) { if (0 !== n.paint.get("fill-extrusion-opacity")) if ("offscreen" === t.renderPass) { h = n, f = (c = t).context, d = f.gl, m = h.viewportFrame, c.depthRboNeedsClear && c.setupOffscreenDepthRenderbuffer(), m || ((p = new D.Texture(f, { width: c.width, height: c.height, data: null }, d.RGBA)).bind(d.LINEAR, d.CLAMP_TO_EDGE), (m = h.viewportFrame = f.createFramebuffer(c.width, c.height)).colorAttachment.set(p.texture)), f.bindFramebuffer.set(m.framebuffer), m.depthAttachment.set(c.depthRbo), c.depthRboNeedsClear && (f.clear({ depth: 1 }), c.depthRboNeedsClear = !1), f.clear({ color: D.Color.transparent }), f.setStencilMode(Xt.disabled), f.setDepthMode(new Gt(d.LEQUAL, Gt.ReadWrite, [0, 1])), f.setColorMode(c.colorModeForRenderPass()); for (var r = !0, o = 0, a = i; o < a.length; o += 1) { var s = a[o], l = e.getTile(s), u = l.getBucket(n); u && (function (t, e, n, i, r, o) { var a = t.context, s = a.gl, l = e.paint.get("fill-extrusion-pattern"), u = t.context.program.get(), c = r.programConfigurations.get(e.id), h = t.useProgram(l ? "fillExtrusionPattern" : "fillExtrusion", c); if (!o && h.program === u || c.setUniforms(a, h, e.paint, { zoom: t.transform.zoom }), l) { if (fn(l, t)) return; dn(l, t, h), mn(n, t, h), s.uniform1f(h.uniforms.u_height_factor, -Math.pow(2, i.overscaledZ) / n.tileSize / 8) } t.context.gl.uniformMatrix4fv(h.uniforms.u_matrix, !1, t.translatePosMatrix(i.posMatrix, n, e.paint.get("fill-extrusion-translate"), e.paint.get("fill-extrusion-translate-anchor"))), function (t, e) { var n = e.context.gl, i = e.style.light, r = i.properties.get("position"), o = [r.x, r.y, r.z], r = D.create$2(); "viewport" === i.properties.get("anchor") && D.fromRotation(r, -e.transform.angle), D.transformMat3(o, o, r); r = i.properties.get("color"); n.uniform3fv(t.uniforms.u_lightpos, o), n.uniform1f(t.uniforms.u_lightintensity, i.properties.get("intensity")), n.uniform3f(t.uniforms.u_lightcolor, r.r, r.g, r.b) }(h, t), h.draw(a, s.TRIANGLES, e.id, r.layoutVertexBuffer, r.indexBuffer, r.segments, c) }(t, n, l, s, u, r), r = !1) } } else "translucent" === t.renderPass && (p = t, (d = (m = n).viewportFrame) && (c = (f = p.context).gl, i = p.useProgram("extrusionTexture"), f.setStencilMode(Xt.disabled), f.setDepthMode(Gt.disabled), f.setColorMode(p.colorModeForRenderPass()), f.activeTexture.set(c.TEXTURE0), c.bindTexture(c.TEXTURE_2D, d.colorAttachment.get()), c.uniform1f(i.uniforms.u_opacity, m.paint.get("fill-extrusion-opacity")), c.uniform1i(i.uniforms.u_image, 0), m = D.create(), D.ortho(m, 0, p.width, p.height, 0, 0, 1), c.uniformMatrix4fv(i.uniforms.u_matrix, !1, m), c.uniform2f(i.uniforms.u_world, c.drawingBufferWidth, c.drawingBufferHeight), p.viewportVAO.bind(f, i, p.viewportBuffer, []), c.drawArrays(c.TRIANGLE_STRIP, 0, 4))); var c, h, p, f, d, m }, hillshade: function (t, e, n, i) { if ("offscreen" === t.renderPass || "translucent" === t.renderPass) { var r = t.context, o = e.getSource().maxzoom; r.setDepthMode(t.depthModeForSublayer(0, Gt.ReadOnly)), r.setStencilMode(Xt.disabled), r.setColorMode(t.colorModeForRenderPass()); for (var a = 0, s = i; a < s.length; a += 1) { var l = s[a], u = e.getTile(l); u.needsHillshadePrepare && "offscreen" === t.renderPass ? (p = u, f = o, _ = v = g = y = m = d = void 0, v = (h = t).context, _ = v.gl, p.dem && p.dem.data && (d = p.dem.dim, g = p.dem.getPixels(), v.activeTexture.set(_.TEXTURE1), v.pixelStoreUnpackPremultiplyAlpha.set(!1), p.demTexture = p.demTexture || h.getTileTexture(p.tileSize), p.demTexture ? ((m = p.demTexture).update(g, { premultiply: !1 }), m.bind(_.NEAREST, _.CLAMP_TO_EDGE)) : (p.demTexture = new D.Texture(v, g, _.RGBA, { premultiply: !1 }), p.demTexture.bind(_.NEAREST, _.CLAMP_TO_EDGE)), v.activeTexture.set(_.TEXTURE0), (g = p.fbo) || ((y = new D.Texture(v, { width: d, height: d, data: null }, _.RGBA)).bind(_.LINEAR, _.CLAMP_TO_EDGE), (g = p.fbo = v.createFramebuffer(d, d)).colorAttachment.set(y.texture)), v.bindFramebuffer.set(g.framebuffer), v.viewport.set([0, 0, d, d]), y = D.create(), D.ortho(y, 0, D.EXTENT, -D.EXTENT, 0, 0, 1), D.translate(y, y, [0, -D.EXTENT, 0]), g = h.useProgram("hillshadePrepare"), _.uniformMatrix4fv(g.uniforms.u_matrix, !1, y), _.uniform1f(g.uniforms.u_zoom, p.tileID.overscaledZ), _.uniform2fv(g.uniforms.u_dimension, [2 * d, 2 * d]), _.uniform1i(g.uniforms.u_image, 1), _.uniform1f(g.uniforms.u_maxzoom, f), f = h.rasterBoundsBuffer, h.rasterBoundsVAO.bind(v, g, f, []), _.drawArrays(_.TRIANGLE_STRIP, 0, f.length), p.needsHillshadePrepare = !1)) : "translucent" === t.renderPass && (c = u, l = n, p = f = _ = g = v = h = d = y = m = void 0, _ = (u = t).context, f = _.gl, (p = c.fbo) && (m = u.useProgram("hillshade"), y = u.transform.calculatePosMatrix(c.tileID.toUnwrapped(), !0), d = m, h = u, g = (v = l).paint.get("hillshade-illumination-direction") * (Math.PI / 180), "viewport" === v.paint.get("hillshade-illumination-anchor") && (g -= h.transform.angle), h.context.gl.uniform2f(d.uniforms.u_light, v.paint.get("hillshade-exaggeration"), g), d = u, v = c.tileID.toCoordinate(), g = new D.Coordinate(v.column, v.row + 1, v.zoom), g = [d.transform.coordinateLocation(v).lat, d.transform.coordinateLocation(g).lat], _.activeTexture.set(f.TEXTURE0), f.bindTexture(f.TEXTURE_2D, p.colorAttachment.get()), f.uniformMatrix4fv(m.uniforms.u_matrix, !1, y), f.uniform2fv(m.uniforms.u_latrange, g), f.uniform1i(m.uniforms.u_image, 0), g = l.paint.get("hillshade-shadow-color"), f.uniform4f(m.uniforms.u_shadow, g.r, g.g, g.b, g.a), g = l.paint.get("hillshade-highlight-color"), f.uniform4f(m.uniforms.u_highlight, g.r, g.g, g.b, g.a), g = l.paint.get("hillshade-accent-color"), f.uniform4f(m.uniforms.u_accent, g.r, g.g, g.b, g.a), c.maskedBoundsBuffer && c.maskedIndexBuffer && c.segments ? m.draw(_, f.TRIANGLES, l.id, c.maskedBoundsBuffer, c.maskedIndexBuffer, c.segments) : (c = u.rasterBoundsBuffer, u.rasterBoundsVAO.bind(_, m, c, []), f.drawArrays(f.TRIANGLE_STRIP, 0, c.length)))) } r.viewport.set([0, 0, t.width, t.height]) } var c, h, p, f, d, m, y, g, v, _ }, raster: function (t, e, n, i) { if ("translucent" === t.renderPass && 0 !== n.paint.get("raster-opacity")) { var r, o = t.context, a = o.gl, s = e.getSource(), l = t.useProgram("raster"); o.setStencilMode(Xt.disabled), o.setColorMode(t.colorModeForRenderPass()), a.uniform1f(l.uniforms.u_brightness_low, n.paint.get("raster-brightness-min")), a.uniform1f(l.uniforms.u_brightness_high, n.paint.get("raster-brightness-max")), a.uniform1f(l.uniforms.u_saturation_factor, 0 < (r = n.paint.get("raster-saturation")) ? 1 - 1 / (1.001 - r) : -r), a.uniform1f(l.uniforms.u_contrast_factor, 0 < (r = n.paint.get("raster-contrast")) ? 1 / (1 - r) : 1 + r), a.uniform3fv(l.uniforms.u_spin_weights, function (t) { t *= Math.PI / 180; var e = Math.sin(t), t = Math.cos(t); return [(2 * t + 1) / 3, (-Math.sqrt(3) * e - t + 1) / 3, (Math.sqrt(3) * e - t + 1) / 3] }(n.paint.get("raster-hue-rotate"))), a.uniform1f(l.uniforms.u_buffer_scale, 1), a.uniform1i(l.uniforms.u_image0, 0), a.uniform1i(l.uniforms.u_image1, 1); for (var u = i.length && i[0].overscaledZ, c = 0, h = i; c < h.length; c += 1) { var p = h[c]; o.setDepthMode(t.depthModeForSublayer(p.overscaledZ - u, 1 === n.paint.get("raster-opacity") ? Gt.ReadWrite : Gt.ReadOnly, a.LESS)); var f = e.getTile(p), d = t.transform.calculatePosMatrix(p.toUnwrapped(), !0); f.registerFadeDuration(n.paint.get("raster-fade-duration")), a.uniformMatrix4fv(l.uniforms.u_matrix, !1, d); var m = e.findLoadedParent(p, 0), y = function (t, e, n, i, r) { if (0 < (a = i.paint.get("raster-fade-duration"))) { var o = D.browser.now(), i = (o - t.timeAdded) / a, a = e ? (o - e.timeAdded) / a : -1, n = n.getSource(), n = r.coveringZoomLevel({ tileSize: n.tileSize, roundZoom: n.roundZoom }), n = !e || Math.abs(e.tileID.overscaledZ - n) > Math.abs(t.tileID.overscaledZ - n), a = n && t.refreshedUponExpiration ? 1 : D.clamp(n ? i : 1 - a, 0, 1); return t.refreshedUponExpiration && 1 <= i && (t.refreshedUponExpiration = !1), e ? { opacity: 1, mix: 1 - a } : { opacity: a, mix: 0 } } return { opacity: 1, mix: 0 } }(f, m, e, n, t.transform), g = void 0, d = void 0, p = "nearest" === n.paint.get("raster-resampling") ? a.NEAREST : a.LINEAR; o.activeTexture.set(a.TEXTURE0), f.texture.bind(p, a.CLAMP_TO_EDGE, a.LINEAR_MIPMAP_NEAREST), o.activeTexture.set(a.TEXTURE1), m ? (m.texture.bind(p, a.CLAMP_TO_EDGE, a.LINEAR_MIPMAP_NEAREST), g = Math.pow(2, m.tileID.overscaledZ - f.tileID.overscaledZ), d = [f.tileID.canonical.x * g % 1, f.tileID.canonical.y * g % 1]) : f.texture.bind(p, a.CLAMP_TO_EDGE, a.LINEAR_MIPMAP_NEAREST), a.uniform2fv(l.uniforms.u_tl_parent, d || [0, 0]), a.uniform1f(l.uniforms.u_scale_parent, g || 1), a.uniform1f(l.uniforms.u_fade_t, y.mix), a.uniform1f(l.uniforms.u_opacity, y.opacity * n.paint.get("raster-opacity")), s instanceof nt ? (y = s.boundsBuffer, s.boundsVAO.bind(o, l, y, []), a.drawArrays(a.TRIANGLE_STRIP, 0, y.length)) : f.maskedBoundsBuffer && f.maskedIndexBuffer && f.segments ? l.draw(o, a.TRIANGLES, n.id, f.maskedBoundsBuffer, f.maskedIndexBuffer, f.segments) : (f = t.rasterBoundsBuffer, t.rasterBoundsVAO.bind(o, l, f, []), a.drawArrays(a.TRIANGLE_STRIP, 0, f.length)) } } }, background: function (t, e, n) { var i = n.paint.get("background-color"), r = n.paint.get("background-opacity"); if (0 !== r) { var o, a = t.context, s = a.gl, l = t.transform, u = l.tileSize, c = n.paint.get("background-pattern"), n = c || 1 !== i.a || 1 !== r ? "translucent" : "opaque"; if (t.renderPass === n) { if (a.setStencilMode(Xt.disabled), a.setDepthMode(t.depthModeForSublayer(0, "opaque" == n ? Gt.ReadWrite : Gt.ReadOnly)), a.setColorMode(t.colorModeForRenderPass()), c) { if (fn(c, t)) return; o = t.useProgram("backgroundPattern"), dn(c, t, o), t.tileExtentPatternVAO.bind(a, o, t.tileExtentBuffer, []) } else o = t.useProgram("background"), s.uniform4f(o.uniforms.u_color, i.r, i.g, i.b, i.a), t.tileExtentVAO.bind(a, o, t.tileExtentBuffer, []); s.uniform1f(o.uniforms.u_opacity, r); for (var h = 0, p = l.coveringTiles({ tileSize: u }); h < p.length; h += 1) { var f = p[h]; c && mn({ tileID: f, tileSize: u }, t, o), s.uniformMatrix4fv(o.uniforms.u_matrix, !1, t.transform.calculatePosMatrix(f.toUnwrapped())), s.drawArrays(s.TRIANGLE_STRIP, 0, t.tileExtentBuffer.length) } } } }, debug: function (t, e, n) { for (var i = 0; i < n.length; i++)!function (t, e, n) { var i = t.context, r = i.gl, o = n.posMatrix, a = t.useProgram("debug"); i.setDepthMode(Gt.disabled), i.setStencilMode(Xt.disabled), i.setColorMode(t.colorModeForRenderPass()), r.uniformMatrix4fv(a.uniforms.u_matrix, !1, o), r.uniform4f(a.uniforms.u_color, 1, 0, 0, 1), t.debugVAO.bind(i, a, t.debugBuffer, []), r.drawArrays(r.LINE_STRIP, 0, t.debugBuffer.length); for (var s = function (t, e) { for (var n, i, r, o, a, s, l = [], u = 0, c = t.length; u < c; u++)if (r = bn[t[u]]) { for (s = null, n = 0, i = r[1].length; n < i; n += 2)s = -1 === r[1][n] && -1 === r[1][n + 1] ? null : (o = e + 5 * r[1][n], a = 200 - 5 * r[1][n + 1], s && l.push(s.x, s.y, o, a), { x: o, y: a }); e += 5 * r[0] } return l }(n.toString(), 50), l = new D.StructArrayLayout2i4, u = 0; u < s.length; u += 2)l.emplaceBack(s[u], s[u + 1]); var c = i.createVertexBuffer(l, en.members); (new H).bind(i, a, c, []), r.uniform4f(a.uniforms.u_color, 1, 1, 1, 1); for (var e = e.getTile(n).tileSize, h = D.EXTENT / (Math.pow(2, t.transform.zoom - n.overscaledZ) * e), p = [[-1, -1], [-1, 1], [1, -1], [1, 1]], f = 0; f < p.length; f++) { var d = p[f]; r.uniformMatrix4fv(a.uniforms.u_matrix, !1, D.translate([], o, [h * d[0], h * d[1], 0])), r.drawArrays(r.LINES, 0, c.length) } r.uniform4f(a.uniforms.u_color, 0, 0, 0, 1), r.uniformMatrix4fv(a.uniforms.u_matrix, !1, o), r.drawArrays(r.LINES, 0, c.length) }(t, e, n[i]) } }; function En(t, e) { var n; return t.row > e.row && (n = t, t = e, e = n), { x0: t.column, y0: t.row, x1: e.column, y1: e.row, dx: e.column - t.column, dy: e.row - t.row } } function Sn(t, e, n, i, r) { var n = Math.max(n, Math.floor(e.y0)), o = Math.min(i, Math.ceil(e.y1)); (t.x0 === e.x0 && t.y0 === e.y0 ? t.x0 + e.dy / t.dy * t.dx < e.x1 : t.x1 - e.dy / t.dy * t.dx < e.x0) && (i = t, t = e, e = i); for (var a = t.dx / t.dy, s = e.dx / e.dy, l = 0 < t.dx, u = e.dx < 0, c = n; c < o; c++) { var h = a * Math.max(0, Math.min(t.dy, c + l - t.y0)) + t.x0, p = s * Math.max(0, Math.min(e.dy, c + u - e.y0)) + e.x0; r(Math.floor(p), Math.ceil(h), c) } } function Tn(t, e, n, i, r, o) { var a, s = En(t, e), e = En(e, n), t = En(n, t); s.dy > e.dy && (a = s, s = e, e = a), s.dy > t.dy && (a = s, s = t, t = a), e.dy > t.dy && (a = e, e = t, t = a), s.dy && Sn(t, s, i, r, o), e.dy && Sn(t, e, i, r, o) } xn.prototype.resize = function (t, e) { var n = this.context.gl; if (this.width = t * D.browser.devicePixelRatio, this.height = e * D.browser.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (var i = 0, r = this.style._order; i < r.length; i += 1) { var o = r[i]; this.style._layers[o].resize() } this.depthRbo && (n.deleteRenderbuffer(this.depthRbo), this.depthRbo = null) }, xn.prototype.setup = function () { var t = this.context, e = new D.StructArrayLayout2i4; e.emplaceBack(0, 0), e.emplaceBack(D.EXTENT, 0), e.emplaceBack(0, D.EXTENT), e.emplaceBack(D.EXTENT, D.EXTENT), this.tileExtentBuffer = t.createVertexBuffer(e, en.members), this.tileExtentVAO = new H, this.tileExtentPatternVAO = new H; e = new D.StructArrayLayout2i4; e.emplaceBack(0, 0), e.emplaceBack(D.EXTENT, 0), e.emplaceBack(D.EXTENT, D.EXTENT), e.emplaceBack(0, D.EXTENT), e.emplaceBack(0, 0), this.debugBuffer = t.createVertexBuffer(e, en.members), this.debugVAO = new H; e = new D.StructArrayLayout4i8; e.emplaceBack(0, 0, 0, 0), e.emplaceBack(D.EXTENT, 0, D.EXTENT, 0), e.emplaceBack(0, D.EXTENT, 0, D.EXTENT), e.emplaceBack(D.EXTENT, D.EXTENT, D.EXTENT, D.EXTENT), this.rasterBoundsBuffer = t.createVertexBuffer(e, D.rasterBoundsAttributes.members), this.rasterBoundsVAO = new H; e = new D.StructArrayLayout2i4; e.emplaceBack(0, 0), e.emplaceBack(1, 0), e.emplaceBack(0, 1), e.emplaceBack(1, 1), this.viewportBuffer = t.createVertexBuffer(e, en.members), this.viewportVAO = new H }, xn.prototype.clearStencil = function () { var t = this.context, e = t.gl; t.setColorMode(Wt.disabled), t.setDepthMode(Gt.disabled), t.setStencilMode(new Xt({ func: e.ALWAYS, mask: 0 }, 0, 255, e.ZERO, e.ZERO, e.ZERO)); var n = D.create(); D.ortho(n, 0, this.width, this.height, 0, 0, 1), D.scale(n, n, [e.drawingBufferWidth, e.drawingBufferHeight, 0]); var i = this.useProgram("clippingMask"); e.uniformMatrix4fv(i.uniforms.u_matrix, !1, n), this.viewportVAO.bind(t, i, this.viewportBuffer, []), e.drawArrays(e.TRIANGLE_STRIP, 0, 4) }, xn.prototype._renderTileClippingMasks = function (t) { var e = this.context, n = e.gl; e.setColorMode(Wt.disabled), e.setDepthMode(Gt.disabled); var i = 1; this._tileClippingMaskIDs = {}; for (var r = 0, o = t; r < o.length; r += 1) { var a = o[r], s = this._tileClippingMaskIDs[a.key] = i++; e.setStencilMode(new Xt({ func: n.ALWAYS, mask: 0 }, s, 255, n.KEEP, n.KEEP, n.REPLACE)); s = this.useProgram("clippingMask"); n.uniformMatrix4fv(s.uniforms.u_matrix, !1, a.posMatrix), this.tileExtentVAO.bind(this.context, s, this.tileExtentBuffer, []), n.drawArrays(n.TRIANGLE_STRIP, 0, this.tileExtentBuffer.length) } }, xn.prototype.stencilModeForClipping = function (t) { var e = this.context.gl; return new Xt({ func: e.EQUAL, mask: 255 }, this._tileClippingMaskIDs[t.key], 0, e.KEEP, e.KEEP, e.REPLACE) }, xn.prototype.colorModeForRenderPass = function () { var t = this.context.gl; return this._showOverdrawInspector ? new Wt([t.CONSTANT_COLOR, t.ONE], new D.Color(1 / 8, 1 / 8, 1 / 8, 0), [!0, !0, !0, !0]) : "opaque" === this.renderPass ? Wt.unblended : Wt.alphaBlended }, xn.prototype.depthModeForSublayer = function (t, e, n) { var i = 1 - ((1 + this.currentLayer) * this.numSublayers + t) * this.depthEpsilon, t = i - 1 + this.depthRange; return new Gt(n || this.context.gl.LEQUAL, e, [t, i]) }, xn.prototype.render = function (t, e) { this.style = t, this.options = e, this.lineAtlas = t.lineAtlas, this.imageManager = t.imageManager, this.glyphManager = t.glyphManager, this.symbolFadeChange = t.placement.symbolFadeChange(D.browser.now()); var n, i = this.style._order, r = this.style.sourceCaches; for (n in r) { var o = r[n]; o.used && o.prepare(this.context) } var a, s, l, u = {}, c = {}, h = {}; for (s in r) { var p = r[s]; u[s] = p.getVisibleCoordinates(), c[s] = u[s].slice().reverse(), h[s] = p.getVisibleCoordinates(!0).reverse() } for (l in r) { var f = r[l], d = f.getSource(); if ("raster" === d.type || "raster-dem" === d.type) { for (var m = [], y = 0, g = u[l]; y < g.length; y += 1) { var v = g[y]; m.push(f.getTile(v)) } sn(m, this.context) } } this.renderPass = "offscreen", this.depthRboNeedsClear = !0; for (var _ = 0, x = i; _ < x.length; _ += 1) { var b = x[_], w = this.style._layers[b]; !w.hasOffscreenPass() || w.isHidden(this.transform.zoom) || (b = c[w.source]).length && this.renderLayer(this, r[w.source], w, b) } for (this.context.bindFramebuffer.set(null), this.context.clear({ color: e.showOverdrawInspector ? D.Color.black : D.Color.transparent, depth: 1 }), this._showOverdrawInspector = e.showOverdrawInspector, this.depthRange = (t._order.length + 2) * this.numSublayers * this.depthEpsilon, this.renderPass = "opaque", this.currentLayer = i.length - 1; 0 <= this.currentLayer; this.currentLayer--) { var E = this.style._layers[i[this.currentLayer]], S = r[E.source], T = u[E.source]; E.source !== a && S && (this.clearStencil(), S.getSource().isTileClipped && this._renderTileClippingMasks(T)), this.renderLayer(this, S, E, T), a = E.source } for (this.renderPass = "translucent", this.currentLayer = 0, a = null; this.currentLayer < i.length; this.currentLayer++) { var A = this.style._layers[i[this.currentLayer]], z = r[A.source], I = ("symbol" === A.type ? h : c)[A.source]; A.source !== a && z && (this.clearStencil(), z.getSource().isTileClipped && this._renderTileClippingMasks(u[A.source])), this.renderLayer(this, z, A, I), a = A.source } if (this.options.showTileBoundaries) for (var k in r) { wn.debug(this, r[k], u[k]); break } }, xn.prototype.setupOffscreenDepthRenderbuffer = function () { var t = this.context; this.depthRbo || (this.depthRbo = t.createRenderbuffer(t.gl.DEPTH_COMPONENT16, this.width, this.height)) }, xn.prototype.renderLayer = function (t, e, n, i) { n.isHidden(this.transform.zoom) || "background" !== n.type && !i.length || (this.id = n.id, wn[n.type](t, e, n, i)) }, xn.prototype.translatePosMatrix = function (t, e, n, i, r) { if (!n[0] && !n[1]) return t; var o = r ? "map" === i ? this.transform.angle : 0 : "viewport" === i ? -this.transform.angle : 0; o && (i = Math.sin(o), o = Math.cos(o), n = [n[0] * o - n[1] * i, n[0] * i + n[1] * o]); e = [r ? n[0] : Ae(e, n[0], this.transform.zoom), r ? n[1] : Ae(e, n[1], this.transform.zoom), 0], n = new Float32Array(16); return D.translate(n, t, e), n }, xn.prototype.saveTileTexture = function (t) { var e = this._tileTextures[t.size[0]]; e ? e.push(t) : this._tileTextures[t.size[0]] = [t] }, xn.prototype.getTileTexture = function (t) { t = this._tileTextures[t]; return t && 0 < t.length ? t.pop() : null }, xn.prototype._createProgramCached = function (t, e) { this.cache = this.cache || {}; var n = "" + t + (e.cacheKey || "") + (this._showOverdrawInspector ? "/overdraw" : ""); return this.cache[n] || (this.cache[n] = new on(this.context, an[t], e, this._showOverdrawInspector)), this.cache[n] }, xn.prototype.useProgram = function (t, e) { e = this._createProgramCached(t, e || this.emptyProgramConfiguration); return this.context.program.set(e.program), e }; function An(t, e, n) { this.tileSize = 512, this.maxValidLatitude = 85.051129, this._renderWorldCopies = void 0 === n || n, this._minZoom = t || 0, this._maxZoom = e || 22, this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new V(0, 0), this.zoom = 0, this.angle = 0, this._fov = .6435011087932844, this._pitch = 0, this._unmodified = !0, this._posMatrixCache = {}, this._alignedPosMatrixCache = {} } W = { minZoom: { configurable: !0 }, maxZoom: { configurable: !0 }, renderWorldCopies: { configurable: !0 }, worldSize: { configurable: !0 }, centerPoint: { configurable: !0 }, size: { configurable: !0 }, bearing: { configurable: !0 }, pitch: { configurable: !0 }, fov: { configurable: !0 }, zoom: { configurable: !0 }, center: { configurable: !0 }, unmodified: { configurable: !0 }, x: { configurable: !0 }, y: { configurable: !0 }, point: { configurable: !0 } }; An.prototype.clone = function () { var t = new An(this._minZoom, this._maxZoom, this._renderWorldCopies); return t.tileSize = this.tileSize, t.latRange = this.latRange, t.width = this.width, t.height = this.height, t._center = this._center, t.zoom = this.zoom, t.angle = this.angle, t._fov = this._fov, t._pitch = this._pitch, t._unmodified = this._unmodified, t._calcMatrices(), t }, W.minZoom.get = function () { return this._minZoom }, W.minZoom.set = function (t) { this._minZoom !== t && (this._minZoom = t, this.zoom = Math.max(this.zoom, t)) }, W.maxZoom.get = function () { return this._maxZoom }, W.maxZoom.set = function (t) { this._maxZoom !== t && (this._maxZoom = t, this.zoom = Math.min(this.zoom, t)) }, W.renderWorldCopies.get = function () { return this._renderWorldCopies }, W.renderWorldCopies.set = function (t) { void 0 === t ? t = !0 : null === t && (t = !1), this._renderWorldCopies = t }, W.worldSize.get = function () { return this.tileSize * this.scale }, W.centerPoint.get = function () { return this.size._div(2) }, W.size.get = function () { return new D.Point(this.width, this.height) }, W.bearing.get = function () { return -this.angle / Math.PI * 180 }, W.bearing.set = function (t) { t = -D.wrap(t, -180, 180) * Math.PI / 180; this.angle !== t && (this._unmodified = !1, this.angle = t, this._calcMatrices(), this.rotationMatrix = D.create$4(), D.rotate(this.rotationMatrix, this.rotationMatrix, this.angle)) }, W.pitch.get = function () { return this._pitch / Math.PI * 180 }, W.pitch.set = function (t) { t = D.clamp(t, 0, 60) / 180 * Math.PI; this._pitch !== t && (this._unmodified = !1, this._pitch = t, this._calcMatrices()) }, W.fov.get = function () { return this._fov / Math.PI * 180 }, W.fov.set = function (t) { t = Math.max(.01, Math.min(60, t)), this._fov !== t && (this._unmodified = !1, this._fov = t / 180 * Math.PI, this._calcMatrices()) }, W.zoom.get = function () { return this._zoom }, W.zoom.set = function (t) { t = Math.min(Math.max(t, this.minZoom), this.maxZoom); this._zoom !== t && (this._unmodified = !1, this._zoom = t, this.scale = this.zoomScale(t), this.tileZoom = Math.floor(t), this.zoomFraction = t - this.tileZoom, this._constrain(), this._calcMatrices()) }, W.center.get = function () { return this._center }, W.center.set = function (t) { t.lat === this._center.lat && t.lng === this._center.lng || (this._unmodified = !1, this._center = t, this._constrain(), this._calcMatrices()) }, An.prototype.coveringZoomLevel = function (t) { return (t.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / t.tileSize)) }, An.prototype.getVisibleUnwrappedCoordinates = function (t) { var e = this.pointCoordinate(new D.Point(0, 0), 0), n = this.pointCoordinate(new D.Point(this.width, 0), 0), e = Math.floor(e.column), i = Math.floor(n.column), r = [new D.UnwrappedTileID(0, t)]; if (this._renderWorldCopies) for (var o = e; o <= i; o++)0 !== o && r.push(new D.UnwrappedTileID(o, t)); return r }, An.prototype.coveringTiles = function (t) { var e = this.coveringZoomLevel(t), n = e; if (void 0 !== t.minzoom && e < t.minzoom) return []; void 0 !== t.maxzoom && e > t.maxzoom && (e = t.maxzoom); var i = this.pointCoordinate(this.centerPoint, e), r = new D.Point(i.column - .5, i.row - .5); return function (a, t, s, l) { void 0 === l && (l = !0); var u = 1 << a, c = {}; function e(t, e, n) { var i, r, o; if (0 <= n && n <= u) for (i = t; i < e; i++)r = Math.floor(i / u), o = (i % u + u) % u, 0 !== r && !0 !== l || (o = new D.OverscaledTileID(s, r, a, o, n), c[o.key] = o) } return Tn(t[0], t[1], t[2], 0, u, e), Tn(t[2], t[3], t[0], 0, u, e), Object.keys(c).map(function (t) { return c[t] }) }(e, [this.pointCoordinate(new D.Point(0, 0), e), this.pointCoordinate(new D.Point(this.width, 0), e), this.pointCoordinate(new D.Point(this.width, this.height), e), this.pointCoordinate(new D.Point(0, this.height), e)], t.reparseOverscaled ? n : e, this._renderWorldCopies).sort(function (t, e) { return r.dist(t.canonical) - r.dist(e.canonical) }) }, An.prototype.resize = function (t, e) { this.width = t, this.height = e, this.pixelsToGLUnits = [2 / t, -2 / e], this._constrain(), this._calcMatrices() }, W.unmodified.get = function () { return this._unmodified }, An.prototype.zoomScale = function (t) { return Math.pow(2, t) }, An.prototype.scaleZoom = function (t) { return Math.log(t) / Math.LN2 }, An.prototype.project = function (t) { return new D.Point(this.lngX(t.lng), this.latY(t.lat)) }, An.prototype.unproject = function (t) { return new V(this.xLng(t.x), this.yLat(t.y)) }, W.x.get = function () { return this.lngX(this.center.lng) }, W.y.get = function () { return this.latY(this.center.lat) }, W.point.get = function () { return new D.Point(this.x, this.y) }, An.prototype.lngX = function (t) { return (180 + t) * this.worldSize / 360 }, An.prototype.latY = function (t) { return t = D.clamp(t, -this.maxValidLatitude, this.maxValidLatitude), (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t * Math.PI / 360))) * this.worldSize / 360 }, An.prototype.xLng = function (t) { return 360 * t / this.worldSize - 180 }, An.prototype.yLat = function (t) { t = 180 - 360 * t / this.worldSize; return 360 / Math.PI * Math.atan(Math.exp(t * Math.PI / 180)) - 90 }, An.prototype.setLocationAtPoint = function (t, e) { e = this.pointCoordinate(e)._sub(this.pointCoordinate(this.centerPoint)); this.center = this.coordinateLocation(this.locationCoordinate(t)._sub(e)), this._renderWorldCopies && (this.center = this.center.wrap()) }, An.prototype.locationPoint = function (t) { return this.coordinatePoint(this.locationCoordinate(t)) }, An.prototype.pointLocation = function (t) { return this.coordinateLocation(this.pointCoordinate(t)) }, An.prototype.locationCoordinate = function (t) { return new D.Coordinate(this.lngX(t.lng) / this.tileSize, this.latY(t.lat) / this.tileSize, this.zoom).zoomTo(this.tileZoom) }, An.prototype.coordinateLocation = function (t) { t = t.zoomTo(this.zoom); return new V(this.xLng(t.column * this.tileSize), this.yLat(t.row * this.tileSize)) }, An.prototype.pointCoordinate = function (t, e) { void 0 === e && (e = this.tileZoom); var n = [t.x, t.y, 0, 1], i = [t.x, t.y, 1, 1]; D.transformMat4(n, n, this.pixelMatrixInverse), D.transformMat4(i, i, this.pixelMatrixInverse); var r = n[3], o = i[3], a = n[0] / r, s = i[0] / o, l = n[1] / r, t = i[1] / o, r = n[2] / r, o = i[2] / o, r = r == o ? 0 : (0 - r) / (o - r); return new D.Coordinate(D.number(a, s, r) / this.tileSize, D.number(l, t, r) / this.tileSize, this.zoom)._zoomTo(e) }, An.prototype.coordinatePoint = function (t) { t = t.zoomTo(this.zoom), t = [t.column * this.tileSize, t.row * this.tileSize, 0, 1]; return D.transformMat4(t, t, this.pixelMatrix), new D.Point(t[0] / t[3], t[1] / t[3]) }, An.prototype.getBounds = function () { return (new N).extend(this.pointLocation(new D.Point(0, 0))).extend(this.pointLocation(new D.Point(this.width, 0))).extend(this.pointLocation(new D.Point(this.width, this.height))).extend(this.pointLocation(new D.Point(0, this.height))) }, An.prototype.getMaxBounds = function () { return this.latRange && 2 === this.latRange.length && this.lngRange && 2 === this.lngRange.length ? new N([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]) : null }, An.prototype.setMaxBounds = function (t) { t ? (this.lngRange = [t.getWest(), t.getEast()], this.latRange = [t.getSouth(), t.getNorth()], this._constrain()) : (this.lngRange = null, this.latRange = [-this.maxValidLatitude, this.maxValidLatitude]) }, An.prototype.calculatePosMatrix = function (t, e) { void 0 === e && (e = !1); var n = t.key, i = e ? this._alignedPosMatrixCache : this._posMatrixCache; if (i[n]) return i[n]; var r = t.canonical, o = this.worldSize / this.zoomScale(r.z), a = r.x + Math.pow(2, r.z) * t.wrap, t = D.identity(new Float64Array(16)); return D.translate(t, t, [a * o, r.y * o, 0]), D.scale(t, t, [o / D.EXTENT, o / D.EXTENT, 1]), D.multiply(t, e ? this.alignedProjMatrix : this.projMatrix, t), i[n] = new Float32Array(t), i[n] }, An.prototype._constrain = function () { if (this.center && this.width && this.height && !this._constraining) { this._constraining = !0; var t, e, n, i, r = -90, o = 90, a = -180, s = 180, l = this.size, u = this._unmodified; this.latRange && (n = this.latRange, r = this.latY(n[1]), n = (o = this.latY(n[0])) - r < l.y ? l.y / (o - r) : 0), this.lngRange && (h = this.lngRange, a = this.lngX(h[0]), i = (s = this.lngX(h[1])) - a < l.x ? l.x / (s - a) : 0); var c, h = Math.max(i || 0, n || 0); if (h) return this.center = this.unproject(new D.Point(i ? (s + a) / 2 : this.x, n ? (o + r) / 2 : this.y)), this.zoom += this.scaleZoom(h), this._unmodified = u, void (this._constraining = !1); this.latRange && ((h = this.y) - (c = l.y / 2) < r && (e = r + c), o < h + c && (e = o - c)), this.lngRange && ((c = this.x) - (l = l.x / 2) < a && (t = a + l), s < c + l && (t = s - l)), void 0 === t && void 0 === e || (this.center = this.unproject(new D.Point(void 0 !== t ? t : this.x, void 0 !== e ? e : this.y))), this._unmodified = u, this._constraining = !1 } }, An.prototype._calcMatrices = function () { if (this.height) { this.cameraToCenterDistance = .5 / Math.tan(this._fov / 2) * this.height; var t = this._fov / 2, e = Math.PI / 2 + this._pitch, n = Math.sin(t) * this.cameraToCenterDistance / Math.sin(Math.PI - e - t), i = this.x, r = this.y, o = 1.01 * (Math.cos(Math.PI / 2 - this._pitch) * n + this.cameraToCenterDistance), a = new Float64Array(16); D.perspective(a, this._fov, this.width / this.height, 1, o), D.scale(a, a, [1, -1, 1]), D.translate(a, a, [0, 0, -this.cameraToCenterDistance]), D.rotateX(a, a, this._pitch), D.rotateZ(a, a, this.angle), D.translate(a, a, [-i, -r, 0]); e = this.worldSize / (2 * Math.PI * 6378137 * Math.abs(Math.cos(this.center.lat * (Math.PI / 180)))); D.scale(a, a, [1, 1, e, 1]), this.projMatrix = a; t = this.width % 2 / 2, n = this.height % 2 / 2, o = Math.cos(this.angle), e = Math.sin(this.angle), i = i - Math.round(i) + o * t + e * n, e = r - Math.round(r) + o * n + e * t, t = new Float64Array(a); if (D.translate(t, t, [.5 < i ? i - 1 : i, .5 < e ? e - 1 : e, 0]), this.alignedProjMatrix = t, a = D.create(), D.scale(a, a, [this.width / 2, -this.height / 2, 1]), D.translate(a, a, [1, -1, 0]), this.pixelMatrix = D.multiply(new Float64Array(16), a, this.projMatrix), !(a = D.invert(new Float64Array(16), this.pixelMatrix))) throw new Error("failed to invert matrix"); this.pixelMatrixInverse = a, this._posMatrixCache = {}, this._alignedPosMatrixCache = {} } }, An.prototype.maxPitchScaleFactor = function () { if (!this.pixelMatrixInverse) return 1; var t = this.pointCoordinate(new D.Point(0, 0)).zoomTo(this.zoom), t = [t.column * this.tileSize, t.row * this.tileSize, 0, 1]; return D.transformMat4(t, t, this.pixelMatrix)[3] / this.cameraToCenterDistance }, Object.defineProperties(An.prototype, W); function zn() { var t, e, n, i; D.bindAll(["_onHashChange", "_updateHash"], this), this._updateHash = (t = this._updateHashUnthrottled.bind(this), e = !300, n = 0, i = function () { n = 0, e && (t(), n = setTimeout(i, 300), e = !1) }, function () { return e = !0, n || i(), n }) } zn.prototype.addTo = function (t) { return this._map = t, D.window.addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this }, zn.prototype.remove = function () { return D.window.removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), delete this._map, this }, zn.prototype.getHashString = function (t) { var e = this._map.getCenter(), n = Math.round(100 * this._map.getZoom()) / 100, i = Math.ceil((n * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10), r = Math.pow(10, i), o = Math.round(e.lng * r) / r, a = Math.round(e.lat * r) / r, i = this._map.getBearing(), e = this._map.getPitch(), r = ""; return r += t ? "#/" + o + "/" + a + "/" + n : "#" + n + "/" + a + "/" + o, (i || e) && (r += "/" + Math.round(10 * i) / 10), e && (r += "/" + Math.round(e)), r }, zn.prototype._onHashChange = function () { var t = D.window.location.hash.replace("#", "").split("/"); return 3 <= t.length && (this._map.jumpTo({ center: [+t[2], +t[1]], zoom: +t[0], bearing: +(t[3] || 0), pitch: +(t[4] || 0) }), !0) }, zn.prototype._updateHashUnthrottled = function () { var t = this.getHashString(); D.window.history.replaceState(D.window.history.state, "", t) }; var In = function (a) { function t(t, e, n, i) { void 0 === i && (i = {}); var r = d.mousePos(e.getCanvasContainer(), n), o = e.unproject(r); a.call(this, t, D.extend({ point: r, lngLat: o, originalEvent: n }, i)), this._defaultPrevented = !1, this.target = e } a && (t.__proto__ = a); var e = { defaultPrevented: { configurable: !0 } }; return ((t.prototype = Object.create(a && a.prototype)).constructor = t).prototype.preventDefault = function () { this._defaultPrevented = !0 }, e.defaultPrevented.get = function () { return this._defaultPrevented }, Object.defineProperties(t.prototype, e), t }(D.Event), kn = function (s) { function t(t, e, n) { var i = d.touchPos(e.getCanvasContainer(), n), r = i.map(function (t) { return e.unproject(t) }), o = i.reduce(function (t, e, n, i) { return t.add(e.div(i.length)) }, new D.Point(0, 0)), a = e.unproject(o); s.call(this, t, { points: i, point: o, lngLats: r, lngLat: a, originalEvent: n }), this._defaultPrevented = !1 } s && (t.__proto__ = s); var e = { defaultPrevented: { configurable: !0 } }; return ((t.prototype = Object.create(s && s.prototype)).constructor = t).prototype.preventDefault = function () { this._defaultPrevented = !0 }, e.defaultPrevented.get = function () { return this._defaultPrevented }, Object.defineProperties(t.prototype, e), t }(D.Event), Cn = function (i) { function t(t, e, n) { i.call(this, t, { originalEvent: n }), this._defaultPrevented = !1 } i && (t.__proto__ = i); var e = { defaultPrevented: { configurable: !0 } }; return ((t.prototype = Object.create(i && i.prototype)).constructor = t).prototype.preventDefault = function () { this._defaultPrevented = !0 }, e.defaultPrevented.get = function () { return this._defaultPrevented }, Object.defineProperties(t.prototype, e), t }(D.Event), x = function (t) { this._map = t, this._el = t.getCanvasContainer(), this._delta = 0, D.bindAll(["_onWheel", "_onTimeout", "_onScrollFrame", "_onScrollFinished"], this) }; x.prototype.isEnabled = function () { return !!this._enabled }, x.prototype.isActive = function () { return !!this._active }, x.prototype.enable = function (t) { this.isEnabled() || (this._enabled = !0, this._aroundCenter = t && "center" === t.around) }, x.prototype.disable = function () { this.isEnabled() && (this._enabled = !1) }, x.prototype.onWheel = function (t) { var e, n, i; this.isEnabled() && (e = t.deltaMode === D.window.WheelEvent.DOM_DELTA_LINE ? 40 * t.deltaY : t.deltaY, i = (n = D.browser.now()) - (this._lastWheelEventTime || 0), this._lastWheelEventTime = n, 0 !== e && e % 4.000244140625 == 0 ? this._type = "wheel" : 0 !== e && Math.abs(e) < 4 ? this._type = "trackpad" : 400 < i ? (this._type = null, this._lastValue = e, this._timeout = setTimeout(this._onTimeout, 40, t)) : this._type || (this._type = Math.abs(i * e) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, e += this._lastValue)), t.shiftKey && e && (e /= 4), this._type && (this._lastWheelEvent = t, this._delta -= e, this.isActive() || this._start(t)), t.preventDefault()) }, x.prototype._onTimeout = function (t) { this._type = "wheel", this._delta -= this._lastValue, this.isActive() || this._start(t) }, x.prototype._start = function (t) { this._delta && (this._frameId && (this._map._cancelRenderFrame(this._frameId), this._frameId = null), this._active = !0, this._map.fire(new D.Event("movestart", { originalEvent: t })), this._map.fire(new D.Event("zoomstart", { originalEvent: t })), this._finishTimeout && clearTimeout(this._finishTimeout), t = d.mousePos(this._el, t), this._around = V.convert(this._aroundCenter ? this._map.getCenter() : this._map.unproject(t)), this._aroundPoint = this._map.transform.locationPoint(this._around), this._frameId || (this._frameId = this._map._requestRenderFrame(this._onScrollFrame))) }, x.prototype._onScrollFrame = function () { var t, e, n, i, r, o, a = this; this._frameId = null, this.isActive() && (t = this._map.transform, 0 !== this._delta && (o = "wheel" === this._type && 4.000244140625 < Math.abs(this._delta) ? 1 / 450 : .01, r = 2 / (1 + Math.exp(-Math.abs(this._delta * o))), this._delta < 0 && 0 !== r && (r = 1 / r), i = "number" == typeof this._targetZoom ? t.zoomScale(this._targetZoom) : t.scale, this._targetZoom = Math.min(t.maxZoom, Math.max(t.minZoom, t.scaleZoom(i * r))), "wheel" === this._type && (this._startZoom = t.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0), e = "number" == typeof this._targetZoom ? this._targetZoom : t.zoom, n = this._startZoom, o = this._easing, i = !1, "wheel" === this._type && n && o ? (o = o(r = Math.min((D.browser.now() - this._lastWheelEventTime) / 200, 1)), t.zoom = D.number(n, e, o), r < 1 ? this._frameId || (this._frameId = this._map._requestRenderFrame(this._onScrollFrame)) : i = !0) : (t.zoom = e, i = !0), t.setLocationAtPoint(this._around, this._aroundPoint), this._map.fire(new D.Event("move", { originalEvent: this._lastWheelEvent })), this._map.fire(new D.Event("zoom", { originalEvent: this._lastWheelEvent })), i && (this._active = !1, this._finishTimeout = setTimeout(function () { a._map.fire(new D.Event("zoomend", { originalEvent: a._lastWheelEvent })), a._map.fire(new D.Event("moveend", { originalEvent: a._lastWheelEvent })), delete a._targetZoom }, 200))) }, x.prototype._smoothOutEasing = function (t) { var e, n, i = D.ease; return this._prevEase && (n = this._prevEase, e = (D.browser.now() - n.start) / n.duration, n = n.easing(.01 + e) - n.easing(e), e = .27 / Math.sqrt(n * n + 1e-4) * .01, n = Math.sqrt(.0729 - e * e), i = D.bezier(e, n, .25, 1)), this._prevEase = { start: D.browser.now(), duration: t, easing: i }, i }; b = function (t, e) { this._map = t, this._el = t.getCanvasContainer(), this._container = t.getContainer(), this._clickTolerance = e.clickTolerance || 1, D.bindAll(["_onMouseMove", "_onMouseUp", "_onKeyDown"], this) }; b.prototype.isEnabled = function () { return !!this._enabled }, b.prototype.isActive = function () { return !!this._active }, b.prototype.enable = function () { this.isEnabled() || (this._enabled = !0) }, b.prototype.disable = function () { this.isEnabled() && (this._enabled = !1) }, b.prototype.onMouseDown = function (t) { this.isEnabled() && t.shiftKey && 0 === t.button && (D.window.document.addEventListener("mousemove", this._onMouseMove, !1), D.window.document.addEventListener("keydown", this._onKeyDown, !1), D.window.document.addEventListener("mouseup", this._onMouseUp, !1), d.disableDrag(), this._startPos = this._lastPos = d.mousePos(this._el, t), this._active = !0) }, b.prototype._onMouseMove = function (t) { var e, n, i, r = d.mousePos(this._el, t); this._lastPos.equals(r) || !this._box && r.dist(this._startPos) < this._clickTolerance || (e = this._startPos, this._lastPos = r, this._box || (this._box = d.create("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", t)), n = Math.min(e.x, r.x), i = Math.max(e.x, r.x), t = Math.min(e.y, r.y), r = Math.max(e.y, r.y), d.setTransform(this._box, "translate(" + n + "px," + t + "px)"), this._box.style.width = i - n + "px", this._box.style.height = r - t + "px") }, b.prototype._onMouseUp = function (t) { var e, n, i; 0 === t.button && (e = this._startPos, n = d.mousePos(this._el, t), i = (new N).extend(this._map.unproject(e)).extend(this._map.unproject(n)), this._finish(), d.suppressClick(), e.x === n.x && e.y === n.y ? this._fireEvent("boxzoomcancel", t) : this._map.fitBounds(i, { linear: !0 }).fire(new D.Event("boxzoomend", { originalEvent: t, boxZoomBounds: i }))) }, b.prototype._onKeyDown = function (t) { 27 === t.keyCode && (this._finish(), this._fireEvent("boxzoomcancel", t)) }, b.prototype._finish = function () { this._active = !1, D.window.document.removeEventListener("mousemove", this._onMouseMove, !1), D.window.document.removeEventListener("keydown", this._onKeyDown, !1), D.window.document.removeEventListener("mouseup", this._onMouseUp, !1), this._container.classList.remove("mapboxgl-crosshair"), this._box && (d.remove(this._box), this._box = null), d.enableDrag(), delete this._startPos, delete this._lastPos }, b.prototype._fireEvent = function (t, e) { return this._map.fire(new D.Event(t, { originalEvent: e })) }; function Mn(t, e) { this._map = t, this._el = e.element || t.getCanvasContainer(), this._state = "disabled", this._button = e.button || "right", this._bearingSnap = e.bearingSnap || 0, this._pitchWithRotate = !1 !== e.pitchWithRotate, D.bindAll(["onMouseDown", "_onMouseMove", "_onMouseUp", "_onBlur", "_onDragFrame"], this) } var Pn = D.bezier(0, 0, .25, 1); Mn.prototype.isEnabled = function () { return "disabled" !== this._state }, Mn.prototype.isActive = function () { return "active" === this._state }, Mn.prototype.enable = function () { this.isEnabled() || (this._state = "enabled") }, Mn.prototype.disable = function () { if (this.isEnabled()) switch (this._state) { case "active": this._state = "disabled", this._unbind(), this._deactivate(), this._fireEvent("rotateend"), this._pitchWithRotate && this._fireEvent("pitchend"), this._fireEvent("moveend"); break; case "pending": this._state = "disabled", this._unbind(); break; default: this._state = "disabled" } }, Mn.prototype.onMouseDown = function (t) { if ("enabled" === this._state) { if ("right" === this._button) { if (this._eventButton = d.mouseButton(t), this._eventButton !== (t.ctrlKey ? 0 : 2)) return } else { if (t.ctrlKey || 0 !== d.mouseButton(t)) return; this._eventButton = 0 } d.disableDrag(), D.window.document.addEventListener("mousemove", this._onMouseMove, { capture: !0 }), D.window.document.addEventListener("mouseup", this._onMouseUp), D.window.addEventListener("blur", this._onBlur), this._state = "pending", this._inertia = [[D.browser.now(), this._map.getBearing()]], this._startPos = this._lastPos = d.mousePos(this._el, t), this._center = this._map.transform.centerPoint, t.preventDefault() } }, Mn.prototype._onMouseMove = function (t) { var e = d.mousePos(this._el, t); this._lastPos.equals(e) || (this._lastMoveEvent = t, this._lastPos = e, "pending" === this._state && (this._state = "active", this._fireEvent("rotatestart", t), this._fireEvent("movestart", t), this._pitchWithRotate && this._fireEvent("pitchstart", t)), this._frameId || (this._frameId = this._map._requestRenderFrame(this._onDragFrame))) }, Mn.prototype._onDragFrame = function () { this._frameId = null; var t, e, n, i, r, o = this._lastMoveEvent; o && (t = this._map.transform, e = this._startPos, n = this._lastPos, i = .8 * (e.x - n.x), r = -.5 * (e.y - n.y), e = t.bearing - i, n = t.pitch - r, r = (i = this._inertia)[i.length - 1], this._drainInertiaBuffer(), i.push([D.browser.now(), this._map._normalizeBearing(e, r[1])]), t.bearing = e, this._pitchWithRotate && (this._fireEvent("pitch", o), t.pitch = n), this._fireEvent("rotate", o), this._fireEvent("move", o), delete this._lastMoveEvent, this._startPos = this._lastPos) }, Mn.prototype._onMouseUp = function (t) { if (d.mouseButton(t) === this._eventButton) switch (this._state) { case "active": this._state = "enabled", d.suppressClick(), this._unbind(), this._deactivate(), this._inertialRotate(t); break; case "pending": this._state = "enabled", this._unbind() } }, Mn.prototype._onBlur = function (t) { switch (this._state) { case "active": this._state = "enabled", this._unbind(), this._deactivate(), this._fireEvent("rotateend", t), this._pitchWithRotate && this._fireEvent("pitchend", t), this._fireEvent("moveend", t); break; case "pending": this._state = "enabled", this._unbind() } }, Mn.prototype._unbind = function () { D.window.document.removeEventListener("mousemove", this._onMouseMove, { capture: !0 }), D.window.document.removeEventListener("mouseup", this._onMouseUp), D.window.removeEventListener("blur", this._onBlur), d.enableDrag() }, Mn.prototype._deactivate = function () { this._frameId && (this._map._cancelRenderFrame(this._frameId), this._frameId = null), delete this._lastMoveEvent, delete this._startPos, delete this._lastPos }, Mn.prototype._inertialRotate = function (t) { var e = this; this._fireEvent("rotateend", t), this._drainInertiaBuffer(); function n() { Math.abs(l) < e._bearingSnap ? s.resetNorth({ noMoveStart: !0 }, { originalEvent: t }) : e._fireEvent("moveend", t), e._pitchWithRotate && e._fireEvent("pitchend", t) } var i, r, o, a, s = this._map, l = s.getBearing(), u = this._inertia; u.length < 2 ? n() : (a = u[0], i = u[u.length - 1], o = u[u.length - 2], r = s._normalizeBearing(l, o[1]), o = (u = i[1] - a[1]) < 0 ? -1 : 1, a = (i[0] - a[0]) / 1e3, 0 != u && 0 != a ? (180 < (u = Math.abs(.25 / a * u)) && (u = 180), r += o * u * ((u = u / 180) / 2), Math.abs(s._normalizeBearing(r, 0)) < this._bearingSnap && (r = s._normalizeBearing(0, r)), s.rotateTo(r, { duration: 1e3 * u, easing: Pn, noMoveStart: !0 }, { originalEvent: t })) : n()) }, Mn.prototype._fireEvent = function (t, e) { return this._map.fire(new D.Event(t, e ? { originalEvent: e } : {})) }, Mn.prototype._drainInertiaBuffer = function () { for (var t = this._inertia, e = D.browser.now(); 0 < t.length && 160 < e - t[0][0];)t.shift() }; var Ln = D.bezier(0, 0, .3, 1), S = function (t, e) { this._map = t, this._el = t.getCanvasContainer(), this._state = "disabled", this._clickTolerance = e.clickTolerance || 1, D.bindAll(["_onMove", "_onMouseUp", "_onTouchEnd", "_onBlur", "_onDragFrame"], this) }; S.prototype.isEnabled = function () { return "disabled" !== this._state }, S.prototype.isActive = function () { return "active" === this._state }, S.prototype.enable = function () { this.isEnabled() || (this._el.classList.add("mapboxgl-touch-drag-pan"), this._state = "enabled") }, S.prototype.disable = function () { if (this.isEnabled()) switch (this._el.classList.remove("mapboxgl-touch-drag-pan"), this._state) { case "active": this._state = "disabled", this._unbind(), this._deactivate(), this._fireEvent("dragend"), this._fireEvent("moveend"); break; case "pending": this._state = "disabled", this._unbind(); break; default: this._state = "disabled" } }, S.prototype.onMouseDown = function (t) { "enabled" === this._state && (t.ctrlKey || 0 !== d.mouseButton(t) || (d.addEventListener(D.window.document, "mousemove", this._onMove, { capture: !0 }), d.addEventListener(D.window.document, "mouseup", this._onMouseUp), this._start(t))) }, S.prototype.onTouchStart = function (t) { "enabled" === this._state && (1 < t.touches.length || (d.addEventListener(D.window.document, "touchmove", this._onMove, { capture: !0, passive: !1 }), d.addEventListener(D.window.document, "touchend", this._onTouchEnd), this._start(t))) }, S.prototype._start = function (t) { D.window.addEventListener("blur", this._onBlur), this._state = "pending", this._startPos = this._mouseDownPos = this._lastPos = d.mousePos(this._el, t), this._inertia = [[D.browser.now(), this._startPos]] }, S.prototype._onMove = function (t) { t.preventDefault(); var e = d.mousePos(this._el, t); this._lastPos.equals(e) || "pending" === this._state && e.dist(this._mouseDownPos) < this._clickTolerance || (this._lastMoveEvent = t, this._lastPos = e, this._drainInertiaBuffer(), this._inertia.push([D.browser.now(), this._lastPos]), "pending" === this._state && (this._state = "active", this._fireEvent("dragstart", t), this._fireEvent("movestart", t)), this._frameId || (this._frameId = this._map._requestRenderFrame(this._onDragFrame))) }, S.prototype._onDragFrame = function () { this._frameId = null; var t, e = this._lastMoveEvent; e && ((t = this._map.transform).setLocationAtPoint(t.pointLocation(this._startPos), this._lastPos), this._fireEvent("drag", e), this._fireEvent("move", e), this._startPos = this._lastPos, delete this._lastMoveEvent) }, S.prototype._onMouseUp = function (t) { if (0 === d.mouseButton(t)) switch (this._state) { case "active": this._state = "enabled", d.suppressClick(), this._unbind(), this._deactivate(), this._inertialPan(t); break; case "pending": this._state = "enabled", this._unbind() } }, S.prototype._onTouchEnd = function (t) { switch (this._state) { case "active": this._state = "enabled", this._unbind(), this._deactivate(), this._inertialPan(t); break; case "pending": this._state = "enabled", this._unbind() } }, S.prototype._onBlur = function (t) { switch (this._state) { case "active": this._state = "enabled", this._unbind(), this._deactivate(), this._fireEvent("dragend", t), this._fireEvent("moveend", t); break; case "pending": this._state = "enabled", this._unbind() } }, S.prototype._unbind = function () { d.removeEventListener(D.window.document, "touchmove", this._onMove, { capture: !0, passive: !1 }), d.removeEventListener(D.window.document, "touchend", this._onTouchEnd), d.removeEventListener(D.window.document, "mousemove", this._onMove, { capture: !0 }), d.removeEventListener(D.window.document, "mouseup", this._onMouseUp), d.removeEventListener(D.window, "blur", this._onBlur) }, S.prototype._deactivate = function () { this._frameId && (this._map._cancelRenderFrame(this._frameId), this._frameId = null), delete this._lastMoveEvent, delete this._startPos, delete this._mouseDownPos, delete this._lastPos }, S.prototype._inertialPan = function (t) { this._fireEvent("dragend", t), this._drainInertiaBuffer(); var e, n, i, r = this._inertia; r.length < 2 ? this._fireEvent("moveend", t) : (e = r[r.length - 1], n = r[0], i = e[1].sub(n[1]), 0 == (r = (e[0] - n[0]) / 1e3) || e[1].equals(n[1]) ? this._fireEvent("moveend", t) : (1400 < (r = (i = i.mult(.3 / r)).mag()) && (r = 1400, i._unit()._mult(r)), r = r / 750, i = i.mult(-r / 2), this._map.panBy(i, { duration: 1e3 * r, easing: Ln, noMoveStart: !0 }, { originalEvent: t }))) }, S.prototype._fireEvent = function (t, e) { return this._map.fire(new D.Event(t, e ? { originalEvent: e } : {})) }, S.prototype._drainInertiaBuffer = function () { for (var t = this._inertia, e = D.browser.now(); 0 < t.length && 160 < e - t[0][0];)t.shift() }; C = function (t) { this._map = t, this._el = t.getCanvasContainer(), D.bindAll(["_onKeyDown"], this) }; function Dn(t) { return t * (2 - t) } C.prototype.isEnabled = function () { return !!this._enabled }, C.prototype.enable = function () { this.isEnabled() || (this._el.addEventListener("keydown", this._onKeyDown, !1), this._enabled = !0) }, C.prototype.disable = function () { this.isEnabled() && (this._el.removeEventListener("keydown", this._onKeyDown), this._enabled = !1) }, C.prototype._onKeyDown = function (t) { if (!(t.altKey || t.ctrlKey || t.metaKey)) { var e = 0, n = 0, i = 0, r = 0, o = 0; switch (t.keyCode) { case 61: case 107: case 171: case 187: e = 1; break; case 189: case 109: case 173: e = -1; break; case 37: t.shiftKey ? n = -1 : (t.preventDefault(), r = -1); break; case 39: t.shiftKey ? n = 1 : (t.preventDefault(), r = 1); break; case 38: t.shiftKey ? i = 1 : (t.preventDefault(), o = -1); break; case 40: t.shiftKey ? i = -1 : (o = 1, t.preventDefault()); break; default: return }var a = this._map, s = a.getZoom(), o = { duration: 300, delayEndEvents: 500, easing: Dn, zoom: e ? Math.round(s) + e * (t.shiftKey ? 2 : 1) : s, bearing: a.getBearing() + 15 * n, pitch: a.getPitch() + 10 * i, offset: [100 * -r, 100 * -o], center: a.getCenter() }; a.easeTo(o, { originalEvent: t }) } }; X = function (t) { this._map = t, D.bindAll(["_onDblClick", "_onZoomEnd"], this) }; X.prototype.isEnabled = function () { return !!this._enabled }, X.prototype.isActive = function () { return !!this._active }, X.prototype.enable = function () { this.isEnabled() || (this._enabled = !0) }, X.prototype.disable = function () { this.isEnabled() && (this._enabled = !1) }, X.prototype.onTouchStart = function (t) { var e = this; this.isEnabled() && (1 < t.points.length || (this._tapped ? (clearTimeout(this._tapped), this._tapped = null, this._zoom(t)) : this._tapped = setTimeout(function () { e._tapped = null }, 300))) }, X.prototype.onDblClick = function (t) { this.isEnabled() && (t.originalEvent.preventDefault(), this._zoom(t)) }, X.prototype._zoom = function (t) { this._active = !0, this._map.on("zoomend", this._onZoomEnd), this._map.zoomTo(this._map.getZoom() + (t.originalEvent.shiftKey ? -1 : 1), { around: t.lngLat }, t) }, X.prototype._onZoomEnd = function () { this._active = !1, this._map.off("zoomend", this._onZoomEnd) }; var Rn = D.bezier(0, 0, .15, 1), W = function (t) { this._map = t, this._el = t.getCanvasContainer(), D.bindAll(["_onMove", "_onEnd", "_onTouchFrame"], this) }; W.prototype.isEnabled = function () { return !!this._enabled }, W.prototype.enable = function (t) { this.isEnabled() || (this._el.classList.add("mapboxgl-touch-zoom-rotate"), this._enabled = !0, this._aroundCenter = !!t && "center" === t.around) }, W.prototype.disable = function () { this.isEnabled() && (this._el.classList.remove("mapboxgl-touch-zoom-rotate"), this._enabled = !1) }, W.prototype.disableRotation = function () { this._rotationDisabled = !0 }, W.prototype.enableRotation = function () { this._rotationDisabled = !1 }, W.prototype.onStart = function (t) { var e; this.isEnabled() && 2 === t.touches.length && (e = d.mousePos(this._el, t.touches[0]), t = d.mousePos(this._el, t.touches[1]), this._startVec = e.sub(t), this._gestureIntent = void 0, this._inertia = [], d.addEventListener(D.window.document, "touchmove", this._onMove, { passive: !1 }), d.addEventListener(D.window.document, "touchend", this._onEnd)) }, W.prototype._getTouchEventData = function (t) { var e = d.mousePos(this._el, t.touches[0]), n = d.mousePos(this._el, t.touches[1]), t = e.sub(n); return { vec: t, center: e.add(n).div(2), scale: t.mag() / this._startVec.mag(), bearing: this._rotationDisabled ? 0 : 180 * t.angleWith(this._startVec) / Math.PI } }, W.prototype._onMove = function (t) { var e, n, i; 2 === t.touches.length && (e = (n = this._getTouchEventData(t)).vec, i = n.scale, n = n.bearing, this._gestureIntent || (i = .15 < Math.abs(1 - i), 10 < Math.abs(n) ? this._gestureIntent = "rotate" : i && (this._gestureIntent = "zoom"), this._gestureIntent && (this._map.fire(new D.Event(this._gestureIntent + "start", { originalEvent: t })), this._map.fire(new D.Event("movestart", { originalEvent: t })), this._startVec = e)), this._lastTouchEvent = t, this._frameId || (this._frameId = this._map._requestRenderFrame(this._onTouchFrame)), t.preventDefault()) }, W.prototype._onTouchFrame = function () { this._frameId = null; var t, e, n, i, r, o, a = this._gestureIntent; a && (t = this._map.transform, this._startScale || (this._startScale = t.scale, this._startBearing = t.bearing), e = (o = this._getTouchEventData(this._lastTouchEvent)).center, n = o.bearing, i = o.scale, r = t.pointLocation(e), o = t.locationPoint(r), "rotate" === a && (t.bearing = this._startBearing + n), t.zoom = t.scaleZoom(this._startScale * i), t.setLocationAtPoint(r, o), this._map.fire(new D.Event(a, { originalEvent: this._lastTouchEvent })), this._map.fire(new D.Event("move", { originalEvent: this._lastTouchEvent })), this._drainInertiaBuffer(), this._inertia.push([D.browser.now(), i, e])) }, W.prototype._onEnd = function (t) { d.removeEventListener(D.window.document, "touchmove", this._onMove, { passive: !1 }), d.removeEventListener(D.window.document, "touchend", this._onEnd); var e, n, i, r, o = this._gestureIntent, a = this._startScale; this._frameId && (this._map._cancelRenderFrame(this._frameId), this._frameId = null), delete this._gestureIntent, delete this._startScale, delete this._startBearing, delete this._lastTouchEvent, o && (this._map.fire(new D.Event(o + "end", { originalEvent: t })), this._drainInertiaBuffer(), n = this._inertia, e = this._map, n.length < 2 ? e.snapToNorth({}, { originalEvent: t }) : (i = n[n.length - 1], r = n[0], a = (o = e.transform.scaleZoom(a * i[1])) - (n = e.transform.scaleZoom(a * r[1])), r = (i[0] - r[0]) / 1e3, i = i[2], 0 != r && o !== n ? (r = .15 * a / r, 2.5 < Math.abs(r) && (r = 0 < r ? 2.5 : -2.5), (r = o + r * (o = 1e3 * Math.abs(r / (12 * .15))) / 2e3) < 0 && (r = 0), e.easeTo({ zoom: r, duration: o, easing: Rn, around: this._aroundCenter ? e.getCenter() : e.unproject(i), noMoveStart: !0 }, { originalEvent: t })) : e.snapToNorth({}, { originalEvent: t }))) }, W.prototype._drainInertiaBuffer = function () { for (var t = this._inertia, e = D.browser.now(); 2 < t.length && 160 < e - t[0][0];)t.shift() }; function Bn(t) { void 0 === t && (t = {}), this.options = t, D.bindAll(["_updateEditLink", "_updateData", "_updateCompact"], this) } var On, Fn = { scrollZoom: x, boxZoom: b, dragRotate: Mn, dragPan: S, keyboard: C, doubleClickZoom: X, touchZoomRotate: W }, x = ((On = D.Evented) && (Vn.__proto__ = On), ((Vn.prototype = Object.create(On && On.prototype)).constructor = Vn).prototype.getCenter = function () { return this.transform.center }, Vn.prototype.setCenter = function (t, e) { return this.jumpTo({ center: t }, e) }, Vn.prototype.panBy = function (t, e, n) { return t = D.Point.convert(t).mult(-1), this.panTo(this.transform.center, D.extend({ offset: t }, e), n) }, Vn.prototype.panTo = function (t, e, n) { return this.easeTo(D.extend({ center: t }, e), n) }, Vn.prototype.getZoom = function () { return this.transform.zoom }, Vn.prototype.setZoom = function (t, e) { return this.jumpTo({ zoom: t }, e), this }, Vn.prototype.zoomTo = function (t, e, n) { return this.easeTo(D.extend({ zoom: t }, e), n) }, Vn.prototype.zoomIn = function (t, e) { return this.zoomTo(this.getZoom() + 1, t, e), this }, Vn.prototype.zoomOut = function (t, e) { return this.zoomTo(this.getZoom() - 1, t, e), this }, Vn.prototype.getBearing = function () { return this.transform.bearing }, Vn.prototype.setBearing = function (t, e) { return this.jumpTo({ bearing: t }, e), this }, Vn.prototype.rotateTo = function (t, e, n) { return this.easeTo(D.extend({ bearing: t }, e), n) }, Vn.prototype.resetNorth = function (t, e) { return this.rotateTo(0, D.extend({ duration: 1e3 }, t), e), this }, Vn.prototype.snapToNorth = function (t, e) { return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(t, e) : this }, Vn.prototype.getPitch = function () { return this.transform.pitch }, Vn.prototype.setPitch = function (t, e) { return this.jumpTo({ pitch: t }, e), this }, Vn.prototype.cameraForBounds = function (t, e) { if ("number" == typeof (e = D.extend({ padding: { top: 0, bottom: 0, right: 0, left: 0 }, offset: [0, 0], maxZoom: this.transform.maxZoom }, e)).padding && (s = e.padding, e.padding = { top: s, bottom: s, right: s, left: s }), D.deepEqual(Object.keys(e.padding).sort(function (t, e) { return t < e ? -1 : e < t ? 1 : 0 }), ["bottom", "left", "right", "top"])) { t = N.convert(t); var n = [(e.padding.left - e.padding.right) / 2, (e.padding.top - e.padding.bottom) / 2], i = Math.min(e.padding.right, e.padding.left), r = Math.min(e.padding.top, e.padding.bottom); e.offset = [e.offset[0] + n[0], e.offset[1] + n[1]]; var o = D.Point.convert(e.offset), a = this.transform, s = a.project(t.getNorthWest()), n = a.project(t.getSouthEast()), t = n.sub(s), i = (a.width - 2 * i - 2 * Math.abs(o.x)) / t.x, t = (a.height - 2 * r - 2 * Math.abs(o.y)) / t.y; if (!(t < 0 || i < 0)) return e.center = a.unproject(s.add(n).div(2)), e.zoom = Math.min(a.scaleZoom(a.scale * Math.min(i, t)), e.maxZoom), e.bearing = 0, e; D.warnOnce("Map cannot fit within canvas with the given bounds, padding, and/or offset.") } else D.warnOnce("options.padding must be a positive number, or an Object with keys 'bottom', 'left', 'right', 'top'") }, Vn.prototype.fitBounds = function (t, e, n) { t = this.cameraForBounds(t, e); return t ? (e = D.extend(t, e)).linear ? this.easeTo(e, n) : this.flyTo(e, n) : this }, Vn.prototype.jumpTo = function (t, e) { this.stop(); var n = this.transform, i = !1, r = !1, o = !1; return "zoom" in t && n.zoom !== +t.zoom && (i = !0, n.zoom = +t.zoom), void 0 !== t.center && (n.center = V.convert(t.center)), "bearing" in t && n.bearing !== +t.bearing && (r = !0, n.bearing = +t.bearing), "pitch" in t && n.pitch !== +t.pitch && (o = !0, n.pitch = +t.pitch), this.fire(new D.Event("movestart", e)).fire(new D.Event("move", e)), i && this.fire(new D.Event("zoomstart", e)).fire(new D.Event("zoom", e)).fire(new D.Event("zoomend", e)), r && this.fire(new D.Event("rotatestart", e)).fire(new D.Event("rotate", e)).fire(new D.Event("rotateend", e)), o && this.fire(new D.Event("pitchstart", e)).fire(new D.Event("pitch", e)).fire(new D.Event("pitchend", e)), this.fire(new D.Event("moveend", e)) }, Vn.prototype.easeTo = function (t, i) { var r = this; this.stop(), !1 === (t = D.extend({ offset: [0, 0], duration: 500, easing: D.ease }, t)).animate && (t.duration = 0); var o = this.transform, a = this.getZoom(), s = this.getBearing(), l = this.getPitch(), u = "zoom" in t ? +t.zoom : a, c = "bearing" in t ? this._normalizeBearing(t.bearing, s) : s, h = "pitch" in t ? +t.pitch : l, p = o.centerPoint.add(D.Point.convert(t.offset)), e = o.pointLocation(p), n = V.convert(t.center || e); this._normalizeCenter(n); var f, d, m = o.project(e), y = o.project(n).sub(m), g = o.zoomScale(u - a); return t.around && (f = V.convert(t.around), d = o.locationPoint(f)), this._zooming = u !== a, this._rotating = s !== c, this._pitching = h !== l, this._prepareEase(i, t.noMoveStart), clearTimeout(this._easeEndTimeoutID), this._ease(function (t) { var e, n; r._zooming && (o.zoom = D.number(a, u, t)), r._rotating && (o.bearing = D.number(s, c, t)), r._pitching && (o.pitch = D.number(l, h, t)), f ? o.setLocationAtPoint(f, d) : (n = o.zoomScale(o.zoom - a), e = a < u ? Math.min(2, g) : Math.max(.5, g), e = Math.pow(e, 1 - t), n = o.unproject(m.add(y.mult(t * e)).mult(n)), o.setLocationAtPoint(o.renderWorldCopies ? n.wrap() : n, p)), r._fireMoveEvents(i) }, function () { t.delayEndEvents ? r._easeEndTimeoutID = setTimeout(function () { return r._afterEase(i) }, t.delayEndEvents) : r._afterEase(i) }, t), this }, Vn.prototype._prepareEase = function (t, e) { this._moving = !0, e || this.fire(new D.Event("movestart", t)), this._zooming && this.fire(new D.Event("zoomstart", t)), this._rotating && this.fire(new D.Event("rotatestart", t)), this._pitching && this.fire(new D.Event("pitchstart", t)) }, Vn.prototype._fireMoveEvents = function (t) { this.fire(new D.Event("move", t)), this._zooming && this.fire(new D.Event("zoom", t)), this._rotating && this.fire(new D.Event("rotate", t)), this._pitching && this.fire(new D.Event("pitch", t)) }, Vn.prototype._afterEase = function (t) { var e = this._zooming, n = this._rotating, i = this._pitching; this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, e && this.fire(new D.Event("zoomend", t)), n && this.fire(new D.Event("rotateend", t)), i && this.fire(new D.Event("pitchend", t)), this.fire(new D.Event("moveend", t)) }, Vn.prototype.flyTo = function (t, i) { var r = this; this.stop(), t = D.extend({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: D.ease }, t); var o = this.transform, a = this.getZoom(), s = this.getBearing(), l = this.getPitch(), u = "zoom" in t ? D.clamp(+t.zoom, o.minZoom, o.maxZoom) : a, c = "bearing" in t ? this._normalizeBearing(t.bearing, s) : s, h = "pitch" in t ? +t.pitch : l, e = o.zoomScale(u - a), p = o.centerPoint.add(D.Point.convert(t.offset)), n = o.pointLocation(p), f = V.convert(t.center || n); this._normalizeCenter(f); var d = o.project(n), m = o.project(f).sub(d), y = t.curve, g = Math.max(o.width, o.height), v = g / e, _ = m.mag(); "minZoom" in t && (S = D.clamp(Math.min(t.minZoom, a, u), o.minZoom, o.maxZoom), S = g / o.zoomScale(S - a), y = Math.sqrt(S / _ * 2)); var x = y * y; function b(t) { t = (v * v - g * g + (t ? -1 : 1) * x * x * _ * _) / (2 * (t ? v : g) * x * _); return Math.log(Math.sqrt(t * t + 1) - t) } function w(t) { return (Math.exp(t) - Math.exp(-t)) / 2 } function E(t) { return (Math.exp(t) + Math.exp(-t)) / 2 } var S, T = b(0), A = function (t) { return E(T) / E(T + y * t) }, z = function (t) { return g * ((E(T) * (w(t = T + y * t) / E(t)) - w(T)) / x) / _ }, I = (b(1) - T) / y; if (Math.abs(_) < 1e-6 || !isFinite(I)) { if (Math.abs(g - v) < 1e-6) return this.easeTo(t, i); var k = v < g ? -1 : 1, I = Math.abs(Math.log(v / g)) / y, z = function () { return 0 }, A = function (t) { return Math.exp(k * y * t) } } return "duration" in t ? t.duration = +t.duration : (S = "screenSpeed" in t ? +t.screenSpeed / y : +t.speed, t.duration = 1e3 * I / S), t.maxDuration && t.duration > t.maxDuration && (t.duration = 0), this._zooming = !0, this._rotating = s !== c, this._pitching = h !== l, this._prepareEase(i, !1), this._ease(function (t) { var e = t * I, n = 1 / A(e); o.zoom = 1 === t ? u : a + o.scaleZoom(n), r._rotating && (o.bearing = D.number(s, c, t)), r._pitching && (o.pitch = D.number(l, h, t)); n = o.unproject(d.add(m.mult(z(e))).mult(n)); o.setLocationAtPoint(o.renderWorldCopies ? n.wrap() : n, p), r._fireMoveEvents(i) }, function () { return r._afterEase(i) }, t), this }, Vn.prototype.isEasing = function () { return !!this._easeFrameId }, Vn.prototype.stop = function () { var t; return this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd && (t = this._onEaseEnd, delete this._onEaseEnd, t.call(this)), this }, Vn.prototype._ease = function (t, e, n) { !1 === n.animate || 0 === n.duration ? (t(1), e()) : (this._easeStart = D.browser.now(), this._easeOptions = n, this._onEaseFrame = t, this._onEaseEnd = e, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback)) }, Vn.prototype._renderFrameCallback = function () { var t = Math.min((D.browser.now() - this._easeStart) / this._easeOptions.duration, 1); this._onEaseFrame(this._easeOptions.easing(t)), t < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop() }, Vn.prototype._normalizeBearing = function (t, e) { t = D.wrap(t, -180, 180); var n = Math.abs(t - e); return Math.abs(t - 360 - e) < n && (t -= 360), Math.abs(t + 360 - e) < n && (t += 360), t }, Vn.prototype._normalizeCenter = function (t) { var e = this.transform; e.renderWorldCopies && !e.lngRange && (e = t.lng - e.center.lng, t.lng += 180 < e ? -360 : e < -180 ? 360 : 0) }, Vn); function Vn(t, e) { On.call(this), this._moving = !1, this._zooming = !1, this.transform = t, this._bearingSnap = e.bearingSnap, D.bindAll(["_renderFrameCallback"], this) } Bn.prototype.getDefaultPosition = function () { return "bottom-right" }, Bn.prototype.onAdd = function (t) { var e = this.options && this.options.compact; return this._map = t, this._container = d.create("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), e && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), void 0 === e && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container }, Bn.prototype.onRemove = function () { d.remove(this._container), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0 }, Bn.prototype._updateEditLink = function () { var t, e = (e = this._editLink) || (this._editLink = this._container.querySelector(".mapbox-improve-map")), i = [{ key: "owner", value: this.styleOwner }, { key: "id", value: this.styleId }, { key: "access_token", value: u.ACCESS_TOKEN }]; e && (t = i.reduce(function (t, e, n) { return e.value && (t += e.key + "=" + e.value + (n < i.length - 1 ? "&" : "")), t }, "?"), e.href = "https://www.mapbox.com/feedback/" + t + (this._map._hash ? this._map._hash.getHashString(!0) : "")) }, Bn.prototype._updateData = function (t) { t && "metadata" === t.sourceDataType && (this._updateAttributions(), this._updateEditLink()) }, Bn.prototype._updateAttributions = function () { if (this._map.style) { var t, i = []; this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? i = i.concat(this.options.customAttribution) : "string" == typeof this.options.customAttribution && i.push(this.options.customAttribution)), this._map.style.stylesheet && (t = this._map.style.stylesheet, this.styleOwner = t.owner, this.styleId = t.id); var e, n = this._map.style.sourceCaches; for (e in n) { var r = n[e].getSource(); r.attribution && i.indexOf(r.attribution) < 0 && i.push(r.attribution) } i.sort(function (t, e) { return t.length - e.length }), (i = i.filter(function (t, e) { for (var n = e + 1; n < i.length; n++)if (0 <= i[n].indexOf(t)) return !1; return !0 })).length ? (this._container.innerHTML = i.join(" | "), this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null } }, Bn.prototype._updateCompact = function () { this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact") }; function Nn() { D.bindAll(["_updateLogo"], this), D.bindAll(["_updateCompact"], this) } Nn.prototype.onAdd = function (t) { this._map = t, this._container = d.create("div", "mapboxgl-ctrl"); t = d.create("a", "mapboxgl-ctrl-logo"); return t.target = "_blank", t.href = "https://www.mapbox.com/", t.setAttribute("aria-label", "Mapbox logo"), t.setAttribute("rel", "noopener"), this._container.appendChild(t), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container }, Nn.prototype.onRemove = function () { d.remove(this._container), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact) }, Nn.prototype.getDefaultPosition = function () { return "bottom-left" }, Nn.prototype._updateLogo = function (t) { t && "metadata" !== t.sourceDataType || (this._container.style.display = this._logoRequired() ? "block" : "none") }, Nn.prototype._logoRequired = function () { if (this._map.style) { var t, e = this._map.style.sourceCaches; for (t in e) if (e[t].getSource().mapbox_logo) return !0; return !1 } }, Nn.prototype._updateCompact = function () { var t = this._container.children; t.length && (t = t[0], this._map.getCanvasContainer().offsetWidth < 250 ? t.classList.add("mapboxgl-compact") : t.classList.remove("mapboxgl-compact")) }; function jn() { this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1 } jn.prototype.add = function (t) { var e = ++this._id; return this._queue.push({ callback: t, id: e, cancelled: !1 }), e }, jn.prototype.remove = function (t) { for (var e = this._currentlyRunning, n = 0, i = e ? this._queue.concat(e) : this._queue; n < i.length; n += 1) { var r = i[n]; if (r.id === t) return void (r.cancelled = !0) } }, jn.prototype.run = function () { var t = this._currentlyRunning = this._queue; this._queue = []; for (var e = 0, n = t; e < n.length; e += 1) { var i = n[e]; if (!i.cancelled && (i.callback(), this._cleared)) break } this._cleared = !1, this._currentlyRunning = !1 }, jn.prototype.clear = function () { this._currentlyRunning && (this._cleared = !0), this._queue = [] }; var Un = D.window.HTMLImageElement, qn = D.window.HTMLElement, Zn = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: 0, maxZoom: 22, interactive: !0, scrollZoom: !0, boxZoom: !0, dragRotate: !0, dragPan: !0, keyboard: !0, doubleClickZoom: !0, touchZoomRotate: !0, bearingSnap: 7, clickTolerance: 3, hash: !1, attributionControl: !0, failIfMajorPerformanceCaveat: !1, preserveDrawingBuffer: !1, trackResize: !0, renderWorldCopies: !0, refreshExpiredTiles: !0, maxTileCacheSize: null, transformRequest: null, fadeDuration: 300, crossSourceCollisions: !0 }, b = function (s) { function t(t) { var e = this; if (null != (t = D.extend({}, Zn, t)).minZoom && null != t.maxZoom && t.minZoom > t.maxZoom) throw new Error("maxZoom must be greater than minZoom"); var n = new An(t.minZoom, t.maxZoom, t.renderWorldCopies); s.call(this, n, t), this._interactive = t.interactive, this._maxTileCacheSize = t.maxTileCacheSize, this._failIfMajorPerformanceCaveat = t.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = t.preserveDrawingBuffer, this._trackResize = t.trackResize, this._bearingSnap = t.bearingSnap, this._refreshExpiredTiles = t.refreshExpiredTiles, this._fadeDuration = t.fadeDuration, this._crossSourceCollisions = t.crossSourceCollisions, this._crossFadingFactor = 1, this._collectResourceTiming = t.collectResourceTiming, this._renderTaskQueue = new jn, this._controls = []; var i = t.transformRequest; if (this._transformRequest = i ? function (t, e) { return i(t, e) || { url: t } } : function (t) { return { url: t } }, "string" == typeof t.container) { if (this._container = D.window.document.getElementById(t.container), !this._container) throw new Error("Container '" + t.container + "' not found.") } else { if (!(t.container instanceof qn)) throw new Error("Invalid type: 'container' must be a String or HTMLElement."); this._container = t.container } if (t.maxBounds && this.setMaxBounds(t.maxBounds), D.bindAll(["_onWindowOnline", "_onWindowResize", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._setupPainter(), void 0 === this.painter) throw new Error("Failed to initialize WebGL."); this.on("move", function () { return e._update(!1) }), this.on("zoom", function () { return e._update(!0) }), void 0 !== D.window && (D.window.addEventListener("online", this._onWindowOnline, !1), D.window.addEventListener("resize", this._onWindowResize, !1)), function (n, i) { var t, r = n.getCanvasContainer(), o = null, a = !1, s = null; for (t in Fn) n[t] = new Fn[t](n, i), i.interactive && i[t] && n[t].enable(i[t]); d.addEventListener(r, "mouseout", function (t) { n.fire(new In("mouseout", n, t)) }), d.addEventListener(r, "mousedown", function (t) { a = !0, s = d.mousePos(r, t); var e = new In("mousedown", n, t); n.fire(e), e.defaultPrevented || (i.interactive && !n.doubleClickZoom.isActive() && n.stop(), n.boxZoom.onMouseDown(t), n.boxZoom.isActive() || n.dragPan.isActive() || n.dragRotate.onMouseDown(t), n.boxZoom.isActive() || n.dragRotate.isActive() || n.dragPan.onMouseDown(t)) }), d.addEventListener(r, "mouseup", function (t) { var e = n.dragRotate.isActive(); o && !e && n.fire(new In("contextmenu", n, o)), o = null, a = !1, n.fire(new In("mouseup", n, t)) }), d.addEventListener(r, "mousemove", function (t) { if (!n.dragPan.isActive() && !n.dragRotate.isActive()) { for (var e = t.target; e && e !== r;)e = e.parentNode; e === r && n.fire(new In("mousemove", n, t)) } }), d.addEventListener(r, "mouseover", function (t) { for (var e = t.target; e && e !== r;)e = e.parentNode; e === r && n.fire(new In("mouseover", n, t)) }), d.addEventListener(r, "touchstart", function (t) { var e = new kn("touchstart", n, t); n.fire(e), e.defaultPrevented || (i.interactive && n.stop(), n.boxZoom.isActive() || n.dragRotate.isActive() || n.dragPan.onTouchStart(t), n.touchZoomRotate.onStart(t), n.doubleClickZoom.onTouchStart(e)) }, { passive: !1 }), d.addEventListener(r, "touchmove", function (t) { n.fire(new kn("touchmove", n, t)) }, { passive: !1 }), d.addEventListener(r, "touchend", function (t) { n.fire(new kn("touchend", n, t)) }), d.addEventListener(r, "touchcancel", function (t) { n.fire(new kn("touchcancel", n, t)) }), d.addEventListener(r, "click", function (t) { var e = d.mousePos(r, t); (e.equals(s) || e.dist(s) < i.clickTolerance) && n.fire(new In("click", n, t)) }), d.addEventListener(r, "dblclick", function (t) { t = new In("dblclick", n, t); n.fire(t), t.defaultPrevented || n.doubleClickZoom.onDblClick(t) }), d.addEventListener(r, "contextmenu", function (t) { var e = n.dragRotate.isActive(); a || e ? a && (o = t) : n.fire(new In("contextmenu", n, t)), t.preventDefault() }), d.addEventListener(r, "wheel", function (t) { i.interactive && n.stop(); var e = new Cn("wheel", n, t); n.fire(e), e.defaultPrevented || n.scrollZoom.onWheel(t) }, { passive: !1 }) }(this, t), this._hash = t.hash && (new zn).addTo(this), this._hash && this._hash._onHashChange() || this.jumpTo({ center: t.center, zoom: t.zoom, bearing: t.bearing, pitch: t.pitch }), this.resize(), t.style && this.setStyle(t.style, { localIdeographFontFamily: t.localIdeographFontFamily }), t.attributionControl && this.addControl(new Bn({ customAttribution: t.customAttribution })), this.addControl(new Nn, t.logoPosition), this.on("style.load", function () { e.transform.unmodified && e.jumpTo(e.style.stylesheet) }), this.on("data", function (t) { e._update("style" === t.dataType), e.fire(new D.Event(t.dataType + "data", t)) }), this.on("dataloading", function (t) { e.fire(new D.Event(t.dataType + "dataloading", t)) }) } s && (t.__proto__ = s); var e = { showTileBoundaries: { configurable: !0 }, showCollisionBoxes: { configurable: !0 }, showOverdrawInspector: { configurable: !0 }, repaint: { configurable: !0 }, vertices: { configurable: !0 } }; return ((t.prototype = Object.create(s && s.prototype)).constructor = t).prototype.addControl = function (t, e) { if (void 0 === e && t.getDefaultPosition && (e = t.getDefaultPosition()), void 0 === e && (e = "top-right"), !t || !t.onAdd) return this.fire(new D.ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods."))); var n = t.onAdd(this); this._controls.push(t); t = this._controlPositions[e]; return -1 !== e.indexOf("bottom") ? t.insertBefore(n, t.firstChild) : t.appendChild(n), this }, t.prototype.removeControl = function (t) { if (!t || !t.onRemove) return this.fire(new D.ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods."))); var e = this._controls.indexOf(t); return -1 < e && this._controls.splice(e, 1), t.onRemove(this), this }, t.prototype.resize = function (t) { var e = this._containerDimensions(), n = e[0], e = e[1]; return this._resizeCanvas(n, e), this.transform.resize(n, e), this.painter.resize(n, e), this.fire(new D.Event("movestart", t)).fire(new D.Event("move", t)).fire(new D.Event("resize", t)).fire(new D.Event("moveend", t)), this }, t.prototype.getBounds = function () { return this.transform.getBounds() }, t.prototype.getMaxBounds = function () { return this.transform.getMaxBounds() }, t.prototype.setMaxBounds = function (t) { return this.transform.setMaxBounds(N.convert(t)), this._update() }, t.prototype.setMinZoom = function (t) { if (0 <= (t = null == t ? 0 : t) && t <= this.transform.maxZoom) return this.transform.minZoom = t, this._update(), this.getZoom() < t && this.setZoom(t), this; throw new Error("minZoom must be between 0 and the current maxZoom, inclusive") }, t.prototype.getMinZoom = function () { return this.transform.minZoom }, t.prototype.setMaxZoom = function (t) { if ((t = null == t ? 22 : t) >= this.transform.minZoom) return this.transform.maxZoom = t, this._update(), this.getZoom() > t && this.setZoom(t), this; throw new Error("maxZoom must be greater than the current minZoom") }, t.prototype.getRenderWorldCopies = function () { return this.transform.renderWorldCopies }, t.prototype.setRenderWorldCopies = function (t) { return this.transform.renderWorldCopies = t, this._update() }, t.prototype.getMaxZoom = function () { return this.transform.maxZoom }, t.prototype.project = function (t) { return this.transform.locationPoint(V.convert(t)) }, t.prototype.unproject = function (t) { return this.transform.pointLocation(D.Point.convert(t)) }, t.prototype.isMoving = function () { return this._moving || this.dragPan.isActive() || this.dragRotate.isActive() || this.scrollZoom.isActive() }, t.prototype.isZooming = function () { return this._zooming || this.scrollZoom.isActive() }, t.prototype.isRotating = function () { return this._rotating || this.dragRotate.isActive() }, t.prototype.on = function (i, r, o) { var t, a = this; if (void 0 === o) return s.prototype.on.call(this, i, r); var e, n = function () { if ("mouseenter" === i || "mouseover" === i) { var n = !1; return { layer: r, listener: o, delegates: { mousemove: function (t) { var e = a.getLayer(r) ? a.queryRenderedFeatures(t.point, { layers: [r] }) : []; e.length ? n || (n = !0, o.call(a, new In(i, a, t.originalEvent, { features: e }))) : n = !1 }, mouseout: function () { n = !1 } } } } if ("mouseleave" !== i && "mouseout" !== i) return { layer: r, listener: o, delegates: ((t = {})[i] = function (t) { var e = a.getLayer(r) ? a.queryRenderedFeatures(t.point, { layers: [r] }) : []; e.length && (t.features = e, o.call(a, t), delete t.features) }, t) }; var e = !1; return { layer: r, listener: o, delegates: { mousemove: function (t) { (a.getLayer(r) ? a.queryRenderedFeatures(t.point, { layers: [r] }) : []).length ? e = !0 : e && (e = !1, o.call(a, new In(i, a, t.originalEvent))) }, mouseout: function (t) { e && (e = !1, o.call(a, new In(i, a, t.originalEvent))) } } } }(); for (e in this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[i] = this._delegatedListeners[i] || [], this._delegatedListeners[i].push(n), n.delegates) a.on(e, n.delegates[e]); return this }, t.prototype.off = function (t, e, n) { if (void 0 === n) return s.prototype.off.call(this, t, e); if (this._delegatedListeners && this._delegatedListeners[t]) for (var i = this._delegatedListeners[t], r = 0; r < i.length; r++) { var o = i[r]; if (o.layer === e && o.listener === n) { for (var a in o.delegates) this.off(a, o.delegates[a]); return i.splice(r, 1), this } } return this }, t.prototype.queryRenderedFeatures = function (t, e) { return this.style ? (void 0 !== e || void 0 === t || t instanceof D.Point || Array.isArray(t) || (e = t, t = void 0), e = e || {}, n = (t = t || [[0, 0], [this.transform.width, this.transform.height]]) instanceof D.Point || "number" == typeof t[0] ? [D.Point.convert(t)] : (n = D.Point.convert(t[0]), t = D.Point.convert(t[1]), [n, new D.Point(t.x, n.y), t, new D.Point(n.x, t.y), n]), this.style.queryRenderedFeatures(n, e, this.transform)) : []; var n }, t.prototype.querySourceFeatures = function (t, e) { return this.style.querySourceFeatures(t, e) }, t.prototype.setStyle = function (t, e) { if ((!e || !1 !== e.diff && !e.localIdeographFontFamily) && this.style && t && "object" == typeof t) try { return this.style.setState(t) && this._update(!0), this } catch (t) { D.warnOnce("Unable to perform style diff: " + (t.message || t.error || t) + ".  Rebuilding the style from scratch.") } return this.style && (this.style.setEventedParent(null), this.style._remove()), t ? (this.style = new $e(this, e || {}), this.style.setEventedParent(this, { style: this.style }), "string" == typeof t ? this.style.loadURL(t) : this.style.loadJSON(t)) : delete this.style, this }, t.prototype.getStyle = function () { if (this.style) return this.style.serialize() }, t.prototype.isStyleLoaded = function () { return this.style ? this.style.loaded() : D.warnOnce("There is no style added to the map.") }, t.prototype.addSource = function (t, e) { return this.style.addSource(t, e), this._update(!0) }, t.prototype.isSourceLoaded = function (t) { var e = this.style && this.style.sourceCaches[t]; if (void 0 !== e) return e.loaded(); this.fire(new D.ErrorEvent(new Error("There is no source with ID '" + t + "'"))) }, t.prototype.areTilesLoaded = function () { var t, e = this.style && this.style.sourceCaches; for (t in e) { var n, i = e[t]._tiles; for (n in i) { var r = i[n]; if ("loaded" !== r.state && "errored" !== r.state) return !1 } } return !0 }, t.prototype.addSourceType = function (t, e, n) { return this.style.addSourceType(t, e, n) }, t.prototype.removeSource = function (t) { return this.style.removeSource(t), this._update(!0) }, t.prototype.getSource = function (t) { return this.style.getSource(t) }, t.prototype.addImage = function (t, e, n) { void 0 === n && (n = {}); var i = n.pixelRatio; void 0 === i && (i = 1); var r = n.sdf; if (void 0 === r && (r = !1), e instanceof Un) { var o = D.browser.getImageData(e), n = o.width, a = o.height, o = o.data; this.style.addImage(t, { data: new D.RGBAImage({ width: n, height: a }, o), pixelRatio: i, sdf: r }) } else { if (void 0 === e.width || void 0 === e.height) return this.fire(new D.ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`"))); a = e.width, o = e.height, e = e.data; this.style.addImage(t, { data: new D.RGBAImage({ width: a, height: o }, new Uint8Array(e)), pixelRatio: i, sdf: r }) } }, t.prototype.hasImage = function (t) { return t ? !!this.style.getImage(t) : (this.fire(new D.ErrorEvent(new Error("Missing required image id"))), !1) }, t.prototype.removeImage = function (t) { this.style.removeImage(t) }, t.prototype.loadImage = function (t, e) { D.getImage(this._transformRequest(t, D.ResourceType.Image), e) }, t.prototype.listImages = function () { return this.style.listImages() }, t.prototype.addLayer = function (t, e) { return this.style.addLayer(t, e), this._update(!0) }, t.prototype.moveLayer = function (t, e) { return this.style.moveLayer(t, e), this._update(!0) }, t.prototype.removeLayer = function (t) { return this.style.removeLayer(t), this._update(!0) }, t.prototype.getLayer = function (t) { return this.style.getLayer(t) }, t.prototype.setFilter = function (t, e) { return this.style.setFilter(t, e), this._update(!0) }, t.prototype.setLayerZoomRange = function (t, e, n) { return this.style.setLayerZoomRange(t, e, n), this._update(!0) }, t.prototype.getFilter = function (t) { return this.style.getFilter(t) }, t.prototype.setPaintProperty = function (t, e, n) { return this.style.setPaintProperty(t, e, n), this._update(!0) }, t.prototype.getPaintProperty = function (t, e) { return this.style.getPaintProperty(t, e) }, t.prototype.setLayoutProperty = function (t, e, n) { return this.style.setLayoutProperty(t, e, n), this._update(!0) }, t.prototype.getLayoutProperty = function (t, e) { return this.style.getLayoutProperty(t, e) }, t.prototype.setLight = function (t) { return this.style.setLight(t), this._update(!0) }, t.prototype.getLight = function () { return this.style.getLight() }, t.prototype.setFeatureState = function (t, e) { return this.style.setFeatureState(t, e), this._update() }, t.prototype.getFeatureState = function (t) { return this.style.getFeatureState(t) }, t.prototype.getContainer = function () { return this._container }, t.prototype.getCanvasContainer = function () { return this._canvasContainer }, t.prototype.getCanvas = function () { return this._canvas }, t.prototype._containerDimensions = function () { var t = 0, e = 0; return this._container && (t = this._container.offsetWidth || 400, e = this._container.offsetHeight || 300), [t, e] }, t.prototype._detectMissingCSS = function () { "rgb(250, 128, 114)" !== D.window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") && D.warnOnce("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.") }, t.prototype._setupContainer = function () { var t = this._container; t.classList.add("mapboxgl-map"), (this._missingCSSCanary = d.create("div", "mapboxgl-canary", t)).style.visibility = "hidden", this._detectMissingCSS(); var e = this._canvasContainer = d.create("div", "mapboxgl-canvas-container", t); this._interactive && e.classList.add("mapboxgl-interactive"), this._canvas = d.create("canvas", "mapboxgl-canvas", e), this._canvas.style.position = "absolute", this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", "Map"); e = this._containerDimensions(); this._resizeCanvas(e[0], e[1]); var n = this._controlContainer = d.create("div", "mapboxgl-control-container", t), i = this._controlPositions = {};["top-left", "top-right", "bottom-left", "bottom-right"].forEach(function (t) { i[t] = d.create("div", "mapboxgl-ctrl-" + t, n) }) }, t.prototype._resizeCanvas = function (t, e) { var n = D.window.devicePixelRatio || 1; this._canvas.width = n * t, this._canvas.height = n * e, this._canvas.style.width = t + "px", this._canvas.style.height = e + "px" }, t.prototype._setupPainter = function () { var t = D.extend({ failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer }, n.webGLContextAttributes), t = this._canvas.getContext("webgl", t) || this._canvas.getContext("experimental-webgl", t); t ? this.painter = new xn(t, this.transform) : this.fire(new D.ErrorEvent(new Error("Failed to initialize WebGL"))) }, t.prototype._contextLost = function (t) { t.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new D.Event("webglcontextlost", { originalEvent: t })) }, t.prototype._contextRestored = function (t) { this._setupPainter(), this.resize(), this._update(), this.fire(new D.Event("webglcontextrestored", { originalEvent: t })) }, t.prototype.loaded = function () { return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded() }, t.prototype._update = function (t) { return this.style && (this._styleDirty = this._styleDirty || t, this._sourcesDirty = !0, this._rerender()), this }, t.prototype._requestRenderFrame = function (t) { return this._update(), this._renderTaskQueue.add(t) }, t.prototype._cancelRenderFrame = function (t) { this._renderTaskQueue.remove(t) }, t.prototype._render = function () { this._renderTaskQueue.run(); var t, e, n = !1; return this.style && this._styleDirty && (this._styleDirty = !1, t = this.transform.zoom, e = D.browser.now(), this.style.zoomHistory.update(t, e), 1 === (e = (t = new D.EvaluationParameters(t, { now: e, fadeDuration: this._fadeDuration, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() })).crossFadingFactor()) && e === this._crossFadingFactor || (n = !0, this._crossFadingFactor = e), this.style.update(t)), this.style && this._sourcesDirty && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, this._fadeDuration, this._crossSourceCollisions), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), fadeDuration: this._fadeDuration }), this.fire(new D.Event("render")), this.loaded() && !this._loaded && (this._loaded = !0, this.fire(new D.Event("load"))), this.style && (this.style.hasTransitions() || n) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), (this._sourcesDirty || this._repaint || this._styleDirty || this._placementDirty) && this._rerender(), this }, t.prototype.remove = function () { this._hash && this._hash.remove(), this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this.setStyle(null), void 0 !== D.window && (D.window.removeEventListener("resize", this._onWindowResize, !1), D.window.removeEventListener("online", this._onWindowOnline, !1)); for (var t = 0, e = this._controls; t < e.length; t += 1)e[t].onRemove(this); this._controls = []; var n = this.painter.context.gl.getExtension("WEBGL_lose_context"); n && n.loseContext(), Gn(this._canvasContainer), Gn(this._controlContainer), Gn(this._missingCSSCanary), this._container.classList.remove("mapboxgl-map"), this.fire(new D.Event("remove")) }, t.prototype._rerender = function () { var t = this; this.style && !this._frame && (this._frame = D.browser.frame(function () { t._frame = null, t._render() })) }, t.prototype._onWindowOnline = function () { this._update() }, t.prototype._onWindowResize = function () { this._trackResize && this.resize()._update() }, e.showTileBoundaries.get = function () { return !!this._showTileBoundaries }, e.showTileBoundaries.set = function (t) { this._showTileBoundaries !== t && (this._showTileBoundaries = t, this._update()) }, e.showCollisionBoxes.get = function () { return !!this._showCollisionBoxes }, e.showCollisionBoxes.set = function (t) { this._showCollisionBoxes !== t && ((this._showCollisionBoxes = t) ? this.style._generateCollisionBoxes() : this._update()) }, e.showOverdrawInspector.get = function () { return !!this._showOverdrawInspector }, e.showOverdrawInspector.set = function (t) { this._showOverdrawInspector !== t && (this._showOverdrawInspector = t, this._update()) }, e.repaint.get = function () { return !!this._repaint }, e.repaint.set = function (t) { this._repaint = t, this._update() }, e.vertices.get = function () { return !!this._vertices }, e.vertices.set = function (t) { this._vertices = t, this._update() }, Object.defineProperties(t.prototype, e), t }(x); function Gn(t) { t.parentNode && t.parentNode.removeChild(t) } var Xn = { showCompass: !0, showZoom: !0 }, S = function (t) { var e = this; this.options = D.extend({}, Xn, t), this._container = d.create("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", function (t) { return t.preventDefault() }), this.options.showZoom && (this._zoomInButton = this._createButton("mapboxgl-ctrl-icon mapboxgl-ctrl-zoom-in", "Zoom In", function () { return e._map.zoomIn() }), this._zoomOutButton = this._createButton("mapboxgl-ctrl-icon mapboxgl-ctrl-zoom-out", "Zoom Out", function () { return e._map.zoomOut() })), this.options.showCompass && (D.bindAll(["_rotateCompassArrow"], this), this._compass = this._createButton("mapboxgl-ctrl-icon mapboxgl-ctrl-compass", "Reset North", function () { return e._map.resetNorth() }), this._compassArrow = d.create("span", "mapboxgl-ctrl-compass-arrow", this._compass)) }; function Wn(t, e, n) { var i, r, o; for (t = new V(t.lng, t.lat), e && (i = new V(t.lng - 360, t.lat), r = new V(t.lng + 360, t.lat), o = n.locationPoint(t).distSqr(e), n.locationPoint(i).distSqr(e) < o ? t = i : n.locationPoint(r).distSqr(e) < o && (t = r)); 180 < Math.abs(t.lng - n.center.lng);) { var a = n.locationPoint(t); if (0 <= a.x && 0 <= a.y && a.x <= n.width && a.y <= n.height) break; t.lng > n.center.lng ? t.lng -= 360 : t.lng += 360 } return t } S.prototype._rotateCompassArrow = function () { var t = "rotate(" + this._map.transform.angle * (180 / Math.PI) + "deg)"; this._compassArrow.style.transform = t }, S.prototype.onAdd = function (t) { return this._map = t, this.options.showCompass && (this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Mn(t, { button: "left", element: this._compass }), d.addEventListener(this._compass, "mousedown", this._handler.onMouseDown), this._handler.enable()), this._container }, S.prototype.onRemove = function () { d.remove(this._container), this.options.showCompass && (this._map.off("rotate", this._rotateCompassArrow), d.removeEventListener(this._compass, "mousedown", this._handler.onMouseDown), this._handler.disable(), delete this._handler), delete this._map }, S.prototype._createButton = function (t, e, n) { t = d.create("button", t, this._container); return t.type = "button", t.setAttribute("aria-label", e), t.addEventListener("click", n), t }; var Hn = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" }; function Kn(t, e, n) { var i, r = t.classList; for (i in Hn) r.remove("mapboxgl-" + n + "-anchor-" + i); r.add("mapboxgl-" + n + "-anchor-" + e) } var Jn, Yn, $n = ((Yn = D.Evented) && (ti.__proto__ = Yn), ((ti.prototype = Object.create(Yn && Yn.prototype)).constructor = ti).prototype.addTo = function (t) { return this.remove(), (this._map = t).getCanvasContainer().appendChild(this._element), t.on("move", this._update), t.on("moveend", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this }, ti.prototype.remove = function () { return this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), delete this._map), d.remove(this._element), this._popup && this._popup.remove(), this }, ti.prototype.getLngLat = function () { return this._lngLat }, ti.prototype.setLngLat = function (t) { return this._lngLat = V.convert(t), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this }, ti.prototype.getElement = function () { return this._element }, ti.prototype.setPopup = function (t) { var e; return this._popup && (this._popup.remove(), this._popup = null), t && ("offset" in t.options || (e = Math.sqrt(Math.pow(13.5, 2) / 2), t.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [e, -1 * (24.6 + e)], "bottom-right": [-e, -1 * (24.6 + e)], left: [13.5, -24.6], right: [-13.5, -24.6] } : this._offset), this._popup = t, this._lngLat && this._popup.setLngLat(this._lngLat)), this }, ti.prototype._onMapClick = function (t) { var e = t.originalEvent.target, t = this._element; this._popup && (e === t || t.contains(e)) && this.togglePopup() }, ti.prototype.getPopup = function () { return this._popup }, ti.prototype.togglePopup = function () { var t = this._popup; return t && (t.isOpen() ? t.remove() : t.addTo(this._map)), this }, ti.prototype._update = function (t) { this._map && (this._map.transform.renderWorldCopies && (this._lngLat = Wn(this._lngLat, this._pos, this._map.transform)), this._pos = this._map.project(this._lngLat)._add(this._offset), t && "moveend" !== t.type || (this._pos = this._pos.round()), d.setTransform(this._element, Hn[this._anchor] + " translate(" + this._pos.x + "px, " + this._pos.y + "px)"), Kn(this._element, this._anchor, "marker")) }, ti.prototype.getOffset = function () { return this._offset }, ti.prototype.setOffset = function (t) { return this._offset = D.Point.convert(t), this._update(), this }, ti.prototype._onMove = function (t) { this._pos = t.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new D.Event("dragstart"))), this.fire(new D.Event("drag")) }, ti.prototype._onUp = function () { this._element.style.pointerEvents = "auto", this._positionDelta = null, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), "active" === this._state && this.fire(new D.Event("dragend")), this._state = "inactive" }, ti.prototype._addDragHandler = function (t) { this._element.contains(t.originalEvent.target) && (t.preventDefault(), this._positionDelta = t.point.sub(this._pos).add(this._offset), this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp)) }, ti.prototype.setDraggable = function (t) { return this._draggable = !!t, this._map && (t ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this }, ti.prototype.isDraggable = function () { return this._draggable }, ti), Qn = { positionOptions: { enableHighAccuracy: !1, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: !1, showUserLocation: !0 }; function ti(t) { if (Yn.call(this), (arguments[0] instanceof D.window.HTMLElement || 2 === arguments.length) && (t = D.extend({ element: t }, arguments[1])), D.bindAll(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick"], this), this._anchor = t && t.anchor || "center", this._color = t && t.color || "#3FB1CE", this._draggable = t && t.draggable || !1, this._state = "inactive", t && t.element) this._element = t.element, this._offset = D.Point.convert(t && t.offset || [0, 0]); else { this._defaultMarker = !0, this._element = d.create("div"); var e = d.createNS("http://www.w3.org/2000/svg", "svg"); e.setAttributeNS(null, "height", "41px"), e.setAttributeNS(null, "width", "27px"), e.setAttributeNS(null, "viewBox", "0 0 27 41"); var n = d.createNS("http://www.w3.org/2000/svg", "g"); n.setAttributeNS(null, "stroke", "none"), n.setAttributeNS(null, "stroke-width", "1"), n.setAttributeNS(null, "fill", "none"), n.setAttributeNS(null, "fill-rule", "evenodd"); var i = d.createNS("http://www.w3.org/2000/svg", "g"); i.setAttributeNS(null, "fill-rule", "nonzero"); var r = d.createNS("http://www.w3.org/2000/svg", "g"); r.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), r.setAttributeNS(null, "fill", "#000000"); for (var o = 0, a = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }]; o < a.length; o += 1) { var s = a[o], l = d.createNS("http://www.w3.org/2000/svg", "ellipse"); l.setAttributeNS(null, "opacity", "0.04"), l.setAttributeNS(null, "cx", "10.5"), l.setAttributeNS(null, "cy", "5.80029008"), l.setAttributeNS(null, "rx", s.rx), l.setAttributeNS(null, "ry", s.ry), r.appendChild(l) } var u = d.createNS("http://www.w3.org/2000/svg", "g"); u.setAttributeNS(null, "fill", this._color); var c = d.createNS("http://www.w3.org/2000/svg", "path"); c.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), u.appendChild(c); var h = d.createNS("http://www.w3.org/2000/svg", "g"); h.setAttributeNS(null, "opacity", "0.25"), h.setAttributeNS(null, "fill", "#000000"); var p = d.createNS("http://www.w3.org/2000/svg", "path"); p.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), h.appendChild(p); var f = d.createNS("http://www.w3.org/2000/svg", "g"); f.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), f.setAttributeNS(null, "fill", "#FFFFFF"); n = d.createNS("http://www.w3.org/2000/svg", "g"); n.setAttributeNS(null, "transform", "translate(8.0, 8.0)"); c = d.createNS("http://www.w3.org/2000/svg", "circle"); c.setAttributeNS(null, "fill", "#000000"), c.setAttributeNS(null, "opacity", "0.25"), c.setAttributeNS(null, "cx", "5.5"), c.setAttributeNS(null, "cy", "5.5"), c.setAttributeNS(null, "r", "5.4999962"); p = d.createNS("http://www.w3.org/2000/svg", "circle"); p.setAttributeNS(null, "fill", "#FFFFFF"), p.setAttributeNS(null, "cx", "5.5"), p.setAttributeNS(null, "cy", "5.5"), p.setAttributeNS(null, "r", "5.4999962"), n.appendChild(c), n.appendChild(p), i.appendChild(r), i.appendChild(u), i.appendChild(h), i.appendChild(f), i.appendChild(n), e.appendChild(i), this._element.appendChild(e), this._offset = D.Point.convert(t && t.offset || [0, -14]) } this._element.classList.add("mapboxgl-marker"), this._popup = null } var ei, C = ((ei = D.Evented) && (ii.__proto__ = ei), ((ii.prototype = Object.create(ei && ei.prototype)).constructor = ii).prototype.onAdd = function (t) { var e; return this._map = t, this._container = d.create("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), e = this._setupUI, void 0 !== Jn ? e(Jn) : void 0 !== D.window.navigator.permissions ? D.window.navigator.permissions.query({ name: "geolocation" }).then(function (t) { Jn = "denied" !== t.state, e(Jn) }) : (Jn = !!D.window.navigator.geolocation, e(Jn)), this._container }, ii.prototype.onRemove = function () { void 0 !== this._geolocationWatchID && (D.window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), d.remove(this._container), this._map = void 0 }, ii.prototype._onSuccess = function (t) { if (this.options.trackUserLocation) switch (this._lastKnownPosition = t, this._watchState) { case "WAITING_ACTIVE": case "ACTIVE_LOCK": case "ACTIVE_ERROR": this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active"); break; case "BACKGROUND": case "BACKGROUND_ERROR": this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background") }this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(t), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(t), this.options.showUserLocation && this._dotElement.classList.remove("mapboxgl-user-location-dot-stale"), this.fire(new D.Event("geolocate", t)), this._finish() }, ii.prototype._updateCamera = function (t) { var e = new V(t.coords.longitude, t.coords.latitude), t = t.coords.accuracy; this._map.fitBounds(e.toBounds(t), this.options.fitBoundsOptions, { geolocateSource: !0 }) }, ii.prototype._updateMarker = function (t) { t ? this._userLocationDotMarker.setLngLat([t.coords.longitude, t.coords.latitude]).addTo(this._map) : this._userLocationDotMarker.remove() }, ii.prototype._onError = function (t) { if (this.options.trackUserLocation) if (1 === t.code) this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), void 0 !== this._geolocationWatchID && this._clearWatch(); else switch (this._watchState) { case "WAITING_ACTIVE": this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"); break; case "ACTIVE_LOCK": this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"); break; case "BACKGROUND": this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting") }"OFF" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add("mapboxgl-user-location-dot-stale"), this.fire(new D.Event("error", t)), this._finish() }, ii.prototype._finish = function () { this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0 }, ii.prototype._setupUI = function (t) { var e = this; !1 !== t ? (this._container.addEventListener("contextmenu", function (t) { return t.preventDefault() }), this._geolocateButton = d.create("button", "mapboxgl-ctrl-icon mapboxgl-ctrl-geolocate", this._container), this._geolocateButton.type = "button", this._geolocateButton.setAttribute("aria-label", "Geolocate"), this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = d.create("div", "mapboxgl-user-location-dot"), this._userLocationDotMarker = new $n(this._dotElement), this.options.trackUserLocation && (this._watchState = "OFF")), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", function (t) { t.geolocateSource || "ACTIVE_LOCK" !== e._watchState || (e._watchState = "BACKGROUND", e._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), e._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), e.fire(new D.Event("trackuserlocationend"))) })) : D.warnOnce("Geolocation support is not available, the GeolocateControl will not be visible.") }, ii.prototype.trigger = function () { if (!this._setup) return D.warnOnce("Geolocate control triggered before added to a map"), !1; if (this.options.trackUserLocation) { switch (this._watchState) { case "OFF": this._watchState = "WAITING_ACTIVE", this.fire(new D.Event("trackuserlocationstart")); break; case "WAITING_ACTIVE": case "ACTIVE_LOCK": case "ACTIVE_ERROR": case "BACKGROUND_ERROR": this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new D.Event("trackuserlocationend")); break; case "BACKGROUND": this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new D.Event("trackuserlocationstart")) }switch (this._watchState) { case "WAITING_ACTIVE": this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active"); break; case "ACTIVE_LOCK": this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active"); break; case "ACTIVE_ERROR": this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"); break; case "BACKGROUND": this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"); break; case "BACKGROUND_ERROR": this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error") }"OFF" === this._watchState && void 0 !== this._geolocationWatchID ? this._clearWatch() : void 0 === this._geolocationWatchID && (this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), this._geolocationWatchID = D.window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, this.options.positionOptions)) } else D.window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4); return !0 }, ii.prototype._clearWatch = function () { D.window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null) }, ii), ni = { maxWidth: 100, unit: "metric" }, X = function (t) { this.options = D.extend({}, ni, t), D.bindAll(["_onMove", "setUnit"], this) }; function ii(t) { ei.call(this), this.options = D.extend({}, Qn, t), D.bindAll(["_onSuccess", "_onError", "_finish", "_setupUI", "_updateCamera", "_updateMarker"], this) } function ri(t, e, n) { var i, r, o = n && n.maxWidth || 100, a = t._container.clientHeight / 2, s = (r = t.unproject([0, a]), i = t.unproject([o, a]), s = Math.PI / 180, t = r.lat * s, a = i.lat * s, r = Math.sin(t) * Math.sin(a) + Math.cos(t) * Math.cos(a) * Math.cos((i.lng - r.lng) * s), 6371e3 * Math.acos(Math.min(r, 1))); n && "imperial" === n.unit ? 5280 < (r = 3.2808 * s) ? oi(e, o, r / 5280, "mi") : oi(e, o, r, "ft") : n && "nautical" === n.unit ? oi(e, o, s / 1852, "nm") : oi(e, o, s, "m") } function oi(t, e, n, i) { var r, o = (r = n, (o = Math.pow(10, ("" + Math.floor(r)).length - 1)) * (o = 10 <= (o = r / o) ? 10 : 5 <= o ? 5 : 3 <= o ? 3 : 2 <= o ? 2 : 1)), n = o / n; "m" === i && 1e3 <= o && (o /= 1e3, i = "km"), t.style.width = e * n + "px", t.innerHTML = o + i } X.prototype.getDefaultPosition = function () { return "bottom-left" }, X.prototype._onMove = function () { ri(this._map, this._container, this.options) }, X.prototype.onAdd = function (t) { return this._map = t, this._container = d.create("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", t.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container }, X.prototype.onRemove = function () { d.remove(this._container), this._map.off("move", this._onMove), this._map = void 0 }, X.prototype.setUnit = function (t) { this.options.unit = t, ri(this._map, this._container, this.options) }; W = function () { this._fullscreen = !1, D.bindAll(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in D.window.document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in D.window.document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in D.window.document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in D.window.document && (this._fullscreenchange = "MSFullscreenChange"), this._className = "mapboxgl-ctrl" }; W.prototype.onAdd = function (t) { return this._map = t, this._mapContainer = this._map.getContainer(), this._container = d.create("div", this._className + " mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._container.style.display = "none", D.warnOnce("This device does not support fullscreen mode.")), this._container }, W.prototype.onRemove = function () { d.remove(this._container), this._map = null, D.window.document.removeEventListener(this._fullscreenchange, this._changeIcon) }, W.prototype._checkFullscreenSupport = function () { return !!(D.window.document.fullscreenEnabled || D.window.document.mozFullScreenEnabled || D.window.document.msFullscreenEnabled || D.window.document.webkitFullscreenEnabled) }, W.prototype._setupUI = function () { var t = this._fullscreenButton = d.create("button", this._className + "-icon " + this._className + "-fullscreen", this._container); t.setAttribute("aria-label", "Toggle fullscreen"), t.type = "button", this._fullscreenButton.addEventListener("click", this._onClickFullscreen), D.window.document.addEventListener(this._fullscreenchange, this._changeIcon) }, W.prototype._isFullscreen = function () { return this._fullscreen }, W.prototype._changeIcon = function () { (D.window.document.fullscreenElement || D.window.document.mozFullScreenElement || D.window.document.webkitFullscreenElement || D.window.document.msFullscreenElement) === this._mapContainer !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle(this._className + "-shrink"), this._fullscreenButton.classList.toggle(this._className + "-fullscreen")) }, W.prototype._onClickFullscreen = function () { this._isFullscreen() ? D.window.document.exitFullscreen ? D.window.document.exitFullscreen() : D.window.document.mozCancelFullScreen ? D.window.document.mozCancelFullScreen() : D.window.document.msExitFullscreen ? D.window.document.msExitFullscreen() : D.window.document.webkitCancelFullScreen && D.window.document.webkitCancelFullScreen() : this._mapContainer.requestFullscreen ? this._mapContainer.requestFullscreen() : this._mapContainer.mozRequestFullScreen ? this._mapContainer.mozRequestFullScreen() : this._mapContainer.msRequestFullscreen ? this._mapContainer.msRequestFullscreen() : this._mapContainer.webkitRequestFullscreen && this._mapContainer.webkitRequestFullscreen() }; var ai, si = { closeButton: !0, closeOnClick: !0, className: "" }, x = ((ai = D.Evented) && (li.__proto__ = ai), ((li.prototype = Object.create(ai && ai.prototype)).constructor = li).prototype.addTo = function (t) { return this._map = t, this._map.on("move", this._update), this.options.closeOnClick && this._map.on("click", this._onClickClose), this._update(), this.fire(new D.Event("open")), this }, li.prototype.isOpen = function () { return !!this._map }, li.prototype.remove = function () { return this._content && d.remove(this._content), this._container && (d.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("click", this._onClickClose), delete this._map), this.fire(new D.Event("close")), this }, li.prototype.getLngLat = function () { return this._lngLat }, li.prototype.setLngLat = function (t) { return this._lngLat = V.convert(t), this._pos = null, this._update(), this }, li.prototype.setText = function (t) { return this.setDOMContent(D.window.document.createTextNode(t)) }, li.prototype.setHTML = function (t) { var e, n = D.window.document.createDocumentFragment(), i = D.window.document.createElement("body"); for (i.innerHTML = t; e = i.firstChild;)n.appendChild(e); return this.setDOMContent(n) }, li.prototype.setDOMContent = function (t) { return this._createContent(), this._content.appendChild(t), this._update(), this }, li.prototype._createContent = function () { this._content && d.remove(this._content), this._content = d.create("div", "mapboxgl-popup-content", this._container), this.options.closeButton && (this._closeButton = d.create("button", "mapboxgl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.setAttribute("aria-label", "Close popup"), this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClickClose)) }, li.prototype._update = function () { var t, e, n, i, r, o = this; this._map && this._lngLat && this._content && (this._container || (this._container = d.create("div", "mapboxgl-popup", this._map.getContainer()), this._tip = d.create("div", "mapboxgl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className && this.options.className.split(" ").forEach(function (t) { return o._container.classList.add(t) })), this._map.transform.renderWorldCopies && (this._lngLat = Wn(this._lngLat, this._pos, this._map.transform)), t = this._pos = this._map.project(this._lngLat), e = this.options.anchor, r = function t(e) { if (e) { if ("number" == typeof e) { var n = Math.round(Math.sqrt(.5 * Math.pow(e, 2))); return { center: new D.Point(0, 0), top: new D.Point(0, e), "top-left": new D.Point(n, n), "top-right": new D.Point(-n, n), bottom: new D.Point(0, -e), "bottom-left": new D.Point(n, -n), "bottom-right": new D.Point(-n, -n), left: new D.Point(e, 0), right: new D.Point(-e, 0) } } if (e instanceof D.Point || Array.isArray(e)) { n = D.Point.convert(e); return { center: n, top: n, "top-left": n, "top-right": n, bottom: n, "bottom-left": n, "bottom-right": n, left: n, right: n } } return { center: D.Point.convert(e.center || [0, 0]), top: D.Point.convert(e.top || [0, 0]), "top-left": D.Point.convert(e["top-left"] || [0, 0]), "top-right": D.Point.convert(e["top-right"] || [0, 0]), bottom: D.Point.convert(e.bottom || [0, 0]), "bottom-left": D.Point.convert(e["bottom-left"] || [0, 0]), "bottom-right": D.Point.convert(e["bottom-right"] || [0, 0]), left: D.Point.convert(e.left || [0, 0]), right: D.Point.convert(e.right || [0, 0]) } } return t(new D.Point(0, 0)) }(this.options.offset), e || (n = this._container.offsetWidth, i = this._container.offsetHeight, i = t.y + r.bottom.y < i ? ["top"] : t.y > this._map.transform.height - i ? ["bottom"] : [], t.x < n / 2 ? i.push("left") : t.x > this._map.transform.width - n / 2 && i.push("right"), e = 0 === i.length ? "bottom" : i.join("-")), r = t.add(r[e]).round(), d.setTransform(this._container, Hn[e] + " translate(" + r.x + "px," + r.y + "px)"), Kn(this._container, e, "popup")) }, li.prototype._onClickClose = function () { this.remove() }, li); function li(t) { ai.call(this), this.options = D.extend(Object.create(si), t), D.bindAll(["_update", "_onClickClose"], this) } var ui = { version: "0.48.0", supported: n, setRTLTextPlugin: D.setRTLTextPlugin, Map: b, NavigationControl: S, GeolocateControl: C, AttributionControl: Bn, ScaleControl: X, FullscreenControl: W, Popup: x, Marker: $n, Style: $e, LngLat: V, LngLatBounds: N, Point: D.Point, Evented: D.Evented, config: u, get accessToken() { return u.ACCESS_TOKEN }, set accessToken(t) { u.ACCESS_TOKEN = t }, get workerCount() { return ie.workerCount }, set workerCount(t) { ie.workerCount = t }, workerUrl: "" }; return ui }), a });

!function (t, e) { "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e(t.L = {}) }(this, function (t) { "use strict"; function h(t) { for (var e, i, n = 1, o = arguments.length; n < o; n++)for (e in i = arguments[n]) t[e] = i[e]; return t } function _(t, e) { var i = Array.prototype.slice; if (t.bind) return t.bind.apply(t, i.call(arguments, 1)); var n = i.call(arguments, 2); return function () { return t.apply(e, n.length ? n.concat(i.call(arguments)) : arguments) } } function a(t) { return t._leaflet_id = t._leaflet_id || ++Vt, t._leaflet_id } function e(t, e, i) { var n, o, s, r = function () { n = !1, o && (s.apply(i, o), o = !1) }; return s = function () { n ? o = arguments : (t.apply(i, arguments), setTimeout(r, e), n = !0) } } function i(t, e, i) { var n = e[1], o = e[0], e = n - o; return t === n && i ? t : ((t - o) % e + e) % e + o } function u() { return !1 } function n(t, e) { e = Math.pow(10, void 0 === e ? 6 : e); return Math.round(t * e) / e } function o(t) { return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "") } function l(t) { return o(t).split(/\s+/) } function s(t, e) { for (var i in t.hasOwnProperty("options") || (t.options = t.options ? Ut(t.options) : {}), e) t.options[i] = e[i]; return t.options } function r(t, e, i) { var n, o = []; for (n in t) o.push(encodeURIComponent(i ? n.toUpperCase() : n) + "=" + encodeURIComponent(t[n])); return (e && -1 !== e.indexOf("?") ? "&" : "?") + o.join("&") } function c(t, i) { return t.replace(qt, function (t, e) { e = i[e]; if (void 0 === e) throw new Error("No value provided for variable " + t); return "function" == typeof e && (e = e(i)), e }) } function d(t, e) { for (var i = 0; i < t.length; i++)if (t[i] === e) return i; return -1 } function p(t) { return window["webkit" + t] || window["moz" + t] || window["ms" + t] } function m(t) { var e = +new Date, i = Math.max(0, 16 - (e - Yt)); return Yt = e + i, window.setTimeout(t, i) } function x(t, e, i) { if (!i || Xt !== m) return Xt.call(window, _(t, e)); t.call(e) } function f(t) { t && Jt.call(window, t) } function g() { } function v(t, e, i) { this.x = i ? Math.round(t) : t, this.y = i ? Math.round(e) : e } function y(t, e, i) { return t instanceof v ? t : Gt(t) ? new v(t[0], t[1]) : null == t ? t : "object" == typeof t && "x" in t && "y" in t ? new v(t.x, t.y) : new v(t, e, i) } function w(t, e) { if (t) for (var i = e ? [t, e] : t, n = 0, o = i.length; n < o; n++)this.extend(i[n]) } function P(t, e) { return !t || t instanceof w ? t : new w(t, e) } function b(t, e) { if (t) for (var i = e ? [t, e] : t, n = 0, o = i.length; n < o; n++)this.extend(i[n]) } function T(t, e) { return t instanceof b ? t : new b(t, e) } function z(t, e, i) { if (isNaN(t) || isNaN(e)) throw new Error("Invalid LatLng object: (" + t + ", " + e + ")"); this.lat = +t, this.lng = +e, void 0 !== i && (this.alt = +i) } function M(t, e, i) { return t instanceof z ? t : Gt(t) && "object" != typeof t[0] ? 3 === t.length ? new z(t[0], t[1], t[2]) : 2 === t.length ? new z(t[0], t[1]) : null : null == t ? t : "object" == typeof t && "lat" in t ? new z(t.lat, "lng" in t ? t.lng : t.lon, t.alt) : void 0 === e ? null : new z(t, e, i) } function C(t, e, i, n) { if (Gt(t)) return this._a = t[0], this._b = t[1], this._c = t[2], void (this._d = t[3]); this._a = t, this._b = e, this._c = i, this._d = n } function S(t, e, i, n) { return new C(t, e, i, n) } function Z(t) { return document.createElementNS("http://www.w3.org/2000/svg", t) } function E(t, e) { for (var i, n, o, s, r = "", a = 0, h = t.length; a < h; a++) { for (i = 0, n = (o = t[a]).length; i < n; i++)r += (i ? "L" : "M") + (s = o[i]).x + " " + s.y; r += e ? je ? "z" : "x" : "" } return r || "M0 0" } function k(t) { return 0 <= navigator.userAgent.toLowerCase().indexOf(t) } function A(t, e, i, n) { return "touchstart" === e ? (a = t, h = i, u = n, l = _(function (t) { if ("mouse" !== t.pointerType && t.MSPOINTER_TYPE_MOUSE && t.pointerType !== t.MSPOINTER_TYPE_MOUSE) { if (!(qe.indexOf(t.target.tagName) < 0)) return; ft(t) } R(t, h) }), a["_leaflet_touchstart" + u] = l, a.addEventListener(He, l, !1), Ke || (document.documentElement.addEventListener(He, B, !0), document.documentElement.addEventListener(Fe, I, !0), document.documentElement.addEventListener(Ue, O, !0), document.documentElement.addEventListener(Ve, O, !0), Ke = !0)) : "touchmove" === e ? (r = i, (l = t)["_leaflet_touchmove" + n] = c, l.addEventListener(Fe, c, !1)) : "touchend" === e && (s = i, (t = t)["_leaflet_touchend" + n] = o, t.addEventListener(Ue, o, !1), t.addEventListener(Ve, o, !1)), this; function o(t) { R(t, s) } var s, r, a, h, u, l; function c(t) { (t.pointerType !== t.MSPOINTER_TYPE_MOUSE && "mouse" !== t.pointerType || 0 !== t.buttons) && R(t, r) } } function B(t) { Ge[t.pointerId] = t, Ye++ } function I(t) { Ge[t.pointerId] && (Ge[t.pointerId] = t) } function O(t) { delete Ge[t.pointerId], Ye-- } function R(t, e) { for (var i in t.touches = [], Ge) t.touches.push(Ge[i]); t.changedTouches = [t], e(t) } function N(t, o, e) { function i(t) { var e, i; if (Ie) { if (!me || "mouse" === t.pointerType) return; i = Ye } else i = t.touches.length; 1 < i || (i = (e = Date.now()) - (s || e), r = t.touches ? t.touches[0] : t, a = 0 < i && i <= 250, s = e) } function n(t) { if (a && !r.cancelBubble) { if (Ie) { if (!me || "mouse" === t.pointerType) return; var e, i, n = {}; for (i in r) e = r[i], n[i] = e && e.bind ? e.bind(r) : e; r = n } r.type = "dblclick", o(r), s = null } } var s, r, a = !1; return t[$e + Xe + e] = i, t[$e + Je + e] = n, t[$e + "dblclick" + e] = o, t.addEventListener(Xe, i, !1), t.addEventListener(Je, n, !1), t.addEventListener("dblclick", o, !1), this } function D(t, e) { var i = t[$e + Xe + e], n = t[$e + Je + e], e = t[$e + "dblclick" + e]; return t.removeEventListener(Xe, i, !1), t.removeEventListener(Je, n, !1), me || t.removeEventListener("dblclick", e, !1), this } function j(t) { return "string" == typeof t ? document.getElementById(t) : t } function W(t, e) { var i = t.style[e] || t.currentStyle && t.currentStyle[e]; return i && "auto" !== i || !document.defaultView || (i = (t = document.defaultView.getComputedStyle(t, null)) ? t[e] : null), "auto" === i ? null : i } function H(t, e, i) { t = document.createElement(t); return t.className = e || "", i && i.appendChild(t), t } function F(t) { var e = t.parentNode; e && e.removeChild(t) } function U(t) { for (; t.firstChild;)t.removeChild(t.firstChild) } function V(t) { var e = t.parentNode; e.lastChild !== t && e.appendChild(t) } function q(t) { var e = t.parentNode; e.firstChild !== t && e.insertBefore(t, e.firstChild) } function G(t, e) { if (void 0 !== t.classList) return t.classList.contains(e); t = J(t); return 0 < t.length && new RegExp("(^|\\s)" + e + "(\\s|$)").test(t) } function K(t, e) { var i; if (void 0 !== t.classList) for (var n = l(e), o = 0, s = n.length; o < s; o++)t.classList.add(n[o]); else G(t, e) || X(t, ((i = J(t)) ? i + " " : "") + e) } function Y(t, e) { void 0 !== t.classList ? t.classList.remove(e) : X(t, o((" " + J(t) + " ").replace(" " + e + " ", " "))) } function X(t, e) { void 0 === t.className.baseVal ? t.className = e : t.className.baseVal = e } function J(t) { return void 0 === t.className.baseVal ? t.className : t.className.baseVal } function $(t, e) { "opacity" in t.style ? t.style.opacity = e : "filter" in t.style && function (t, e) { var i = !1, n = "DXImageTransform.Microsoft.Alpha"; try { i = t.filters.item(n) } catch (t) { if (1 === e) return } e = Math.round(100 * e), i ? (i.Enabled = 100 !== e, i.Opacity = e) : t.style.filter += " progid:" + n + "(opacity=" + e + ")" }(t, e) } function Q(t) { for (var e = document.documentElement.style, i = 0; i < t.length; i++)if (t[i] in e) return t[i]; return !1 } function tt(t, e, i) { e = e || new v(0, 0); t.style[Qe] = (Ce ? "translate(" + e.x + "px," + e.y + "px)" : "translate3d(" + e.x + "px," + e.y + "px,0)") + (i ? " scale(" + i + ")" : "") } function et(t, e) { t._leaflet_pos = e, Ee ? tt(t, e) : (t.style.left = e.x + "px", t.style.top = e.y + "px") } function it(t) { return t._leaflet_pos || new v(0, 0) } function nt() { ut(window, "dragstart", ft) } function ot() { lt(window, "dragstart", ft) } function st(t) { for (; -1 === t.tabIndex;)t = t.parentNode; t.style && (rt(), ni = (ii = t).style.outline, t.style.outline = "none", ut(window, "keydown", rt)) } function rt() { ii && (ii.style.outline = ni, ni = ii = void 0, lt(window, "keydown", rt)) } function at(t) { for (; !((t = t.parentNode).offsetWidth && t.offsetHeight || t === document.body);); return t } function ht(t) { var e = t.getBoundingClientRect(); return { x: e.width / t.offsetWidth || 1, y: e.height / t.offsetHeight || 1, boundingClientRect: e } } function ut(t, e, i, n) { if ("object" == typeof e) for (var o in e) ct(t, o, e[o], i); else for (var s = 0, r = (e = l(e)).length; s < r; s++)ct(t, e[s], i, n); return this } function lt(t, e, i, n) { if ("object" == typeof e) for (var o in e) _t(t, o, e[o], i); else if (e) for (var s = 0, r = (e = l(e)).length; s < r; s++)_t(t, e[s], i, n); else { for (var a in t[si]) _t(t, a, t[si][a]); delete t[si] } return this } function ct(e, t, i, n) { var o = t + a(i) + (n ? "_" + a(n) : ""); if (e[si] && e[si][o]) return this; var s = function (t) { return i.call(n || e, t || window.event) }, r = s; Ie && 0 === t.indexOf("touch") ? A(e, t, s, o) : !Oe || "dblclick" !== t || Ie && Pe ? "addEventListener" in e ? "mousewheel" === t ? e.addEventListener("onwheel" in e ? "wheel" : "mousewheel", s, !1) : "mouseenter" === t || "mouseleave" === t ? (s = function (t) { t = t || window.event, Pt(e, t) && r(t) }, e.addEventListener("mouseenter" === t ? "mouseover" : "mouseout", s, !1)) : ("click" === t && ge && (s = function (t) { var e, i, n; i = r, n = (e = t).timeStamp || e.originalEvent && e.originalEvent.timeStamp, (t = oi && n - oi) && 100 < t && t < 500 || e.target._simulatedClick && !e._simulated ? gt(e) : (oi = n, i(e)) }), e.addEventListener(t, s, !1)) : "attachEvent" in e && e.attachEvent("on" + t, s) : N(e, s, o), e[si] = e[si] || {}, e[si][o] = s } function _t(t, e, i, n) { var o, s = e + a(i) + (n ? "_" + a(n) : ""), r = t[si] && t[si][s]; if (!r) return this; Ie && 0 === e.indexOf("touch") ? (n = (o = t)["_leaflet_" + (i = e) + (n = s)], "touchstart" === i ? o.removeEventListener(He, n, !1) : "touchmove" === i ? o.removeEventListener(Fe, n, !1) : "touchend" === i && (o.removeEventListener(Ue, n, !1), o.removeEventListener(Ve, n, !1))) : !Oe || "dblclick" !== e || Ie && Pe ? "removeEventListener" in t ? "mousewheel" === e ? t.removeEventListener("onwheel" in t ? "wheel" : "mousewheel", r, !1) : t.removeEventListener("mouseenter" === e ? "mouseover" : "mouseleave" === e ? "mouseout" : e, r, !1) : "detachEvent" in t && t.detachEvent("on" + e, r) : D(t, s), t[si][s] = null } function dt(t) { return t.stopPropagation ? t.stopPropagation() : t.originalEvent ? t.originalEvent._stopped = !0 : t.cancelBubble = !0, wt(t), this } function pt(t) { return ct(t, "mousewheel", dt), this } function mt(t) { return ut(t, "mousedown touchstart dblclick", dt), ct(t, "click", xt), this } function ft(t) { return t.preventDefault ? t.preventDefault() : t.returnValue = !1, this } function gt(t) { return ft(t), dt(t), this } function vt(t, e) { if (!e) return new v(t.clientX, t.clientY); var i = ht(e), n = i.boundingClientRect; return new v((t.clientX - n.left) / i.x - e.clientLeft, (t.clientY - n.top) / i.y - e.clientTop) } function yt(t) { return me ? t.wheelDeltaY / 2 : t.deltaY && 0 === t.deltaMode ? -t.deltaY / ri : t.deltaY && 1 === t.deltaMode ? 20 * -t.deltaY : t.deltaY && 2 === t.deltaMode ? 60 * -t.deltaY : t.deltaX || t.deltaZ ? 0 : t.wheelDelta ? (t.wheelDeltaY || t.wheelDelta) / 2 : t.detail && Math.abs(t.detail) < 32765 ? 20 * -t.detail : t.detail ? t.detail / -32765 * 60 : 0 } function xt(t) { ai[t.type] = !0 } function wt(t) { var e = ai[t.type]; return ai[t.type] = !1, e } function Pt(t, e) { var i = e.relatedTarget; if (!i) return !0; try { for (; i && i !== t;)i = i.parentNode } catch (t) { return !1 } return i !== t } function Lt(t, e) { if (!e || !t.length) return t.slice(); e *= e; return function (t, e) { var i = t.length, n = new (typeof Uint8Array != void 0 + "" ? Uint8Array : Array)(i); n[0] = n[i - 1] = 1, function t(e, i, n, o, s) { var r, a, h, u = 0; for (a = o + 1; a <= s - 1; a++)(h = Ct(e[a], e[o], e[s], !0)) > u && (r = a, u = h); n < u && (i[r] = 1, t(e, i, n, o, r), t(e, i, n, r, s)) }(t, n, e, 0, i - 1); var o, s = []; for (o = 0; o < i; o++)n[o] && s.push(t[o]); return s }(t = function (t, e) { for (var i = [t[0]], n = 1, o = 0, s = t.length; n < s; n++)(function (t, e) { var i = e.x - t.x, t = e.y - t.y; return i * i + t * t })(t[n], t[o]) > e && (i.push(t[n]), o = n); return o < s - 1 && i.push(t[s - 1]), i }(t, e), e) } function bt(t, e, i) { return Math.sqrt(Ct(t, e, i, !0)) } function Tt(t, e, i, n, o) { var s, r, a, h = n ? mi : Mt(t, i), u = Mt(e, i); for (mi = u; ;) { if (!(h | u)) return [t, e]; if (h & u) return !1; a = Mt(r = zt(t, e, s = h || u, i, o), i), s === h ? (t = r, h = a) : (e = r, u = a) } } function zt(t, e, i, n, o) { var s, r, a = e.x - t.x, h = e.y - t.y, e = n.min, n = n.max; return 8 & i ? (s = t.x + a * (n.y - t.y) / h, r = n.y) : 4 & i ? (s = t.x + a * (e.y - t.y) / h, r = e.y) : 2 & i ? (s = n.x, r = t.y + h * (n.x - t.x) / a) : 1 & i && (s = e.x, r = t.y + h * (e.x - t.x) / a), new v(s, r, o) } function Mt(t, e) { var i = 0; return t.x < e.min.x ? i |= 1 : t.x > e.max.x && (i |= 2), t.y < e.min.y ? i |= 4 : t.y > e.max.y && (i |= 8), i } function Ct(t, e, i, n) { var o = e.x, s = e.y, r = i.x - o, a = i.y - s, e = r * r + a * a; return 0 < e && (1 < (e = ((t.x - o) * r + (t.y - s) * a) / e) ? (o = i.x, s = i.y) : 0 < e && (o += r * e, s += a * e)), r = t.x - o, a = t.y - s, n ? r * r + a * a : new v(o, s) } function St(t) { return !Gt(t[0]) || "object" != typeof t[0][0] && void 0 !== t[0][0] } function Zt(t) { return console.warn("Deprecated use of _flat, please use L.LineUtil.isFlat instead."), St(t) } function Et(t, e, i) { for (var n, o, s, r, a, h, u, l = [1, 4, 2, 8], c = 0, _ = t.length; c < _; c++)t[c]._code = Mt(t[c], e); for (s = 0; s < 4; s++) { for (h = l[s], n = [], c = 0, o = (_ = t.length) - 1; c < _; o = c++)r = t[c], a = t[o], r._code & h ? a._code & h || ((u = zt(a, r, h, e, i))._code = Mt(u, e), n.push(u)) : (a._code & h && ((u = zt(a, r, h, e, i))._code = Mt(u, e), n.push(u)), n.push(r)); t = n } return t } function kt(t, e) { var i, n, o, s, r = "Feature" === t.type ? t.geometry : t, a = r ? r.coordinates : null, h = [], u = e && e.pointToLayer, l = e && e.coordsToLatLng || At; if (!a && !r) return null; switch (r.type) { case "Point": return i = l(a), u ? u(t, i) : new Mi(i); case "MultiPoint": for (o = 0, s = a.length; o < s; o++)i = l(a[o]), h.push(u ? u(t, i) : new Mi(i)); return new Li(h); case "LineString": case "MultiLineString": return n = Bt(a, "LineString" === r.type ? 0 : 1, l), new Ei(n, e); case "Polygon": case "MultiPolygon": return n = Bt(a, "Polygon" === r.type ? 1 : 2, l), new ki(n, e); case "GeometryCollection": for (o = 0, s = r.geometries.length; o < s; o++) { var c = kt({ geometry: r.geometries[o], type: "Feature", properties: t.properties }, e); c && h.push(c) } return new Li(h); default: throw new Error("Invalid GeoJSON object.") } } function At(t) { return new z(t[1], t[0], t[2]) } function Bt(t, e, i) { for (var n, o = [], s = 0, r = t.length; s < r; s++)n = e ? Bt(t[s], e - 1, i) : (i || At)(t[s]), o.push(n); return o } function It(t, e) { return e = "number" == typeof e ? e : 6, void 0 !== t.alt ? [n(t.lng, e), n(t.lat, e), n(t.alt, e)] : [n(t.lng, e), n(t.lat, e)] } function Ot(t, e, i, n) { for (var o = [], s = 0, r = t.length; s < r; s++)o.push(e ? Ot(t[s], e - 1, i, n) : It(t[s], n)); return !e && i && o.push(o[0]), o } function Rt(t, e) { return t.feature ? h({}, t.feature, { geometry: e }) : Nt(e) } function Nt(t) { return "Feature" === t.type || "FeatureCollection" === t.type ? t : { type: "Feature", properties: {}, geometry: t } } function Dt(t, e) { return new Ai(t, e) } function jt(t, e) { return new Wi(t, e) } function Wt(t) { return De ? new Ui(t) : null } function Ht(t) { return je || We ? new Gi(t) : null } var Ft = Object.freeze; Object.freeze = function (t) { return t }; var Ut = Object.create || function (t) { return Qt.prototype = t, new Qt }, Vt = 0, qt = /\{ *([\w_-]+) *\}/g, Gt = Array.isArray || function (t) { return "[object Array]" === Object.prototype.toString.call(t) }, Kt = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=", Yt = 0, Xt = window.requestAnimationFrame || p("RequestAnimationFrame") || m, Jt = window.cancelAnimationFrame || p("CancelAnimationFrame") || p("CancelRequestAnimationFrame") || function (t) { window.clearTimeout(t) }, $t = (Object.freeze || Object)({ freeze: Ft, extend: h, create: Ut, bind: _, lastId: Vt, stamp: a, throttle: e, wrapNum: i, falseFn: u, formatNum: n, trim: o, splitWords: l, setOptions: s, getParamString: r, template: c, isArray: Gt, indexOf: d, emptyImageUrl: Kt, requestFn: Xt, cancelFn: Jt, requestAnimFrame: x, cancelAnimFrame: f }); function Qt() { } g.extend = function (t) { function e() { this.initialize && this.initialize.apply(this, arguments), this.callInitHooks() } var i, n = e.__super__ = this.prototype, o = Ut(n); for (i in (o.constructor = e).prototype = o, this) this.hasOwnProperty(i) && "prototype" !== i && "__super__" !== i && (e[i] = this[i]); return t.statics && (h(e, t.statics), delete t.statics), t.includes && (function (t) { if ("undefined" != typeof L && L && L.Mixin) { t = Gt(t) ? t : [t]; for (var e = 0; e < t.length; e++)t[e] === L.Mixin.Events && console.warn("Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.", (new Error).stack) } }(t.includes), h.apply(null, [o].concat(t.includes)), delete t.includes), o.options && (t.options = h(Ut(o.options), t.options)), h(o, t), o._initHooks = [], o.callInitHooks = function () { if (!this._initHooksCalled) { n.callInitHooks && n.callInitHooks.call(this), this._initHooksCalled = !0; for (var t = 0, e = o._initHooks.length; t < e; t++)o._initHooks[t].call(this) } }, e }, g.include = function (t) { return h(this.prototype, t), this }, g.mergeOptions = function (t) { return h(this.prototype.options, t), this }, g.addInitHook = function (t) { var e = Array.prototype.slice.call(arguments, 1), i = "function" == typeof t ? t : function () { this[t].apply(this, e) }; return this.prototype._initHooks = this.prototype._initHooks || [], this.prototype._initHooks.push(i), this }; var te = { on: function (t, e, i) { if ("object" == typeof t) for (var n in t) this._on(n, t[n], e); else for (var o = 0, s = (t = l(t)).length; o < s; o++)this._on(t[o], e, i); return this }, off: function (t, e, i) { if (t) if ("object" == typeof t) for (var n in t) this._off(n, t[n], e); else for (var o = 0, s = (t = l(t)).length; o < s; o++)this._off(t[o], e, i); else delete this._events; return this }, _on: function (t, e, i) { this._events = this._events || {}; var n = this._events[t]; n || (n = [], this._events[t] = n), i === this && (i = void 0); for (var t = { fn: e, ctx: i }, o = n, s = 0, r = o.length; s < r; s++)if (o[s].fn === e && o[s].ctx === i) return; o.push(t) }, _off: function (t, e, i) { var n, o, s; if (this._events && (n = this._events[t])) if (e) { if (i === this && (i = void 0), n) for (o = 0, s = n.length; o < s; o++) { var r = n[o]; if (r.ctx === i && r.fn === e) return r.fn = u, this._firingCount && (this._events[t] = n = n.slice()), void n.splice(o, 1) } } else { for (o = 0, s = n.length; o < s; o++)n[o].fn = u; delete this._events[t] } }, fire: function (t, e, i) { if (!this.listens(t, i)) return this; var n = h({}, e, { type: t, target: this, sourceTarget: e && e.sourceTarget || this }); if (this._events) { var o = this._events[t]; if (o) { this._firingCount = this._firingCount + 1 || 1; for (var s = 0, r = o.length; s < r; s++) { var a = o[s]; a.fn.call(a.ctx || this, n) } this._firingCount-- } } return i && this._propagateEvent(n), this }, listens: function (t, e) { var i = this._events && this._events[t]; if (i && i.length) return !0; if (e) for (var n in this._eventParents) if (this._eventParents[n].listens(t, e)) return !0; return !1 }, once: function (t, e, i) { if ("object" == typeof t) { for (var n in t) this.once(n, t[n], e); return this } var o = _(function () { this.off(t, e, i).off(t, o, i) }, this); return this.on(t, e, i).on(t, o, i) }, addEventParent: function (t) { return this._eventParents = this._eventParents || {}, this._eventParents[a(t)] = t, this }, removeEventParent: function (t) { return this._eventParents && delete this._eventParents[a(t)], this }, _propagateEvent: function (t) { for (var e in this._eventParents) this._eventParents[e].fire(t.type, h({ layer: t.target, propagatedFrom: t.target }, t), !0) } }; te.addEventListener = te.on, te.removeEventListener = te.clearAllEventListeners = te.off, te.addOneTimeEventListener = te.once, te.fireEvent = te.fire, te.hasEventListeners = te.listens; var ee = g.extend(te), ie = Math.trunc || function (t) { return 0 < t ? Math.floor(t) : Math.ceil(t) }; v.prototype = { clone: function () { return new v(this.x, this.y) }, add: function (t) { return this.clone()._add(y(t)) }, _add: function (t) { return this.x += t.x, this.y += t.y, this }, subtract: function (t) { return this.clone()._subtract(y(t)) }, _subtract: function (t) { return this.x -= t.x, this.y -= t.y, this }, divideBy: function (t) { return this.clone()._divideBy(t) }, _divideBy: function (t) { return this.x /= t, this.y /= t, this }, multiplyBy: function (t) { return this.clone()._multiplyBy(t) }, _multiplyBy: function (t) { return this.x *= t, this.y *= t, this }, scaleBy: function (t) { return new v(this.x * t.x, this.y * t.y) }, unscaleBy: function (t) { return new v(this.x / t.x, this.y / t.y) }, round: function () { return this.clone()._round() }, _round: function () { return this.x = Math.round(this.x), this.y = Math.round(this.y), this }, floor: function () { return this.clone()._floor() }, _floor: function () { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this }, ceil: function () { return this.clone()._ceil() }, _ceil: function () { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this }, trunc: function () { return this.clone()._trunc() }, _trunc: function () { return this.x = ie(this.x), this.y = ie(this.y), this }, distanceTo: function (t) { var e = (t = y(t)).x - this.x, t = t.y - this.y; return Math.sqrt(e * e + t * t) }, equals: function (t) { return (t = y(t)).x === this.x && t.y === this.y }, contains: function (t) { return t = y(t), Math.abs(t.x) <= Math.abs(this.x) && Math.abs(t.y) <= Math.abs(this.y) }, toString: function () { return "Point(" + n(this.x) + ", " + n(this.y) + ")" } }, w.prototype = { extend: function (t) { return t = y(t), this.min || this.max ? (this.min.x = Math.min(t.x, this.min.x), this.max.x = Math.max(t.x, this.max.x), this.min.y = Math.min(t.y, this.min.y), this.max.y = Math.max(t.y, this.max.y)) : (this.min = t.clone(), this.max = t.clone()), this }, getCenter: function (t) { return new v((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, t) }, getBottomLeft: function () { return new v(this.min.x, this.max.y) }, getTopRight: function () { return new v(this.max.x, this.min.y) }, getTopLeft: function () { return this.min }, getBottomRight: function () { return this.max }, getSize: function () { return this.max.subtract(this.min) }, contains: function (t) { var e, i; return (t = ("number" == typeof t[0] || t instanceof v ? y : P)(t)) instanceof w ? (e = t.min, i = t.max) : e = i = t, e.x >= this.min.x && i.x <= this.max.x && e.y >= this.min.y && i.y <= this.max.y }, intersects: function (t) { t = P(t); var e = this.min, i = this.max, n = t.min, o = t.max, t = o.x >= e.x && n.x <= i.x, i = o.y >= e.y && n.y <= i.y; return t && i }, overlaps: function (t) { t = P(t); var e = this.min, i = this.max, n = t.min, o = t.max, t = o.x > e.x && n.x < i.x, i = o.y > e.y && n.y < i.y; return t && i }, isValid: function () { return !(!this.min || !this.max) } }, b.prototype = { extend: function (t) { var e, i, n = this._southWest, o = this._northEast; if (t instanceof z) i = e = t; else { if (!(t instanceof b)) return t ? this.extend(M(t) || T(t)) : this; if (e = t._southWest, i = t._northEast, !e || !i) return this } return n || o ? (n.lat = Math.min(e.lat, n.lat), n.lng = Math.min(e.lng, n.lng), o.lat = Math.max(i.lat, o.lat), o.lng = Math.max(i.lng, o.lng)) : (this._southWest = new z(e.lat, e.lng), this._northEast = new z(i.lat, i.lng)), this }, pad: function (t) { var e = this._southWest, i = this._northEast, n = Math.abs(e.lat - i.lat) * t, t = Math.abs(e.lng - i.lng) * t; return new b(new z(e.lat - n, e.lng - t), new z(i.lat + n, i.lng + t)) }, getCenter: function () { return new z((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2) }, getSouthWest: function () { return this._southWest }, getNorthEast: function () { return this._northEast }, getNorthWest: function () { return new z(this.getNorth(), this.getWest()) }, getSouthEast: function () { return new z(this.getSouth(), this.getEast()) }, getWest: function () { return this._southWest.lng }, getSouth: function () { return this._southWest.lat }, getEast: function () { return this._northEast.lng }, getNorth: function () { return this._northEast.lat }, contains: function (t) { t = ("number" == typeof t[0] || t instanceof z || "lat" in t ? M : T)(t); var e, i, n = this._southWest, o = this._northEast; return t instanceof b ? (e = t.getSouthWest(), i = t.getNorthEast()) : e = i = t, e.lat >= n.lat && i.lat <= o.lat && e.lng >= n.lng && i.lng <= o.lng }, intersects: function (t) { t = T(t); var e = this._southWest, i = this._northEast, n = t.getSouthWest(), o = t.getNorthEast(), t = o.lat >= e.lat && n.lat <= i.lat, i = o.lng >= e.lng && n.lng <= i.lng; return t && i }, overlaps: function (t) { t = T(t); var e = this._southWest, i = this._northEast, n = t.getSouthWest(), o = t.getNorthEast(), t = o.lat > e.lat && n.lat < i.lat, i = o.lng > e.lng && n.lng < i.lng; return t && i }, toBBoxString: function () { return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(",") }, equals: function (t, e) { return !!t && (t = T(t), this._southWest.equals(t.getSouthWest(), e) && this._northEast.equals(t.getNorthEast(), e)) }, isValid: function () { return !(!this._southWest || !this._northEast) } }; var ne = { latLngToPoint: function (t, e) { t = this.projection.project(t), e = this.scale(e); return this.transformation._transform(t, e) }, pointToLatLng: function (t, e) { e = this.scale(e), e = this.transformation.untransform(t, e); return this.projection.unproject(e) }, project: function (t) { return this.projection.project(t) }, unproject: function (t) { return this.projection.unproject(t) }, scale: function (t) { return 256 * Math.pow(2, t) }, zoom: function (t) { return Math.log(t / 256) / Math.LN2 }, getProjectedBounds: function (t) { if (this.infinite) return null; var e = this.projection.bounds, t = this.scale(t); return new w(this.transformation.transform(e.min, t), this.transformation.transform(e.max, t)) }, infinite: !(z.prototype = { equals: function (t, e) { return !!t && (t = M(t), Math.max(Math.abs(this.lat - t.lat), Math.abs(this.lng - t.lng)) <= (void 0 === e ? 1e-9 : e)) }, toString: function (t) { return "LatLng(" + n(this.lat, t) + ", " + n(this.lng, t) + ")" }, distanceTo: function (t) { return oe.distance(this, M(t)) }, wrap: function () { return oe.wrapLatLng(this) }, toBounds: function (t) { var e = 180 * t / 40075017, t = e / Math.cos(Math.PI / 180 * this.lat); return T([this.lat - e, this.lng - t], [this.lat + e, this.lng + t]) }, clone: function () { return new z(this.lat, this.lng, this.alt) } }), wrapLatLng: function (t) { var e = this.wrapLng ? i(t.lng, this.wrapLng, !0) : t.lng; return new z(this.wrapLat ? i(t.lat, this.wrapLat, !0) : t.lat, e, t.alt) }, wrapLatLngBounds: function (t) { var e = t.getCenter(), i = this.wrapLatLng(e), n = e.lat - i.lat, e = e.lng - i.lng; if (0 == n && 0 == e) return t; i = t.getSouthWest(), t = t.getNorthEast(); return new b(new z(i.lat - n, i.lng - e), new z(t.lat - n, t.lng - e)) } }, oe = h({}, ne, { wrapLng: [-180, 180], R: 6371e3, distance: function (t, e) { var i = Math.PI / 180, n = t.lat * i, o = e.lat * i, s = Math.sin((e.lat - t.lat) * i / 2), i = Math.sin((e.lng - t.lng) * i / 2), i = s * s + Math.cos(n) * Math.cos(o) * i * i, i = 2 * Math.atan2(Math.sqrt(i), Math.sqrt(1 - i)); return this.R * i } }), se = { R: 6378137, MAX_LATITUDE: 85.0511287798, project: function (t) { var e = Math.PI / 180, i = this.MAX_LATITUDE, i = Math.max(Math.min(i, t.lat), -i), i = Math.sin(i * e); return new v(this.R * t.lng * e, this.R * Math.log((1 + i) / (1 - i)) / 2) }, unproject: function (t) { var e = 180 / Math.PI; return new z((2 * Math.atan(Math.exp(t.y / this.R)) - Math.PI / 2) * e, t.x * e / this.R) }, bounds: new w([-(Ae = 6378137 * Math.PI), -Ae], [Ae, Ae]) }; C.prototype = { transform: function (t, e) { return this._transform(t.clone(), e) }, _transform: function (t, e) { return e = e || 1, t.x = e * (this._a * t.x + this._b), t.y = e * (this._c * t.y + this._d), t }, untransform: function (t, e) { return e = e || 1, new v((t.x / e - this._b) / this._a, (t.y / e - this._d) / this._c) } }; var re, ae, he, ue, le = h({}, oe, { code: "EPSG:3857", projection: se, transformation: S(Be = .5 / (Math.PI * se.R), .5, -Be, .5) }), ce = h({}, le, { code: "EPSG:900913" }), _e = document.documentElement.style, de = "ActiveXObject" in window, pe = de && !document.addEventListener, me = "msLaunchUri" in navigator && !("documentMode" in document), fe = k("webkit"), ge = k("android"), ve = k("android 2") || k("android 3"), ye = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10), xe = ge && k("Google") && ye < 537 && !("AudioNode" in window), we = !!window.opera, Pe = k("chrome"), Le = k("gecko") && !fe && !we && !de, be = !Pe && k("safari"), Te = k("phantom"), ze = "OTransition" in _e, Me = 0 === navigator.platform.indexOf("Win"), Ce = de && "transition" in _e, Se = "WebKitCSSMatrix" in window && "m11" in new window.WebKitCSSMatrix && !ve, Ze = "MozPerspective" in _e, Ee = !window.L_DISABLE_3D && (Ce || Se || Ze) && !ze && !Te, ke = "undefined" != typeof orientation || k("mobile"), Ae = ke && fe, Be = ke && Se, ye = !window.PointerEvent && window.MSPointerEvent, Ie = !(!window.PointerEvent && !ye), Oe = !window.L_NO_TOUCH && (Ie || "ontouchstart" in window || window.DocumentTouch && document instanceof window.DocumentTouch), Re = ke && we, _e = ke && Le, Ne = 1 < (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI), De = !!document.createElement("canvas").getContext, je = !(!document.createElementNS || !Z("svg").createSVGRect), We = !je && function () { try { var t = document.createElement("div"); t.innerHTML = '<v:shape adj="1"/>'; var e = t.firstChild; return e.style.behavior = "url(#default#VML)", e && "object" == typeof e.adj } catch (t) { return !1 } }(), fe = (Object.freeze || Object)({ ie: de, ielt9: pe, edge: me, webkit: fe, android: ge, android23: ve, androidStock: xe, opera: we, chrome: Pe, gecko: Le, safari: be, phantom: Te, opera12: ze, win: Me, ie3d: Ce, webkit3d: Se, gecko3d: Ze, any3d: Ee, mobile: ke, mobileWebkit: Ae, mobileWebkit3d: Be, msPointer: ye, pointer: Ie, touch: Oe, mobileOpera: Re, mobileGecko: _e, retina: Ne, canvas: De, svg: je, vml: We }), He = ye ? "MSPointerDown" : "pointerdown", Fe = ye ? "MSPointerMove" : "pointermove", Ue = ye ? "MSPointerUp" : "pointerup", Ve = ye ? "MSPointerCancel" : "pointercancel", qe = ["INPUT", "SELECT", "OPTION"], Ge = {}, Ke = !1, Ye = 0, Xe = ye ? "MSPointerDown" : Ie ? "pointerdown" : "touchstart", Je = ye ? "MSPointerUp" : Ie ? "pointerup" : "touchend", $e = "_leaflet_", Qe = Q(["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]), ti = Q(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]), ei = "webkitTransition" === ti || "OTransition" === ti ? ti + "End" : "transitionend"; ue = "onselectstart" in document ? (he = function () { ut(window, "selectstart", ft) }, function () { lt(window, "selectstart", ft) }) : (ae = Q(["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]), he = function () { var t; ae && (t = document.documentElement.style, re = t[ae], t[ae] = "none") }, function () { ae && (document.documentElement.style[ae] = re, re = void 0) }); var ii, ni, oi, we = (Object.freeze || Object)({ TRANSFORM: Qe, TRANSITION: ti, TRANSITION_END: ei, get: j, getStyle: W, create: H, remove: F, empty: U, toFront: V, toBack: q, hasClass: G, addClass: K, removeClass: Y, setClass: X, getClass: J, setOpacity: $, testProp: Q, setTransform: tt, setPosition: et, getPosition: it, disableTextSelection: he, enableTextSelection: ue, disableImageDrag: nt, enableImageDrag: ot, preventOutline: st, restoreOutline: rt, getSizedParentNode: at, getScale: ht }), si = "_leaflet_events", ri = Me && Pe ? 2 * window.devicePixelRatio : Le ? window.devicePixelRatio : 1, ai = {}, Te = (Object.freeze || Object)({ on: ut, off: lt, stopPropagation: dt, disableScrollPropagation: pt, disableClickPropagation: mt, preventDefault: ft, stop: gt, getMousePosition: vt, getWheelDelta: yt, fakeStop: xt, skipped: wt, isExternalTarget: Pt, addListener: ut, removeListener: lt }), hi = ee.extend({ run: function (t, e, i, n) { this.stop(), this._el = t, this._inProgress = !0, this._duration = i || .25, this._easeOutPower = 1 / Math.max(n || .5, .2), this._startPos = it(t), this._offset = e.subtract(this._startPos), this._startTime = +new Date, this.fire("start"), this._animate() }, stop: function () { this._inProgress && (this._step(!0), this._complete()) }, _animate: function () { this._animId = x(this._animate, this), this._step() }, _step: function (t) { var e = +new Date - this._startTime, i = 1e3 * this._duration; e < i ? this._runFrame(this._easeOut(e / i), t) : (this._runFrame(1), this._complete()) }, _runFrame: function (t, e) { t = this._startPos.add(this._offset.multiplyBy(t)); e && t._round(), et(this._el, t), this.fire("step") }, _complete: function () { f(this._animId), this._inProgress = !1, this.fire("end") }, _easeOut: function (t) { return 1 - Math.pow(1 - t, this._easeOutPower) } }), ui = ee.extend({ options: { crs: le, center: void 0, zoom: void 0, minZoom: void 0, maxZoom: void 0, layers: [], maxBounds: void 0, renderer: void 0, zoomAnimation: !0, zoomAnimationThreshold: 4, fadeAnimation: !0, markerZoomAnimation: !0, transform3DLimit: 8388608, zoomSnap: 1, zoomDelta: 1, trackResize: !0 }, initialize: function (t, e) { e = s(this, e), this._initContainer(t), this._initLayout(), this._onResize = _(this._onResize, this), this._initEvents(), e.maxBounds && this.setMaxBounds(e.maxBounds), void 0 !== e.zoom && (this._zoom = this._limitZoom(e.zoom)), e.center && void 0 !== e.zoom && this.setView(M(e.center), e.zoom, { reset: !0 }), this._handlers = [], this._layers = {}, this._zoomBoundLayers = {}, this._sizeChanged = !0, this.callInitHooks(), this._zoomAnimated = ti && Ee && !Re && this.options.zoomAnimation, this._zoomAnimated && (this._createAnimProxy(), ut(this._proxy, ei, this._catchTransitionEnd, this)), this._addLayers(this.options.layers) }, setView: function (t, e, i) { return e = void 0 === e ? this._zoom : this._limitZoom(e), t = this._limitCenter(M(t), e, this.options.maxBounds), i = i || {}, this._stop(), this._loaded && !i.reset && !0 !== i && (void 0 !== i.animate && (i.zoom = h({ animate: i.animate }, i.zoom), i.pan = h({ animate: i.animate, duration: i.duration }, i.pan)), this._zoom !== e ? this._tryAnimatedZoom && this._tryAnimatedZoom(t, e, i.zoom) : this._tryAnimatedPan(t, i.pan)) ? clearTimeout(this._sizeTimer) : this._resetView(t, e), this }, setZoom: function (t, e) { return this._loaded ? this.setView(this.getCenter(), t, { zoom: e }) : (this._zoom = t, this) }, zoomIn: function (t, e) { return t = t || (Ee ? this.options.zoomDelta : 1), this.setZoom(this._zoom + t, e) }, zoomOut: function (t, e) { return t = t || (Ee ? this.options.zoomDelta : 1), this.setZoom(this._zoom - t, e) }, setZoomAround: function (t, e, i) { var n = this.getZoomScale(e), o = this.getSize().divideBy(2), n = (t instanceof v ? t : this.latLngToContainerPoint(t)).subtract(o).multiplyBy(1 - 1 / n), n = this.containerPointToLatLng(o.add(n)); return this.setView(n, e, { zoom: i }) }, _getBoundsCenterZoom: function (t, e) { e = e || {}, t = t.getBounds ? t.getBounds() : T(t); var i = y(e.paddingTopLeft || e.padding || [0, 0]), n = y(e.paddingBottomRight || e.padding || [0, 0]), o = this.getBoundsZoom(t, !1, i.add(n)); if ((o = "number" == typeof e.maxZoom ? Math.min(e.maxZoom, o) : o) === 1 / 0) return { center: t.getCenter(), zoom: o }; n = n.subtract(i).divideBy(2), i = this.project(t.getSouthWest(), o), t = this.project(t.getNorthEast(), o); return { center: this.unproject(i.add(t).divideBy(2).add(n), o), zoom: o } }, fitBounds: function (t, e) { if (!(t = T(t)).isValid()) throw new Error("Bounds are not valid."); t = this._getBoundsCenterZoom(t, e); return this.setView(t.center, t.zoom, e) }, fitWorld: function (t) { return this.fitBounds([[-90, -180], [90, 180]], t) }, panTo: function (t, e) { return this.setView(t, this._zoom, { pan: e }) }, panBy: function (t, e) { return e = e || {}, (t = y(t).round()).x || t.y ? (!0 === e.animate || this.getSize().contains(t) ? (this._panAnim || (this._panAnim = new hi, this._panAnim.on({ step: this._onPanTransitionStep, end: this._onPanTransitionEnd }, this)), e.noMoveStart || this.fire("movestart"), !1 !== e.animate ? (K(this._mapPane, "leaflet-pan-anim"), i = this._getMapPanePos().subtract(t).round(), this._panAnim.run(this._mapPane, i, e.duration || .25, e.easeLinearity)) : (this._rawPanBy(t), this.fire("move").fire("moveend"))) : this._resetView(this.unproject(this.project(this.getCenter()).add(t)), this.getZoom()), this) : this.fire("moveend"); var i }, flyTo: function (n, o, t) { function e(t) { t = (_ * _ - c * c + (t ? -1 : 1) * m * m * d * d) / (2 * (t ? _ : c) * m * d), t = Math.sqrt(t * t + 1) - t; return t < 1e-9 ? -18 : Math.log(t) } function i(t) { return (Math.exp(t) - Math.exp(-t)) / 2 } function s(t) { return (Math.exp(t) + Math.exp(-t)) / 2 } function r(t) { return c * (s(f) * (i(t = f + p * t) / s(t)) - i(f)) / m } if (!1 === (t = t || {}).animate || !Ee) return this.setView(n, o, t); this._stop(); var a = this.project(this.getCenter()), h = this.project(n), u = this.getSize(), l = this._zoom; n = M(n), o = void 0 === o ? l : o; var c = Math.max(u.x, u.y), _ = c * this.getZoomScale(l, o), d = h.distanceTo(a) || 1, p = 1.42, m = p * p, f = e(0), g = Date.now(), v = (e(1) - f) / p, y = t.duration ? 1e3 * t.duration : 1e3 * v * .8; return this._moveStart(!0, t.noMoveStart), function t() { var e = (Date.now() - g) / y, i = (i = e, (1 - Math.pow(1 - i, 1.5)) * v); e <= 1 ? (this._flyToFrame = x(t, this), this._move(this.unproject(a.add(h.subtract(a).multiplyBy(r(i) / d)), l), this.getScaleZoom(c / (c * (s(f) / s(f + p * i))), l), { flyTo: !0 })) : this._move(n, o)._moveEnd(!0) }.call(this), this }, flyToBounds: function (t, e) { t = this._getBoundsCenterZoom(t, e); return this.flyTo(t.center, t.zoom, e) }, setMaxBounds: function (t) { return (t = T(t)).isValid() ? (this.options.maxBounds && this.off("moveend", this._panInsideMaxBounds), this.options.maxBounds = t, this._loaded && this._panInsideMaxBounds(), this.on("moveend", this._panInsideMaxBounds)) : (this.options.maxBounds = null, this.off("moveend", this._panInsideMaxBounds)) }, setMinZoom: function (t) { var e = this.options.minZoom; return this.options.minZoom = t, this._loaded && e !== t && (this.fire("zoomlevelschange"), this.getZoom() < this.options.minZoom) ? this.setZoom(t) : this }, setMaxZoom: function (t) { var e = this.options.maxZoom; return this.options.maxZoom = t, this._loaded && e !== t && (this.fire("zoomlevelschange"), this.getZoom() > this.options.maxZoom) ? this.setZoom(t) : this }, panInsideBounds: function (t, e) { this._enforcingBounds = !0; var i = this.getCenter(), t = this._limitCenter(i, this._zoom, T(t)); return i.equals(t) || this.panTo(t, e), this._enforcingBounds = !1, this }, invalidateSize: function (t) { if (!this._loaded) return this; t = h({ animate: !1, pan: !0 }, !0 === t ? { animate: !0 } : t); var e = this.getSize(); this._sizeChanged = !0, this._lastCenter = null; var i = this.getSize(), n = e.divideBy(2).round(), o = i.divideBy(2).round(), o = n.subtract(o); return o.x || o.y ? (t.animate && t.pan ? this.panBy(o) : (t.pan && this._rawPanBy(o), this.fire("move"), t.debounceMoveend ? (clearTimeout(this._sizeTimer), this._sizeTimer = setTimeout(_(this.fire, this, "moveend"), 200)) : this.fire("moveend")), this.fire("resize", { oldSize: e, newSize: i })) : this }, stop: function () { return this.setZoom(this._limitZoom(this._zoom)), this.options.zoomSnap || this.fire("viewreset"), this._stop() }, locate: function (t) { if (t = this._locateOptions = h({ timeout: 1e4, watch: !1 }, t), !("geolocation" in navigator)) return this._handleGeolocationError({ code: 0, message: "Geolocation not supported." }), this; var e = _(this._handleGeolocationResponse, this), i = _(this._handleGeolocationError, this); return t.watch ? this._locationWatchId = navigator.geolocation.watchPosition(e, i, t) : navigator.geolocation.getCurrentPosition(e, i, t), this }, stopLocate: function () { return navigator.geolocation && navigator.geolocation.clearWatch && navigator.geolocation.clearWatch(this._locationWatchId), this._locateOptions && (this._locateOptions.setView = !1), this }, _handleGeolocationError: function (t) { var e = t.code, t = t.message || (1 === e ? "permission denied" : 2 === e ? "position unavailable" : "timeout"); this._locateOptions.setView && !this._loaded && this.fitWorld(), this.fire("locationerror", { code: e, message: "Geolocation error: " + t + "." }) }, _handleGeolocationResponse: function (t) { var e, i = new z(t.coords.latitude, t.coords.longitude), n = i.toBounds(2 * t.coords.accuracy), o = this._locateOptions; o.setView && (e = this.getBoundsZoom(n), this.setView(i, o.maxZoom ? Math.min(e, o.maxZoom) : e)); var s, r = { latlng: i, bounds: n, timestamp: t.timestamp }; for (s in t.coords) "number" == typeof t.coords[s] && (r[s] = t.coords[s]); this.fire("locationfound", r) }, addHandler: function (t, e) { if (!e) return this; e = this[t] = new e(this); return this._handlers.push(e), this.options[t] && e.enable(), this }, remove: function () { if (this._initEvents(!0), this._containerId !== this._container._leaflet_id) throw new Error("Map container is being reused by another instance"); try { delete this._container._leaflet_id, delete this._containerId } catch (t) { this._container._leaflet_id = void 0, this._containerId = void 0 } for (var t in void 0 !== this._locationWatchId && this.stopLocate(), this._stop(), F(this._mapPane), this._clearControlPos && this._clearControlPos(), this._resizeRequest && (f(this._resizeRequest), this._resizeRequest = null), this._clearHandlers(), this._loaded && this.fire("unload"), this._layers) this._layers[t].remove(); for (t in this._panes) F(this._panes[t]); return this._layers = [], this._panes = [], delete this._mapPane, delete this._renderer, this }, createPane: function (t, e) { e = H("div", "leaflet-pane" + (t ? " leaflet-" + t.replace("Pane", "") + "-pane" : ""), e || this._mapPane); return t && (this._panes[t] = e), e }, getCenter: function () { return this._checkIfLoaded(), this._lastCenter && !this._moved() ? this._lastCenter : this.layerPointToLatLng(this._getCenterLayerPoint()) }, getZoom: function () { return this._zoom }, getBounds: function () { var t = this.getPixelBounds(); return new b(this.unproject(t.getBottomLeft()), this.unproject(t.getTopRight())) }, getMinZoom: function () { return void 0 === this.options.minZoom ? this._layersMinZoom || 0 : this.options.minZoom }, getMaxZoom: function () { return void 0 === this.options.maxZoom ? void 0 === this._layersMaxZoom ? 1 / 0 : this._layersMaxZoom : this.options.maxZoom }, getBoundsZoom: function (t, e, i) { t = T(t), i = y(i || [0, 0]); var n = this.getZoom() || 0, o = this.getMinZoom(), s = this.getMaxZoom(), r = t.getNorthWest(), a = t.getSouthEast(), t = this.getSize().subtract(i), i = P(this.project(a, n), this.project(r, n)).getSize(), a = Ee ? this.options.zoomSnap : 1, r = t.x / i.x, i = t.y / i.y, i = e ? Math.max(r, i) : Math.min(r, i), n = this.getScaleZoom(i, n); return a && (n = Math.round(n / (a / 100)) * (a / 100), n = e ? Math.ceil(n / a) * a : Math.floor(n / a) * a), Math.max(o, Math.min(s, n)) }, getSize: function () { return this._size && !this._sizeChanged || (this._size = new v(this._container.clientWidth || 0, this._container.clientHeight || 0), this._sizeChanged = !1), this._size.clone() }, getPixelBounds: function (t, e) { e = this._getTopLeftPoint(t, e); return new w(e, e.add(this.getSize())) }, getPixelOrigin: function () { return this._checkIfLoaded(), this._pixelOrigin }, getPixelWorldBounds: function (t) { return this.options.crs.getProjectedBounds(void 0 === t ? this.getZoom() : t) }, getPane: function (t) { return "string" == typeof t ? this._panes[t] : t }, getPanes: function () { return this._panes }, getContainer: function () { return this._container }, getZoomScale: function (t, e) { var i = this.options.crs; return e = void 0 === e ? this._zoom : e, i.scale(t) / i.scale(e) }, getScaleZoom: function (t, e) { var i = this.options.crs; e = void 0 === e ? this._zoom : e; e = i.zoom(t * i.scale(e)); return isNaN(e) ? 1 / 0 : e }, project: function (t, e) { return e = void 0 === e ? this._zoom : e, this.options.crs.latLngToPoint(M(t), e) }, unproject: function (t, e) { return e = void 0 === e ? this._zoom : e, this.options.crs.pointToLatLng(y(t), e) }, layerPointToLatLng: function (t) { t = y(t).add(this.getPixelOrigin()); return this.unproject(t) }, latLngToLayerPoint: function (t) { return this.project(M(t))._round()._subtract(this.getPixelOrigin()) }, wrapLatLng: function (t) { return this.options.crs.wrapLatLng(M(t)) }, wrapLatLngBounds: function (t) { return this.options.crs.wrapLatLngBounds(T(t)) }, distance: function (t, e) { return this.options.crs.distance(M(t), M(e)) }, containerPointToLayerPoint: function (t) { return y(t).subtract(this._getMapPanePos()) }, layerPointToContainerPoint: function (t) { return y(t).add(this._getMapPanePos()) }, containerPointToLatLng: function (t) { t = this.containerPointToLayerPoint(y(t)); return this.layerPointToLatLng(t) }, latLngToContainerPoint: function (t) { return this.layerPointToContainerPoint(this.latLngToLayerPoint(M(t))) }, mouseEventToContainerPoint: function (t) { return vt(t, this._container) }, mouseEventToLayerPoint: function (t) { return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(t)) }, mouseEventToLatLng: function (t) { return this.layerPointToLatLng(this.mouseEventToLayerPoint(t)) }, _initContainer: function (t) { t = this._container = j(t); if (!t) throw new Error("Map container not found."); if (t._leaflet_id) throw new Error("Map container is already initialized."); ut(t, "scroll", this._onScroll, this), this._containerId = a(t) }, _initLayout: function () { var t = this._container; this._fadeAnimated = this.options.fadeAnimation && Ee, K(t, "leaflet-container" + (Oe ? " leaflet-touch" : "") + (Ne ? " leaflet-retina" : "") + (pe ? " leaflet-oldie" : "") + (be ? " leaflet-safari" : "") + (this._fadeAnimated ? " leaflet-fade-anim" : "")); var e = W(t, "position"); "absolute" !== e && "relative" !== e && "fixed" !== e && (t.style.position = "relative"), this._initPanes(), this._initControlPos && this._initControlPos() }, _initPanes: function () { var t = this._panes = {}; this._paneRenderers = {}, this._mapPane = this.createPane("mapPane", this._container), et(this._mapPane, new v(0, 0)), this.createPane("tilePane"), this.createPane("shadowPane"), this.createPane("overlayPane"), this.createPane("markerPane"), this.createPane("tooltipPane"), this.createPane("popupPane"), this.options.markerZoomAnimation || (K(t.markerPane, "leaflet-zoom-hide"), K(t.shadowPane, "leaflet-zoom-hide")) }, _resetView: function (t, e) { et(this._mapPane, new v(0, 0)); var i = !this._loaded; this._loaded = !0, e = this._limitZoom(e), this.fire("viewprereset"); var n = this._zoom !== e; this._moveStart(n, !1)._move(t, e)._moveEnd(n), this.fire("viewreset"), i && this.fire("load") }, _moveStart: function (t, e) { return t && this.fire("zoomstart"), e || this.fire("movestart"), this }, _move: function (t, e, i) { void 0 === e && (e = this._zoom); var n = this._zoom !== e; return this._zoom = e, this._lastCenter = t, this._pixelOrigin = this._getNewPixelOrigin(t), (n || i && i.pinch) && this.fire("zoom", i), this.fire("move", i) }, _moveEnd: function (t) { return t && this.fire("zoomend"), this.fire("moveend") }, _stop: function () { return f(this._flyToFrame), this._panAnim && this._panAnim.stop(), this }, _rawPanBy: function (t) { et(this._mapPane, this._getMapPanePos().subtract(t)) }, _getZoomSpan: function () { return this.getMaxZoom() - this.getMinZoom() }, _panInsideMaxBounds: function () { this._enforcingBounds || this.panInsideBounds(this.options.maxBounds) }, _checkIfLoaded: function () { if (!this._loaded) throw new Error("Set map center and zoom first.") }, _initEvents: function (t) { this._targets = {}; var e = t ? lt : ut; e((this._targets[a(this._container)] = this)._container, "click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress", this._handleDOMEvent, this), this.options.trackResize && e(window, "resize", this._onResize, this), Ee && this.options.transform3DLimit && (t ? this.off : this.on).call(this, "moveend", this._onMoveEnd) }, _onResize: function () { f(this._resizeRequest), this._resizeRequest = x(function () { this.invalidateSize({ debounceMoveend: !0 }) }, this) }, _onScroll: function () { this._container.scrollTop = 0, this._container.scrollLeft = 0 }, _onMoveEnd: function () { var t = this._getMapPanePos(); Math.max(Math.abs(t.x), Math.abs(t.y)) >= this.options.transform3DLimit && this._resetView(this.getCenter(), this.getZoom()) }, _findEventTargets: function (t, e) { for (var i, n = [], o = "mouseout" === e || "mouseover" === e, s = t.target || t.srcElement, r = !1; s;) { if ((i = this._targets[a(s)]) && ("click" === e || "preclick" === e) && !t._simulated && this._draggableMoved(i)) { r = !0; break } if (i && i.listens(e, !0)) { if (o && !Pt(s, t)) break; if (n.push(i), o) break } if (s === this._container) break; s = s.parentNode } return n.length || r || o || !Pt(s, t) || (n = [this]), n }, _handleDOMEvent: function (t) { var e; this._loaded && !wt(t) && ("mousedown" !== (e = t.type) && "keypress" !== e || st(t.target || t.srcElement), this._fireDOMEvent(t, e)) }, _mouseEvents: ["click", "dblclick", "mouseover", "mouseout", "contextmenu"], _fireDOMEvent: function (t, e, i) { if ("click" === t.type && ((o = h({}, t)).type = "preclick", this._fireDOMEvent(o, o.type, i)), !t._stopped && (i = (i || []).concat(this._findEventTargets(t, e))).length) { var n = i[0]; "contextmenu" === e && n.listens(e, !0) && ft(t); var o, s = { originalEvent: t }; "keypress" !== t.type && (o = n.getLatLng && (!n._radius || n._radius <= 10), s.containerPoint = o ? this.latLngToContainerPoint(n.getLatLng()) : this.mouseEventToContainerPoint(t), s.layerPoint = this.containerPointToLayerPoint(s.containerPoint), s.latlng = o ? n.getLatLng() : this.layerPointToLatLng(s.layerPoint)); for (var r = 0; r < i.length; r++)if (i[r].fire(e, s, !0), s.originalEvent._stopped || !1 === i[r].options.bubblingMouseEvents && -1 !== d(this._mouseEvents, e)) return } }, _draggableMoved: function (t) { return (t = t.dragging && t.dragging.enabled() ? t : this).dragging && t.dragging.moved() || this.boxZoom && this.boxZoom.moved() }, _clearHandlers: function () { for (var t = 0, e = this._handlers.length; t < e; t++)this._handlers[t].disable() }, whenReady: function (t, e) { return this._loaded ? t.call(e || this, { target: this }) : this.on("load", t, e), this }, _getMapPanePos: function () { return it(this._mapPane) || new v(0, 0) }, _moved: function () { var t = this._getMapPanePos(); return t && !t.equals([0, 0]) }, _getTopLeftPoint: function (t, e) { return (t && void 0 !== e ? this._getNewPixelOrigin(t, e) : this.getPixelOrigin()).subtract(this._getMapPanePos()) }, _getNewPixelOrigin: function (t, e) { var i = this.getSize()._divideBy(2); return this.project(t, e)._subtract(i)._add(this._getMapPanePos())._round() }, _latLngToNewLayerPoint: function (t, e, i) { i = this._getNewPixelOrigin(i, e); return this.project(t, e)._subtract(i) }, _latLngBoundsToNewLayerBounds: function (t, e, i) { i = this._getNewPixelOrigin(i, e); return P([this.project(t.getSouthWest(), e)._subtract(i), this.project(t.getNorthWest(), e)._subtract(i), this.project(t.getSouthEast(), e)._subtract(i), this.project(t.getNorthEast(), e)._subtract(i)]) }, _getCenterLayerPoint: function () { return this.containerPointToLayerPoint(this.getSize()._divideBy(2)) }, _getCenterOffset: function (t) { return this.latLngToLayerPoint(t).subtract(this._getCenterLayerPoint()) }, _limitCenter: function (t, e, i) { if (!i) return t; var n = this.project(t, e), o = this.getSize().divideBy(2), o = new w(n.subtract(o), n.add(o)), i = this._getBoundsOffset(o, i, e); return i.round().equals([0, 0]) ? t : this.unproject(n.add(i), e) }, _limitOffset: function (t, e) { if (!e) return t; var i = this.getPixelBounds(), i = new w(i.min.add(t), i.max.add(t)); return t.add(this._getBoundsOffset(i, e)) }, _getBoundsOffset: function (t, e, i) { e = P(this.project(e.getNorthEast(), i), this.project(e.getSouthWest(), i)), i = e.min.subtract(t.min), t = e.max.subtract(t.max); return new v(this._rebound(i.x, -t.x), this._rebound(i.y, -t.y)) }, _rebound: function (t, e) { return 0 < t + e ? Math.round(t - e) / 2 : Math.max(0, Math.ceil(t)) - Math.max(0, Math.floor(e)) }, _limitZoom: function (t) { var e = this.getMinZoom(), i = this.getMaxZoom(), n = Ee ? this.options.zoomSnap : 1; return n && (t = Math.round(t / n) * n), Math.max(e, Math.min(i, t)) }, _onPanTransitionStep: function () { this.fire("move") }, _onPanTransitionEnd: function () { Y(this._mapPane, "leaflet-pan-anim"), this.fire("moveend") }, _tryAnimatedPan: function (t, e) { t = this._getCenterOffset(t)._trunc(); return !(!0 !== (e && e.animate) && !this.getSize().contains(t) || (this.panBy(t, e), 0)) }, _createAnimProxy: function () { var t = this._proxy = H("div", "leaflet-proxy leaflet-zoom-animated"); this._panes.mapPane.appendChild(t), this.on("zoomanim", function (t) { var e = Qe, i = this._proxy.style[e]; tt(this._proxy, this.project(t.center, t.zoom), this.getZoomScale(t.zoom, 1)), i === this._proxy.style[e] && this._animatingZoom && this._onZoomTransitionEnd() }, this), this.on("load moveend", function () { var t = this.getCenter(), e = this.getZoom(); tt(this._proxy, this.project(t, e), this.getZoomScale(e, 1)) }, this), this._on("unload", this._destroyAnimProxy, this) }, _destroyAnimProxy: function () { F(this._proxy), delete this._proxy }, _catchTransitionEnd: function (t) { this._animatingZoom && 0 <= t.propertyName.indexOf("transform") && this._onZoomTransitionEnd() }, _nothingToAnimate: function () { return !this._container.getElementsByClassName("leaflet-zoom-animated").length }, _tryAnimatedZoom: function (t, e, i) { if (this._animatingZoom) return !0; if (i = i || {}, !this._zoomAnimated || !1 === i.animate || this._nothingToAnimate() || Math.abs(e - this._zoom) > this.options.zoomAnimationThreshold) return !1; var n = this.getZoomScale(e), n = this._getCenterOffset(t)._divideBy(1 - 1 / n); return !(!0 !== i.animate && !this.getSize().contains(n) || (x(function () { this._moveStart(!0, !1)._animateZoom(t, e, !0) }, this), 0)) }, _animateZoom: function (t, e, i, n) { this._mapPane && (i && (this._animatingZoom = !0, this._animateToCenter = t, this._animateToZoom = e, K(this._mapPane, "leaflet-zoom-anim")), this.fire("zoomanim", { center: t, zoom: e, noUpdate: n }), setTimeout(_(this._onZoomTransitionEnd, this), 250)) }, _onZoomTransitionEnd: function () { this._animatingZoom && (this._mapPane && Y(this._mapPane, "leaflet-zoom-anim"), this._animatingZoom = !1, this._move(this._animateToCenter, this._animateToZoom), x(function () { this._moveEnd(!0) }, this)) } }), li = g.extend({ options: { position: "topright" }, initialize: function (t) { s(this, t) }, getPosition: function () { return this.options.position }, setPosition: function (t) { var e = this._map; return e && e.removeControl(this), this.options.position = t, e && e.addControl(this), this }, getContainer: function () { return this._container }, addTo: function (t) { this.remove(), this._map = t; var e = this._container = this.onAdd(t), i = this.getPosition(), t = t._controlCorners[i]; return K(e, "leaflet-control"), -1 !== i.indexOf("bottom") ? t.insertBefore(e, t.firstChild) : t.appendChild(e), this }, remove: function () { return this._map && (F(this._container), this.onRemove && this.onRemove(this._map), this._map = null), this }, _refocusOnMap: function (t) { this._map && t && 0 < t.screenX && 0 < t.screenY && this._map.getContainer().focus() } }), ze = function (t) { return new li(t) }; ui.include({ addControl: function (t) { return t.addTo(this), this }, removeControl: function (t) { return t.remove(), this }, _initControlPos: function () { function t(t, e) { var i = o + t + " " + o + e; n[t + e] = H("div", i, s) } var n = this._controlCorners = {}, o = "leaflet-", s = this._controlContainer = H("div", o + "control-container", this._container); t("top", "left"), t("top", "right"), t("bottom", "left"), t("bottom", "right") }, _clearControlPos: function () { for (var t in this._controlCorners) F(this._controlCorners[t]); F(this._controlContainer), delete this._controlCorners, delete this._controlContainer } }); var ci = li.extend({ options: { collapsed: !0, position: "topright", autoZIndex: !0, hideSingleBase: !1, sortLayers: !1, sortFunction: function (t, e, i, n) { return i < n ? -1 : n < i ? 1 : 0 } }, initialize: function (t, e, i) { for (var n in s(this, i), this._layerControlInputs = [], this._layers = [], this._lastZIndex = 0, this._handlingClick = !1, t) this._addLayer(t[n], n); for (n in e) this._addLayer(e[n], n, !0) }, onAdd: function (t) { this._initLayout(), this._update(), (this._map = t).on("zoomend", this._checkDisabledLayers, this); for (var e = 0; e < this._layers.length; e++)this._layers[e].layer.on("add remove", this._onLayerChange, this); return this._container }, addTo: function (t) { return li.prototype.addTo.call(this, t), this._expandIfNotCollapsed() }, onRemove: function () { this._map.off("zoomend", this._checkDisabledLayers, this); for (var t = 0; t < this._layers.length; t++)this._layers[t].layer.off("add remove", this._onLayerChange, this) }, addBaseLayer: function (t, e) { return this._addLayer(t, e), this._map ? this._update() : this }, addOverlay: function (t, e) { return this._addLayer(t, e, !0), this._map ? this._update() : this }, removeLayer: function (t) { t.off("add remove", this._onLayerChange, this); t = this._getLayer(a(t)); return t && this._layers.splice(this._layers.indexOf(t), 1), this._map ? this._update() : this }, expand: function () { K(this._container, "leaflet-control-layers-expanded"), this._form.style.height = null; var t = this._map.getSize().y - (this._container.offsetTop + 50); return t < this._form.clientHeight ? (K(this._form, "leaflet-control-layers-scrollbar"), this._form.style.height = t + "px") : Y(this._form, "leaflet-control-layers-scrollbar"), this._checkDisabledLayers(), this }, collapse: function () { return Y(this._container, "leaflet-control-layers-expanded"), this }, _initLayout: function () { var t = "leaflet-control-layers", e = this._container = H("div", t), i = this.options.collapsed; e.setAttribute("aria-haspopup", !0), mt(e), pt(e); var n = this._form = H("form", t + "-list"); i && (this._map.on("click", this.collapse, this), ge || ut(e, { mouseenter: this.expand, mouseleave: this.collapse }, this)); var o = this._layersLink = H("a", t + "-toggle", e); o.href = "#", o.title = "Layers", Oe ? (ut(o, "click", gt), ut(o, "click", this.expand, this)) : ut(o, "focus", this.expand, this), i || this.expand(), this._baseLayersList = H("div", t + "-base", n), this._separator = H("div", t + "-separator", n), this._overlaysList = H("div", t + "-overlays", n), e.appendChild(n) }, _getLayer: function (t) { for (var e = 0; e < this._layers.length; e++)if (this._layers[e] && a(this._layers[e].layer) === t) return this._layers[e] }, _addLayer: function (t, e, i) { this._map && t.on("add remove", this._onLayerChange, this), this._layers.push({ layer: t, name: e, overlay: i }), this.options.sortLayers && this._layers.sort(_(function (t, e) { return this.options.sortFunction(t.layer, e.layer, t.name, e.name) }, this)), this.options.autoZIndex && t.setZIndex && (this._lastZIndex++, t.setZIndex(this._lastZIndex)), this._expandIfNotCollapsed() }, _update: function () { if (!this._container) return this; U(this._baseLayersList), U(this._overlaysList), this._layerControlInputs = []; for (var t, e, i, n = 0, o = 0; o < this._layers.length; o++)i = this._layers[o], this._addItem(i), e = e || i.overlay, t = t || !i.overlay, n += i.overlay ? 0 : 1; return this.options.hideSingleBase && (t = t && 1 < n, this._baseLayersList.style.display = t ? "" : "none"), this._separator.style.display = e && t ? "" : "none", this }, _onLayerChange: function (t) { this._handlingClick || this._update(); var e = this._getLayer(a(t.target)), t = e.overlay ? "add" === t.type ? "overlayadd" : "overlayremove" : "add" === t.type ? "baselayerchange" : null; t && this._map.fire(t, e) }, _createRadioElement: function (t, e) { t = '<input type="radio" class="leaflet-control-layers-selector" name="' + t + '"' + (e ? ' checked="checked"' : "") + "/>", e = document.createElement("div"); return e.innerHTML = t, e.firstChild }, _addItem: function (t) { var e, i = document.createElement("label"), n = this._map.hasLayer(t.layer); t.overlay ? ((e = document.createElement("input")).type = "checkbox", e.className = "leaflet-control-layers-selector", e.defaultChecked = n) : e = this._createRadioElement("leaflet-base-layers", n), this._layerControlInputs.push(e), e.layerId = a(t.layer), ut(e, "click", this._onInputClick, this); var o = document.createElement("span"); o.innerHTML = " " + t.name; n = document.createElement("div"); return i.appendChild(n), n.appendChild(e), n.appendChild(o), (t.overlay ? this._overlaysList : this._baseLayersList).appendChild(i), this._checkDisabledLayers(), i }, _onInputClick: function () { var t, e, i = this._layerControlInputs, n = [], o = []; this._handlingClick = !0; for (var s = i.length - 1; 0 <= s; s--)t = i[s], e = this._getLayer(t.layerId).layer, t.checked ? n.push(e) : t.checked || o.push(e); for (s = 0; s < o.length; s++)this._map.hasLayer(o[s]) && this._map.removeLayer(o[s]); for (s = 0; s < n.length; s++)this._map.hasLayer(n[s]) || this._map.addLayer(n[s]); this._handlingClick = !1, this._refocusOnMap() }, _checkDisabledLayers: function () { for (var t, e, i = this._layerControlInputs, n = this._map.getZoom(), o = i.length - 1; 0 <= o; o--)t = i[o], e = this._getLayer(t.layerId).layer, t.disabled = void 0 !== e.options.minZoom && n < e.options.minZoom || void 0 !== e.options.maxZoom && n > e.options.maxZoom }, _expandIfNotCollapsed: function () { return this._map && !this.options.collapsed && this.expand(), this }, _expand: function () { return this.expand() }, _collapse: function () { return this.collapse() } }), _i = li.extend({ options: { position: "topleft", zoomInText: "+", zoomInTitle: "Zoom in", zoomOutText: "&#x2212;", zoomOutTitle: "Zoom out" }, onAdd: function (t) { var e = "leaflet-control-zoom", i = H("div", e + " leaflet-bar"), n = this.options; return this._zoomInButton = this._createButton(n.zoomInText, n.zoomInTitle, e + "-in", i, this._zoomIn), this._zoomOutButton = this._createButton(n.zoomOutText, n.zoomOutTitle, e + "-out", i, this._zoomOut), this._updateDisabled(), t.on("zoomend zoomlevelschange", this._updateDisabled, this), i }, onRemove: function (t) { t.off("zoomend zoomlevelschange", this._updateDisabled, this) }, disable: function () { return this._disabled = !0, this._updateDisabled(), this }, enable: function () { return this._disabled = !1, this._updateDisabled(), this }, _zoomIn: function (t) { !this._disabled && this._map._zoom < this._map.getMaxZoom() && this._map.zoomIn(this._map.options.zoomDelta * (t.shiftKey ? 3 : 1)) }, _zoomOut: function (t) { !this._disabled && this._map._zoom > this._map.getMinZoom() && this._map.zoomOut(this._map.options.zoomDelta * (t.shiftKey ? 3 : 1)) }, _createButton: function (t, e, i, n, o) { n = H("a", i, n); return n.innerHTML = t, n.href = "#", n.title = e, n.setAttribute("role", "button"), n.setAttribute("aria-label", e), mt(n), ut(n, "click", gt), ut(n, "click", o, this), ut(n, "click", this._refocusOnMap, this), n }, _updateDisabled: function () { var t = this._map, e = "leaflet-disabled"; Y(this._zoomInButton, e), Y(this._zoomOutButton, e), !this._disabled && t._zoom !== t.getMinZoom() || K(this._zoomOutButton, e), !this._disabled && t._zoom !== t.getMaxZoom() || K(this._zoomInButton, e) } }); ui.mergeOptions({ zoomControl: !0 }), ui.addInitHook(function () { this.options.zoomControl && (this.zoomControl = new _i, this.addControl(this.zoomControl)) }); var di = li.extend({ options: { position: "bottomleft", maxWidth: 100, metric: !0, imperial: !0 }, onAdd: function (t) { var e = H("div", "leaflet-control-scale"), i = this.options; return this._addScales(i, "leaflet-control-scale-line", e), t.on(i.updateWhenIdle ? "moveend" : "move", this._update, this), t.whenReady(this._update, this), e }, onRemove: function (t) { t.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this) }, _addScales: function (t, e, i) { t.metric && (this._mScale = H("div", e, i)), t.imperial && (this._iScale = H("div", e, i)) }, _update: function () { var t = this._map, e = t.getSize().y / 2, e = t.distance(t.containerPointToLatLng([0, e]), t.containerPointToLatLng([this.options.maxWidth, e])); this._updateScales(e) }, _updateScales: function (t) { this.options.metric && t && this._updateMetric(t), this.options.imperial && t && this._updateImperial(t) }, _updateMetric: function (t) { var e = this._getRoundNum(t), i = e < 1e3 ? e + " m" : e / 1e3 + " km"; this._updateScale(this._mScale, i, e / t) }, _updateImperial: function (t) { var e, i = 3.2808399 * t; 5280 < i ? (e = i / 5280, t = this._getRoundNum(e), this._updateScale(this._iScale, t + " mi", t / e)) : (e = this._getRoundNum(i), this._updateScale(this._iScale, e + " ft", e / i)) }, _updateScale: function (t, e, i) { t.style.width = Math.round(this.options.maxWidth * i) + "px", t.innerHTML = e }, _getRoundNum: function (t) { var e = Math.pow(10, (Math.floor(t) + "").length - 1), t = t / e; return e * (t = 10 <= t ? 10 : 5 <= t ? 5 : 3 <= t ? 3 : 2 <= t ? 2 : 1) } }), pi = li.extend({ options: { position: "bottomright", prefix: '<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>' }, initialize: function (t) { s(this, t), this._attributions = {} }, onAdd: function (t) { for (var e in (t.attributionControl = this)._container = H("div", "leaflet-control-attribution"), mt(this._container), t._layers) t._layers[e].getAttribution && this.addAttribution(t._layers[e].getAttribution()); return this._update(), this._container }, setPrefix: function (t) { return this.options.prefix = t, this._update(), this }, addAttribution: function (t) { return t && (this._attributions[t] || (this._attributions[t] = 0), this._attributions[t]++, this._update()), this }, removeAttribution: function (t) { return t && this._attributions[t] && (this._attributions[t]--, this._update()), this }, _update: function () { if (this._map) { var t, e = []; for (t in this._attributions) this._attributions[t] && e.push(t); var i = []; this.options.prefix && i.push(this.options.prefix), e.length && i.push(e.join(", ")), this._container.innerHTML = i.join(" | ") } } }); ui.mergeOptions({ attributionControl: !0 }), ui.addInitHook(function () { this.options.attributionControl && (new pi).addTo(this) }), li.Layers = ci, li.Zoom = _i, li.Scale = di, li.Attribution = pi, ze.layers = function (t, e, i) { return new ci(t, e, i) }, ze.zoom = function (t) { return new _i(t) }, ze.scale = function (t) { return new di(t) }, ze.attribution = function (t) { return new pi(t) }; Se = g.extend({ initialize: function (t) { this._map = t }, enable: function () { return this._enabled || (this._enabled = !0, this.addHooks()), this }, disable: function () { return this._enabled && (this._enabled = !1, this.removeHooks()), this }, enabled: function () { return !!this._enabled } }); Se.addTo = function (t, e) { return t.addHandler(e, this), this }; var mi, Ze = { Events: te }, fi = Oe ? "touchstart mousedown" : "mousedown", gi = { mousedown: "mouseup", touchstart: "touchend", pointerdown: "touchend", MSPointerDown: "touchend" }, vi = { mousedown: "mousemove", touchstart: "touchmove", pointerdown: "touchmove", MSPointerDown: "touchmove" }, yi = ee.extend({ options: { clickTolerance: 3 }, initialize: function (t, e, i, n) { s(this, n), this._element = t, this._dragStartTarget = e || t, this._preventOutline = i }, enable: function () { this._enabled || (ut(this._dragStartTarget, fi, this._onDown, this), this._enabled = !0) }, disable: function () { this._enabled && (yi._dragging === this && this.finishDrag(), lt(this._dragStartTarget, fi, this._onDown, this), this._enabled = !1, this._moved = !1) }, _onDown: function (t) { var e, i; t._simulated || !this._enabled || (this._moved = !1, G(this._element, "leaflet-zoom-anim") || yi._dragging || t.shiftKey || 1 !== t.which && 1 !== t.button && !t.touches || ((yi._dragging = this)._preventOutline && st(this._element), nt(), he(), this._moving)) || (this.fire("down"), e = t.touches ? t.touches[0] : t, i = at(this._element), this._startPoint = new v(e.clientX, e.clientY), this._parentScale = ht(i), ut(document, vi[t.type], this._onMove, this), ut(document, gi[t.type], this._onUp, this)) }, _onMove: function (t) { var e; !t._simulated && this._enabled && (t.touches && 1 < t.touches.length ? this._moved = !0 : ((e = new v((e = t.touches && 1 === t.touches.length ? t.touches[0] : t).clientX, e.clientY)._subtract(this._startPoint)).x || e.y) && (Math.abs(e.x) + Math.abs(e.y) < this.options.clickTolerance || (e.x /= this._parentScale.x, e.y /= this._parentScale.y, ft(t), this._moved || (this.fire("dragstart"), this._moved = !0, this._startPos = it(this._element).subtract(e), K(document.body, "leaflet-dragging"), this._lastTarget = t.target || t.srcElement, window.SVGElementInstance && this._lastTarget instanceof SVGElementInstance && (this._lastTarget = this._lastTarget.correspondingUseElement), K(this._lastTarget, "leaflet-drag-target")), this._newPos = this._startPos.add(e), this._moving = !0, f(this._animRequest), this._lastEvent = t, this._animRequest = x(this._updatePosition, this, !0)))) }, _updatePosition: function () { var t = { originalEvent: this._lastEvent }; this.fire("predrag", t), et(this._element, this._newPos), this.fire("drag", t) }, _onUp: function (t) { !t._simulated && this._enabled && this.finishDrag() }, finishDrag: function () { for (var t in Y(document.body, "leaflet-dragging"), this._lastTarget && (Y(this._lastTarget, "leaflet-drag-target"), this._lastTarget = null), vi) lt(document, vi[t], this._onMove, this), lt(document, gi[t], this._onUp, this); ot(), ue(), this._moved && this._moving && (f(this._animRequest), this.fire("dragend", { distance: this._newPos.distanceTo(this._startPos) })), this._moving = !1, yi._dragging = !1 } }), Ae = (Object.freeze || Object)({ simplify: Lt, pointToSegmentDistance: bt, closestPointOnSegment: function (t, e, i) { return Ct(t, e, i) }, clipSegment: Tt, _getEdgeIntersection: zt, _getBitCode: Mt, _sqClosestPointOnSegment: Ct, isFlat: St, _flat: Zt }), Be = (Object.freeze || Object)({ clipPolygon: Et }), _e = { project: function (t) { return new v(t.lng, t.lat) }, unproject: function (t) { return new z(t.y, t.x) }, bounds: new w([-180, -90], [180, 90]) }, ye = { R: 6378137, R_MINOR: 6356752.314245179, bounds: new w([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]), project: function (t) { var e = Math.PI / 180, i = this.R, n = t.lat * e, o = this.R_MINOR / i, s = Math.sqrt(1 - o * o), o = s * Math.sin(n), s = Math.tan(Math.PI / 4 - n / 2) / Math.pow((1 - o) / (1 + o), s / 2), n = -i * Math.log(Math.max(s, 1e-10)); return new v(t.lng * e * i, n) }, unproject: function (t) { for (var e, i = 180 / Math.PI, n = this.R, o = this.R_MINOR / n, s = Math.sqrt(1 - o * o), r = Math.exp(-t.y / n), a = Math.PI / 2 - 2 * Math.atan(r), h = 0, u = .1; h < 15 && 1e-7 < Math.abs(u); h++)e = s * Math.sin(a), e = Math.pow((1 - e) / (1 + e), s / 2), a += u = Math.PI / 2 - 2 * Math.atan(r * e) - a; return new z(a * i, t.x * i / n) } }, Me = (Object.freeze || Object)({ LonLat: _e, Mercator: ye, SphericalMercator: se }), te = h({}, oe, { code: "EPSG:3395", projection: ye, transformation: S(Le = .5 / (Math.PI * ye.R), .5, -Le, .5) }), xi = h({}, oe, { code: "EPSG:4326", projection: _e, transformation: S(1 / 180, 1, -1 / 180, .5) }), se = h({}, ne, { projection: _e, transformation: S(1, 0, -1, 0), scale: function (t) { return Math.pow(2, t) }, zoom: function (t) { return Math.log(t) / Math.LN2 }, distance: function (t, e) { var i = e.lng - t.lng, t = e.lat - t.lat; return Math.sqrt(i * i + t * t) }, infinite: !0 }); ne.Earth = oe, ne.EPSG3395 = te, ne.EPSG3857 = le, ne.EPSG900913 = ce, ne.EPSG4326 = xi, ne.Simple = se; var wi = ee.extend({ options: { pane: "overlayPane", attribution: null, bubblingMouseEvents: !0 }, addTo: function (t) { return t.addLayer(this), this }, remove: function () { return this.removeFrom(this._map || this._mapToAdd) }, removeFrom: function (t) { return t && t.removeLayer(this), this }, getPane: function (t) { return this._map.getPane(t ? this.options[t] || t : this.options.pane) }, addInteractiveTarget: function (t) { return this._map._targets[a(t)] = this }, removeInteractiveTarget: function (t) { return delete this._map._targets[a(t)], this }, getAttribution: function () { return this.options.attribution }, _layerAdd: function (t) { var e, i = t.target; i.hasLayer(this) && (this._map = i, this._zoomAnimated = i._zoomAnimated, this.getEvents && (e = this.getEvents(), i.on(e, this), this.once("remove", function () { i.off(e, this) }, this)), this.onAdd(i), this.getAttribution && i.attributionControl && i.attributionControl.addAttribution(this.getAttribution()), this.fire("add"), i.fire("layeradd", { layer: this })) } }); ui.include({ addLayer: function (t) { if (!t._layerAdd) throw new Error("The provided object is not a Layer."); var e = a(t); return this._layers[e] || ((this._layers[e] = t)._mapToAdd = this, t.beforeAdd && t.beforeAdd(this), this.whenReady(t._layerAdd, t)), this }, removeLayer: function (t) { var e = a(t); return this._layers[e] && (this._loaded && t.onRemove(this), t.getAttribution && this.attributionControl && this.attributionControl.removeAttribution(t.getAttribution()), delete this._layers[e], this._loaded && (this.fire("layerremove", { layer: t }), t.fire("remove")), t._map = t._mapToAdd = null), this }, hasLayer: function (t) { return !!t && a(t) in this._layers }, eachLayer: function (t, e) { for (var i in this._layers) t.call(e, this._layers[i]); return this }, _addLayers: function (t) { for (var e = 0, i = (t = t ? Gt(t) ? t : [t] : []).length; e < i; e++)this.addLayer(t[e]) }, _addZoomLimit: function (t) { !isNaN(t.options.maxZoom) && isNaN(t.options.minZoom) || (this._zoomBoundLayers[a(t)] = t, this._updateZoomLevels()) }, _removeZoomLimit: function (t) { t = a(t); this._zoomBoundLayers[t] && (delete this._zoomBoundLayers[t], this._updateZoomLevels()) }, _updateZoomLevels: function () { var t, e = 1 / 0, i = -1 / 0, n = this._getZoomSpan(); for (t in this._zoomBoundLayers) var o = this._zoomBoundLayers[t].options, e = void 0 === o.minZoom ? e : Math.min(e, o.minZoom), i = void 0 === o.maxZoom ? i : Math.max(i, o.maxZoom); this._layersMaxZoom = i === -1 / 0 ? void 0 : i, this._layersMinZoom = e === 1 / 0 ? void 0 : e, n !== this._getZoomSpan() && this.fire("zoomlevelschange"), void 0 === this.options.maxZoom && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom && this.setZoom(this._layersMaxZoom), void 0 === this.options.minZoom && this._layersMinZoom && this.getZoom() < this._layersMinZoom && this.setZoom(this._layersMinZoom) } }); var Pi = wi.extend({ initialize: function (t, e) { var i, n; if (s(this, e), this._layers = {}, t) for (i = 0, n = t.length; i < n; i++)this.addLayer(t[i]) }, addLayer: function (t) { var e = this.getLayerId(t); return this._layers[e] = t, this._map && this._map.addLayer(t), this }, removeLayer: function (t) { t = t in this._layers ? t : this.getLayerId(t); return this._map && this._layers[t] && this._map.removeLayer(this._layers[t]), delete this._layers[t], this }, hasLayer: function (t) { return !!t && (t in this._layers || this.getLayerId(t) in this._layers) }, clearLayers: function () { return this.eachLayer(this.removeLayer, this) }, invoke: function (t) { var e, i, n = Array.prototype.slice.call(arguments, 1); for (e in this._layers) (i = this._layers[e])[t] && i[t].apply(i, n); return this }, onAdd: function (t) { this.eachLayer(t.addLayer, t) }, onRemove: function (t) { this.eachLayer(t.removeLayer, t) }, eachLayer: function (t, e) { for (var i in this._layers) t.call(e, this._layers[i]); return this }, getLayer: function (t) { return this._layers[t] }, getLayers: function () { var t = []; return this.eachLayer(t.push, t), t }, setZIndex: function (t) { return this.invoke("setZIndex", t) }, getLayerId: a }), Li = Pi.extend({ addLayer: function (t) { return this.hasLayer(t) ? this : (t.addEventParent(this), Pi.prototype.addLayer.call(this, t), this.fire("layeradd", { layer: t })) }, removeLayer: function (t) { return this.hasLayer(t) ? (t in this._layers && (t = this._layers[t]), t.removeEventParent(this), Pi.prototype.removeLayer.call(this, t), this.fire("layerremove", { layer: t })) : this }, setStyle: function (t) { return this.invoke("setStyle", t) }, bringToFront: function () { return this.invoke("bringToFront") }, bringToBack: function () { return this.invoke("bringToBack") }, getBounds: function () { var t, e = new b; for (t in this._layers) { var i = this._layers[t]; e.extend(i.getBounds ? i.getBounds() : i.getLatLng()) } return e } }), bi = g.extend({ options: { popupAnchor: [0, 0], tooltipAnchor: [0, 0] }, initialize: function (t) { s(this, t) }, createIcon: function (t) { return this._createIcon("icon", t) }, createShadow: function (t) { return this._createIcon("shadow", t) }, _createIcon: function (t, e) { var i = this._getIconUrl(t); if (!i) { if ("icon" === t) throw new Error("iconUrl not set in Icon options (see the docs)."); return null } e = this._createImg(i, e && "IMG" === e.tagName ? e : null); return this._setIconStyles(e, t), e }, _setIconStyles: function (t, e) { var i = this.options, n = i[e + "Size"]; "number" == typeof n && (n = [n, n]); var o = y(n), n = y("shadow" === e && i.shadowAnchor || i.iconAnchor || o && o.divideBy(2, !0)); t.className = "leaflet-marker-" + e + " " + (i.className || ""), n && (t.style.marginLeft = -n.x + "px", t.style.marginTop = -n.y + "px"), o && (t.style.width = o.x + "px", t.style.height = o.y + "px") }, _createImg: function (t, e) { return (e = e || document.createElement("img")).src = t, e }, _getIconUrl: function (t) { return Ne && this.options[t + "RetinaUrl"] || this.options[t + "Url"] } }), Ti = bi.extend({ options: { iconUrl: "marker-icon.png", iconRetinaUrl: "marker-icon-2x.png", shadowUrl: "marker-shadow.png", iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], tooltipAnchor: [16, -28], shadowSize: [41, 41] }, _getIconUrl: function (t) { return Ti.imagePath || (Ti.imagePath = this._detectIconPath()), (this.options.imagePath || Ti.imagePath) + bi.prototype._getIconUrl.call(this, t) }, _detectIconPath: function () { var t = H("div", "leaflet-default-icon-path", document.body), e = W(t, "background-image") || W(t, "backgroundImage"); return document.body.removeChild(t), null === e || 0 !== e.indexOf("url") ? "" : e.replace(/^url\(["']?/, "").replace(/marker-icon\.png["']?\)$/, "") } }), zi = Se.extend({ initialize: function (t) { this._marker = t }, addHooks: function () { var t = this._marker._icon; this._draggable || (this._draggable = new yi(t, t, !0)), this._draggable.on({ dragstart: this._onDragStart, predrag: this._onPreDrag, drag: this._onDrag, dragend: this._onDragEnd }, this).enable(), K(t, "leaflet-marker-draggable") }, removeHooks: function () { this._draggable.off({ dragstart: this._onDragStart, predrag: this._onPreDrag, drag: this._onDrag, dragend: this._onDragEnd }, this).disable(), this._marker._icon && Y(this._marker._icon, "leaflet-marker-draggable") }, moved: function () { return this._draggable && this._draggable._moved }, _adjustPan: function (t) { var e = this._marker, i = e._map, n = this._marker.options.autoPanSpeed, o = this._marker.options.autoPanPadding, s = it(e._icon), r = i.getPixelBounds(), a = i.getPixelOrigin(), o = P(r.min._subtract(a).add(o), r.max._subtract(a).subtract(o)); o.contains(s) || (n = y((Math.max(o.max.x, s.x) - o.max.x) / (r.max.x - o.max.x) - (Math.min(o.min.x, s.x) - o.min.x) / (r.min.x - o.min.x), (Math.max(o.max.y, s.y) - o.max.y) / (r.max.y - o.max.y) - (Math.min(o.min.y, s.y) - o.min.y) / (r.min.y - o.min.y)).multiplyBy(n), i.panBy(n, { animate: !1 }), this._draggable._newPos._add(n), this._draggable._startPos._add(n), et(e._icon, this._draggable._newPos), this._onDrag(t), this._panRequest = x(this._adjustPan.bind(this, t))) }, _onDragStart: function () { this._oldLatLng = this._marker.getLatLng(), this._marker.closePopup().fire("movestart").fire("dragstart") }, _onPreDrag: function (t) { this._marker.options.autoPan && (f(this._panRequest), this._panRequest = x(this._adjustPan.bind(this, t))) }, _onDrag: function (t) { var e = this._marker, i = e._shadow, n = it(e._icon), o = e._map.layerPointToLatLng(n); i && et(i, n), e._latlng = o, t.latlng = o, t.oldLatLng = this._oldLatLng, e.fire("move", t).fire("drag", t) }, _onDragEnd: function (t) { f(this._panRequest), delete this._oldLatLng, this._marker.fire("moveend").fire("dragend", t) } }), Mi = wi.extend({ options: { icon: new Ti, interactive: !0, keyboard: !0, title: "", alt: "", zIndexOffset: 0, opacity: 1, riseOnHover: !1, riseOffset: 250, pane: "markerPane", bubblingMouseEvents: !1, draggable: !1, autoPan: !1, autoPanPadding: [50, 50], autoPanSpeed: 10 }, initialize: function (t, e) { s(this, e), this._latlng = M(t) }, onAdd: function (t) { this._zoomAnimated = this._zoomAnimated && t.options.markerZoomAnimation, this._zoomAnimated && t.on("zoomanim", this._animateZoom, this), this._initIcon(), this.update() }, onRemove: function (t) { this.dragging && this.dragging.enabled() && (this.options.draggable = !0, this.dragging.removeHooks()), delete this.dragging, this._zoomAnimated && t.off("zoomanim", this._animateZoom, this), this._removeIcon(), this._removeShadow() }, getEvents: function () { return { zoom: this.update, viewreset: this.update } }, getLatLng: function () { return this._latlng }, setLatLng: function (t) { var e = this._latlng; return this._latlng = M(t), this.update(), this.fire("move", { oldLatLng: e, latlng: this._latlng }) }, setZIndexOffset: function (t) { return this.options.zIndexOffset = t, this.update() }, setIcon: function (t) { return this.options.icon = t, this._map && (this._initIcon(), this.update()), this._popup && this.bindPopup(this._popup, this._popup.options), this }, getElement: function () { return this._icon }, update: function () { var t; return this._icon && this._map && (t = this._map.latLngToLayerPoint(this._latlng).round(), this._setPos(t)), this }, _initIcon: function () { var t = this.options, e = "leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide"), i = t.icon.createIcon(this._icon), n = !1; i !== this._icon && (this._icon && this._removeIcon(), n = !0, t.title && (i.title = t.title), "IMG" === i.tagName && (i.alt = t.alt || "")), K(i, e), t.keyboard && (i.tabIndex = "0"), this._icon = i, t.riseOnHover && this.on({ mouseover: this._bringToFront, mouseout: this._resetZIndex }); var o = t.icon.createShadow(this._shadow), i = !1; o !== this._shadow && (this._removeShadow(), i = !0), o && (K(o, e), o.alt = ""), this._shadow = o, t.opacity < 1 && this._updateOpacity(), n && this.getPane().appendChild(this._icon), this._initInteraction(), o && i && this.getPane("shadowPane").appendChild(this._shadow) }, _removeIcon: function () { this.options.riseOnHover && this.off({ mouseover: this._bringToFront, mouseout: this._resetZIndex }), F(this._icon), this.removeInteractiveTarget(this._icon), this._icon = null }, _removeShadow: function () { this._shadow && F(this._shadow), this._shadow = null }, _setPos: function (t) { et(this._icon, t), this._shadow && et(this._shadow, t), this._zIndex = t.y + this.options.zIndexOffset, this._resetZIndex() }, _updateZIndex: function (t) { this._icon.style.zIndex = this._zIndex + t }, _animateZoom: function (t) { t = this._map._latLngToNewLayerPoint(this._latlng, t.zoom, t.center).round(); this._setPos(t) }, _initInteraction: function () { var t; this.options.interactive && (K(this._icon, "leaflet-interactive"), this.addInteractiveTarget(this._icon), zi) && (t = this.options.draggable, this.dragging && (t = this.dragging.enabled(), this.dragging.disable()), this.dragging = new zi(this), t && this.dragging.enable()) }, setOpacity: function (t) { return this.options.opacity = t, this._map && this._updateOpacity(), this }, _updateOpacity: function () { var t = this.options.opacity; $(this._icon, t), this._shadow && $(this._shadow, t) }, _bringToFront: function () { this._updateZIndex(this.options.riseOffset) }, _resetZIndex: function () { this._updateZIndex(0) }, _getPopupAnchor: function () { return this.options.icon.options.popupAnchor }, _getTooltipAnchor: function () { return this.options.icon.options.tooltipAnchor } }), Ci = wi.extend({ options: { stroke: !0, color: "#3388ff", weight: 3, opacity: 1, lineCap: "round", lineJoin: "round", dashArray: null, dashOffset: null, fill: !1, fillColor: null, fillOpacity: .2, fillRule: "evenodd", interactive: !0, bubblingMouseEvents: !0 }, beforeAdd: function (t) { this._renderer = t.getRenderer(this) }, onAdd: function () { this._renderer._initPath(this), this._reset(), this._renderer._addPath(this) }, onRemove: function () { this._renderer._removePath(this) }, redraw: function () { return this._map && this._renderer._updatePath(this), this }, setStyle: function (t) { return s(this, t), this._renderer && this._renderer._updateStyle(this), this }, bringToFront: function () { return this._renderer && this._renderer._bringToFront(this), this }, bringToBack: function () { return this._renderer && this._renderer._bringToBack(this), this }, getElement: function () { return this._path }, _reset: function () { this._project(), this._update() }, _clickTolerance: function () { return (this.options.stroke ? this.options.weight / 2 : 0) + this._renderer.options.tolerance } }), Si = Ci.extend({ options: { fill: !0, radius: 10 }, initialize: function (t, e) { s(this, e), this._latlng = M(t), this._radius = this.options.radius }, setLatLng: function (t) { return this._latlng = M(t), this.redraw(), this.fire("move", { latlng: this._latlng }) }, getLatLng: function () { return this._latlng }, setRadius: function (t) { return this.options.radius = this._radius = t, this.redraw() }, getRadius: function () { return this._radius }, setStyle: function (t) { var e = t && t.radius || this._radius; return Ci.prototype.setStyle.call(this, t), this.setRadius(e), this }, _project: function () { this._point = this._map.latLngToLayerPoint(this._latlng), this._updateBounds() }, _updateBounds: function () { var t = this._radius, e = this._radiusY || t, i = this._clickTolerance(), i = [t + i, e + i]; this._pxBounds = new w(this._point.subtract(i), this._point.add(i)) }, _update: function () { this._map && this._updatePath() }, _updatePath: function () { this._renderer._updateCircle(this) }, _empty: function () { return this._radius && !this._renderer._bounds.intersects(this._pxBounds) }, _containsPoint: function (t) { return t.distanceTo(this._point) <= this._radius + this._clickTolerance() } }), Zi = Si.extend({ initialize: function (t, e, i) { if ("number" == typeof e && (e = h({}, i, { radius: e })), s(this, e), this._latlng = M(t), isNaN(this.options.radius)) throw new Error("Circle radius cannot be NaN"); this._mRadius = this.options.radius }, setRadius: function (t) { return this._mRadius = t, this.redraw() }, getRadius: function () { return this._mRadius }, getBounds: function () { var t = [this._radius, this._radiusY || this._radius]; return new b(this._map.layerPointToLatLng(this._point.subtract(t)), this._map.layerPointToLatLng(this._point.add(t))) }, setStyle: Ci.prototype.setStyle, _project: function () { var t, e, i, n, o, s = this._latlng.lng, r = this._latlng.lat, a = this._map, h = a.options.crs; h.distance === oe.distance ? (o = Math.PI / 180, t = this._mRadius / oe.R / o, e = a.project([r + t, s]), n = a.project([r - t, s]), i = e.add(n).divideBy(2), n = a.unproject(i).lat, o = Math.acos((Math.cos(t * o) - Math.sin(r * o) * Math.sin(n * o)) / (Math.cos(r * o) * Math.cos(n * o))) / o, !isNaN(o) && 0 !== o || (o = t / Math.cos(Math.PI / 180 * r)), this._point = i.subtract(a.getPixelOrigin()), this._radius = isNaN(o) ? 0 : i.x - a.project([n, s - o]).x, this._radiusY = i.y - e.y) : (h = h.unproject(h.project(this._latlng).subtract([this._mRadius, 0])), this._point = a.latLngToLayerPoint(this._latlng), this._radius = this._point.x - a.latLngToLayerPoint(h).x), this._updateBounds() } }), Ei = Ci.extend({ options: { smoothFactor: 1, noClip: !1 }, initialize: function (t, e) { s(this, e), this._setLatLngs(t) }, getLatLngs: function () { return this._latlngs }, setLatLngs: function (t) { return this._setLatLngs(t), this.redraw() }, isEmpty: function () { return !this._latlngs.length }, closestLayerPoint: function (t) { for (var e, i, n = 1 / 0, o = null, s = Ct, r = 0, a = this._parts.length; r < a; r++)for (var h = this._parts[r], u = 1, l = h.length; u < l; u++) { var c = s(t, e = h[u - 1], i = h[u], !0); c < n && (n = c, o = s(t, e, i)) } return o && (o.distance = Math.sqrt(n)), o }, getCenter: function () { if (!this._map) throw new Error("Must add layer to map before using getCenter()"); var t, e, i, n, o, s, r = this._rings[0], a = r.length; if (!a) return null; for (e = t = 0; t < a - 1; t++)e += r[t].distanceTo(r[t + 1]) / 2; if (0 === e) return this._map.layerPointToLatLng(r[0]); for (i = t = 0; t < a - 1; t++)if (n = r[t], o = r[t + 1], (i += s = n.distanceTo(o)) > e) return s = (i - e) / s, this._map.layerPointToLatLng([o.x - s * (o.x - n.x), o.y - s * (o.y - n.y)]) }, getBounds: function () { return this._bounds }, addLatLng: function (t, e) { return e = e || this._defaultShape(), t = M(t), e.push(t), this._bounds.extend(t), this.redraw() }, _setLatLngs: function (t) { this._bounds = new b, this._latlngs = this._convertLatLngs(t) }, _defaultShape: function () { return St(this._latlngs) ? this._latlngs : this._latlngs[0] }, _convertLatLngs: function (t) { for (var e = [], i = St(t), n = 0, o = t.length; n < o; n++)i ? (e[n] = M(t[n]), this._bounds.extend(e[n])) : e[n] = this._convertLatLngs(t[n]); return e }, _project: function () { var t = new w; this._rings = [], this._projectLatlngs(this._latlngs, this._rings, t); var e = this._clickTolerance(), e = new v(e, e); this._bounds.isValid() && t.isValid() && (t.min._subtract(e), t.max._add(e), this._pxBounds = t) }, _projectLatlngs: function (t, e, i) { var n, o, s = t[0] instanceof z, r = t.length; if (s) { for (o = [], n = 0; n < r; n++)o[n] = this._map.latLngToLayerPoint(t[n]), i.extend(o[n]); e.push(o) } else for (n = 0; n < r; n++)this._projectLatlngs(t[n], e, i) }, _clipPoints: function () { var t = this._renderer._bounds; if (this._parts = [], this._pxBounds && this._pxBounds.intersects(t)) if (this.options.noClip) this._parts = this._rings; else for (var e, i, n, o, s = this._parts, r = 0, a = 0, h = this._rings.length; r < h; r++)for (e = 0, i = (o = this._rings[r]).length; e < i - 1; e++)(n = Tt(o[e], o[e + 1], t, e, !0)) && (s[a] = s[a] || [], s[a].push(n[0]), n[1] === o[e + 1] && e !== i - 2 || (s[a].push(n[1]), a++)) }, _simplifyPoints: function () { for (var t = this._parts, e = this.options.smoothFactor, i = 0, n = t.length; i < n; i++)t[i] = Lt(t[i], e) }, _update: function () { this._map && (this._clipPoints(), this._simplifyPoints(), this._updatePath()) }, _updatePath: function () { this._renderer._updatePoly(this) }, _containsPoint: function (t, e) { var i, n, o, s, r, a, h = this._clickTolerance(); if (!this._pxBounds || !this._pxBounds.contains(t)) return !1; for (i = 0, s = this._parts.length; i < s; i++)for (n = 0, o = (r = (a = this._parts[i]).length) - 1; n < r; o = n++)if ((e || 0 !== n) && bt(t, a[o], a[n]) <= h) return !0; return !1 } }); Ei._flat = Zt; var ki = Ei.extend({ options: { fill: !0 }, isEmpty: function () { return !this._latlngs.length || !this._latlngs[0].length }, getCenter: function () { if (!this._map) throw new Error("Must add layer to map before using getCenter()"); var t, e, i, n, o, s, r, a, h, u = this._rings[0], l = u.length; if (!l) return null; for (t = s = r = a = 0, e = l - 1; t < l; e = t++)i = u[t], n = u[e], o = i.y * n.x - n.y * i.x, r += (i.x + n.x) * o, a += (i.y + n.y) * o, s += 3 * o; return h = 0 === s ? u[0] : [r / s, a / s], this._map.layerPointToLatLng(h) }, _convertLatLngs: function (t) { var e = Ei.prototype._convertLatLngs.call(this, t), t = e.length; return 2 <= t && e[0] instanceof z && e[0].equals(e[t - 1]) && e.pop(), e }, _setLatLngs: function (t) { Ei.prototype._setLatLngs.call(this, t), St(this._latlngs) && (this._latlngs = [this._latlngs]) }, _defaultShape: function () { return (St(this._latlngs[0]) ? this._latlngs : this._latlngs[0])[0] }, _clipPoints: function () { var t = this._renderer._bounds, e = this.options.weight, e = new v(e, e), t = new w(t.min.subtract(e), t.max.add(e)); if (this._parts = [], this._pxBounds && this._pxBounds.intersects(t)) if (this.options.noClip) this._parts = this._rings; else for (var i, n = 0, o = this._rings.length; n < o; n++)(i = Et(this._rings[n], t, !0)).length && this._parts.push(i) }, _updatePath: function () { this._renderer._updatePoly(this, !0) }, _containsPoint: function (t) { var e, i, n, o, s, r, a, h, u = !1; if (!this._pxBounds || !this._pxBounds.contains(t)) return !1; for (o = 0, a = this._parts.length; o < a; o++)for (s = 0, r = (h = (e = this._parts[o]).length) - 1; s < h; r = s++)i = e[s], n = e[r], i.y > t.y != n.y > t.y && t.x < (n.x - i.x) * (t.y - i.y) / (n.y - i.y) + i.x && (u = !u); return u || Ei.prototype._containsPoint.call(this, t, !0) } }), Ai = Li.extend({ initialize: function (t, e) { s(this, e), this._layers = {}, t && this.addData(t) }, addData: function (t) { var e, i, n, o = Gt(t) ? t : t.features; if (o) { for (e = 0, i = o.length; e < i; e++)((n = o[e]).geometries || n.geometry || n.features || n.coordinates) && this.addData(n); return this } var s = this.options; if (s.filter && !s.filter(t)) return this; var r = kt(t, s); return r ? (r.feature = Nt(t), r.defaultOptions = r.options, this.resetStyle(r), s.onEachFeature && s.onEachFeature(t, r), this.addLayer(r)) : this }, resetStyle: function (t) { return t.options = h({}, t.defaultOptions), this._setLayerStyle(t, this.options.style), this }, setStyle: function (e) { return this.eachLayer(function (t) { this._setLayerStyle(t, e) }, this) }, _setLayerStyle: function (t, e) { "function" == typeof e && (e = e(t.feature)), t.setStyle && t.setStyle(e) } }), ye = { toGeoJSON: function (t) { return Rt(this, { type: "Point", coordinates: It(this.getLatLng(), t) }) } }; Mi.include(ye), Zi.include(ye), Si.include(ye), Ei.include({ toGeoJSON: function (t) { var e = !St(this._latlngs); return Rt(this, { type: (e ? "Multi" : "") + "LineString", coordinates: Ot(this._latlngs, e ? 1 : 0, !1, t) }) } }), ki.include({ toGeoJSON: function (t) { var e = !St(this._latlngs), i = e && !St(this._latlngs[0]), t = Ot(this._latlngs, i ? 2 : e ? 1 : 0, !0, t); return e || (t = [t]), Rt(this, { type: (i ? "Multi" : "") + "Polygon", coordinates: t }) } }), Pi.include({ toMultiPoint: function (e) { var i = []; return this.eachLayer(function (t) { i.push(t.toGeoJSON(e).geometry.coordinates) }), Rt(this, { type: "MultiPoint", coordinates: i }) }, toGeoJSON: function (e) { var t = this.feature && this.feature.geometry && this.feature.geometry.type; if ("MultiPoint" === t) return this.toMultiPoint(e); var i = "GeometryCollection" === t, n = []; return this.eachLayer(function (t) { t.toGeoJSON && (t = t.toGeoJSON(e), i ? n.push(t.geometry) : "FeatureCollection" === (t = Nt(t)).type ? n.push.apply(n, t.features) : n.push(t)) }), i ? Rt(this, { geometries: n, type: "GeometryCollection" }) : { type: "FeatureCollection", features: n } } }); var Le = Dt, Bi = wi.extend({ options: { opacity: 1, alt: "", interactive: !1, crossOrigin: !1, errorOverlayUrl: "", zIndex: 1, className: "" }, initialize: function (t, e, i) { this._url = t, this._bounds = T(e), s(this, i) }, onAdd: function () { this._image || (this._initImage(), this.options.opacity < 1 && this._updateOpacity()), this.options.interactive && (K(this._image, "leaflet-interactive"), this.addInteractiveTarget(this._image)), this.getPane().appendChild(this._image), this._reset() }, onRemove: function () { F(this._image), this.options.interactive && this.removeInteractiveTarget(this._image) }, setOpacity: function (t) { return this.options.opacity = t, this._image && this._updateOpacity(), this }, setStyle: function (t) { return t.opacity && this.setOpacity(t.opacity), this }, bringToFront: function () { return this._map && V(this._image), this }, bringToBack: function () { return this._map && q(this._image), this }, setUrl: function (t) { return this._url = t, this._image && (this._image.src = t), this }, setBounds: function (t) { return this._bounds = T(t), this._map && this._reset(), this }, getEvents: function () { var t = { zoom: this._reset, viewreset: this._reset }; return this._zoomAnimated && (t.zoomanim = this._animateZoom), t }, setZIndex: function (t) { return this.options.zIndex = t, this._updateZIndex(), this }, getBounds: function () { return this._bounds }, getElement: function () { return this._image }, _initImage: function () { var t = "IMG" === this._url.tagName, e = this._image = t ? this._url : H("img"); K(e, "leaflet-image-layer"), this._zoomAnimated && K(e, "leaflet-zoom-animated"), this.options.className && K(e, this.options.className), e.onselectstart = u, e.onmousemove = u, e.onload = _(this.fire, this, "load"), e.onerror = _(this._overlayOnError, this, "error"), !this.options.crossOrigin && "" !== this.options.crossOrigin || (e.crossOrigin = !0 === this.options.crossOrigin ? "" : this.options.crossOrigin), this.options.zIndex && this._updateZIndex(), t ? this._url = e.src : (e.src = this._url, e.alt = this.options.alt) }, _animateZoom: function (t) { var e = this._map.getZoomScale(t.zoom), t = this._map._latLngBoundsToNewLayerBounds(this._bounds, t.zoom, t.center).min; tt(this._image, t, e) }, _reset: function () { var t = this._image, e = new w(this._map.latLngToLayerPoint(this._bounds.getNorthWest()), this._map.latLngToLayerPoint(this._bounds.getSouthEast())), i = e.getSize(); et(t, e.min), t.style.width = i.x + "px", t.style.height = i.y + "px" }, _updateOpacity: function () { $(this._image, this.options.opacity) }, _updateZIndex: function () { this._image && void 0 !== this.options.zIndex && null !== this.options.zIndex && (this._image.style.zIndex = this.options.zIndex) }, _overlayOnError: function () { this.fire("error"); var t = this.options.errorOverlayUrl; t && this._url !== t && (this._url = t, this._image.src = t) } }), Ii = Bi.extend({ options: { autoplay: !0, loop: !0 }, _initImage: function () { var t = "VIDEO" === this._url.tagName, e = this._image = t ? this._url : H("video"); if (K(e, "leaflet-image-layer"), this._zoomAnimated && K(e, "leaflet-zoom-animated"), e.onselectstart = u, e.onmousemove = u, e.onloadeddata = _(this.fire, this, "load"), t) { for (var i = e.getElementsByTagName("source"), n = [], o = 0; o < i.length; o++)n.push(i[o].src); this._url = 0 < i.length ? n : [e.src] } else { Gt(this._url) || (this._url = [this._url]), e.autoplay = !!this.options.autoplay, e.loop = !!this.options.loop; for (var s = 0; s < this._url.length; s++) { var r = H("source"); r.src = this._url[s], e.appendChild(r) } } } }), Oi = wi.extend({ options: { offset: [0, 7], className: "", pane: "popupPane" }, initialize: function (t, e) { s(this, t), this._source = e }, onAdd: function (t) { this._zoomAnimated = t._zoomAnimated, this._container || this._initLayout(), t._fadeAnimated && $(this._container, 0), clearTimeout(this._removeTimeout), this.getPane().appendChild(this._container), this.update(), t._fadeAnimated && $(this._container, 1), this.bringToFront() }, onRemove: function (t) { t._fadeAnimated ? ($(this._container, 0), this._removeTimeout = setTimeout(_(F, void 0, this._container), 200)) : F(this._container) }, getLatLng: function () { return this._latlng }, setLatLng: function (t) { return this._latlng = M(t), this._map && (this._updatePosition(), this._adjustPan()), this }, getContent: function () { return this._content }, setContent: function (t) { return this._content = t, this.update(), this }, getElement: function () { return this._container }, update: function () { this._map && (this._container.style.visibility = "hidden", this._updateContent(), this._updateLayout(), this._updatePosition(), this._container.style.visibility = "", this._adjustPan()) }, getEvents: function () { var t = { zoom: this._updatePosition, viewreset: this._updatePosition }; return this._zoomAnimated && (t.zoomanim = this._animateZoom), t }, isOpen: function () { return !!this._map && this._map.hasLayer(this) }, bringToFront: function () { return this._map && V(this._container), this }, bringToBack: function () { return this._map && q(this._container), this }, _updateContent: function () { if (this._content) { var t = this._contentNode, e = "function" == typeof this._content ? this._content(this._source || this) : this._content; if ("string" == typeof e) t.innerHTML = e; else { for (; t.hasChildNodes();)t.removeChild(t.firstChild); t.appendChild(e) } this.fire("contentupdate") } }, _updatePosition: function () { var t, e, i; this._map && (t = this._map.latLngToLayerPoint(this._latlng), i = y(this.options.offset), e = this._getAnchor(), this._zoomAnimated ? et(this._container, t.add(e)) : i = i.add(t).add(e), e = this._containerBottom = -i.y, i = this._containerLeft = -Math.round(this._containerWidth / 2) + i.x, this._container.style.bottom = e + "px", this._container.style.left = i + "px") }, _getAnchor: function () { return [0, 0] } }), Ri = Oi.extend({ options: { maxWidth: 300, minWidth: 50, maxHeight: null, autoPan: !0, autoPanPaddingTopLeft: null, autoPanPaddingBottomRight: null, autoPanPadding: [5, 5], keepInView: !1, closeButton: !0, autoClose: !0, closeOnEscapeKey: !0, className: "" }, openOn: function (t) { return t.openPopup(this), this }, onAdd: function (t) { Oi.prototype.onAdd.call(this, t), t.fire("popupopen", { popup: this }), this._source && (this._source.fire("popupopen", { popup: this }, !0), this._source instanceof Ci || this._source.on("preclick", dt)) }, onRemove: function (t) { Oi.prototype.onRemove.call(this, t), t.fire("popupclose", { popup: this }), this._source && (this._source.fire("popupclose", { popup: this }, !0), this._source instanceof Ci || this._source.off("preclick", dt)) }, getEvents: function () { var t = Oi.prototype.getEvents.call(this); return (void 0 !== this.options.closeOnClick ? this.options.closeOnClick : this._map.options.closePopupOnClick) && (t.preclick = this._close), this.options.keepInView && (t.moveend = this._adjustPan), t }, _close: function () { this._map && this._map.closePopup(this) }, _initLayout: function () { var t = "leaflet-popup", e = this._container = H("div", t + " " + (this.options.className || "") + " leaflet-zoom-animated"), i = this._wrapper = H("div", t + "-content-wrapper", e); this._contentNode = H("div", t + "-content", i), mt(i), pt(this._contentNode), ut(i, "contextmenu", dt), this._tipContainer = H("div", t + "-tip-container", e), this._tip = H("div", t + "-tip", this._tipContainer), this.options.closeButton && ((e = this._closeButton = H("a", t + "-close-button", e)).href = "#close", e.innerHTML = "&#215;", ut(e, "click", this._onCloseButtonClick, this)) }, _updateLayout: function () { var t = this._contentNode, e = t.style; e.width = "", e.whiteSpace = "nowrap"; var i = t.offsetWidth, i = Math.min(i, this.options.maxWidth); i = Math.max(i, this.options.minWidth), e.width = i + 1 + "px", e.whiteSpace = "", e.height = ""; var n = t.offsetHeight, i = this.options.maxHeight; i && i < n ? (e.height = i + "px", K(t, "leaflet-popup-scrolled")) : Y(t, "leaflet-popup-scrolled"), this._containerWidth = this._container.offsetWidth }, _animateZoom: function (t) { var e = this._map._latLngToNewLayerPoint(this._latlng, t.zoom, t.center), t = this._getAnchor(); et(this._container, e.add(t)) }, _adjustPan: function () { var t, e, i, n, o, s, r, a, h; !this.options.autoPan || this._map._panAnim && this._map._panAnim._inProgress || (t = this._map, r = parseInt(W(this._container, "marginBottom"), 10) || 0, e = this._container.offsetHeight + r, i = this._containerWidth, (a = new v(this._containerLeft, -e - this._containerBottom))._add(it(this._container)), n = t.layerPointToContainerPoint(a), h = y(this.options.autoPanPadding), o = y(this.options.autoPanPaddingTopLeft || h), s = y(this.options.autoPanPaddingBottomRight || h), r = t.getSize(), h = a = 0, n.x + i + s.x > r.x && (a = n.x + i - r.x + s.x), n.x - a - o.x < 0 && (a = n.x - o.x), n.y + e + s.y > r.y && (h = n.y + e - r.y + s.y), n.y - h - o.y < 0 && (h = n.y - o.y), (a || h) && t.fire("autopanstart").panBy([a, h])) }, _onCloseButtonClick: function (t) { this._close(), gt(t) }, _getAnchor: function () { return y(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]) } }); ui.mergeOptions({ closePopupOnClick: !0 }), ui.include({ openPopup: function (t, e, i) { return t instanceof Ri || (t = new Ri(i).setContent(t)), e && t.setLatLng(e), this.hasLayer(t) ? this : (this._popup && this._popup.options.autoClose && this.closePopup(), this._popup = t, this.addLayer(t)) }, closePopup: function (t) { return t && t !== this._popup || (t = this._popup, this._popup = null), t && this.removeLayer(t), this } }), wi.include({ bindPopup: function (t, e) { return t instanceof Ri ? (s(t, e), (this._popup = t)._source = this) : (this._popup && !e || (this._popup = new Ri(e, this)), this._popup.setContent(t)), this._popupHandlersAdded || (this.on({ click: this._openPopup, keypress: this._onKeyPress, remove: this.closePopup, move: this._movePopup }), this._popupHandlersAdded = !0), this }, unbindPopup: function () { return this._popup && (this.off({ click: this._openPopup, keypress: this._onKeyPress, remove: this.closePopup, move: this._movePopup }), this._popupHandlersAdded = !1, this._popup = null), this }, openPopup: function (t, e) { if (t instanceof wi || (e = t, t = this), t instanceof Li) for (var i in this._layers) { t = this._layers[i]; break } return e = e || (t.getCenter ? t.getCenter() : t.getLatLng()), this._popup && this._map && (this._popup._source = t, this._popup.update(), this._map.openPopup(this._popup, e)), this }, closePopup: function () { return this._popup && this._popup._close(), this }, togglePopup: function (t) { return this._popup && (this._popup._map ? this.closePopup() : this.openPopup(t)), this }, isPopupOpen: function () { return !!this._popup && this._popup.isOpen() }, setPopupContent: function (t) { return this._popup && this._popup.setContent(t), this }, getPopup: function () { return this._popup }, _openPopup: function (t) { var e = t.layer || t.target; this._popup && this._map && (gt(t), e instanceof Ci ? this.openPopup(t.layer || t.target, t.latlng) : this._map.hasLayer(this._popup) && this._popup._source === e ? this.closePopup() : this.openPopup(e, t.latlng)) }, _movePopup: function (t) { this._popup.setLatLng(t.latlng) }, _onKeyPress: function (t) { 13 === t.originalEvent.keyCode && this._openPopup(t) } }); var Ni = Oi.extend({ options: { pane: "tooltipPane", offset: [0, 0], direction: "auto", permanent: !1, sticky: !1, interactive: !1, opacity: .9 }, onAdd: function (t) { Oi.prototype.onAdd.call(this, t), this.setOpacity(this.options.opacity), t.fire("tooltipopen", { tooltip: this }), this._source && this._source.fire("tooltipopen", { tooltip: this }, !0) }, onRemove: function (t) { Oi.prototype.onRemove.call(this, t), t.fire("tooltipclose", { tooltip: this }), this._source && this._source.fire("tooltipclose", { tooltip: this }, !0) }, getEvents: function () { var t = Oi.prototype.getEvents.call(this); return Oe && !this.options.permanent && (t.preclick = this._close), t }, _close: function () { this._map && this._map.closeTooltip(this) }, _initLayout: function () { var t = "leaflet-tooltip " + (this.options.className || "") + " leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide"); this._contentNode = this._container = H("div", t) }, _updateLayout: function () { }, _adjustPan: function () { }, _setPosition: function (t) { var e = this._map, i = this._container, n = e.latLngToContainerPoint(e.getCenter()), o = e.layerPointToContainerPoint(t), s = this.options.direction, r = i.offsetWidth, a = i.offsetHeight, h = y(this.options.offset), e = this._getAnchor(); t = "top" === s ? t.add(y(-r / 2 + h.x, -a + h.y + e.y, !0)) : "bottom" === s ? t.subtract(y(r / 2 - h.x, -h.y, !0)) : "center" === s ? t.subtract(y(r / 2 + h.x, a / 2 - e.y + h.y, !0)) : "right" === s || "auto" === s && o.x < n.x ? (s = "right", t.add(y(h.x + e.x, e.y - a / 2 + h.y, !0))) : (s = "left", t.subtract(y(r + e.x - h.x, a / 2 - e.y - h.y, !0))), Y(i, "leaflet-tooltip-right"), Y(i, "leaflet-tooltip-left"), Y(i, "leaflet-tooltip-top"), Y(i, "leaflet-tooltip-bottom"), K(i, "leaflet-tooltip-" + s), et(i, t) }, _updatePosition: function () { var t = this._map.latLngToLayerPoint(this._latlng); this._setPosition(t) }, setOpacity: function (t) { this.options.opacity = t, this._container && $(this._container, t) }, _animateZoom: function (t) { t = this._map._latLngToNewLayerPoint(this._latlng, t.zoom, t.center); this._setPosition(t) }, _getAnchor: function () { return y(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]) } }); ui.include({ openTooltip: function (t, e, i) { return t instanceof Ni || (t = new Ni(i).setContent(t)), e && t.setLatLng(e), this.hasLayer(t) ? this : this.addLayer(t) }, closeTooltip: function (t) { return t && this.removeLayer(t), this } }), wi.include({ bindTooltip: function (t, e) { return t instanceof Ni ? (s(t, e), (this._tooltip = t)._source = this) : (this._tooltip && !e || (this._tooltip = new Ni(e, this)), this._tooltip.setContent(t)), this._initTooltipInteractions(), this._tooltip.options.permanent && this._map && this._map.hasLayer(this) && this.openTooltip(), this }, unbindTooltip: function () { return this._tooltip && (this._initTooltipInteractions(!0), this.closeTooltip(), this._tooltip = null), this }, _initTooltipInteractions: function (t) { var e, i; !t && this._tooltipHandlersAdded || (e = t ? "off" : "on", i = { remove: this.closeTooltip, move: this._moveTooltip }, this._tooltip.options.permanent ? i.add = this._openTooltip : (i.mouseover = this._openTooltip, i.mouseout = this.closeTooltip, this._tooltip.options.sticky && (i.mousemove = this._moveTooltip), Oe && (i.click = this._openTooltip)), this[e](i), this._tooltipHandlersAdded = !t) }, openTooltip: function (t, e) { if (t instanceof wi || (e = t, t = this), t instanceof Li) for (var i in this._layers) { t = this._layers[i]; break } return e = e || (t.getCenter ? t.getCenter() : t.getLatLng()), this._tooltip && this._map && (this._tooltip._source = t, this._tooltip.update(), this._map.openTooltip(this._tooltip, e), this._tooltip.options.interactive && this._tooltip._container && (K(this._tooltip._container, "leaflet-clickable"), this.addInteractiveTarget(this._tooltip._container))), this }, closeTooltip: function () { return this._tooltip && (this._tooltip._close(), this._tooltip.options.interactive && this._tooltip._container && (Y(this._tooltip._container, "leaflet-clickable"), this.removeInteractiveTarget(this._tooltip._container))), this }, toggleTooltip: function (t) { return this._tooltip && (this._tooltip._map ? this.closeTooltip() : this.openTooltip(t)), this }, isTooltipOpen: function () { return this._tooltip.isOpen() }, setTooltipContent: function (t) { return this._tooltip && this._tooltip.setContent(t), this }, getTooltip: function () { return this._tooltip }, _openTooltip: function (t) { var e = t.layer || t.target; this._tooltip && this._map && this.openTooltip(e, this._tooltip.options.sticky ? t.latlng : void 0) }, _moveTooltip: function (t) { var e = t.latlng; this._tooltip.options.sticky && t.originalEvent && (t = this._map.mouseEventToContainerPoint(t.originalEvent), t = this._map.containerPointToLayerPoint(t), e = this._map.layerPointToLatLng(t)), this._tooltip.setLatLng(e) } }); var Di = bi.extend({ options: { iconSize: [12, 12], html: !1, bgPos: null, className: "leaflet-div-icon" }, createIcon: function (t) { var e = t && "DIV" === t.tagName ? t : document.createElement("div"), t = this.options; return e.innerHTML = !1 !== t.html ? t.html : "", t.bgPos && (t = y(t.bgPos), e.style.backgroundPosition = -t.x + "px " + -t.y + "px"), this._setIconStyles(e, "icon"), e }, createShadow: function () { return null } }); bi.Default = Ti; var ji = wi.extend({ options: { tileSize: 256, opacity: 1, updateWhenIdle: ke, updateWhenZooming: !0, updateInterval: 200, zIndex: 1, bounds: null, minZoom: 0, maxZoom: void 0, maxNativeZoom: void 0, minNativeZoom: void 0, noWrap: !1, pane: "tilePane", className: "", keepBuffer: 2 }, initialize: function (t) { s(this, t) }, onAdd: function () { this._initContainer(), this._levels = {}, this._tiles = {}, this._resetView(), this._update() }, beforeAdd: function (t) { t._addZoomLimit(this) }, onRemove: function (t) { this._removeAllTiles(), F(this._container), t._removeZoomLimit(this), this._container = null, this._tileZoom = void 0 }, bringToFront: function () { return this._map && (V(this._container), this._setAutoZIndex(Math.max)), this }, bringToBack: function () { return this._map && (q(this._container), this._setAutoZIndex(Math.min)), this }, getContainer: function () { return this._container }, setOpacity: function (t) { return this.options.opacity = t, this._updateOpacity(), this }, setZIndex: function (t) { return this.options.zIndex = t, this._updateZIndex(), this }, isLoading: function () { return this._loading }, redraw: function () { return this._map && (this._removeAllTiles(), this._update()), this }, getEvents: function () { var t = { viewprereset: this._invalidateAll, viewreset: this._resetView, zoom: this._resetView, moveend: this._onMoveEnd }; return this.options.updateWhenIdle || (this._onMove || (this._onMove = e(this._onMoveEnd, this.options.updateInterval, this)), t.move = this._onMove), this._zoomAnimated && (t.zoomanim = this._animateZoom), t }, createTile: function () { return document.createElement("div") }, getTileSize: function () { var t = this.options.tileSize; return t instanceof v ? t : new v(t, t) }, _updateZIndex: function () { this._container && void 0 !== this.options.zIndex && null !== this.options.zIndex && (this._container.style.zIndex = this.options.zIndex) }, _setAutoZIndex: function (t) { for (var e, i = this.getPane().children, n = -t(-1 / 0, 1 / 0), o = 0, s = i.length; o < s; o++)e = i[o].style.zIndex, i[o] !== this._container && e && (n = t(n, +e)); isFinite(n) && (this.options.zIndex = n + t(-1, 1), this._updateZIndex()) }, _updateOpacity: function () { if (this._map && !pe) { $(this._container, this.options.opacity); var t, e = +new Date, i = !1, n = !1; for (t in this._tiles) { var o, s = this._tiles[t]; s.current && s.loaded && (o = Math.min(1, (e - s.loaded) / 200), $(s.el, o), o < 1 ? i = !0 : (s.active ? n = !0 : this._onOpaqueTile(s), s.active = !0)) } n && !this._noPrune && this._pruneTiles(), i && (f(this._fadeFrame), this._fadeFrame = x(this._updateOpacity, this)) } }, _onOpaqueTile: u, _initContainer: function () { this._container || (this._container = H("div", "leaflet-layer " + (this.options.className || "")), this._updateZIndex(), this.options.opacity < 1 && this._updateOpacity(), this.getPane().appendChild(this._container)) }, _updateLevels: function () { var t = this._tileZoom, e = this.options.maxZoom; if (void 0 !== t) { for (var i in this._levels) this._levels[i].el.children.length || i === t ? (this._levels[i].el.style.zIndex = e - Math.abs(t - i), this._onUpdateLevel(i)) : (F(this._levels[i].el), this._removeTilesAtZoom(i), this._onRemoveLevel(i), delete this._levels[i]); var n = this._levels[t], o = this._map; return n || ((n = this._levels[t] = {}).el = H("div", "leaflet-tile-container leaflet-zoom-animated", this._container), n.el.style.zIndex = e, n.origin = o.project(o.unproject(o.getPixelOrigin()), t).round(), n.zoom = t, this._setZoomTransform(n, o.getCenter(), o.getZoom()), n.el.offsetWidth, this._onCreateLevel(n)), this._level = n } }, _onUpdateLevel: u, _onRemoveLevel: u, _onCreateLevel: u, _pruneTiles: function () { if (this._map) { var t, e, i, n = this._map.getZoom(); if (n > this.options.maxZoom || n < this.options.minZoom) this._removeAllTiles(); else { for (t in this._tiles) (e = this._tiles[t]).retain = e.current; for (t in this._tiles) { (e = this._tiles[t]).current && !e.active && (i = e.coords, this._retainParent(i.x, i.y, i.z, i.z - 5) || this._retainChildren(i.x, i.y, i.z, i.z + 2)) } for (t in this._tiles) this._tiles[t].retain || this._removeTile(t) } } }, _removeTilesAtZoom: function (t) { for (var e in this._tiles) this._tiles[e].coords.z === t && this._removeTile(e) }, _removeAllTiles: function () { for (var t in this._tiles) this._removeTile(t) }, _invalidateAll: function () { for (var t in this._levels) F(this._levels[t].el), this._onRemoveLevel(t), delete this._levels[t]; this._removeAllTiles(), this._tileZoom = void 0 }, _retainParent: function (t, e, i, n) { var o = Math.floor(t / 2), t = Math.floor(e / 2), e = i - 1, i = new v(+o, +t); i.z = +e; i = this._tileCoordsToKey(i), i = this._tiles[i]; return i && i.active ? i.retain = !0 : (i && i.loaded && (i.retain = !0), n < e && this._retainParent(o, t, e, n)) }, _retainChildren: function (t, e, i, n) { for (var o = 2 * t; o < 2 * t + 2; o++)for (var s = 2 * e; s < 2 * e + 2; s++) { var r = new v(o, s); r.z = i + 1; r = this._tileCoordsToKey(r), r = this._tiles[r]; r && r.active ? r.retain = !0 : (r && r.loaded && (r.retain = !0), i + 1 < n && this._retainChildren(o, s, i + 1, n)) } }, _resetView: function (t) { t = t && (t.pinch || t.flyTo); this._setView(this._map.getCenter(), this._map.getZoom(), t, t) }, _animateZoom: function (t) { this._setView(t.center, t.zoom, !0, t.noUpdate) }, _clampZoom: function (t) { var e = this.options; return void 0 !== e.minNativeZoom && t < e.minNativeZoom ? e.minNativeZoom : void 0 !== e.maxNativeZoom && e.maxNativeZoom < t ? e.maxNativeZoom : t }, _setView: function (t, e, i, n) { var o = this._clampZoom(Math.round(e)); (void 0 !== this.options.maxZoom && o > this.options.maxZoom || void 0 !== this.options.minZoom && o < this.options.minZoom) && (o = void 0); var s = this.options.updateWhenZooming && o !== this._tileZoom; n && !s || (this._tileZoom = o, this._abortLoading && this._abortLoading(), this._updateLevels(), this._resetGrid(), void 0 !== o && this._update(t), i || this._pruneTiles(), this._noPrune = !!i), this._setZoomTransforms(t, e) }, _setZoomTransforms: function (t, e) { for (var i in this._levels) this._setZoomTransform(this._levels[i], t, e) }, _setZoomTransform: function (t, e, i) { var n = this._map.getZoomScale(i, t.zoom), i = t.origin.multiplyBy(n).subtract(this._map._getNewPixelOrigin(e, i)).round(); Ee ? tt(t.el, i, n) : et(t.el, i) }, _resetGrid: function () { var t = this._map, e = t.options.crs, i = this._tileSize = this.getTileSize(), n = this._tileZoom, o = this._map.getPixelWorldBounds(this._tileZoom); o && (this._globalTileRange = this._pxBoundsToTileRange(o)), this._wrapX = e.wrapLng && !this.options.noWrap && [Math.floor(t.project([0, e.wrapLng[0]], n).x / i.x), Math.ceil(t.project([0, e.wrapLng[1]], n).x / i.y)], this._wrapY = e.wrapLat && !this.options.noWrap && [Math.floor(t.project([e.wrapLat[0], 0], n).y / i.x), Math.ceil(t.project([e.wrapLat[1], 0], n).y / i.y)] }, _onMoveEnd: function () { this._map && !this._map._animatingZoom && this._update() }, _getTiledPixelBounds: function (t) { var e = this._map, i = e._animatingZoom ? Math.max(e._animateToZoom, e.getZoom()) : e.getZoom(), i = e.getZoomScale(i, this._tileZoom), t = e.project(t, this._tileZoom).floor(), i = e.getSize().divideBy(2 * i); return new w(t.subtract(i), t.add(i)) }, _update: function (t) { var e = this._map; if (e) { var i = this._clampZoom(e.getZoom()); if (void 0 === t && (t = e.getCenter()), void 0 !== this._tileZoom) { var n, e = this._getTiledPixelBounds(t), o = this._pxBoundsToTileRange(e), s = o.getCenter(), r = [], e = this.options.keepBuffer, a = new w(o.getBottomLeft().subtract([e, -e]), o.getTopRight().add([e, -e])); if (!(isFinite(o.min.x) && isFinite(o.min.y) && isFinite(o.max.x) && isFinite(o.max.y))) throw new Error("Attempted to load an infinite number of tiles"); for (n in this._tiles) { var h = this._tiles[n].coords; h.z === this._tileZoom && a.contains(new v(h.x, h.y)) || (this._tiles[n].current = !1) } if (1 < Math.abs(i - this._tileZoom)) this._setView(t, i); else { for (var u = o.min.y; u <= o.max.y; u++)for (var l = o.min.x; l <= o.max.x; l++) { var c, _ = new v(l, u); _.z = this._tileZoom, this._isValidTile(_) && ((c = this._tiles[this._tileCoordsToKey(_)]) ? c.current = !0 : r.push(_)) } if (r.sort(function (t, e) { return t.distanceTo(s) - e.distanceTo(s) }), 0 !== r.length) { this._loading || (this._loading = !0, this.fire("loading")); for (var d = document.createDocumentFragment(), l = 0; l < r.length; l++)this._addTile(r[l], d); this._level.el.appendChild(d) } } } } }, _isValidTile: function (t) { var e = this._map.options.crs; if (!e.infinite) { var i = this._globalTileRange; if (!e.wrapLng && (t.x < i.min.x || t.x > i.max.x) || !e.wrapLat && (t.y < i.min.y || t.y > i.max.y)) return !1 } if (!this.options.bounds) return !0; t = this._tileCoordsToBounds(t); return T(this.options.bounds).overlaps(t) }, _keyToBounds: function (t) { return this._tileCoordsToBounds(this._keyToTileCoords(t)) }, _tileCoordsToNwSe: function (t) { var e = this._map, i = this.getTileSize(), n = t.scaleBy(i), i = n.add(i); return [e.unproject(n, t.z), e.unproject(i, t.z)] }, _tileCoordsToBounds: function (t) { t = this._tileCoordsToNwSe(t), t = new b(t[0], t[1]); return this.options.noWrap || (t = this._map.wrapLatLngBounds(t)), t }, _tileCoordsToKey: function (t) { return t.x + ":" + t.y + ":" + t.z }, _keyToTileCoords: function (t) { var e = t.split(":"), t = new v(+e[0], +e[1]); return t.z = +e[2], t }, _removeTile: function (t) { var e = this._tiles[t]; e && (F(e.el), delete this._tiles[t], this.fire("tileunload", { tile: e.el, coords: this._keyToTileCoords(t) })) }, _initTile: function (t) { K(t, "leaflet-tile"); var e = this.getTileSize(); t.style.width = e.x + "px", t.style.height = e.y + "px", t.onselectstart = u, t.onmousemove = u, pe && this.options.opacity < 1 && $(t, this.options.opacity), ge && !ve && (t.style.WebkitBackfaceVisibility = "hidden") }, _addTile: function (t, e) { var i = this._getTilePos(t), n = this._tileCoordsToKey(t), o = this.createTile(this._wrapCoords(t), _(this._tileReady, this, t)); this._initTile(o), this.createTile.length < 2 && x(_(this._tileReady, this, t, null, o)), et(o, i), this._tiles[n] = { el: o, coords: t, current: !0 }, e.appendChild(o), this.fire("tileloadstart", { tile: o, coords: t }) }, _tileReady: function (t, e, i) { e && this.fire("tileerror", { error: e, tile: i, coords: t }); var n = this._tileCoordsToKey(t); (i = this._tiles[n]) && (i.loaded = +new Date, this._map._fadeAnimated ? ($(i.el, 0), f(this._fadeFrame), this._fadeFrame = x(this._updateOpacity, this)) : (i.active = !0, this._pruneTiles()), e || (K(i.el, "leaflet-tile-loaded"), this.fire("tileload", { tile: i.el, coords: t })), this._noTilesToLoad() && (this._loading = !1, this.fire("load"), pe || !this._map._fadeAnimated ? x(this._pruneTiles, this) : setTimeout(_(this._pruneTiles, this), 250))) }, _getTilePos: function (t) { return t.scaleBy(this.getTileSize()).subtract(this._level.origin) }, _wrapCoords: function (t) { var e = new v(this._wrapX ? i(t.x, this._wrapX) : t.x, this._wrapY ? i(t.y, this._wrapY) : t.y); return e.z = t.z, e }, _pxBoundsToTileRange: function (t) { var e = this.getTileSize(); return new w(t.min.unscaleBy(e).floor(), t.max.unscaleBy(e).ceil().subtract([1, 1])) }, _noTilesToLoad: function () { for (var t in this._tiles) if (!this._tiles[t].loaded) return !1; return !0 } }), Wi = ji.extend({ options: { minZoom: 0, maxZoom: 18, subdomains: "abc", errorTileUrl: "", zoomOffset: 0, tms: !1, zoomReverse: !1, detectRetina: !1, crossOrigin: !1 }, initialize: function (t, e) { this._url = t, (e = s(this, e)).detectRetina && Ne && 0 < e.maxZoom && (e.tileSize = Math.floor(e.tileSize / 2), e.zoomReverse ? (e.zoomOffset--, e.minZoom++) : (e.zoomOffset++, e.maxZoom--), e.minZoom = Math.max(0, e.minZoom)), "string" == typeof e.subdomains && (e.subdomains = e.subdomains.split("")), ge || this.on("tileunload", this._onTileRemove) }, setUrl: function (t, e) { return this._url = t, e || this.redraw(), this }, createTile: function (t, e) { var i = document.createElement("img"); return ut(i, "load", _(this._tileOnLoad, this, e, i)), ut(i, "error", _(this._tileOnError, this, e, i)), !this.options.crossOrigin && "" !== this.options.crossOrigin || (i.crossOrigin = !0 === this.options.crossOrigin ? "" : this.options.crossOrigin), i.alt = "", i.setAttribute("role", "presentation"), i.src = this.getTileUrl(t), i }, getTileUrl: function (t) { var e = { r: Ne ? "@2x" : "", s: this._getSubdomain(t), x: t.x, y: t.y, z: this._getZoomForUrl() }; return this._map && !this._map.options.crs.infinite && (t = this._globalTileRange.max.y - t.y, this.options.tms && (e.y = t), e["-y"] = t), c(this._url, h(e, this.options)) }, _tileOnLoad: function (t, e) { pe ? setTimeout(_(t, this, null, e), 0) : t(null, e) }, _tileOnError: function (t, e, i) { var n = this.options.errorTileUrl; n && e.getAttribute("src") !== n && (e.src = n), t(i, e) }, _onTileRemove: function (t) { t.tile.onload = null }, _getZoomForUrl: function () { var t = this._tileZoom, e = this.options.maxZoom; return this.options.zoomReverse && (t = e - t), t + this.options.zoomOffset }, _getSubdomain: function (t) { t = Math.abs(t.x + t.y) % this.options.subdomains.length; return this.options.subdomains[t] }, _abortLoading: function () { var t, e; for (t in this._tiles) this._tiles[t].coords.z !== this._tileZoom && ((e = this._tiles[t].el).onload = u, e.onerror = u, e.complete || (e.src = Kt, F(e), delete this._tiles[t])) }, _removeTile: function (t) { var e = this._tiles[t]; if (e) return xe || e.el.setAttribute("src", Kt), ji.prototype._removeTile.call(this, t) }, _tileReady: function (t, e, i) { if (this._map && (!i || i.getAttribute("src") !== Kt)) return ji.prototype._tileReady.call(this, t, e, i) } }), Hi = Wi.extend({ defaultWmsParams: { service: "WMS", request: "GetMap", layers: "", styles: "", format: "image/jpeg", transparent: !1, version: "1.1.1" }, options: { crs: null, uppercase: !1 }, initialize: function (t, e) { this._url = t; var i, n = h({}, this.defaultWmsParams); for (i in e) i in this.options || (n[i] = e[i]); var o = (e = s(this, e)).detectRetina && Ne ? 2 : 1, t = this.getTileSize(); n.width = t.x * o, n.height = t.y * o, this.wmsParams = n }, onAdd: function (t) { this._crs = this.options.crs || t.options.crs, this._wmsVersion = parseFloat(this.wmsParams.version); var e = 1.3 <= this._wmsVersion ? "crs" : "srs"; this.wmsParams[e] = this._crs.code, Wi.prototype.onAdd.call(this, t) }, getTileUrl: function (t) { var e = this._tileCoordsToNwSe(t), i = this._crs, i = P(i.project(e[0]), i.project(e[1])), e = i.min, i = i.max, i = (1.3 <= this._wmsVersion && this._crs === xi ? [e.y, e.x, i.y, i.x] : [e.x, e.y, i.x, i.y]).join(","), t = Wi.prototype.getTileUrl.call(this, t); return t + r(this.wmsParams, t, this.options.uppercase) + (this.options.uppercase ? "&BBOX=" : "&bbox=") + i }, setParams: function (t, e) { return h(this.wmsParams, t), e || this.redraw(), this } }); Wi.WMS = Hi, jt.wms = function (t, e) { return new Hi(t, e) }; var Fi = wi.extend({ options: { padding: .1, tolerance: 0 }, initialize: function (t) { s(this, t), a(this), this._layers = this._layers || {} }, onAdd: function () { this._container || (this._initContainer(), this._zoomAnimated && K(this._container, "leaflet-zoom-animated")), this.getPane().appendChild(this._container), this._update(), this.on("update", this._updatePaths, this) }, onRemove: function () { this.off("update", this._updatePaths, this), this._destroyContainer() }, getEvents: function () { var t = { viewreset: this._reset, zoom: this._onZoom, moveend: this._update, zoomend: this._onZoomEnd }; return this._zoomAnimated && (t.zoomanim = this._onAnimZoom), t }, _onAnimZoom: function (t) { this._updateTransform(t.center, t.zoom) }, _onZoom: function () { this._updateTransform(this._map.getCenter(), this._map.getZoom()) }, _updateTransform: function (t, e) { var i = this._map.getZoomScale(e, this._zoom), n = it(this._container), o = this._map.getSize().multiplyBy(.5 + this.options.padding), s = this._map.project(this._center, e), s = this._map.project(t, e).subtract(s), s = o.multiplyBy(-i).add(n).add(o).subtract(s); Ee ? tt(this._container, s, i) : et(this._container, s) }, _reset: function () { for (var t in this._update(), this._updateTransform(this._center, this._zoom), this._layers) this._layers[t]._reset() }, _onZoomEnd: function () { for (var t in this._layers) this._layers[t]._project() }, _updatePaths: function () { for (var t in this._layers) this._layers[t]._update() }, _update: function () { var t = this.options.padding, e = this._map.getSize(), i = this._map.containerPointToLayerPoint(e.multiplyBy(-t)).round(); this._bounds = new w(i, i.add(e.multiplyBy(1 + 2 * t)).round()), this._center = this._map.getCenter(), this._zoom = this._map.getZoom() } }), Ui = Fi.extend({ getEvents: function () { var t = Fi.prototype.getEvents.call(this); return t.viewprereset = this._onViewPreReset, t }, _onViewPreReset: function () { this._postponeUpdatePaths = !0 }, onAdd: function () { Fi.prototype.onAdd.call(this), this._draw() }, _initContainer: function () { var t = this._container = document.createElement("canvas"); ut(t, "mousemove", e(this._onMouseMove, 32, this), this), ut(t, "click dblclick mousedown mouseup contextmenu", this._onClick, this), ut(t, "mouseout", this._handleMouseOut, this), this._ctx = t.getContext("2d") }, _destroyContainer: function () { f(this._redrawRequest), delete this._ctx, F(this._container), lt(this._container), delete this._container }, _updatePaths: function () { if (!this._postponeUpdatePaths) { for (var t in this._redrawBounds = null, this._layers) this._layers[t]._update(); this._redraw() } }, _update: function () { var t, e, i, n; this._map._animatingZoom && this._bounds || (this._drawnLayers = {}, Fi.prototype._update.call(this), t = this._bounds, e = this._container, i = t.getSize(), n = Ne ? 2 : 1, et(e, t.min), e.width = n * i.x, e.height = n * i.y, e.style.width = i.x + "px", e.style.height = i.y + "px", Ne && this._ctx.scale(2, 2), this._ctx.translate(-t.min.x, -t.min.y), this.fire("update")) }, _reset: function () { Fi.prototype._reset.call(this), this._postponeUpdatePaths && (this._postponeUpdatePaths = !1, this._updatePaths()) }, _initPath: function (t) { this._updateDashArray(t); t = (this._layers[a(t)] = t)._order = { layer: t, prev: this._drawLast, next: null }; this._drawLast && (this._drawLast.next = t), this._drawLast = t, this._drawFirst = this._drawFirst || this._drawLast }, _addPath: function (t) { this._requestRedraw(t) }, _removePath: function (t) { var e = t._order, i = e.next, e = e.prev; i ? i.prev = e : this._drawLast = e, e ? e.next = i : this._drawFirst = i, delete this._drawnLayers[t._leaflet_id], delete t._order, delete this._layers[a(t)], this._requestRedraw(t) }, _updatePath: function (t) { this._extendRedrawBounds(t), t._project(), t._update(), this._requestRedraw(t) }, _updateStyle: function (t) { this._updateDashArray(t), this._requestRedraw(t) }, _updateDashArray: function (t) { if ("string" == typeof t.options.dashArray) { for (var e = t.options.dashArray.split(/[, ]+/), i = [], n = 0; n < e.length; n++)i.push(Number(e[n])); t.options._dashArray = i } else t.options._dashArray = t.options.dashArray }, _requestRedraw: function (t) { this._map && (this._extendRedrawBounds(t), this._redrawRequest = this._redrawRequest || x(this._redraw, this)) }, _extendRedrawBounds: function (t) { var e; t._pxBounds && (e = (t.options.weight || 0) + 1, this._redrawBounds = this._redrawBounds || new w, this._redrawBounds.extend(t._pxBounds.min.subtract([e, e])), this._redrawBounds.extend(t._pxBounds.max.add([e, e]))) }, _redraw: function () { this._redrawRequest = null, this._redrawBounds && (this._redrawBounds.min._floor(), this._redrawBounds.max._ceil()), this._clear(), this._draw(), this._redrawBounds = null }, _clear: function () { var t, e = this._redrawBounds; e ? (t = e.getSize(), this._ctx.clearRect(e.min.x, e.min.y, t.x, t.y)) : this._ctx.clearRect(0, 0, this._container.width, this._container.height) }, _draw: function () { var t, e, i = this._redrawBounds; this._ctx.save(), i && (e = i.getSize(), this._ctx.beginPath(), this._ctx.rect(i.min.x, i.min.y, e.x, e.y), this._ctx.clip()), this._drawing = !0; for (var n = this._drawFirst; n; n = n.next)t = n.layer, (!i || t._pxBounds && t._pxBounds.intersects(i)) && t._updatePath(); this._drawing = !1, this._ctx.restore() }, _updatePoly: function (t, e) { if (this._drawing) { var i, n, o, s, r = t._parts, a = r.length, h = this._ctx; if (a) { for (this._drawnLayers[t._leaflet_id] = t, h.beginPath(), i = 0; i < a; i++) { for (n = 0, o = r[i].length; n < o; n++)s = r[i][n], h[n ? "lineTo" : "moveTo"](s.x, s.y); e && h.closePath() } this._fillStroke(h, t) } } }, _updateCircle: function (t) { var e, i, n, o; this._drawing && !t._empty() && (e = t._point, i = this._ctx, n = Math.max(Math.round(t._radius), 1), o = (Math.max(Math.round(t._radiusY), 1) || n) / n, this._drawnLayers[t._leaflet_id] = t, 1 != o && (i.save(), i.scale(1, o)), i.beginPath(), i.arc(e.x, e.y / o, n, 0, 2 * Math.PI, !1), 1 != o && i.restore(), this._fillStroke(i, t)) }, _fillStroke: function (t, e) { var i = e.options; i.fill && (t.globalAlpha = i.fillOpacity, t.fillStyle = i.fillColor || i.color, t.fill(i.fillRule || "evenodd")), i.stroke && 0 !== i.weight && (t.setLineDash && t.setLineDash(e.options && e.options._dashArray || []), t.globalAlpha = i.opacity, t.lineWidth = i.weight, t.strokeStyle = i.color, t.lineCap = i.lineCap, t.lineJoin = i.lineJoin, t.stroke()) }, _onClick: function (t) { for (var e, i, n = this._map.mouseEventToLayerPoint(t), o = this._drawFirst; o; o = o.next)(e = o.layer).options.interactive && e._containsPoint(n) && !this._map._draggableMoved(e) && (i = e); i && (xt(t), this._fireEvent([i], t)) }, _onMouseMove: function (t) { var e; !this._map || this._map.dragging.moving() || this._map._animatingZoom || (e = this._map.mouseEventToLayerPoint(t), this._handleMouseHover(t, e)) }, _handleMouseOut: function (t) { var e = this._hoveredLayer; e && (Y(this._container, "leaflet-interactive"), this._fireEvent([e], t, "mouseout"), this._hoveredLayer = null) }, _handleMouseHover: function (t, e) { for (var i, n, o = this._drawFirst; o; o = o.next)(i = o.layer).options.interactive && i._containsPoint(e) && (n = i); n !== this._hoveredLayer && (this._handleMouseOut(t), n && (K(this._container, "leaflet-interactive"), this._fireEvent([n], t, "mouseover"), this._hoveredLayer = n)), this._hoveredLayer && this._fireEvent([this._hoveredLayer], t) }, _fireEvent: function (t, e, i) { this._map._fireDOMEvent(e, i || e.type, t) }, _bringToFront: function (t) { var e = t._order, i = e.next, n = e.prev; i && ((i.prev = n) ? n.next = i : i && (this._drawFirst = i), e.prev = this._drawLast, (this._drawLast.next = e).next = null, this._drawLast = e, this._requestRedraw(t)) }, _bringToBack: function (t) { var e = t._order, i = e.next, n = e.prev; n && ((n.next = i) ? i.prev = n : n && (this._drawLast = n), e.prev = null, e.next = this._drawFirst, this._drawFirst.prev = e, this._drawFirst = e, this._requestRedraw(t)) } }), Vi = function () { try { return document.namespaces.add("lvml", "urn:schemas-microsoft-com:vml"), function (t) { return document.createElement("<lvml:" + t + ' class="lvml">') } } catch (t) { return function (t) { return document.createElement("<" + t + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">') } } }(), _e = { _initContainer: function () { this._container = H("div", "leaflet-vml-container") }, _update: function () { this._map._animatingZoom || (Fi.prototype._update.call(this), this.fire("update")) }, _initPath: function (t) { var e = t._container = Vi("shape"); K(e, "leaflet-vml-shape " + (this.options.className || "")), e.coordsize = "1 1", t._path = Vi("path"), e.appendChild(t._path), this._updateStyle(t), this._layers[a(t)] = t }, _addPath: function (t) { var e = t._container; this._container.appendChild(e), t.options.interactive && t.addInteractiveTarget(e) }, _removePath: function (t) { var e = t._container; F(e), t.removeInteractiveTarget(e), delete this._layers[a(t)] }, _updateStyle: function (t) { var e = t._stroke, i = t._fill, n = t.options, o = t._container; o.stroked = !!n.stroke, o.filled = !!n.fill, n.stroke ? (e = e || (t._stroke = Vi("stroke")), o.appendChild(e), e.weight = n.weight + "px", e.color = n.color, e.opacity = n.opacity, n.dashArray ? e.dashStyle = Gt(n.dashArray) ? n.dashArray.join(" ") : n.dashArray.replace(/( *, *)/g, " ") : e.dashStyle = "", e.endcap = n.lineCap.replace("butt", "flat"), e.joinstyle = n.lineJoin) : e && (o.removeChild(e), t._stroke = null), n.fill ? (i = i || (t._fill = Vi("fill")), o.appendChild(i), i.color = n.fillColor || n.color, i.opacity = n.fillOpacity) : i && (o.removeChild(i), t._fill = null) }, _updateCircle: function (t) { var e = t._point.round(), i = Math.round(t._radius), n = Math.round(t._radiusY || i); this._setPath(t, t._empty() ? "M0 0" : "AL " + e.x + "," + e.y + " " + i + "," + n + " 0,23592600") }, _setPath: function (t, e) { t._path.v = e }, _bringToFront: function (t) { V(t._container) }, _bringToBack: function (t) { q(t._container) } }, qi = We ? Vi : Z, Gi = Fi.extend({ getEvents: function () { var t = Fi.prototype.getEvents.call(this); return t.zoomstart = this._onZoomStart, t }, _initContainer: function () { this._container = qi("svg"), this._container.setAttribute("pointer-events", "none"), this._rootGroup = qi("g"), this._container.appendChild(this._rootGroup) }, _destroyContainer: function () { F(this._container), lt(this._container), delete this._container, delete this._rootGroup, delete this._svgSize }, _onZoomStart: function () { this._update() }, _update: function () { var t, e, i; this._map._animatingZoom && this._bounds || (Fi.prototype._update.call(this), e = (t = this._bounds).getSize(), i = this._container, this._svgSize && this._svgSize.equals(e) || (this._svgSize = e, i.setAttribute("width", e.x), i.setAttribute("height", e.y)), et(i, t.min), i.setAttribute("viewBox", [t.min.x, t.min.y, e.x, e.y].join(" ")), this.fire("update")) }, _initPath: function (t) { var e = t._path = qi("path"); t.options.className && K(e, t.options.className), t.options.interactive && K(e, "leaflet-interactive"), this._updateStyle(t), this._layers[a(t)] = t }, _addPath: function (t) { this._rootGroup || this._initContainer(), this._rootGroup.appendChild(t._path), t.addInteractiveTarget(t._path) }, _removePath: function (t) { F(t._path), t.removeInteractiveTarget(t._path), delete this._layers[a(t)] }, _updatePath: function (t) { t._project(), t._update() }, _updateStyle: function (t) { var e = t._path, t = t.options; e && (t.stroke ? (e.setAttribute("stroke", t.color), e.setAttribute("stroke-opacity", t.opacity), e.setAttribute("stroke-width", t.weight), e.setAttribute("stroke-linecap", t.lineCap), e.setAttribute("stroke-linejoin", t.lineJoin), t.dashArray ? e.setAttribute("stroke-dasharray", t.dashArray) : e.removeAttribute("stroke-dasharray"), t.dashOffset ? e.setAttribute("stroke-dashoffset", t.dashOffset) : e.removeAttribute("stroke-dashoffset")) : e.setAttribute("stroke", "none"), t.fill ? (e.setAttribute("fill", t.fillColor || t.color), e.setAttribute("fill-opacity", t.fillOpacity), e.setAttribute("fill-rule", t.fillRule || "evenodd")) : e.setAttribute("fill", "none")) }, _updatePoly: function (t, e) { this._setPath(t, E(t._parts, e)) }, _updateCircle: function (t) { var e = t._point, i = Math.max(Math.round(t._radius), 1), n = "a" + i + "," + (Math.max(Math.round(t._radiusY), 1) || i) + " 0 1,0 ", i = t._empty() ? "M0 0" : "M" + (e.x - i) + "," + e.y + n + 2 * i + ",0 " + n + 2 * -i + ",0 "; this._setPath(t, i) }, _setPath: function (t, e) { t._path.setAttribute("d", e) }, _bringToFront: function (t) { V(t._path) }, _bringToBack: function (t) { q(t._path) } }); We && Gi.include(_e), ui.include({ getRenderer: function (t) { t = (t = t.options.renderer || this._getPaneRenderer(t.options.pane) || this.options.renderer || this._renderer) || (this._renderer = this._createRenderer()); return this.hasLayer(t) || this.addLayer(t), t }, _getPaneRenderer: function (t) { if ("overlayPane" === t || void 0 === t) return !1; var e = this._paneRenderers[t]; return void 0 === e && (e = this._createRenderer({ pane: t }), this._paneRenderers[t] = e), e }, _createRenderer: function (t) { return this.options.preferCanvas && Wt(t) || Ht(t) } }); var Ki = ki.extend({ initialize: function (t, e) { ki.prototype.initialize.call(this, this._boundsToLatLngs(t), e) }, setBounds: function (t) { return this.setLatLngs(this._boundsToLatLngs(t)) }, _boundsToLatLngs: function (t) { return [(t = T(t)).getSouthWest(), t.getNorthWest(), t.getNorthEast(), t.getSouthEast()] } }); Gi.create = qi, Gi.pointsToPath = E, Ai.geometryToLayer = kt, Ai.coordsToLatLng = At, Ai.coordsToLatLngs = Bt, Ai.latLngToCoords = It, Ai.latLngsToCoords = Ot, Ai.getFeature = Rt, Ai.asFeature = Nt, ui.mergeOptions({ boxZoom: !0 }); te = Se.extend({ initialize: function (t) { this._map = t, this._container = t._container, this._pane = t._panes.overlayPane, this._resetStateTimeout = 0, t.on("unload", this._destroy, this) }, addHooks: function () { ut(this._container, "mousedown", this._onMouseDown, this) }, removeHooks: function () { lt(this._container, "mousedown", this._onMouseDown, this) }, moved: function () { return this._moved }, _destroy: function () { F(this._pane), delete this._pane }, _resetState: function () { this._resetStateTimeout = 0, this._moved = !1 }, _clearDeferredResetState: function () { 0 !== this._resetStateTimeout && (clearTimeout(this._resetStateTimeout), this._resetStateTimeout = 0) }, _onMouseDown: function (t) { if (!t.shiftKey || 1 !== t.which && 1 !== t.button) return !1; this._clearDeferredResetState(), this._resetState(), he(), nt(), this._startPoint = this._map.mouseEventToContainerPoint(t), ut(document, { contextmenu: gt, mousemove: this._onMouseMove, mouseup: this._onMouseUp, keydown: this._onKeyDown }, this) }, _onMouseMove: function (t) { this._moved || (this._moved = !0, this._box = H("div", "leaflet-zoom-box", this._container), K(this._container, "leaflet-crosshair"), this._map.fire("boxzoomstart")), this._point = this._map.mouseEventToContainerPoint(t); var e = new w(this._point, this._startPoint), t = e.getSize(); et(this._box, e.min), this._box.style.width = t.x + "px", this._box.style.height = t.y + "px" }, _finish: function () { this._moved && (F(this._box), Y(this._container, "leaflet-crosshair")), ue(), ot(), lt(document, { contextmenu: gt, mousemove: this._onMouseMove, mouseup: this._onMouseUp, keydown: this._onKeyDown }, this) }, _onMouseUp: function (t) { 1 !== t.which && 1 !== t.button || (this._finish(), !this._moved) || (this._clearDeferredResetState(), this._resetStateTimeout = setTimeout(_(this._resetState, this), 0), t = new b(this._map.containerPointToLatLng(this._startPoint), this._map.containerPointToLatLng(this._point)), this._map.fitBounds(t).fire("boxzoomend", { boxZoomBounds: t })) }, _onKeyDown: function (t) { 27 === t.keyCode && this._finish() } }); ui.addInitHook("addHandler", "boxZoom", te), ui.mergeOptions({ doubleClickZoom: !0 }); le = Se.extend({ addHooks: function () { this._map.on("dblclick", this._onDoubleClick, this) }, removeHooks: function () { this._map.off("dblclick", this._onDoubleClick, this) }, _onDoubleClick: function (t) { var e = this._map, i = e.getZoom(), n = e.options.zoomDelta, n = t.originalEvent.shiftKey ? i - n : i + n; "center" === e.options.doubleClickZoom ? e.setZoom(n) : e.setZoomAround(t.containerPoint, n) } }); ui.addInitHook("addHandler", "doubleClickZoom", le), ui.mergeOptions({ dragging: !0, inertia: !ve, inertiaDeceleration: 3400, inertiaMaxSpeed: 1 / 0, easeLinearity: .2, worldCopyJump: !1, maxBoundsViscosity: 0 }); ce = Se.extend({ addHooks: function () { var t; this._draggable || (t = this._map, this._draggable = new yi(t._mapPane, t._container), this._draggable.on({ dragstart: this._onDragStart, drag: this._onDrag, dragend: this._onDragEnd }, this), this._draggable.on("predrag", this._onPreDragLimit, this), t.options.worldCopyJump && (this._draggable.on("predrag", this._onPreDragWrap, this), t.on("zoomend", this._onZoomEnd, this), t.whenReady(this._onZoomEnd, this))), K(this._map._container, "leaflet-grab leaflet-touch-drag"), this._draggable.enable(), this._positions = [], this._times = [] }, removeHooks: function () { Y(this._map._container, "leaflet-grab"), Y(this._map._container, "leaflet-touch-drag"), this._draggable.disable() }, moved: function () { return this._draggable && this._draggable._moved }, moving: function () { return this._draggable && this._draggable._moving }, _onDragStart: function () { var t, e = this._map; e._stop(), this._map.options.maxBounds && this._map.options.maxBoundsViscosity ? (t = T(this._map.options.maxBounds), this._offsetLimit = P(this._map.latLngToContainerPoint(t.getNorthWest()).multiplyBy(-1), this._map.latLngToContainerPoint(t.getSouthEast()).multiplyBy(-1).add(this._map.getSize())), this._viscosity = Math.min(1, Math.max(0, this._map.options.maxBoundsViscosity))) : this._offsetLimit = null, e.fire("movestart").fire("dragstart"), e.options.inertia && (this._positions = [], this._times = []) }, _onDrag: function (t) { var e, i; this._map.options.inertia && (e = this._lastTime = +new Date, i = this._lastPos = this._draggable._absPos || this._draggable._newPos, this._positions.push(i), this._times.push(e), this._prunePositions(e)), this._map.fire("move", t).fire("drag", t) }, _prunePositions: function (t) { for (; 1 < this._positions.length && 50 < t - this._times[0];)this._positions.shift(), this._times.shift() }, _onZoomEnd: function () { var t = this._map.getSize().divideBy(2), e = this._map.latLngToLayerPoint([0, 0]); this._initialWorldOffset = e.subtract(t).x, this._worldWidth = this._map.getPixelWorldBounds().getSize().x }, _viscousLimit: function (t, e) { return t - (t - e) * this._viscosity }, _onPreDragLimit: function () { var t, e; this._viscosity && this._offsetLimit && (t = this._draggable._newPos.subtract(this._draggable._startPos), e = this._offsetLimit, t.x < e.min.x && (t.x = this._viscousLimit(t.x, e.min.x)), t.y < e.min.y && (t.y = this._viscousLimit(t.y, e.min.y)), t.x > e.max.x && (t.x = this._viscousLimit(t.x, e.max.x)), t.y > e.max.y && (t.y = this._viscousLimit(t.y, e.max.y)), this._draggable._newPos = this._draggable._startPos.add(t)) }, _onPreDragWrap: function () { var t = this._worldWidth, e = Math.round(t / 2), i = this._initialWorldOffset, n = this._draggable._newPos.x, o = (n - e + i) % t + e - i, e = (n + e + i) % t - e - i, e = Math.abs(o + i) < Math.abs(e + i) ? o : e; this._draggable._absPos = this._draggable._newPos.clone(), this._draggable._newPos.x = e }, _onDragEnd: function (t) { var e, i, n, o, s = this._map, r = s.options, a = !r.inertia || this._times.length < 2; s.fire("dragend", t), a ? s.fire("moveend") : (this._prunePositions(+new Date), i = this._lastPos.subtract(this._positions[0]), t = (this._lastTime - this._times[0]) / 1e3, e = r.easeLinearity, i = (a = i.multiplyBy(e / t)).distanceTo([0, 0]), t = Math.min(r.inertiaMaxSpeed, i), i = a.multiplyBy(t / i), n = t / (r.inertiaDeceleration * e), (o = i.multiplyBy(-n / 2).round()).x || o.y ? (o = s._limitOffset(o, s.options.maxBounds), x(function () { s.panBy(o, { duration: n, easeLinearity: e, noMoveStart: !0, animate: !0 }) })) : s.fire("moveend")) } }); ui.addInitHook("addHandler", "dragging", ce), ui.mergeOptions({ keyboard: !0, keyboardPanDelta: 80 }); se = Se.extend({ keyCodes: { left: [37], right: [39], down: [40], up: [38], zoomIn: [187, 107, 61, 171], zoomOut: [189, 109, 54, 173] }, initialize: function (t) { this._map = t, this._setPanDelta(t.options.keyboardPanDelta), this._setZoomDelta(t.options.zoomDelta) }, addHooks: function () { var t = this._map._container; t.tabIndex <= 0 && (t.tabIndex = "0"), ut(t, { focus: this._onFocus, blur: this._onBlur, mousedown: this._onMouseDown }, this), this._map.on({ focus: this._addHooks, blur: this._removeHooks }, this) }, removeHooks: function () { this._removeHooks(), lt(this._map._container, { focus: this._onFocus, blur: this._onBlur, mousedown: this._onMouseDown }, this), this._map.off({ focus: this._addHooks, blur: this._removeHooks }, this) }, _onMouseDown: function () { var t, e, i; this._focused || (t = document.body, i = document.documentElement, e = t.scrollTop || i.scrollTop, i = t.scrollLeft || i.scrollLeft, this._map._container.focus(), window.scrollTo(i, e)) }, _onFocus: function () { this._focused = !0, this._map.fire("focus") }, _onBlur: function () { this._focused = !1, this._map.fire("blur") }, _setPanDelta: function (t) { for (var e = this._panKeys = {}, i = this.keyCodes, n = 0, o = i.left.length; n < o; n++)e[i.left[n]] = [-1 * t, 0]; for (n = 0, o = i.right.length; n < o; n++)e[i.right[n]] = [t, 0]; for (n = 0, o = i.down.length; n < o; n++)e[i.down[n]] = [0, t]; for (n = 0, o = i.up.length; n < o; n++)e[i.up[n]] = [0, -1 * t] }, _setZoomDelta: function (t) { for (var e = this._zoomKeys = {}, i = this.keyCodes, n = 0, o = i.zoomIn.length; n < o; n++)e[i.zoomIn[n]] = t; for (n = 0, o = i.zoomOut.length; n < o; n++)e[i.zoomOut[n]] = -t }, _addHooks: function () { ut(document, "keydown", this._onKeyDown, this) }, _removeHooks: function () { lt(document, "keydown", this._onKeyDown, this) }, _onKeyDown: function (t) { if (!(t.altKey || t.ctrlKey || t.metaKey)) { var e, i = t.keyCode, n = this._map; if (i in this._panKeys) n._panAnim && n._panAnim._inProgress || (e = this._panKeys[i], t.shiftKey && (e = y(e).multiplyBy(3)), n.panBy(e), n.options.maxBounds && n.panInsideBounds(n.options.maxBounds)); else if (i in this._zoomKeys) n.setZoom(n.getZoom() + (t.shiftKey ? 3 : 1) * this._zoomKeys[i]); else { if (27 !== i || !n._popup || !n._popup.options.closeOnEscapeKey) return; n.closePopup() } gt(t) } } }); ui.addInitHook("addHandler", "keyboard", se), ui.mergeOptions({ scrollWheelZoom: !0, wheelDebounceTime: 40, wheelPxPerZoomLevel: 60 }); ye = Se.extend({ addHooks: function () { ut(this._map._container, "mousewheel", this._onWheelScroll, this), this._delta = 0 }, removeHooks: function () { lt(this._map._container, "mousewheel", this._onWheelScroll, this) }, _onWheelScroll: function (t) { var e = yt(t), i = this._map.options.wheelDebounceTime; this._delta += e, this._lastMousePos = this._map.mouseEventToContainerPoint(t), this._startTime || (this._startTime = +new Date); i = Math.max(i - (+new Date - this._startTime), 0); clearTimeout(this._timer), this._timer = setTimeout(_(this._performZoom, this), i), gt(t) }, _performZoom: function () { var t = this._map, e = t.getZoom(), i = this._map.options.zoomSnap || 0; t._stop(); var n = this._delta / (4 * this._map.options.wheelPxPerZoomLevel), n = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(n)))) / Math.LN2, n = i ? Math.ceil(n / i) * i : n, n = t._limitZoom(e + (0 < this._delta ? n : -n)) - e; this._delta = 0, this._startTime = null, n && ("center" === t.options.scrollWheelZoom ? t.setZoom(e + n) : t.setZoomAround(this._lastMousePos, e + n)) } }); ui.addInitHook("addHandler", "scrollWheelZoom", ye), ui.mergeOptions({ tap: !0, tapTolerance: 15 }); ke = Se.extend({ addHooks: function () { ut(this._map._container, "touchstart", this._onDown, this) }, removeHooks: function () { lt(this._map._container, "touchstart", this._onDown, this) }, _onDown: function (t) { if (t.touches) { if (ft(t), this._fireClick = !0, 1 < t.touches.length) return this._fireClick = !1, void clearTimeout(this._holdTimeout); var e = t.touches[0], t = e.target; this._startPos = this._newPos = new v(e.clientX, e.clientY), t.tagName && "a" === t.tagName.toLowerCase() && K(t, "leaflet-active"), this._holdTimeout = setTimeout(_(function () { this._isTapValid() && (this._fireClick = !1, this._onUp(), this._simulateEvent("contextmenu", e)) }, this), 1e3), this._simulateEvent("mousedown", e), ut(document, { touchmove: this._onMove, touchend: this._onUp }, this) } }, _onUp: function (t) { var e; clearTimeout(this._holdTimeout), lt(document, { touchmove: this._onMove, touchend: this._onUp }, this), this._fireClick && t && t.changedTouches && ((t = (e = t.changedTouches[0]).target) && t.tagName && "a" === t.tagName.toLowerCase() && Y(t, "leaflet-active"), this._simulateEvent("mouseup", e), this._isTapValid() && this._simulateEvent("click", e)) }, _isTapValid: function () { return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance }, _onMove: function (t) { t = t.touches[0]; this._newPos = new v(t.clientX, t.clientY), this._simulateEvent("mousemove", t) }, _simulateEvent: function (t, e) { var i = document.createEvent("MouseEvents"); i._simulated = !0, e.target._simulatedClick = !0, i.initMouseEvent(t, !0, !0, window, 1, e.screenX, e.screenY, e.clientX, e.clientY, !1, !1, !1, !1, 0, null), e.target.dispatchEvent(i) } }); Oe && !Ie && ui.addInitHook("addHandler", "tap", ke), ui.mergeOptions({ touchZoom: Oe && !ve, bounceAtZoomLimits: !0 }); _e = Se.extend({ addHooks: function () { K(this._map._container, "leaflet-touch-zoom"), ut(this._map._container, "touchstart", this._onTouchStart, this) }, removeHooks: function () { Y(this._map._container, "leaflet-touch-zoom"), lt(this._map._container, "touchstart", this._onTouchStart, this) }, _onTouchStart: function (t) { var e, i, n = this._map; !t.touches || 2 !== t.touches.length || n._animatingZoom || this._zooming || (e = n.mouseEventToContainerPoint(t.touches[0]), i = n.mouseEventToContainerPoint(t.touches[1]), this._centerPoint = n.getSize()._divideBy(2), this._startLatLng = n.containerPointToLatLng(this._centerPoint), "center" !== n.options.touchZoom && (this._pinchStartLatLng = n.containerPointToLatLng(e.add(i)._divideBy(2))), this._startDist = e.distanceTo(i), this._startZoom = n.getZoom(), this._moved = !1, this._zooming = !0, n._stop(), ut(document, "touchmove", this._onTouchMove, this), ut(document, "touchend", this._onTouchEnd, this), ft(t)) }, _onTouchMove: function (t) { if (t.touches && 2 === t.touches.length && this._zooming) { var e = this._map, i = e.mouseEventToContainerPoint(t.touches[0]), n = e.mouseEventToContainerPoint(t.touches[1]), o = i.distanceTo(n) / this._startDist; if (this._zoom = e.getScaleZoom(o, this._startZoom), !e.options.bounceAtZoomLimits && (this._zoom < e.getMinZoom() && o < 1 || this._zoom > e.getMaxZoom() && 1 < o) && (this._zoom = e._limitZoom(this._zoom)), "center" === e.options.touchZoom) { if (this._center = this._startLatLng, 1 == o) return } else { n = i._add(n)._divideBy(2)._subtract(this._centerPoint); if (1 == o && 0 === n.x && 0 === n.y) return; this._center = e.unproject(e.project(this._pinchStartLatLng, this._zoom).subtract(n), this._zoom) } this._moved || (e._moveStart(!0, !1), this._moved = !0), f(this._animRequest); e = _(e._move, e, this._center, this._zoom, { pinch: !0, round: !1 }); this._animRequest = x(e, this, !0), ft(t) } }, _onTouchEnd: function () { this._moved && this._zooming ? (this._zooming = !1, f(this._animRequest), lt(document, "touchmove", this._onTouchMove), lt(document, "touchend", this._onTouchEnd), this._map.options.zoomAnimation ? this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), !0, this._map.options.zoomSnap) : this._map._resetView(this._center, this._map._limitZoom(this._zoom))) : this._zooming = !1 } }); ui.addInitHook("addHandler", "touchZoom", _e), ui.BoxZoom = te, ui.DoubleClickZoom = le, ui.Drag = ce, ui.Keyboard = se, ui.ScrollWheelZoom = ye, ui.Tap = ke, ui.TouchZoom = _e, Object.freeze = Ft, t.version = "1.3.4+HEAD.0e566b2", t.Control = li, t.control = ze, t.Browser = fe, t.Evented = ee, t.Mixin = Ze, t.Util = $t, t.Class = g, t.Handler = Se, t.extend = h, t.bind = _, t.stamp = a, t.setOptions = s, t.DomEvent = Te, t.DomUtil = we, t.PosAnimation = hi, t.Draggable = yi, t.LineUtil = Ae, t.PolyUtil = Be, t.Point = v, t.point = y, t.Bounds = w, t.bounds = P, t.Transformation = C, t.transformation = S, t.Projection = Me, t.LatLng = z, t.latLng = M, t.LatLngBounds = b, t.latLngBounds = T, t.CRS = ne, t.GeoJSON = Ai, t.geoJSON = Dt, t.geoJson = Le, t.Layer = wi, t.LayerGroup = Pi, t.layerGroup = function (t, e) { return new Pi(t, e) }, t.FeatureGroup = Li, t.featureGroup = function (t) { return new Li(t) }, t.ImageOverlay = Bi, t.imageOverlay = function (t, e, i) { return new Bi(t, e, i) }, t.VideoOverlay = Ii, t.videoOverlay = function (t, e, i) { return new Ii(t, e, i) }, t.DivOverlay = Oi, t.Popup = Ri, t.popup = function (t, e) { return new Ri(t, e) }, t.Tooltip = Ni, t.tooltip = function (t, e) { return new Ni(t, e) }, t.Icon = bi, t.icon = function (t) { return new bi(t) }, t.DivIcon = Di, t.divIcon = function (t) { return new Di(t) }, t.Marker = Mi, t.marker = function (t, e) { return new Mi(t, e) }, t.TileLayer = Wi, t.tileLayer = jt, t.GridLayer = ji, t.gridLayer = function (t) { return new ji(t) }, t.SVG = Gi, t.svg = Ht, t.Renderer = Fi, t.Canvas = Ui, t.canvas = Wt, t.Path = Ci, t.CircleMarker = Si, t.circleMarker = function (t, e) { return new Si(t, e) }, t.Circle = Zi, t.circle = function (t, e, i) { return new Zi(t, e, i) }, t.Polyline = Ei, t.polyline = function (t, e) { return new Ei(t, e) }, t.Polygon = ki, t.polygon = function (t, e) { return new ki(t, e) }, t.Rectangle = Ki, t.rectangle = function (t, e) { return new Ki(t, e) }, t.Map = ui, t.map = function (t, e) { return new ui(t, e) }; var Yi = window.L; t.noConflict = function () { return window.L = Yi, this }, window.L = t });

L.KML = L.FeatureGroup.extend({ options: { async: !0 }, initialize: function (e, t) { L.Util.setOptions(this, t), this._kml = e, this._layers = {}, e && this.addKML(e, t, this.options.async) }, loadXML: function (e, t, n, o) { void 0 === o && (o = this.options.async), void 0 === n && (n = this.options); var r = new window.XMLHttpRequest; if (void 0 === r.withCredentials && void 0 !== window.XDomainRequest) { var a = new window.XDomainRequest; a.open("GET", e, o), a.onprogress = function () { }, a.ontimeout = function () { }, a.onerror = function () { }, a.onload = function () { var e; a.responseText && ((e = new window.ActiveXObject("Microsoft.XMLDOM")).loadXML(a.responseText), t(e, n)) }, setTimeout(function () { a.send() }, 0) } else { r.open("GET", e, o), r.setRequestHeader("Accept", "application/vnd.google-earth.kml+xml"); try { r.overrideMimeType("text/xml") } catch (e) { } r.onreadystatechange = function () { 4 === r.readyState && 200 === r.status && t(r.responseXML, n) }, r.send(null) } }, addKML: function (e, t, n) { var o = this; this.loadXML(e, function (e) { o._addKML(e) }, t, n) }, _addKML: function (e) { var t = L.KML.parseKML(e); if (t && t.length) { for (var n = 0; n < t.length; n++)this.fire("addlayer", { layer: t[n] }), this.addLayer(t[n]); this.latLngs = L.KML.getLatLngs(e), this.fire("loaded") } }, latLngs: [] }), L.Util.extend(L.KML, { parseKML: function (e) { var t = this.parseStyles(e); this.parseStyleMap(e, t); for (var n, o = e.getElementsByTagName("Folder"), r = [], a = 0; a < o.length; a++)this._check_folder(o[a]) && (n = this.parseFolder(o[a], t)) && r.push(n); o = e.getElementsByTagName("Placemark"); for (var s = 0; s < o.length; s++)this._check_folder(o[s]) && (n = this.parsePlacemark(o[s], e, t)) && r.push(n); o = e.getElementsByTagName("GroundOverlay"); for (var i = 0; i < o.length; i++)(n = this.parseGroundOverlay(o[i])) && r.push(n); return r }, _check_folder: function (e, t) { for (e = e.parentNode; e && "Folder" !== e.tagName;)e = e.parentNode; return !e || e === t }, parseStyles: function (e) { for (var t = {}, n = e.getElementsByTagName("Style"), o = 0, r = n.length; o < r; o++) { var a = this.parseStyle(n[o]); a && (t["#" + a.id] = a) } return t }, parseStyle: function (e) { var t, n = {}, o = {}, i = {}, l = { color: !0, width: !0, Icon: !0, href: !0, hotSpot: !0 }; function h(e) { for (var t = {}, n = 0; n < e.childNodes.length; n++) { var o = e.childNodes[n], r = o.tagName; if (l[r]) if ("hotSpot" === r) for (var a = 0; a < o.attributes.length; a++)t[o.attributes[a].name] = o.attributes[a].nodeValue; else { var s = o.childNodes[0].nodeValue; "color" === r ? (t.opacity = parseInt(s.substring(0, 2), 16) / 255, t.color = "#" + s.substring(6, 8) + s.substring(4, 6) + s.substring(2, 4)) : "width" === r ? t.weight = s : "Icon" === r ? (i = h(o)).href && (t.href = i.href) : "href" === r && (t.href = s) } } return t } return (t = e.getElementsByTagName("LineStyle")) && t[0] && (n = h(t[0])), (t = e.getElementsByTagName("PolyStyle")) && t[0] && (o = h(t[0])), o.color && (n.fillColor = o.color), o.opacity && (n.fillOpacity = o.opacity), (t = e.getElementsByTagName("IconStyle")) && t[0] && (i = h(t[0])), i.href && (n.icon = new L.KMLIcon({ iconUrl: i.href, shadowUrl: null, anchorRef: { x: i.x, y: i.y }, anchorType: { x: i.xunits, y: i.yunits } })), (e = e.getAttribute("id")) && n && (n.id = e), n }, parseStyleMap: function (e, t) { for (var n = e.getElementsByTagName("StyleMap"), o = 0; o < n.length; o++) { var r, a, s = n[o], i = s.getElementsByTagName("key"); i && i[0] && (r = i[0].textContent), (i = s.getElementsByTagName("styleUrl")) && i[0] && (a = i[0].textContent), "normal" === r && (t["#" + s.getAttribute("id")] = t[a]) } }, parseFolder: function (e, t) { for (var n, o = [], r = e.getElementsByTagName("Folder"), a = 0; a < r.length; a++)this._check_folder(r[a], e) && (n = this.parseFolder(r[a], t)) && o.push(n); r = e.getElementsByTagName("Placemark"); for (var s = 0; s < r.length; s++)this._check_folder(r[s], e) && (n = this.parsePlacemark(r[s], e, t)) && o.push(n); r = e.getElementsByTagName("GroundOverlay"); for (var i = 0; i < r.length; i++)this._check_folder(r[i], e) && (n = this.parseGroundOverlay(r[i])) && o.push(n); if (o.length) return 1 === o.length ? o[0] : new L.FeatureGroup(o) }, parsePlacemark: function (e, t, n, o) { var r, a, s, i = o || {}; for (p = e.getElementsByTagName("styleUrl"), y = 0; y < p.length; y++) { var l, h = p[y].childNodes[0].nodeValue; for (l in n[h]) i[l] = n[h][l] } if (e.getElementsByTagName("Style")[0]) { var g = this.parseStyle(e); if (g) for (s in g) i[s] = g[s] } var c = ["MultiGeometry", "MultiTrack", "gx:MultiTrack"]; for (r in c) if ((y = 0) < (p = e.getElementsByTagName(c[r])).length) return this.parsePlacemark(p[y], t, n, i); var d = [], u = ["LineString", "Polygon", "Point", "Track", "gx:Track"]; for (a in u) for (var f = u[a], p = e.getElementsByTagName(f), y = 0; y < p.length; y++) { var m = this["parse" + f.replace(/gx:/, "")](p[y], t, i); m && d.push(m) } if (d.length) { var v = d[0]; 1 < d.length && (v = new L.FeatureGroup(d)); var N, T = ""; for ((p = e.getElementsByTagName("name")).length && p[0].childNodes.length && (N = p[0].childNodes[0].nodeValue), p = e.getElementsByTagName("description"), y = 0; y < p.length; y++)for (a = 0; a < p[y].childNodes.length; a++)T += p[y].childNodes[a].nodeValue; return N && v.on("add", function () { v.bindPopup("<h2>" + N + "</h2>" + T) }), v } }, parseCoords: function (e) { e = e.getElementsByTagName("coordinates"); return this._read_coords(e[0]) }, parseLineString: function (e, t, n) { e = this.parseCoords(e); if (e.length) return new L.Polyline(e, n) }, parseTrack: function (e, t, n) { var o = t.getElementsByTagName("gx:coord"); 0 === o.length && (o = t.getElementsByTagName("coord")); for (var r = [], a = 0; a < o.length; a++)r = r.concat(this._read_gxcoords(o[a])); if (r.length) return new L.Polyline(r, n) }, parsePoint: function (e, t, n) { e = e.getElementsByTagName("coordinates"); if (e.length) { e = e[0].childNodes[0].nodeValue.split(","); return new L.KMLMarker(new L.LatLng(e[1], e[0]), n) } }, parsePolygon: function (e, t, n) { for (var o, r = [], a = [], s = e.getElementsByTagName("outerBoundaryIs"), i = 0; i < s.length; i++)(o = this.parseCoords(s[i])) && r.push(o); for (s = e.getElementsByTagName("innerBoundaryIs"), i = 0; i < s.length; i++)(o = this.parseCoords(s[i])) && a.push(o); if (r.length) return n.fillColor && (n.fill = !0), 1 === r.length ? new L.Polygon(r.concat(a), n) : new L.MultiPolygon(r, n) }, getLatLngs: function (e) { for (var t = e.getElementsByTagName("coordinates"), n = [], o = 0; o < t.length; o++)n = n.concat(this._read_coords(t[o])); return n }, _read_coords: function (e) { for (var t = "", n = [], o = 0; o < e.childNodes.length; o++)t += e.childNodes[o].nodeValue; for (t = t.split(/[\s\n]+/), o = 0; o < t.length; o++) { var r = t[o].split(","); r.length < 2 || n.push(new L.LatLng(r[1], r[0])) } return n }, _read_gxcoords: function (e) { var t = [], n = e.firstChild.nodeValue.split(" "); return t.push(new L.LatLng(n[1], n[0])), t }, parseGroundOverlay: function (e) { var t = e.getElementsByTagName("LatLonBox")[0], n = new L.LatLngBounds([t.getElementsByTagName("south")[0].childNodes[0].nodeValue, t.getElementsByTagName("west")[0].childNodes[0].nodeValue], [t.getElementsByTagName("north")[0].childNodes[0].nodeValue, t.getElementsByTagName("east")[0].childNodes[0].nodeValue]), i = { Icon: !0, href: !0, color: !0 }; var o = {}, o = function e(t) { for (var n = {}, o = 0; o < t.childNodes.length; o++) { var r, a = t.childNodes[o], s = a.tagName; i[s] && (r = a.childNodes[0].nodeValue, "Icon" === s ? (a = e(a)).href && (n.href = a.href) : "href" === s ? n.href = r : "color" === s && (n.opacity = parseInt(r.substring(0, 2), 16) / 255, n.color = "#" + r.substring(6, 8) + r.substring(4, 6) + r.substring(2, 4))) } return n }(e); return void 0 !== t.getElementsByTagName("rotation")[0] && (t = t.getElementsByTagName("rotation")[0].childNodes[0].nodeValue, o.rotation = parseFloat(t)), new L.RotatedImageOverlay(o.href, n, { opacity: o.opacity, angle: o.rotation }) } }), L.KMLIcon = L.Icon.extend({ _setIconStyles: function (e, t) { L.Icon.prototype._setIconStyles.apply(this, [e, t]); t = this.options; this.options.popupAnchor = [0, -.83 * e.height], "fraction" === t.anchorType.x && (e.style.marginLeft = -t.anchorRef.x * e.width + "px"), "fraction" === t.anchorType.y && (e.style.marginTop = -(1 - t.anchorRef.y) * e.height + 1 + "px"), "pixels" === t.anchorType.x && (e.style.marginLeft = -t.anchorRef.x + "px"), "pixels" === t.anchorType.y && (e.style.marginTop = t.anchorRef.y - e.height + 1 + "px") } }), L.KMLMarker = L.Marker.extend({ options: { icon: new L.KMLIcon.Default } }), L.RotatedImageOverlay = L.ImageOverlay.extend({ options: { angle: 0 }, _reset: function () { L.ImageOverlay.prototype._reset.call(this), this._rotate() }, _animateZoom: function (e) { L.ImageOverlay.prototype._animateZoom.call(this, e), this._rotate() }, _rotate: function () { var e, t; L.DomUtil.TRANSFORM ? this._image.style[L.DomUtil.TRANSFORM] += " rotate(" + this.options.angle + "deg)" : L.Browser.ie && (t = this.options.angle * (Math.PI / 180), e = Math.cos(t), t = Math.sin(t), this._image.style.filter += " progid:DXImageTransform.Microsoft.Matrix(sizingMethod='auto expand', M11=" + e + ", M12=" + -t + ", M21=" + t + ", M22=" + e + ")") }, getBounds: function () { return this._bounds } });

!function (t, o) { "function" == typeof define && define.amd ? define(["leaflet", "mapbox-gl"], o) : "object" == typeof exports ? module.exports = o(require("leaflet"), require("mapbox-gl")) : t.returnExports = o(window.L, window.mapboxgl) }(this, function (m, r) { m.MapboxGL = m.Layer.extend({ options: { updateInterval: 32 }, initialize: function (t) { if (m.setOptions(this, t), !t.accessToken) throw new Error("You should provide a Mapbox GL access token as a token option."); r.accessToken = t.accessToken; var o, i, n, a, e, s, h; this._throttledUpdate = (o = m.Util.bind(this._update, this), i = this.options.updateInterval, s = function () { a = !1, e && (h.apply(n, e), e = !1) }, h = function () { a ? e = arguments : (o.apply(n, arguments), setTimeout(s, i), a = !0) }) }, onAdd: function (t) { this._glContainer || this._initContainer(), this.getPane().appendChild(this._glContainer), this._initGL(), this._offset = this._map.containerPointToLayerPoint([0, 0]), t.options.zoomAnimation && m.DomEvent.on(t._proxy, m.DomUtil.TRANSITION_END, this._transitionEnd, this) }, onRemove: function (t) { this._map._proxy && this._map.options.zoomAnimation && m.DomEvent.off(this._map._proxy, m.DomUtil.TRANSITION_END, this._transitionEnd, this), this.getPane().removeChild(this._glContainer), this._glMap.remove(), this._glMap = null }, getEvents: function () { return { move: this._throttledUpdate, zoomanim: this._animateZoom, zoom: this._pinchZoom, zoomstart: this._zoomStart, zoomend: this._zoomEnd } }, _initContainer: function () { var t = this._glContainer = m.DomUtil.create("div", "leaflet-gl-layer"), o = this._map.getSize(); t.style.width = o.x + "px", t.style.height = o.y + "px" }, _initGL: function () { var t = this._map.getCenter(), t = m.extend({}, this.options, { container: this._glContainer, interactive: !1, center: [t.lng, t.lat], zoom: this._map.getZoom() - 1, attributionControl: !1 }); this._glMap = new r.Map(t), this._glMap.transform.latRange = null, this._glMap._canvas.canvas ? this._glMap._actualCanvas = this._glMap._canvas.canvas : this._glMap._actualCanvas = this._glMap._canvas, m.DomUtil.addClass(this._glMap._actualCanvas, "leaflet-image-layer"), m.DomUtil.addClass(this._glMap._actualCanvas, "leaflet-zoom-animated") }, _update: function (t) { var o, i, n, a, e; this._offset = this._map.containerPointToLayerPoint([0, 0]), this._zooming || (o = this._map.getSize(), i = this._glContainer, n = this._glMap, e = this._map.containerPointToLayerPoint([0, 0]), m.DomUtil.setPosition(i, e), a = this._map.getCenter(), (e = n.transform).center = r.LngLat.convert([a.lng, a.lat]), e.zoom = this._map.getZoom() - 1, n.transform.width !== o.x || n.transform.height !== o.y ? (i.style.width = o.x + "px", i.style.height = o.y + "px", null !== n._resize && void 0 !== n._resize ? n._resize() : n.resize()) : null !== n._update && void 0 !== n._update ? n._update() : n.update()) }, _pinchZoom: function (t) { this._glMap.jumpTo({ zoom: this._map.getZoom() - 1, center: this._map.getCenter() }) }, _animateZoom: function (t) { var o = this._map.getZoomScale(t.zoom), t = this._map._latLngToNewLayerPoint(this._map.getBounds().getNorthWest(), t.zoom, t.center); m.DomUtil.setTransform(this._glMap._actualCanvas, t.subtract(this._offset), o) }, _zoomStart: function (t) { this._zooming = !0 }, _zoomEnd: function () { var t = this._map.getZoomScale(this._map.getZoom()), o = this._map._latLngToNewLayerPoint(this._map.getBounds().getNorthWest(), this._map.getZoom(), this._map.getCenter()); m.DomUtil.setTransform(this._glMap._actualCanvas, o.subtract(this._offset), t), this._zooming = !1 }, _transitionEnd: function (t) { m.Util.requestAnimFrame(function () { var t = this._map.getZoom(), o = this._map.getCenter(), i = this._map.latLngToContainerPoint(this._map.getBounds().getNorthWest()); m.DomUtil.setTransform(this._glMap._actualCanvas, i, 1), this._glMap.once("moveend", m.Util.bind(function () { this._zoomEnd() }, this)), this._glMap.jumpTo({ center: o, zoom: t - 1 }) }, this) } }), m.mapboxGL = function (t) { return new m.MapboxGL(t) } });

!function (n) { "use strict"; L.AwesomeMarkers = {}, L.AwesomeMarkers.version = "2.0.1", L.AwesomeMarkers.Icon = L.Icon.extend({ options: { iconSize: [35, 45], iconAnchor: [17, 42], popupAnchor: [1, -32], shadowAnchor: [10, 12], shadowSize: [36, 16], className: "awesome-marker", prefix: "glyphicon", spinClass: "fa-spin", extraClasses: "", icon: "home", markerColor: "blue", iconColor: "white" }, initialize: function (o) { o = L.Util.setOptions(this, o) }, createIcon: function () { var o = n.createElement("div"), e = this.options; return e.icon && (o.innerHTML = this._createInner()), e.bgPos && (o.style.backgroundPosition = -e.bgPos.x + "px " + -e.bgPos.y + "px"), this._setIconStyles(o, "icon-" + e.markerColor), o }, _createInner: function () { var o = "", e = "", n = "", i = this.options, s = i.icon.slice(0, i.prefix.length + 1) === i.prefix + "-" ? i.icon : i.prefix + "-" + i.icon; return i.spin && "string" == typeof i.spinClass && (o = i.spinClass), i.iconColor && ("white" === i.iconColor || "black" === i.iconColor ? e = "icon-" + i.iconColor : n = "style='color: " + i.iconColor + "' "), "<i " + n + "class='" + i.extraClasses + " " + i.prefix + " " + s + " " + o + " " + e + "'></i>" }, _setIconStyles: function (o, e) { var n = this.options, i = L.point(n["shadow" === e ? "shadowSize" : "iconSize"]), s = "shadow" === e ? L.point(n.shadowAnchor || n.iconAnchor) : L.point(n.iconAnchor); !s && i && (s = i.divideBy(2, !0)), o.className = "awesome-marker-" + e + " " + n.className, s && (o.style.marginLeft = -s.x + "px", o.style.marginTop = -s.y + "px"), i && (o.style.width = i.x + "px", o.style.height = i.y + "px") }, createShadow: function () { var o = n.createElement("div"); return this._setIconStyles(o, "shadow"), o } }), L.AwesomeMarkers.icon = function (o) { return new L.AwesomeMarkers.Icon(o) } }(document);

function SalsaMap(t) { void 0 === t.map_canvas && (t.map_canvas = ""), void 0 === t.zoom && (t.zoom = 5), void 0 === t.center && (t.center = { latitude: 0, longitude: 0 }), void 0 === t.fit_bounds && (t.fit_bounds = !1), void 0 === t.style && (t.style = "osm-bright"), void 0 === t.lazy_load && (t.lazy_load = !1), this.options = t, this.map = null, this.map_markers = new L.featureGroup, this.map_kmls = new L.featureGroup, this.markers = [], this.kmls = [], this.options.lazy_load || this._init_map() } SalsaMap.prototype = { load: function () { null === this.map && (this._init_map(), this._init_markers(this.markers), this._init_kmls(this.kmls)) }, _init_map: function () { var t = L.map(this.options.map_canvas, { attributionControl: !1 }); L.control.attribution({ prefix: '&copy; <a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> contributors' }).addTo(t), t.setView([this.options.center.latitude, this.options.center.longitude], this.options.zoom), t.scrollWheelZoom.disable(), L.Browser.mobile && t.dragging.disable(), L.mapboxGL({ accessToken: "none", style: "https://map.caprionline.it/styles/osm-bright/style.json" }).addTo(t), this.map = t }, addMarkers: function (t) { if (null === this.map) for (var i = 0; i < t.length; i++)this.markers.push(t[i]); else this._init_markers(t) }, _init_markers: function (t) { for (var i = 0; i < t.length; i++) { var s, a = { icon: L.AwesomeMarkers.icon({ icon: t[i].icon_type, prefix: "icon", markerColor: t[i].icon_color }) }, a = L.marker([t[i].latitude, t[i].longitude], a), o = t[i].info_win_tpl; for (s in t[i].info_win_data && t[i].info_win_data.title && (o = o.replace("%name%", t[i].info_win_data.title)), t[i].info_win_data) o = o.replace(new RegExp("%" + s + "%", "g"), t[i].info_win_data[s]); a.bindPopup(o), a.addTo(this.map_markers), this.map_markers.addTo(this.map) } this.options.fit_bounds && this.map_markers.getBounds().isValid() && this.map.fitBounds(this.map_markers.getBounds()) }, removeMarkers: function () { null === this.map ? this.markers = [] : this.map_markers.clearLayers() }, addKml: function (t) { null === this.map ? this.kmls.push(t) : this._init_kmls([t]) }, _init_kmls: function (t) { for (var i = 0; i < t.length; i++) { var s = new L.KML(t[i], { async: !0 }); this.options.fit_bounds && s.on("loaded", function (t) { this.map.fitBounds(t.target.getBounds()) }.bind(this)), s.addTo(this.map_kmls), this.map.addLayer(this.map_kmls) } }, removeKmls: function () { null === this.map ? this.kmls = [] : this.map_kmls.clearLayers() }, removeAll: function () { this.removeMarkers(), this.removeKmls() } };

!function (t, e) { "object" == typeof exports && "object" == typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define("SalsaCalendar", [], e) : "object" == typeof exports ? exports.SalsaCalendar = e() : t.SalsaCalendar = e() }(this, function () { return a = {}, n.m = i = [function (t, e, n) { t.exports = n(1) }, function (t, e, n) { "use strict"; var i = n(2), a = n(3), s = n(4); function r(t) { void 0 === t.name && (t.name = ""), void 0 === t.lang && (t.lang = "en"), void 0 === t.yearsNavigation && (t.yearsNavigation = !1), void 0 === t.range && (t.range = { min: !1, max: !1, weekdays: !1, closing_dates: !1 }), void 0 === t.range.min && (t.range.min = !1), void 0 === t.range.max && (t.range.max = !1), void 0 === t.ranges && (t.ranges = [t.range]), void 0 === t.minDate && (t.minDate = !1), void 0 === t.allowEmptyDate && (t.allowEmptyDate = !1), void 0 === t.inputReadOnly && (t.inputReadOnly = !1), void 0 === t.showNextMonth && (t.showNextMonth = !1), s.isMobile() && (t.showNextMonth = !1), void 0 === t.onSelect && (t.onSelect = function (t) { }), void 0 === t.calendarPosition && (t.calendarPosition = "bottom"), void 0 === t.fixed && (t.fixed = !1), void 0 === t.dateFormats && (t.dateFormats = {}), void 0 === t.scrollableContainerElement && (t.scrollableContainerElement = null), this.options = t, this.calendar = null, this.other_calendar = null, this.current_date = null, this.on_set_current_date_closures = [], this.on_date_click = function () { }, this.before_show = function () { }, this.i18n = new i(this, this.options.lang, t.dateFormats), this.input = new a(this, this.options.inputId, this.options.allowEmptyDate, this.options.inputReadOnly || s.isMobile()), null !== this.options.scrollableContainerElement ? this.scrollable_container = this.options.scrollableContainerElement : this.scrollable_container = document.body, this._init_events(), this._init_options() } n(5), n(6), r.prototype = { _init_options: function () { for (var t = 0; t < this.options.ranges.length; t++)"today" === this.options.ranges[t].min && (this.options.ranges[t].min = this.i18n.date2DateString(new Date)) }, _init_events: function () { var t = s.isMobile() ? "touchstart" : "click"; s.addEvent(document, t, function (t) { t = s.getEventTarget(t); this._is_calendar_element(t) || this.hide() }.bind(this)) }, _is_calendar_element: function (t) { if (t === this.input.getElement()) return !0; if (s.elementHasClass(t, "sc-keep-open")) return !0; for (; t.parentNode;) { if (t === this.calendar) return !0; if (s.elementHasClass(t, "salsa-calendar-input")) return !0; t = t.parentNode } return !1 }, onSetCurrentDate: function (t) { this.on_set_current_date_closures.push(t) }, onDateClick: function (t) { this.on_date_click = t }, beforeShow: function (t) { this.before_show = t }, setOtherCalendar: function (t) { this.other_calendar = t }, setCurrentDate: function (t) { this.current_date = t; for (var e = 0; e < this.on_set_current_date_closures.length; e++)this.on_set_current_date_closures[e]() }, getCurrentDate: function () { return this.current_date }, selectDate: function (t) { this.input.setDate(t), this.input.checkAndValidateDate() && (this.setCurrentDate(t), this.show(t.getFullYear(), t.getMonth())) }, setRangeMin: function (t) { null !== this.i18n.dateString2Date(t) && (this.options.range.min = t) }, setRangeMax: function (t) { null !== this.i18n.dateString2Date(t) && (this.options.range.max = t) }, setFixed: function (t) { this.options.fixed = t, this.calendar && this._position_calendar_near(this.input.getElement()) }, isShown: function () { return this.calendar && "" === this.calendar.style.display }, show: function (t, e) { var n; s.isElementVisible(this.input.getElement()) && (s.elementHasClass(document.body, "salsa-calendar-opened") || (document.body.className += " salsa-calendar-opened"), void 0 !== t && void 0 !== e || (!1 === (n = this.input.checkDate()) && (n = new Date), t = n.getFullYear(), e = n.getMonth()), e < 0 ? (t--, e = 11) : 11 < e && (t++, e = 0), null === this.calendar && (this.calendar = this._get_calendar_structure(), document.getElementsByTagName("body")[0].appendChild(this.calendar)), this.before_show(), this._refresh(t, e), this.calendar.style.display = "", this.input.input.blur(), s.addEvent(this.scrollable_container, "scroll", function (t) { this.isShown() && this._position_calendar_near(this.input.getElement()) }.bind(this)), this._position_calendar_near(this.input.getElement())) }, _get_calendar_structure: function () { var t = document.createElement("div"); return t.className = "salsa-calendar", t.className += "" !== this.options.name ? " " + this.options.name : "", t.className += this.options.showNextMonth ? " salsa-calendar-two-months" : "", t }, _position_calendar_near: function (t) { var e = s.findElementPosition(t); this.scrollable_container !== document.body && (e.top -= this.scrollable_container.scrollTop, this._hide_calendar_on_input_overflow(this.scrollable_container, t, e)), "right" === this.options.calendarPosition ? (this.calendar.style.top = parseInt(e.top) + "px", this.calendar.style.left = parseInt(e.left + t.offsetWidth) + "px", s.elementHasClass(this.calendar, "sc-right") || (this.calendar.className += " sc-right")) : "left" === this.options.calendarPosition ? (this.calendar.style.top = parseInt(e.top) + "px", this.calendar.style.left = parseInt(e.left - this.calendar.offsetWidth) + "px", s.elementHasClass(this.calendar, "sc-left") || (this.calendar.className += " sc-left")) : (this.calendar.style.top = parseInt(e.top + t.offsetHeight) + "px", this.calendar.style.left = parseInt(e.left) + "px", s.elementHasClass(this.calendar, "sc-bottom") || (this.calendar.className += " sc-bottom")), this.calendar.style.position = this.options.fixed ? "fixed" : "absolute" }, _hide_calendar_on_input_overflow: function (t, e, n) { var i = s.findElementPosition(t); n.top - i.top - t.offsetTop + e.clientHeight > t.offsetHeight && this.hide(), n.top < i.top && this.hide() }, hide: function () { this.calendar && (this.calendar.style.display = "none"), document.body.className = document.body.className.replace(" salsa-calendar-opened", "") }, hideOthers: function () { for (var t = s.getElementsByClassName(document, "salsa-calendar"), e = 0; e < t.length; e++)t[e] !== this.calendar && (t[e].style.display = "none") }, _refresh: function (t, e) { this.calendar.innerHTML = ""; var n = this._build_calendar_page(t, e, !1); this.calendar.appendChild(n), this.options.showNextMonth && (11 === e ? (t++, e = 0) : e++, n = this._build_calendar_page(t, e, !0), this.calendar.appendChild(n)) }, _build_calendar_page: function (t, e, n) { var i = document.createElement("table"); i.setAttribute("cellspacing", 0, !1), i.setAttribute("cellpadding", 0, !1), i.appendChild(this._get_header(t, e, n)); var a = document.createElement("tbody"); i.appendChild(a); for (var s = new Date(t, e, 1), r = 0; r < 6; r++) { var o = document.createElement("tr"); a.appendChild(o); for (var l = 0; l < 7; l++) { var h = document.createElement("td"), c = (l + this.i18n.getFirstDayOfWeek()) % 7; s.getMonth() === e && s.getDay() === c ? (h.className = "sc-day sc-keep-open", this.getCurrentDate() && this.getCurrentDate().getTime() === s.getTime() && (h.className += " sc-current"), this._is_today(s) && (h.className += " sc-today"), this.inRangeDate(s) ? function (t) { h.onclick = function () { this.input.setDate(t), this.setCurrentDate(t), this.hide(), this.options.onSelect(this.input.getElement()), this.on_date_click() }.bind(this) }.bind(this)(new Date(s.getTime())) : h.className += " sc-disabled", h.innerHTML = s.getDate(), s.setDate(s.getDate() + 1)) : h.className = "sc-other-month", o.appendChild(h) } } return i }, _is_today: function (t) { var e = new Date; return t.getDate() === e.getDate() && t.getMonth() === e.getMonth() && t.getFullYear() === e.getFullYear() }, inRangeDate: function (t) { if (this.options.minDate && t.getTime() < this.i18n.dateString2Date(this.options.minDate).getTime()) return !1; for (var e = 0; e < this.options.ranges.length; e++)if (this._check_range_min_date(this.options.ranges[e], t) && this._check_range_max_date(this.options.ranges[e], t) && this._check_range_weekday(this.options.ranges[e], t) && this._check_closed_date(this.options.ranges[e], t)) return !0; return !1 }, getRangeValidDate: function (t) { if (!t) return this.getMinValidDate(); if (isNaN(t.getTime())) return this.getMinValidDate(); for (var e = 0; e < this.options.ranges.length; e++)if (!this._check_range_min_date(this.options.ranges[e], t)) return this.getMinValidDate(); for (e = 0; e < this.options.ranges.length; e++)if (!this._check_range_max_date(this.options.ranges[e], t)) return this._get_ranges_max_date(); return t }, getMinValidDate: function () { var t; t = this.options.minDate ? this.i18n.dateString2Date(this.options.minDate) : this.i18n.getTodayDate(); var e = this._get_ranges_max_date(); return null === e && (e = new Date(2050, 1, 1)), t.getTime() <= e.getTime() && !this.inRangeDate(t) && (t = this._get_ranges_min_date()), !!this.inRangeDate(t) && t }, _get_ranges_min_date: function () { for (var t = !1, e = 0; e < this.options.ranges.length; e++) { var n = this.i18n.dateString2Date(this.options.ranges[e].min); (!1 === t || n.getTime() < t.getTime()) && (t = n) } return t }, _get_ranges_max_date: function () { for (var t = !1, e = 0; e < this.options.ranges.length; e++) { var n = this.i18n.dateString2Date(this.options.ranges[e].max); (!1 === t || n.getTime() > t.getTime()) && (t = n) } return t }, _check_range_min_date: function (t, e) { if (!1 === t.min) return !0; t = this.i18n.dateString2Date(t.min); return null !== t && (!!isNaN(t.getTime()) || e.getTime() >= t.getTime()) }, _check_range_max_date: function (t, e) { if (!1 === t.max) return !0; t = this.i18n.dateString2Date(t.max); return null !== t && (!!isNaN(t.getTime()) || e.getTime() <= t.getTime()) }, _check_range_weekday: function (t, e) { if (void 0 === t.weekdays) return !0; if (!1 === t.weekdays) return !0; if ("all" === t.weekdays) return !0; e = e.getDay(); return 0 === e && (e = 7), -1 !== t.weekdays.split(",").indexOf(e.toString()) }, _check_closed_date: function (t, e) { if (void 0 === t.closed_dates || !t.closed_dates) return !0; for (var n = t.closed_dates, i = e.getFullYear() + "-" + this._pad(e.getMonth() + 1) + "-" + this._pad(e.getDate()), a = 0; a <= n.length; a++)if (n[a] === i) return !1; return !0 }, _pad: function (t) { return t < 10 ? "0" + t : t }, _get_header: function (t, e, n) { var i = document.createElement("thead"), a = document.createElement("tr"); i.appendChild(a), (c = document.createElement("th")).colSpan = 7, a.appendChild(c); var s = document.createElement("div"); s.className = "sc-nav", c.appendChild(s); var r, o, l = document.createElement("span"); l.className = "sc-title", l.innerHTML = this.i18n.getMonth(e) + " " + t, s.appendChild(l), this.options.showNextMonth && n || ((r = document.createElement("span")).className = "sc-prev", s.appendChild(r), this.options.yearsNavigation && ((o = document.createElement("a")).href = "#", o.className = "sc-prev-year sc-keep-open", o.innerHTML = "<span>&lt;&lt;</span>", o.onclick = function () { return this.show(t - 1, e), !1 }.bind(this), r.appendChild(o)), (o = document.createElement("a")).href = "#", o.className = "sc-prev-month sc-keep-open", o.innerHTML = "<span>&lt;</span>", o.onclick = function () { return this.show(t, e - 1), !1 }.bind(this), r.appendChild(o)), this.options.showNextMonth && !n || ((r = document.createElement("span")).className = "sc-next", s.appendChild(r), (o = document.createElement("a")).href = "#", o.className = "sc-next-month sc-keep-open", o.innerHTML = "<span>&gt;</span>", o.onclick = function () { return n ? this.show(t, e) : this.show(t, e + 1), !1 }.bind(this), r.appendChild(o), this.options.yearsNavigation && ((o = document.createElement("a")).href = "#", o.className = "sc-next-year sc-keep-open", o.innerHTML = "<span>&gt;&gt;</span>", o.onclick = function () { return this.show(t + 1, e), !1 }.bind(this), r.appendChild(o))); a = document.createElement("tr"); i.appendChild(a); for (var h = 0; h < 7; h++) { var c = document.createElement("th"), d = (h + this.i18n.getFirstDayOfWeek()) % 7; c.className = "sc-week-day", c.innerHTML = this.i18n.getWeekDay(d), a.appendChild(c) } return i } }, r.Connector = n(15), r.NightsCalculator = n(16), t.exports = r }, function (t, e) { "use strict"; function n(t, e, n) { for (var i in this.calendar = t, this.lang = e, this.months = { it: ["Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno", "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"], en: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], pt: ["Janeiro", "Fevereiro", "Mar&ccedil;o", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"], fr: ["janvier", "f&eacute;vrier", "mars", "avril", "mai", "juin", "juillet", "ao&ucirc;t", "septembre", "octobre", "novembre", "d&eacute;cembre"], de: ["Januar", "Februar", "M&auml;rz", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember"], ru: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"] }, this.week_days = { it: ["Do", "Lu", "Ma", "Me", "Gi", "Ve", "Sa"], en: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"], pt: ["Do", "Se", "Te", "Qu", "Qu", "Se", "S&aacute;"], fr: ["di", "lu", "ma", "me", "je", "ve", "sa"], de: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"], ru: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"] }, this.first_day_of_week = { it: 1, en: 0, pt: 0, fr: 1, de: 1, ru: 1 }, this.date_formats = { it: "%d/%m/%Y", en: "%m/%d/%Y", pt: "%d/%m/%Y", fr: "%d/%m/%Y", de: "%d/%m/%Y", ru: "%d/%m/%Y" }, n) this.date_formats[i] = n[i] } n.prototype = { getMonth: function (t) { return (void 0 === this.months[this.lang][t] ? this.months.en : this.months[this.lang])[t] }, getWeekDay: function (t) { return (void 0 === this.week_days[this.lang][t] ? this.week_days.en : this.week_days[this.lang])[t] }, getTodayDate: function () { var t = new Date; return new Date(t.getFullYear(), t.getMonth(), t.getDate()) }, getDateFormat: function () { return void 0 === this.date_formats[this.lang] ? this.date_formats.en : this.date_formats[this.lang] }, getFirstDayOfWeek: function () { return void 0 === this.first_day_of_week[this.lang] ? this.first_day_of_week.en : this.first_day_of_week[this.lang] }, date2DateString: function (t) { if (!t) return ""; var e = this.getDateFormat(), n = this._format_number(t.getDate(), 2), i = this._format_number(t.getMonth() + 1, 2), t = this._format_number(t.getFullYear(), 4); return e.replace("%d", n).replace("%m", i).replace("%Y", t) }, _format_number: function (t, e) { t = "000" + t; return t.substr(t.length - e) }, dateString2Array: function (t) { if ("" === t) return {}; var e = t.split("/"), t = this.getDateFormat().split("/"); return { day: e[t.indexOf("%d")], month: e[t.indexOf("%m")], year: e[t.indexOf("%Y")] } }, dateString2Date: function (t) { if (!t) return null; if ("" === t) return null; if ("today" === t) { var e = new Date; return new Date(e.getFullYear(), e.getMonth(), e.getDate()) } t = this.dateString2Array(t); return new Date(t.year, t.month - 1, t.day) } }, t.exports = n }, function (t, e, n) { "use strict"; var i = n(4); function a(t, e, n, i) { this.calendar = t, this.input = document.getElementById(e), void 0 === n && (n = !1), this.allowEmptyDate = n, void 0 === i && (i = !1), this.inputReadOnly = i, this._init_current_date(), this._init_events() } a.prototype = { _init_current_date: function () { var t = this.checkDate(); !1 !== t ? this.calendar.setCurrentDate(t) : this.allowEmptyDate || (this.setDate(this.calendar.getRangeValidDate(this.calendar.getMinValidDate())), this.calendar.setCurrentDate(this.calendar.getRangeValidDate(this.calendar.getMinValidDate()))), this.inputReadOnly && this.input.setAttribute("readonly", "readonly") }, _init_events: function () { this.input.onclick = function () { this.calendar.hideOthers(), this.calendar.isShown() || this.calendar.show() }.bind(this), this.input.onblur = function () { !1 === this.checkAndValidateDate() && (this.setDate(this.calendar.getCurrentDate()), this.setValidated()) }.bind(this), this.input.onkeyup = function (t) { t = i.getEvent(t), this._is_key_navigation(t.keyCode) || (this._is_key_valid(t.keyCode) ? !1 !== (t = this.checkAndValidateDate()) && (this.calendar.setCurrentDate(t), this.calendar.show(t.getFullYear(), t.getMonth())) : this.setError()) }.bind(this) }, _is_key_navigation: function (t) { return 32 < t && t < 41 }, _is_key_valid: function (t) { return 8 === t || 46 === t || 47 === t || 48 <= t && t <= 57 || 96 <= t && t <= 105 || 111 === t }, getElement: function () { return this.input }, setDate: function (t) { this.input.value = this.calendar.i18n.date2DateString(t) }, getDate: function () { return this.calendar.i18n.dateString2Date(this.input.value) }, checkDate: function () { var t = this.getDate(); return !!t && (!isNaN(t.getTime()) && (!!this._is_string_well_formed(this.input.value) && (!!this.calendar.inRangeDate(t) && t))) }, checkAndValidateDate: function () { var t = this.checkDate(); return !1 === t ? (this.setError(), !1) : (this.setValidated(), t) }, _is_string_well_formed: function (t) { var e = this.calendar.i18n.dateString2Array(t); if (e.day < 1 || 31 < e.day) return !1; if (e.month < 1 || 12 < e.month) return !1; t = (new Date).getFullYear() + 10; return !(e.year < 1970 || e.year > t) }, setError: function () { i.elementHasClass(this.input, "salsa-calendar-error") || (this.input.className += " salsa-calendar-error") }, setValidated: function () { this.input.className = this.input.className.replace(" salsa-calendar-error", "") } }, t.exports = a }, function (t, e) { "use strict"; var n = { getElementsByClassName: function (t, e) { for (var n = t.getElementsByTagName("*"), i = [], a = "(^|\\s)" + e + "(\\s|$)", s = 0; s < n.length; s++) { var r = n[s]; r.className.match && r.className.match(a) && (i[i.length] = r) } return i }, elementHasClass: function (t, e) { return -1 !== t.className.split(" ").indexOf(e) }, findElementPosition: function (t) { for (var e = 0, n = 0; t;)e += t.offsetLeft, n += t.offsetTop, t = t.offsetParent; return { left: e, top: n } }, isElementVisible: function (t) { var e = t.offsetWidth, n = t.offsetHeight; return (0 !== e || 0 !== n) && (0 < e && 0 < n || "none" !== t.display) }, getEvent: function (t) { return t || window.event }, getEventTarget: function (t) { return (t = n.getEvent(t)).target || window.event.srcElement }, addEvent: function (t, e, n) { t.addEventListener ? t.addEventListener(e, n, !1) : t.attachEvent && t.attachEvent("on" + e, n) }, isMobile: function () { return (0 < window.innerWidth ? window.innerWidth : screen.width) <= 480 } }; t.exports = n }, function (t, e) { "use strict"; Function.prototype.bind || (Function.prototype.bind = function (t) { if ("function" != typeof this) throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable"); function e() { } function n() { return a.apply(this instanceof e && t ? this : t, i.concat(Array.prototype.slice.call(arguments))) } var i = Array.prototype.slice.call(arguments, 1), a = this; return e.prototype = this.prototype, n.prototype = new e, n }), Array.prototype.indexOf || (Array.prototype.indexOf = function (t, e) { for (var n = e || 0, i = this.length; n < i; n++)if (this[n] === t) return n; return -1 }) }, function (t, e) { }, , , , , , , , , function (t, e) { "use strict"; function n(t) { this.from = t.from, this.to = t.to, void 0 === t.minimumInterval && (t.minimumInterval = 1), void 0 === t.maximumInterval && (t.maximumInterval = -1), this.options = t, this.from.onDateClick(function () { var t = this.from.getCurrentDate(), e = this.to.getCurrentDate(); this._connect_calendar(), this._check_connected_calendar_integrity(this.from.input.getDate()), t.getTime() > e.getTime() && this.to.show() }.bind(this)), this.from.onSetCurrentDate(function () { var t = new Date(this.from.getCurrentDate()); t.setDate(t.getDate() + this.options.minimumInterval); var e = this.to.getCurrentDate(); (!e || t.getTime() > e.getTime()) && (this.to.input.setDate(t), this.to.setCurrentDate(t)), this._set_connected_calendar_range_min_date(this.from.input.getDate()), this._set_connected_calendar_range_max_date(this.from.input.getDate()), this._check_connected_calendar_integrity(this.from.input.getDate()) }.bind(this)), this._connect_calendar() } n.prototype = { _connect_calendar: function () { var t, e, n, i = this.from.input.getDate(); i && (t = this.to.getCurrentDate(), e = this.from.getCurrentDate(), (n = new Date(i.getTime())).setDate(n.getDate() + this.options.minimumInterval), this._set_connected_calendar_range_min_date(i), this._set_connected_calendar_range_max_date(i), e && t && e.getTime() < t.getTime() || (this.to.input.setDate(n), this.to.setCurrentDate(n))) }, _set_connected_calendar_range_min_date: function (t) { t = new Date(t.getTime()); t.setDate(t.getDate() + this.options.minimumInterval), this.to.setRangeMin(this.from.i18n.date2DateString(t)) }, _set_connected_calendar_range_max_date: function (t) { this.options.maximumInterval < 0 || ((t = new Date(t.getTime())).setDate(t.getDate() + this.options.maximumInterval), this.to.setRangeMax(this.from.i18n.date2DateString(t)), this.to.getCurrentDate().getTime() > t.getTime() && this.to.selectDate(t)) }, _check_connected_calendar_integrity: function (t) { t = new Date(t.getTime()); t.getTime() >= this.to.getCurrentDate().getTime() ? this.to.input.setError() : this.options.maximumInterval < 0 ? this.to.input.setValidated() : (t.setDate(t.getDate() + this.options.maximumInterval), t.getTime() < this.to.getCurrentDate().getTime() ? this.to.input.setError() : this.to.input.setValidated()) } }, t.exports = n }, function (t, e, n) { "use strict"; var a = n(4); function i(t) { this.from = t.from, this.to = t.to, this.nights_summary = document.getElementById(t.nightsNo), this.from.onSetCurrentDate(function () { this.updateNightsNo() }.bind(this)), this.to.onSetCurrentDate(function () { this.updateNightsNo() }.bind(this)), this.updateNightsNo() } i.prototype = { updateNightsNo: function () { var t = a.getElementsByClassName(this.nights_summary, "counter")[0], e = a.getElementsByClassName(this.nights_summary, "singular")[0], n = a.getElementsByClassName(this.nights_summary, "plural")[0], i = this._get_nights_no(); if (!i) return t.innerHTML = "", n.style.display = "none", void (e.style.display = "none"); 1 < (t.innerHTML = i) ? (e.style.display = "none", n.style.display = "") : (e.style.display = "", n.style.display = "none") }, _get_nights_no: function () { var t = this.from.getCurrentDate(), t = this.to.getCurrentDate().getTime() - t.getTime(); return !(t < 0) && Math.round(t / 1e3 / 60 / 60 / 24) } }, t.exports = i }], n.c = a, n.p = "", n(0); function n(t) { if (a[t]) return a[t].exports; var e = a[t] = { exports: {}, id: t, loaded: !1 }; return i[t].call(e.exports, e, e.exports, n), e.loaded = !0, e.exports } var i, a });